
/**
 * Client
**/

import * as runtime from './runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model bot_commands
 * 
 */
export type bot_commands = $Result.DefaultSelection<Prisma.$bot_commandsPayload>
/**
 * Model bot_events
 * 
 */
export type bot_events = $Result.DefaultSelection<Prisma.$bot_eventsPayload>
/**
 * Model bot_list_feature
 * 
 */
export type bot_list_feature = $Result.DefaultSelection<Prisma.$bot_list_featurePayload>
/**
 * Model bot_list_tags
 * 
 */
export type bot_list_tags = $Result.DefaultSelection<Prisma.$bot_list_tagsPayload>
/**
 * Model bot_owner
 * 
 */
export type bot_owner = $Result.DefaultSelection<Prisma.$bot_ownerPayload>
/**
 * Model bot_packs
 * 
 */
export type bot_packs = $Result.DefaultSelection<Prisma.$bot_packsPayload>
/**
 * Model bot_promotions
 * 
 */
export type bot_promotions = $Result.DefaultSelection<Prisma.$bot_promotionsPayload>
/**
 * Model bot_stats_votes_pm
 * 
 */
export type bot_stats_votes_pm = $Result.DefaultSelection<Prisma.$bot_stats_votes_pmPayload>
/**
 * Model bot_tags
 * 
 */
export type bot_tags = $Result.DefaultSelection<Prisma.$bot_tagsPayload>
/**
 * Model bot_voters
 * 
 */
export type bot_voters = $Result.DefaultSelection<Prisma.$bot_votersPayload>
/**
 * Model bots
 * 
 */
export type bots = $Result.DefaultSelection<Prisma.$botsPayload>
/**
 * Model extra_data
 * 
 */
export type extra_data = $Result.DefaultSelection<Prisma.$extra_dataPayload>
/**
 * Model features
 * 
 */
export type features = $Result.DefaultSelection<Prisma.$featuresPayload>
/**
 * Model frostpaw_clients
 * 
 */
export type frostpaw_clients = $Result.DefaultSelection<Prisma.$frostpaw_clientsPayload>
/**
 * Model leave_of_absence
 * 
 */
export type leave_of_absence = $Result.DefaultSelection<Prisma.$leave_of_absencePayload>
/**
 * Model lynx_apps
 * 
 */
export type lynx_apps = $Result.DefaultSelection<Prisma.$lynx_appsPayload>
/**
 * Model lynx_data
 * 
 */
export type lynx_data = $Result.DefaultSelection<Prisma.$lynx_dataPayload>
/**
 * Model lynx_logs
 * 
 */
export type lynx_logs = $Result.DefaultSelection<Prisma.$lynx_logsPayload>
/**
 * Model lynx_notifications
 * 
 */
export type lynx_notifications = $Result.DefaultSelection<Prisma.$lynx_notificationsPayload>
/**
 * Model lynx_ratings
 * 
 */
export type lynx_ratings = $Result.DefaultSelection<Prisma.$lynx_ratingsPayload>
/**
 * Model lynx_survey_responses
 * 
 */
export type lynx_survey_responses = $Result.DefaultSelection<Prisma.$lynx_survey_responsesPayload>
/**
 * Model lynx_surveys
 * 
 */
export type lynx_surveys = $Result.DefaultSelection<Prisma.$lynx_surveysPayload>
/**
 * Model migration
 * 
 */
export type migration = $Result.DefaultSelection<Prisma.$migrationPayload>
/**
 * Model piccolo_user
 * 
 */
export type piccolo_user = $Result.DefaultSelection<Prisma.$piccolo_userPayload>
/**
 * Model platform_map
 * 
 */
export type platform_map = $Result.DefaultSelection<Prisma.$platform_mapPayload>
/**
 * Model push_notifications
 * 
 */
export type push_notifications = $Result.DefaultSelection<Prisma.$push_notificationsPayload>
/**
 * Model review_votes
 * 
 */
export type review_votes = $Result.DefaultSelection<Prisma.$review_votesPayload>
/**
 * Model reviews
 * 
 */
export type reviews = $Result.DefaultSelection<Prisma.$reviewsPayload>
/**
 * Model server_audit_logs
 * 
 */
export type server_audit_logs = $Result.DefaultSelection<Prisma.$server_audit_logsPayload>
/**
 * Model server_tags
 * 
 */
export type server_tags = $Result.DefaultSelection<Prisma.$server_tagsPayload>
/**
 * Model server_voters
 * 
 */
export type server_voters = $Result.DefaultSelection<Prisma.$server_votersPayload>
/**
 * Model servers
 * 
 */
export type servers = $Result.DefaultSelection<Prisma.$serversPayload>
/**
 * Model sessions
 * 
 */
export type sessions = $Result.DefaultSelection<Prisma.$sessionsPayload>
/**
 * Model user_bot_logs
 * 
 */
export type user_bot_logs = $Result.DefaultSelection<Prisma.$user_bot_logsPayload>
/**
 * Model user_connections
 * 
 */
export type user_connections = $Result.DefaultSelection<Prisma.$user_connectionsPayload>
/**
 * Model user_server_vote_table
 * 
 */
export type user_server_vote_table = $Result.DefaultSelection<Prisma.$user_server_vote_tablePayload>
/**
 * Model user_vote_table
 * 
 */
export type user_vote_table = $Result.DefaultSelection<Prisma.$user_vote_tablePayload>
/**
 * Model users
 * 
 */
export type users = $Result.DefaultSelection<Prisma.$usersPayload>
/**
 * Model vanity
 * 
 */
export type vanity = $Result.DefaultSelection<Prisma.$vanityPayload>
/**
 * Model ws_events
 * 
 */
export type ws_events = $Result.DefaultSelection<Prisma.$ws_eventsPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Bot_commands
 * const bot_commands = await prisma.bot_commands.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Bot_commands
   * const bot_commands = await prisma.bot_commands.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.bot_commands`: Exposes CRUD operations for the **bot_commands** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bot_commands
    * const bot_commands = await prisma.bot_commands.findMany()
    * ```
    */
  get bot_commands(): Prisma.bot_commandsDelegate<ExtArgs>;

  /**
   * `prisma.bot_events`: Exposes CRUD operations for the **bot_events** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bot_events
    * const bot_events = await prisma.bot_events.findMany()
    * ```
    */
  get bot_events(): Prisma.bot_eventsDelegate<ExtArgs>;

  /**
   * `prisma.bot_list_feature`: Exposes CRUD operations for the **bot_list_feature** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bot_list_features
    * const bot_list_features = await prisma.bot_list_feature.findMany()
    * ```
    */
  get bot_list_feature(): Prisma.bot_list_featureDelegate<ExtArgs>;

  /**
   * `prisma.bot_list_tags`: Exposes CRUD operations for the **bot_list_tags** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bot_list_tags
    * const bot_list_tags = await prisma.bot_list_tags.findMany()
    * ```
    */
  get bot_list_tags(): Prisma.bot_list_tagsDelegate<ExtArgs>;

  /**
   * `prisma.bot_owner`: Exposes CRUD operations for the **bot_owner** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bot_owners
    * const bot_owners = await prisma.bot_owner.findMany()
    * ```
    */
  get bot_owner(): Prisma.bot_ownerDelegate<ExtArgs>;

  /**
   * `prisma.bot_packs`: Exposes CRUD operations for the **bot_packs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bot_packs
    * const bot_packs = await prisma.bot_packs.findMany()
    * ```
    */
  get bot_packs(): Prisma.bot_packsDelegate<ExtArgs>;

  /**
   * `prisma.bot_promotions`: Exposes CRUD operations for the **bot_promotions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bot_promotions
    * const bot_promotions = await prisma.bot_promotions.findMany()
    * ```
    */
  get bot_promotions(): Prisma.bot_promotionsDelegate<ExtArgs>;

  /**
   * `prisma.bot_stats_votes_pm`: Exposes CRUD operations for the **bot_stats_votes_pm** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bot_stats_votes_pms
    * const bot_stats_votes_pms = await prisma.bot_stats_votes_pm.findMany()
    * ```
    */
  get bot_stats_votes_pm(): Prisma.bot_stats_votes_pmDelegate<ExtArgs>;

  /**
   * `prisma.bot_tags`: Exposes CRUD operations for the **bot_tags** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bot_tags
    * const bot_tags = await prisma.bot_tags.findMany()
    * ```
    */
  get bot_tags(): Prisma.bot_tagsDelegate<ExtArgs>;

  /**
   * `prisma.bot_voters`: Exposes CRUD operations for the **bot_voters** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bot_voters
    * const bot_voters = await prisma.bot_voters.findMany()
    * ```
    */
  get bot_voters(): Prisma.bot_votersDelegate<ExtArgs>;

  /**
   * `prisma.bots`: Exposes CRUD operations for the **bots** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bots
    * const bots = await prisma.bots.findMany()
    * ```
    */
  get bots(): Prisma.botsDelegate<ExtArgs>;

  /**
   * `prisma.extra_data`: Exposes CRUD operations for the **extra_data** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Extra_data
    * const extra_data = await prisma.extra_data.findMany()
    * ```
    */
  get extra_data(): Prisma.extra_dataDelegate<ExtArgs>;

  /**
   * `prisma.features`: Exposes CRUD operations for the **features** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Features
    * const features = await prisma.features.findMany()
    * ```
    */
  get features(): Prisma.featuresDelegate<ExtArgs>;

  /**
   * `prisma.frostpaw_clients`: Exposes CRUD operations for the **frostpaw_clients** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Frostpaw_clients
    * const frostpaw_clients = await prisma.frostpaw_clients.findMany()
    * ```
    */
  get frostpaw_clients(): Prisma.frostpaw_clientsDelegate<ExtArgs>;

  /**
   * `prisma.leave_of_absence`: Exposes CRUD operations for the **leave_of_absence** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Leave_of_absences
    * const leave_of_absences = await prisma.leave_of_absence.findMany()
    * ```
    */
  get leave_of_absence(): Prisma.leave_of_absenceDelegate<ExtArgs>;

  /**
   * `prisma.lynx_apps`: Exposes CRUD operations for the **lynx_apps** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lynx_apps
    * const lynx_apps = await prisma.lynx_apps.findMany()
    * ```
    */
  get lynx_apps(): Prisma.lynx_appsDelegate<ExtArgs>;

  /**
   * `prisma.lynx_data`: Exposes CRUD operations for the **lynx_data** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lynx_data
    * const lynx_data = await prisma.lynx_data.findMany()
    * ```
    */
  get lynx_data(): Prisma.lynx_dataDelegate<ExtArgs>;

  /**
   * `prisma.lynx_logs`: Exposes CRUD operations for the **lynx_logs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lynx_logs
    * const lynx_logs = await prisma.lynx_logs.findMany()
    * ```
    */
  get lynx_logs(): Prisma.lynx_logsDelegate<ExtArgs>;

  /**
   * `prisma.lynx_notifications`: Exposes CRUD operations for the **lynx_notifications** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lynx_notifications
    * const lynx_notifications = await prisma.lynx_notifications.findMany()
    * ```
    */
  get lynx_notifications(): Prisma.lynx_notificationsDelegate<ExtArgs>;

  /**
   * `prisma.lynx_ratings`: Exposes CRUD operations for the **lynx_ratings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lynx_ratings
    * const lynx_ratings = await prisma.lynx_ratings.findMany()
    * ```
    */
  get lynx_ratings(): Prisma.lynx_ratingsDelegate<ExtArgs>;

  /**
   * `prisma.lynx_survey_responses`: Exposes CRUD operations for the **lynx_survey_responses** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lynx_survey_responses
    * const lynx_survey_responses = await prisma.lynx_survey_responses.findMany()
    * ```
    */
  get lynx_survey_responses(): Prisma.lynx_survey_responsesDelegate<ExtArgs>;

  /**
   * `prisma.lynx_surveys`: Exposes CRUD operations for the **lynx_surveys** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lynx_surveys
    * const lynx_surveys = await prisma.lynx_surveys.findMany()
    * ```
    */
  get lynx_surveys(): Prisma.lynx_surveysDelegate<ExtArgs>;

  /**
   * `prisma.migration`: Exposes CRUD operations for the **migration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Migrations
    * const migrations = await prisma.migration.findMany()
    * ```
    */
  get migration(): Prisma.migrationDelegate<ExtArgs>;

  /**
   * `prisma.piccolo_user`: Exposes CRUD operations for the **piccolo_user** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Piccolo_users
    * const piccolo_users = await prisma.piccolo_user.findMany()
    * ```
    */
  get piccolo_user(): Prisma.piccolo_userDelegate<ExtArgs>;

  /**
   * `prisma.platform_map`: Exposes CRUD operations for the **platform_map** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Platform_maps
    * const platform_maps = await prisma.platform_map.findMany()
    * ```
    */
  get platform_map(): Prisma.platform_mapDelegate<ExtArgs>;

  /**
   * `prisma.push_notifications`: Exposes CRUD operations for the **push_notifications** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Push_notifications
    * const push_notifications = await prisma.push_notifications.findMany()
    * ```
    */
  get push_notifications(): Prisma.push_notificationsDelegate<ExtArgs>;

  /**
   * `prisma.review_votes`: Exposes CRUD operations for the **review_votes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Review_votes
    * const review_votes = await prisma.review_votes.findMany()
    * ```
    */
  get review_votes(): Prisma.review_votesDelegate<ExtArgs>;

  /**
   * `prisma.reviews`: Exposes CRUD operations for the **reviews** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reviews
    * const reviews = await prisma.reviews.findMany()
    * ```
    */
  get reviews(): Prisma.reviewsDelegate<ExtArgs>;

  /**
   * `prisma.server_audit_logs`: Exposes CRUD operations for the **server_audit_logs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Server_audit_logs
    * const server_audit_logs = await prisma.server_audit_logs.findMany()
    * ```
    */
  get server_audit_logs(): Prisma.server_audit_logsDelegate<ExtArgs>;

  /**
   * `prisma.server_tags`: Exposes CRUD operations for the **server_tags** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Server_tags
    * const server_tags = await prisma.server_tags.findMany()
    * ```
    */
  get server_tags(): Prisma.server_tagsDelegate<ExtArgs>;

  /**
   * `prisma.server_voters`: Exposes CRUD operations for the **server_voters** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Server_voters
    * const server_voters = await prisma.server_voters.findMany()
    * ```
    */
  get server_voters(): Prisma.server_votersDelegate<ExtArgs>;

  /**
   * `prisma.servers`: Exposes CRUD operations for the **servers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Servers
    * const servers = await prisma.servers.findMany()
    * ```
    */
  get servers(): Prisma.serversDelegate<ExtArgs>;

  /**
   * `prisma.sessions`: Exposes CRUD operations for the **sessions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.sessions.findMany()
    * ```
    */
  get sessions(): Prisma.sessionsDelegate<ExtArgs>;

  /**
   * `prisma.user_bot_logs`: Exposes CRUD operations for the **user_bot_logs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_bot_logs
    * const user_bot_logs = await prisma.user_bot_logs.findMany()
    * ```
    */
  get user_bot_logs(): Prisma.user_bot_logsDelegate<ExtArgs>;

  /**
   * `prisma.user_connections`: Exposes CRUD operations for the **user_connections** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_connections
    * const user_connections = await prisma.user_connections.findMany()
    * ```
    */
  get user_connections(): Prisma.user_connectionsDelegate<ExtArgs>;

  /**
   * `prisma.user_server_vote_table`: Exposes CRUD operations for the **user_server_vote_table** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_server_vote_tables
    * const user_server_vote_tables = await prisma.user_server_vote_table.findMany()
    * ```
    */
  get user_server_vote_table(): Prisma.user_server_vote_tableDelegate<ExtArgs>;

  /**
   * `prisma.user_vote_table`: Exposes CRUD operations for the **user_vote_table** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_vote_tables
    * const user_vote_tables = await prisma.user_vote_table.findMany()
    * ```
    */
  get user_vote_table(): Prisma.user_vote_tableDelegate<ExtArgs>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<ExtArgs>;

  /**
   * `prisma.vanity`: Exposes CRUD operations for the **vanity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vanities
    * const vanities = await prisma.vanity.findMany()
    * ```
    */
  get vanity(): Prisma.vanityDelegate<ExtArgs>;

  /**
   * `prisma.ws_events`: Exposes CRUD operations for the **ws_events** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ws_events
    * const ws_events = await prisma.ws_events.findMany()
    * ```
    */
  get ws_events(): Prisma.ws_eventsDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.8.1
   * Query Engine version: 78caf6feeaed953168c64e15a249c3e9a033ebe2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    bot_commands: 'bot_commands',
    bot_events: 'bot_events',
    bot_list_feature: 'bot_list_feature',
    bot_list_tags: 'bot_list_tags',
    bot_owner: 'bot_owner',
    bot_packs: 'bot_packs',
    bot_promotions: 'bot_promotions',
    bot_stats_votes_pm: 'bot_stats_votes_pm',
    bot_tags: 'bot_tags',
    bot_voters: 'bot_voters',
    bots: 'bots',
    extra_data: 'extra_data',
    features: 'features',
    frostpaw_clients: 'frostpaw_clients',
    leave_of_absence: 'leave_of_absence',
    lynx_apps: 'lynx_apps',
    lynx_data: 'lynx_data',
    lynx_logs: 'lynx_logs',
    lynx_notifications: 'lynx_notifications',
    lynx_ratings: 'lynx_ratings',
    lynx_survey_responses: 'lynx_survey_responses',
    lynx_surveys: 'lynx_surveys',
    migration: 'migration',
    piccolo_user: 'piccolo_user',
    platform_map: 'platform_map',
    push_notifications: 'push_notifications',
    review_votes: 'review_votes',
    reviews: 'reviews',
    server_audit_logs: 'server_audit_logs',
    server_tags: 'server_tags',
    server_voters: 'server_voters',
    servers: 'servers',
    sessions: 'sessions',
    user_bot_logs: 'user_bot_logs',
    user_connections: 'user_connections',
    user_server_vote_table: 'user_server_vote_table',
    user_vote_table: 'user_vote_table',
    users: 'users',
    vanity: 'vanity',
    ws_events: 'ws_events'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'bot_commands' | 'bot_events' | 'bot_list_feature' | 'bot_list_tags' | 'bot_owner' | 'bot_packs' | 'bot_promotions' | 'bot_stats_votes_pm' | 'bot_tags' | 'bot_voters' | 'bots' | 'extra_data' | 'features' | 'frostpaw_clients' | 'leave_of_absence' | 'lynx_apps' | 'lynx_data' | 'lynx_logs' | 'lynx_notifications' | 'lynx_ratings' | 'lynx_survey_responses' | 'lynx_surveys' | 'migration' | 'piccolo_user' | 'platform_map' | 'push_notifications' | 'review_votes' | 'reviews' | 'server_audit_logs' | 'server_tags' | 'server_voters' | 'servers' | 'sessions' | 'user_bot_logs' | 'user_connections' | 'user_server_vote_table' | 'user_vote_table' | 'users' | 'vanity' | 'ws_events'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      bot_commands: {
        payload: Prisma.$bot_commandsPayload<ExtArgs>
        fields: Prisma.bot_commandsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.bot_commandsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_commandsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.bot_commandsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_commandsPayload>
          }
          findFirst: {
            args: Prisma.bot_commandsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_commandsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.bot_commandsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_commandsPayload>
          }
          findMany: {
            args: Prisma.bot_commandsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_commandsPayload>[]
          }
          create: {
            args: Prisma.bot_commandsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_commandsPayload>
          }
          createMany: {
            args: Prisma.bot_commandsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.bot_commandsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_commandsPayload>
          }
          update: {
            args: Prisma.bot_commandsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_commandsPayload>
          }
          deleteMany: {
            args: Prisma.bot_commandsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.bot_commandsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.bot_commandsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_commandsPayload>
          }
          aggregate: {
            args: Prisma.Bot_commandsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBot_commands>
          }
          groupBy: {
            args: Prisma.bot_commandsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Bot_commandsGroupByOutputType>[]
          }
          count: {
            args: Prisma.bot_commandsCountArgs<ExtArgs>,
            result: $Utils.Optional<Bot_commandsCountAggregateOutputType> | number
          }
        }
      }
      bot_events: {
        payload: Prisma.$bot_eventsPayload<ExtArgs>
        fields: Prisma.bot_eventsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.bot_eventsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_eventsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.bot_eventsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_eventsPayload>
          }
          findFirst: {
            args: Prisma.bot_eventsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_eventsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.bot_eventsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_eventsPayload>
          }
          findMany: {
            args: Prisma.bot_eventsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_eventsPayload>[]
          }
          create: {
            args: Prisma.bot_eventsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_eventsPayload>
          }
          createMany: {
            args: Prisma.bot_eventsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.bot_eventsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_eventsPayload>
          }
          update: {
            args: Prisma.bot_eventsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_eventsPayload>
          }
          deleteMany: {
            args: Prisma.bot_eventsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.bot_eventsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.bot_eventsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_eventsPayload>
          }
          aggregate: {
            args: Prisma.Bot_eventsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBot_events>
          }
          groupBy: {
            args: Prisma.bot_eventsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Bot_eventsGroupByOutputType>[]
          }
          count: {
            args: Prisma.bot_eventsCountArgs<ExtArgs>,
            result: $Utils.Optional<Bot_eventsCountAggregateOutputType> | number
          }
        }
      }
      bot_list_feature: {
        payload: Prisma.$bot_list_featurePayload<ExtArgs>
        fields: Prisma.bot_list_featureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.bot_list_featureFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_list_featurePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.bot_list_featureFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_list_featurePayload>
          }
          findFirst: {
            args: Prisma.bot_list_featureFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_list_featurePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.bot_list_featureFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_list_featurePayload>
          }
          findMany: {
            args: Prisma.bot_list_featureFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_list_featurePayload>[]
          }
          create: {
            args: Prisma.bot_list_featureCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_list_featurePayload>
          }
          createMany: {
            args: Prisma.bot_list_featureCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.bot_list_featureDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_list_featurePayload>
          }
          update: {
            args: Prisma.bot_list_featureUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_list_featurePayload>
          }
          deleteMany: {
            args: Prisma.bot_list_featureDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.bot_list_featureUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.bot_list_featureUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_list_featurePayload>
          }
          aggregate: {
            args: Prisma.Bot_list_featureAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBot_list_feature>
          }
          groupBy: {
            args: Prisma.bot_list_featureGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Bot_list_featureGroupByOutputType>[]
          }
          count: {
            args: Prisma.bot_list_featureCountArgs<ExtArgs>,
            result: $Utils.Optional<Bot_list_featureCountAggregateOutputType> | number
          }
        }
      }
      bot_list_tags: {
        payload: Prisma.$bot_list_tagsPayload<ExtArgs>
        fields: Prisma.bot_list_tagsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.bot_list_tagsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_list_tagsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.bot_list_tagsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_list_tagsPayload>
          }
          findFirst: {
            args: Prisma.bot_list_tagsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_list_tagsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.bot_list_tagsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_list_tagsPayload>
          }
          findMany: {
            args: Prisma.bot_list_tagsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_list_tagsPayload>[]
          }
          create: {
            args: Prisma.bot_list_tagsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_list_tagsPayload>
          }
          createMany: {
            args: Prisma.bot_list_tagsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.bot_list_tagsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_list_tagsPayload>
          }
          update: {
            args: Prisma.bot_list_tagsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_list_tagsPayload>
          }
          deleteMany: {
            args: Prisma.bot_list_tagsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.bot_list_tagsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.bot_list_tagsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_list_tagsPayload>
          }
          aggregate: {
            args: Prisma.Bot_list_tagsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBot_list_tags>
          }
          groupBy: {
            args: Prisma.bot_list_tagsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Bot_list_tagsGroupByOutputType>[]
          }
          count: {
            args: Prisma.bot_list_tagsCountArgs<ExtArgs>,
            result: $Utils.Optional<Bot_list_tagsCountAggregateOutputType> | number
          }
        }
      }
      bot_owner: {
        payload: Prisma.$bot_ownerPayload<ExtArgs>
        fields: Prisma.bot_ownerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.bot_ownerFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_ownerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.bot_ownerFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_ownerPayload>
          }
          findFirst: {
            args: Prisma.bot_ownerFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_ownerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.bot_ownerFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_ownerPayload>
          }
          findMany: {
            args: Prisma.bot_ownerFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_ownerPayload>[]
          }
          create: {
            args: Prisma.bot_ownerCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_ownerPayload>
          }
          createMany: {
            args: Prisma.bot_ownerCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.bot_ownerDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_ownerPayload>
          }
          update: {
            args: Prisma.bot_ownerUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_ownerPayload>
          }
          deleteMany: {
            args: Prisma.bot_ownerDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.bot_ownerUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.bot_ownerUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_ownerPayload>
          }
          aggregate: {
            args: Prisma.Bot_ownerAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBot_owner>
          }
          groupBy: {
            args: Prisma.bot_ownerGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Bot_ownerGroupByOutputType>[]
          }
          count: {
            args: Prisma.bot_ownerCountArgs<ExtArgs>,
            result: $Utils.Optional<Bot_ownerCountAggregateOutputType> | number
          }
        }
      }
      bot_packs: {
        payload: Prisma.$bot_packsPayload<ExtArgs>
        fields: Prisma.bot_packsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.bot_packsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_packsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.bot_packsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_packsPayload>
          }
          findFirst: {
            args: Prisma.bot_packsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_packsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.bot_packsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_packsPayload>
          }
          findMany: {
            args: Prisma.bot_packsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_packsPayload>[]
          }
          create: {
            args: Prisma.bot_packsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_packsPayload>
          }
          createMany: {
            args: Prisma.bot_packsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.bot_packsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_packsPayload>
          }
          update: {
            args: Prisma.bot_packsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_packsPayload>
          }
          deleteMany: {
            args: Prisma.bot_packsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.bot_packsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.bot_packsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_packsPayload>
          }
          aggregate: {
            args: Prisma.Bot_packsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBot_packs>
          }
          groupBy: {
            args: Prisma.bot_packsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Bot_packsGroupByOutputType>[]
          }
          count: {
            args: Prisma.bot_packsCountArgs<ExtArgs>,
            result: $Utils.Optional<Bot_packsCountAggregateOutputType> | number
          }
        }
      }
      bot_promotions: {
        payload: Prisma.$bot_promotionsPayload<ExtArgs>
        fields: Prisma.bot_promotionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.bot_promotionsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_promotionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.bot_promotionsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_promotionsPayload>
          }
          findFirst: {
            args: Prisma.bot_promotionsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_promotionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.bot_promotionsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_promotionsPayload>
          }
          findMany: {
            args: Prisma.bot_promotionsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_promotionsPayload>[]
          }
          create: {
            args: Prisma.bot_promotionsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_promotionsPayload>
          }
          createMany: {
            args: Prisma.bot_promotionsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.bot_promotionsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_promotionsPayload>
          }
          update: {
            args: Prisma.bot_promotionsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_promotionsPayload>
          }
          deleteMany: {
            args: Prisma.bot_promotionsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.bot_promotionsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.bot_promotionsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_promotionsPayload>
          }
          aggregate: {
            args: Prisma.Bot_promotionsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBot_promotions>
          }
          groupBy: {
            args: Prisma.bot_promotionsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Bot_promotionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.bot_promotionsCountArgs<ExtArgs>,
            result: $Utils.Optional<Bot_promotionsCountAggregateOutputType> | number
          }
        }
      }
      bot_stats_votes_pm: {
        payload: Prisma.$bot_stats_votes_pmPayload<ExtArgs>
        fields: Prisma.bot_stats_votes_pmFieldRefs
        operations: {
          findUnique: {
            args: Prisma.bot_stats_votes_pmFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_stats_votes_pmPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.bot_stats_votes_pmFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_stats_votes_pmPayload>
          }
          findFirst: {
            args: Prisma.bot_stats_votes_pmFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_stats_votes_pmPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.bot_stats_votes_pmFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_stats_votes_pmPayload>
          }
          findMany: {
            args: Prisma.bot_stats_votes_pmFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_stats_votes_pmPayload>[]
          }
          create: {
            args: Prisma.bot_stats_votes_pmCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_stats_votes_pmPayload>
          }
          createMany: {
            args: Prisma.bot_stats_votes_pmCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.bot_stats_votes_pmDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_stats_votes_pmPayload>
          }
          update: {
            args: Prisma.bot_stats_votes_pmUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_stats_votes_pmPayload>
          }
          deleteMany: {
            args: Prisma.bot_stats_votes_pmDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.bot_stats_votes_pmUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.bot_stats_votes_pmUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_stats_votes_pmPayload>
          }
          aggregate: {
            args: Prisma.Bot_stats_votes_pmAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBot_stats_votes_pm>
          }
          groupBy: {
            args: Prisma.bot_stats_votes_pmGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Bot_stats_votes_pmGroupByOutputType>[]
          }
          count: {
            args: Prisma.bot_stats_votes_pmCountArgs<ExtArgs>,
            result: $Utils.Optional<Bot_stats_votes_pmCountAggregateOutputType> | number
          }
        }
      }
      bot_tags: {
        payload: Prisma.$bot_tagsPayload<ExtArgs>
        fields: Prisma.bot_tagsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.bot_tagsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_tagsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.bot_tagsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_tagsPayload>
          }
          findFirst: {
            args: Prisma.bot_tagsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_tagsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.bot_tagsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_tagsPayload>
          }
          findMany: {
            args: Prisma.bot_tagsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_tagsPayload>[]
          }
          create: {
            args: Prisma.bot_tagsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_tagsPayload>
          }
          createMany: {
            args: Prisma.bot_tagsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.bot_tagsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_tagsPayload>
          }
          update: {
            args: Prisma.bot_tagsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_tagsPayload>
          }
          deleteMany: {
            args: Prisma.bot_tagsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.bot_tagsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.bot_tagsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_tagsPayload>
          }
          aggregate: {
            args: Prisma.Bot_tagsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBot_tags>
          }
          groupBy: {
            args: Prisma.bot_tagsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Bot_tagsGroupByOutputType>[]
          }
          count: {
            args: Prisma.bot_tagsCountArgs<ExtArgs>,
            result: $Utils.Optional<Bot_tagsCountAggregateOutputType> | number
          }
        }
      }
      bot_voters: {
        payload: Prisma.$bot_votersPayload<ExtArgs>
        fields: Prisma.bot_votersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.bot_votersFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_votersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.bot_votersFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_votersPayload>
          }
          findFirst: {
            args: Prisma.bot_votersFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_votersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.bot_votersFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_votersPayload>
          }
          findMany: {
            args: Prisma.bot_votersFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_votersPayload>[]
          }
          create: {
            args: Prisma.bot_votersCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_votersPayload>
          }
          createMany: {
            args: Prisma.bot_votersCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.bot_votersDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_votersPayload>
          }
          update: {
            args: Prisma.bot_votersUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_votersPayload>
          }
          deleteMany: {
            args: Prisma.bot_votersDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.bot_votersUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.bot_votersUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bot_votersPayload>
          }
          aggregate: {
            args: Prisma.Bot_votersAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBot_voters>
          }
          groupBy: {
            args: Prisma.bot_votersGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Bot_votersGroupByOutputType>[]
          }
          count: {
            args: Prisma.bot_votersCountArgs<ExtArgs>,
            result: $Utils.Optional<Bot_votersCountAggregateOutputType> | number
          }
        }
      }
      bots: {
        payload: Prisma.$botsPayload<ExtArgs>
        fields: Prisma.botsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.botsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$botsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.botsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$botsPayload>
          }
          findFirst: {
            args: Prisma.botsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$botsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.botsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$botsPayload>
          }
          findMany: {
            args: Prisma.botsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$botsPayload>[]
          }
          create: {
            args: Prisma.botsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$botsPayload>
          }
          createMany: {
            args: Prisma.botsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.botsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$botsPayload>
          }
          update: {
            args: Prisma.botsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$botsPayload>
          }
          deleteMany: {
            args: Prisma.botsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.botsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.botsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$botsPayload>
          }
          aggregate: {
            args: Prisma.BotsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBots>
          }
          groupBy: {
            args: Prisma.botsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BotsGroupByOutputType>[]
          }
          count: {
            args: Prisma.botsCountArgs<ExtArgs>,
            result: $Utils.Optional<BotsCountAggregateOutputType> | number
          }
        }
      }
      extra_data: {
        payload: Prisma.$extra_dataPayload<ExtArgs>
        fields: Prisma.extra_dataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.extra_dataFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$extra_dataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.extra_dataFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$extra_dataPayload>
          }
          findFirst: {
            args: Prisma.extra_dataFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$extra_dataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.extra_dataFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$extra_dataPayload>
          }
          findMany: {
            args: Prisma.extra_dataFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$extra_dataPayload>[]
          }
          create: {
            args: Prisma.extra_dataCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$extra_dataPayload>
          }
          createMany: {
            args: Prisma.extra_dataCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.extra_dataDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$extra_dataPayload>
          }
          update: {
            args: Prisma.extra_dataUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$extra_dataPayload>
          }
          deleteMany: {
            args: Prisma.extra_dataDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.extra_dataUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.extra_dataUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$extra_dataPayload>
          }
          aggregate: {
            args: Prisma.Extra_dataAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateExtra_data>
          }
          groupBy: {
            args: Prisma.extra_dataGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Extra_dataGroupByOutputType>[]
          }
          count: {
            args: Prisma.extra_dataCountArgs<ExtArgs>,
            result: $Utils.Optional<Extra_dataCountAggregateOutputType> | number
          }
        }
      }
      features: {
        payload: Prisma.$featuresPayload<ExtArgs>
        fields: Prisma.featuresFieldRefs
        operations: {
          findUnique: {
            args: Prisma.featuresFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$featuresPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.featuresFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$featuresPayload>
          }
          findFirst: {
            args: Prisma.featuresFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$featuresPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.featuresFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$featuresPayload>
          }
          findMany: {
            args: Prisma.featuresFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$featuresPayload>[]
          }
          create: {
            args: Prisma.featuresCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$featuresPayload>
          }
          createMany: {
            args: Prisma.featuresCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.featuresDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$featuresPayload>
          }
          update: {
            args: Prisma.featuresUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$featuresPayload>
          }
          deleteMany: {
            args: Prisma.featuresDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.featuresUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.featuresUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$featuresPayload>
          }
          aggregate: {
            args: Prisma.FeaturesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFeatures>
          }
          groupBy: {
            args: Prisma.featuresGroupByArgs<ExtArgs>,
            result: $Utils.Optional<FeaturesGroupByOutputType>[]
          }
          count: {
            args: Prisma.featuresCountArgs<ExtArgs>,
            result: $Utils.Optional<FeaturesCountAggregateOutputType> | number
          }
        }
      }
      frostpaw_clients: {
        payload: Prisma.$frostpaw_clientsPayload<ExtArgs>
        fields: Prisma.frostpaw_clientsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.frostpaw_clientsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$frostpaw_clientsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.frostpaw_clientsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$frostpaw_clientsPayload>
          }
          findFirst: {
            args: Prisma.frostpaw_clientsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$frostpaw_clientsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.frostpaw_clientsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$frostpaw_clientsPayload>
          }
          findMany: {
            args: Prisma.frostpaw_clientsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$frostpaw_clientsPayload>[]
          }
          create: {
            args: Prisma.frostpaw_clientsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$frostpaw_clientsPayload>
          }
          createMany: {
            args: Prisma.frostpaw_clientsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.frostpaw_clientsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$frostpaw_clientsPayload>
          }
          update: {
            args: Prisma.frostpaw_clientsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$frostpaw_clientsPayload>
          }
          deleteMany: {
            args: Prisma.frostpaw_clientsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.frostpaw_clientsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.frostpaw_clientsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$frostpaw_clientsPayload>
          }
          aggregate: {
            args: Prisma.Frostpaw_clientsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFrostpaw_clients>
          }
          groupBy: {
            args: Prisma.frostpaw_clientsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Frostpaw_clientsGroupByOutputType>[]
          }
          count: {
            args: Prisma.frostpaw_clientsCountArgs<ExtArgs>,
            result: $Utils.Optional<Frostpaw_clientsCountAggregateOutputType> | number
          }
        }
      }
      leave_of_absence: {
        payload: Prisma.$leave_of_absencePayload<ExtArgs>
        fields: Prisma.leave_of_absenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.leave_of_absenceFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$leave_of_absencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.leave_of_absenceFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$leave_of_absencePayload>
          }
          findFirst: {
            args: Prisma.leave_of_absenceFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$leave_of_absencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.leave_of_absenceFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$leave_of_absencePayload>
          }
          findMany: {
            args: Prisma.leave_of_absenceFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$leave_of_absencePayload>[]
          }
          create: {
            args: Prisma.leave_of_absenceCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$leave_of_absencePayload>
          }
          createMany: {
            args: Prisma.leave_of_absenceCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.leave_of_absenceDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$leave_of_absencePayload>
          }
          update: {
            args: Prisma.leave_of_absenceUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$leave_of_absencePayload>
          }
          deleteMany: {
            args: Prisma.leave_of_absenceDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.leave_of_absenceUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.leave_of_absenceUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$leave_of_absencePayload>
          }
          aggregate: {
            args: Prisma.Leave_of_absenceAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLeave_of_absence>
          }
          groupBy: {
            args: Prisma.leave_of_absenceGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Leave_of_absenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.leave_of_absenceCountArgs<ExtArgs>,
            result: $Utils.Optional<Leave_of_absenceCountAggregateOutputType> | number
          }
        }
      }
      lynx_apps: {
        payload: Prisma.$lynx_appsPayload<ExtArgs>
        fields: Prisma.lynx_appsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.lynx_appsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$lynx_appsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.lynx_appsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$lynx_appsPayload>
          }
          findFirst: {
            args: Prisma.lynx_appsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$lynx_appsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.lynx_appsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$lynx_appsPayload>
          }
          findMany: {
            args: Prisma.lynx_appsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$lynx_appsPayload>[]
          }
          create: {
            args: Prisma.lynx_appsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$lynx_appsPayload>
          }
          createMany: {
            args: Prisma.lynx_appsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.lynx_appsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$lynx_appsPayload>
          }
          update: {
            args: Prisma.lynx_appsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$lynx_appsPayload>
          }
          deleteMany: {
            args: Prisma.lynx_appsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.lynx_appsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.lynx_appsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$lynx_appsPayload>
          }
          aggregate: {
            args: Prisma.Lynx_appsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLynx_apps>
          }
          groupBy: {
            args: Prisma.lynx_appsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Lynx_appsGroupByOutputType>[]
          }
          count: {
            args: Prisma.lynx_appsCountArgs<ExtArgs>,
            result: $Utils.Optional<Lynx_appsCountAggregateOutputType> | number
          }
        }
      }
      lynx_data: {
        payload: Prisma.$lynx_dataPayload<ExtArgs>
        fields: Prisma.lynx_dataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.lynx_dataFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$lynx_dataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.lynx_dataFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$lynx_dataPayload>
          }
          findFirst: {
            args: Prisma.lynx_dataFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$lynx_dataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.lynx_dataFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$lynx_dataPayload>
          }
          findMany: {
            args: Prisma.lynx_dataFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$lynx_dataPayload>[]
          }
          create: {
            args: Prisma.lynx_dataCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$lynx_dataPayload>
          }
          createMany: {
            args: Prisma.lynx_dataCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.lynx_dataDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$lynx_dataPayload>
          }
          update: {
            args: Prisma.lynx_dataUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$lynx_dataPayload>
          }
          deleteMany: {
            args: Prisma.lynx_dataDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.lynx_dataUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.lynx_dataUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$lynx_dataPayload>
          }
          aggregate: {
            args: Prisma.Lynx_dataAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLynx_data>
          }
          groupBy: {
            args: Prisma.lynx_dataGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Lynx_dataGroupByOutputType>[]
          }
          count: {
            args: Prisma.lynx_dataCountArgs<ExtArgs>,
            result: $Utils.Optional<Lynx_dataCountAggregateOutputType> | number
          }
        }
      }
      lynx_logs: {
        payload: Prisma.$lynx_logsPayload<ExtArgs>
        fields: Prisma.lynx_logsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.lynx_logsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$lynx_logsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.lynx_logsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$lynx_logsPayload>
          }
          findFirst: {
            args: Prisma.lynx_logsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$lynx_logsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.lynx_logsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$lynx_logsPayload>
          }
          findMany: {
            args: Prisma.lynx_logsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$lynx_logsPayload>[]
          }
          create: {
            args: Prisma.lynx_logsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$lynx_logsPayload>
          }
          createMany: {
            args: Prisma.lynx_logsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.lynx_logsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$lynx_logsPayload>
          }
          update: {
            args: Prisma.lynx_logsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$lynx_logsPayload>
          }
          deleteMany: {
            args: Prisma.lynx_logsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.lynx_logsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.lynx_logsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$lynx_logsPayload>
          }
          aggregate: {
            args: Prisma.Lynx_logsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLynx_logs>
          }
          groupBy: {
            args: Prisma.lynx_logsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Lynx_logsGroupByOutputType>[]
          }
          count: {
            args: Prisma.lynx_logsCountArgs<ExtArgs>,
            result: $Utils.Optional<Lynx_logsCountAggregateOutputType> | number
          }
        }
      }
      lynx_notifications: {
        payload: Prisma.$lynx_notificationsPayload<ExtArgs>
        fields: Prisma.lynx_notificationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.lynx_notificationsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$lynx_notificationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.lynx_notificationsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$lynx_notificationsPayload>
          }
          findFirst: {
            args: Prisma.lynx_notificationsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$lynx_notificationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.lynx_notificationsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$lynx_notificationsPayload>
          }
          findMany: {
            args: Prisma.lynx_notificationsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$lynx_notificationsPayload>[]
          }
          create: {
            args: Prisma.lynx_notificationsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$lynx_notificationsPayload>
          }
          createMany: {
            args: Prisma.lynx_notificationsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.lynx_notificationsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$lynx_notificationsPayload>
          }
          update: {
            args: Prisma.lynx_notificationsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$lynx_notificationsPayload>
          }
          deleteMany: {
            args: Prisma.lynx_notificationsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.lynx_notificationsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.lynx_notificationsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$lynx_notificationsPayload>
          }
          aggregate: {
            args: Prisma.Lynx_notificationsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLynx_notifications>
          }
          groupBy: {
            args: Prisma.lynx_notificationsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Lynx_notificationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.lynx_notificationsCountArgs<ExtArgs>,
            result: $Utils.Optional<Lynx_notificationsCountAggregateOutputType> | number
          }
        }
      }
      lynx_ratings: {
        payload: Prisma.$lynx_ratingsPayload<ExtArgs>
        fields: Prisma.lynx_ratingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.lynx_ratingsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$lynx_ratingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.lynx_ratingsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$lynx_ratingsPayload>
          }
          findFirst: {
            args: Prisma.lynx_ratingsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$lynx_ratingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.lynx_ratingsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$lynx_ratingsPayload>
          }
          findMany: {
            args: Prisma.lynx_ratingsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$lynx_ratingsPayload>[]
          }
          create: {
            args: Prisma.lynx_ratingsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$lynx_ratingsPayload>
          }
          createMany: {
            args: Prisma.lynx_ratingsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.lynx_ratingsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$lynx_ratingsPayload>
          }
          update: {
            args: Prisma.lynx_ratingsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$lynx_ratingsPayload>
          }
          deleteMany: {
            args: Prisma.lynx_ratingsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.lynx_ratingsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.lynx_ratingsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$lynx_ratingsPayload>
          }
          aggregate: {
            args: Prisma.Lynx_ratingsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLynx_ratings>
          }
          groupBy: {
            args: Prisma.lynx_ratingsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Lynx_ratingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.lynx_ratingsCountArgs<ExtArgs>,
            result: $Utils.Optional<Lynx_ratingsCountAggregateOutputType> | number
          }
        }
      }
      lynx_survey_responses: {
        payload: Prisma.$lynx_survey_responsesPayload<ExtArgs>
        fields: Prisma.lynx_survey_responsesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.lynx_survey_responsesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$lynx_survey_responsesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.lynx_survey_responsesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$lynx_survey_responsesPayload>
          }
          findFirst: {
            args: Prisma.lynx_survey_responsesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$lynx_survey_responsesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.lynx_survey_responsesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$lynx_survey_responsesPayload>
          }
          findMany: {
            args: Prisma.lynx_survey_responsesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$lynx_survey_responsesPayload>[]
          }
          create: {
            args: Prisma.lynx_survey_responsesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$lynx_survey_responsesPayload>
          }
          createMany: {
            args: Prisma.lynx_survey_responsesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.lynx_survey_responsesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$lynx_survey_responsesPayload>
          }
          update: {
            args: Prisma.lynx_survey_responsesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$lynx_survey_responsesPayload>
          }
          deleteMany: {
            args: Prisma.lynx_survey_responsesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.lynx_survey_responsesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.lynx_survey_responsesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$lynx_survey_responsesPayload>
          }
          aggregate: {
            args: Prisma.Lynx_survey_responsesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLynx_survey_responses>
          }
          groupBy: {
            args: Prisma.lynx_survey_responsesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Lynx_survey_responsesGroupByOutputType>[]
          }
          count: {
            args: Prisma.lynx_survey_responsesCountArgs<ExtArgs>,
            result: $Utils.Optional<Lynx_survey_responsesCountAggregateOutputType> | number
          }
        }
      }
      lynx_surveys: {
        payload: Prisma.$lynx_surveysPayload<ExtArgs>
        fields: Prisma.lynx_surveysFieldRefs
        operations: {
          findUnique: {
            args: Prisma.lynx_surveysFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$lynx_surveysPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.lynx_surveysFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$lynx_surveysPayload>
          }
          findFirst: {
            args: Prisma.lynx_surveysFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$lynx_surveysPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.lynx_surveysFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$lynx_surveysPayload>
          }
          findMany: {
            args: Prisma.lynx_surveysFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$lynx_surveysPayload>[]
          }
          create: {
            args: Prisma.lynx_surveysCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$lynx_surveysPayload>
          }
          createMany: {
            args: Prisma.lynx_surveysCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.lynx_surveysDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$lynx_surveysPayload>
          }
          update: {
            args: Prisma.lynx_surveysUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$lynx_surveysPayload>
          }
          deleteMany: {
            args: Prisma.lynx_surveysDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.lynx_surveysUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.lynx_surveysUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$lynx_surveysPayload>
          }
          aggregate: {
            args: Prisma.Lynx_surveysAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLynx_surveys>
          }
          groupBy: {
            args: Prisma.lynx_surveysGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Lynx_surveysGroupByOutputType>[]
          }
          count: {
            args: Prisma.lynx_surveysCountArgs<ExtArgs>,
            result: $Utils.Optional<Lynx_surveysCountAggregateOutputType> | number
          }
        }
      }
      migration: {
        payload: Prisma.$migrationPayload<ExtArgs>
        fields: Prisma.migrationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.migrationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$migrationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.migrationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$migrationPayload>
          }
          findFirst: {
            args: Prisma.migrationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$migrationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.migrationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$migrationPayload>
          }
          findMany: {
            args: Prisma.migrationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$migrationPayload>[]
          }
          create: {
            args: Prisma.migrationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$migrationPayload>
          }
          createMany: {
            args: Prisma.migrationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.migrationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$migrationPayload>
          }
          update: {
            args: Prisma.migrationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$migrationPayload>
          }
          deleteMany: {
            args: Prisma.migrationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.migrationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.migrationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$migrationPayload>
          }
          aggregate: {
            args: Prisma.MigrationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMigration>
          }
          groupBy: {
            args: Prisma.migrationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MigrationGroupByOutputType>[]
          }
          count: {
            args: Prisma.migrationCountArgs<ExtArgs>,
            result: $Utils.Optional<MigrationCountAggregateOutputType> | number
          }
        }
      }
      piccolo_user: {
        payload: Prisma.$piccolo_userPayload<ExtArgs>
        fields: Prisma.piccolo_userFieldRefs
        operations: {
          findUnique: {
            args: Prisma.piccolo_userFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$piccolo_userPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.piccolo_userFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$piccolo_userPayload>
          }
          findFirst: {
            args: Prisma.piccolo_userFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$piccolo_userPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.piccolo_userFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$piccolo_userPayload>
          }
          findMany: {
            args: Prisma.piccolo_userFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$piccolo_userPayload>[]
          }
          create: {
            args: Prisma.piccolo_userCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$piccolo_userPayload>
          }
          createMany: {
            args: Prisma.piccolo_userCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.piccolo_userDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$piccolo_userPayload>
          }
          update: {
            args: Prisma.piccolo_userUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$piccolo_userPayload>
          }
          deleteMany: {
            args: Prisma.piccolo_userDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.piccolo_userUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.piccolo_userUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$piccolo_userPayload>
          }
          aggregate: {
            args: Prisma.Piccolo_userAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePiccolo_user>
          }
          groupBy: {
            args: Prisma.piccolo_userGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Piccolo_userGroupByOutputType>[]
          }
          count: {
            args: Prisma.piccolo_userCountArgs<ExtArgs>,
            result: $Utils.Optional<Piccolo_userCountAggregateOutputType> | number
          }
        }
      }
      platform_map: {
        payload: Prisma.$platform_mapPayload<ExtArgs>
        fields: Prisma.platform_mapFieldRefs
        operations: {
          findUnique: {
            args: Prisma.platform_mapFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$platform_mapPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.platform_mapFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$platform_mapPayload>
          }
          findFirst: {
            args: Prisma.platform_mapFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$platform_mapPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.platform_mapFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$platform_mapPayload>
          }
          findMany: {
            args: Prisma.platform_mapFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$platform_mapPayload>[]
          }
          create: {
            args: Prisma.platform_mapCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$platform_mapPayload>
          }
          createMany: {
            args: Prisma.platform_mapCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.platform_mapDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$platform_mapPayload>
          }
          update: {
            args: Prisma.platform_mapUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$platform_mapPayload>
          }
          deleteMany: {
            args: Prisma.platform_mapDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.platform_mapUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.platform_mapUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$platform_mapPayload>
          }
          aggregate: {
            args: Prisma.Platform_mapAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePlatform_map>
          }
          groupBy: {
            args: Prisma.platform_mapGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Platform_mapGroupByOutputType>[]
          }
          count: {
            args: Prisma.platform_mapCountArgs<ExtArgs>,
            result: $Utils.Optional<Platform_mapCountAggregateOutputType> | number
          }
        }
      }
      push_notifications: {
        payload: Prisma.$push_notificationsPayload<ExtArgs>
        fields: Prisma.push_notificationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.push_notificationsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$push_notificationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.push_notificationsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$push_notificationsPayload>
          }
          findFirst: {
            args: Prisma.push_notificationsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$push_notificationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.push_notificationsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$push_notificationsPayload>
          }
          findMany: {
            args: Prisma.push_notificationsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$push_notificationsPayload>[]
          }
          create: {
            args: Prisma.push_notificationsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$push_notificationsPayload>
          }
          createMany: {
            args: Prisma.push_notificationsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.push_notificationsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$push_notificationsPayload>
          }
          update: {
            args: Prisma.push_notificationsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$push_notificationsPayload>
          }
          deleteMany: {
            args: Prisma.push_notificationsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.push_notificationsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.push_notificationsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$push_notificationsPayload>
          }
          aggregate: {
            args: Prisma.Push_notificationsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePush_notifications>
          }
          groupBy: {
            args: Prisma.push_notificationsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Push_notificationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.push_notificationsCountArgs<ExtArgs>,
            result: $Utils.Optional<Push_notificationsCountAggregateOutputType> | number
          }
        }
      }
      review_votes: {
        payload: Prisma.$review_votesPayload<ExtArgs>
        fields: Prisma.review_votesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.review_votesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$review_votesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.review_votesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$review_votesPayload>
          }
          findFirst: {
            args: Prisma.review_votesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$review_votesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.review_votesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$review_votesPayload>
          }
          findMany: {
            args: Prisma.review_votesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$review_votesPayload>[]
          }
          create: {
            args: Prisma.review_votesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$review_votesPayload>
          }
          createMany: {
            args: Prisma.review_votesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.review_votesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$review_votesPayload>
          }
          update: {
            args: Prisma.review_votesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$review_votesPayload>
          }
          deleteMany: {
            args: Prisma.review_votesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.review_votesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.review_votesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$review_votesPayload>
          }
          aggregate: {
            args: Prisma.Review_votesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateReview_votes>
          }
          groupBy: {
            args: Prisma.review_votesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Review_votesGroupByOutputType>[]
          }
          count: {
            args: Prisma.review_votesCountArgs<ExtArgs>,
            result: $Utils.Optional<Review_votesCountAggregateOutputType> | number
          }
        }
      }
      reviews: {
        payload: Prisma.$reviewsPayload<ExtArgs>
        fields: Prisma.reviewsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.reviewsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$reviewsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.reviewsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$reviewsPayload>
          }
          findFirst: {
            args: Prisma.reviewsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$reviewsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.reviewsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$reviewsPayload>
          }
          findMany: {
            args: Prisma.reviewsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$reviewsPayload>[]
          }
          create: {
            args: Prisma.reviewsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$reviewsPayload>
          }
          createMany: {
            args: Prisma.reviewsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.reviewsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$reviewsPayload>
          }
          update: {
            args: Prisma.reviewsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$reviewsPayload>
          }
          deleteMany: {
            args: Prisma.reviewsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.reviewsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.reviewsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$reviewsPayload>
          }
          aggregate: {
            args: Prisma.ReviewsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateReviews>
          }
          groupBy: {
            args: Prisma.reviewsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ReviewsGroupByOutputType>[]
          }
          count: {
            args: Prisma.reviewsCountArgs<ExtArgs>,
            result: $Utils.Optional<ReviewsCountAggregateOutputType> | number
          }
        }
      }
      server_audit_logs: {
        payload: Prisma.$server_audit_logsPayload<ExtArgs>
        fields: Prisma.server_audit_logsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.server_audit_logsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$server_audit_logsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.server_audit_logsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$server_audit_logsPayload>
          }
          findFirst: {
            args: Prisma.server_audit_logsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$server_audit_logsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.server_audit_logsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$server_audit_logsPayload>
          }
          findMany: {
            args: Prisma.server_audit_logsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$server_audit_logsPayload>[]
          }
          create: {
            args: Prisma.server_audit_logsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$server_audit_logsPayload>
          }
          createMany: {
            args: Prisma.server_audit_logsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.server_audit_logsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$server_audit_logsPayload>
          }
          update: {
            args: Prisma.server_audit_logsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$server_audit_logsPayload>
          }
          deleteMany: {
            args: Prisma.server_audit_logsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.server_audit_logsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.server_audit_logsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$server_audit_logsPayload>
          }
          aggregate: {
            args: Prisma.Server_audit_logsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateServer_audit_logs>
          }
          groupBy: {
            args: Prisma.server_audit_logsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Server_audit_logsGroupByOutputType>[]
          }
          count: {
            args: Prisma.server_audit_logsCountArgs<ExtArgs>,
            result: $Utils.Optional<Server_audit_logsCountAggregateOutputType> | number
          }
        }
      }
      server_tags: {
        payload: Prisma.$server_tagsPayload<ExtArgs>
        fields: Prisma.server_tagsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.server_tagsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$server_tagsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.server_tagsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$server_tagsPayload>
          }
          findFirst: {
            args: Prisma.server_tagsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$server_tagsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.server_tagsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$server_tagsPayload>
          }
          findMany: {
            args: Prisma.server_tagsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$server_tagsPayload>[]
          }
          create: {
            args: Prisma.server_tagsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$server_tagsPayload>
          }
          createMany: {
            args: Prisma.server_tagsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.server_tagsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$server_tagsPayload>
          }
          update: {
            args: Prisma.server_tagsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$server_tagsPayload>
          }
          deleteMany: {
            args: Prisma.server_tagsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.server_tagsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.server_tagsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$server_tagsPayload>
          }
          aggregate: {
            args: Prisma.Server_tagsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateServer_tags>
          }
          groupBy: {
            args: Prisma.server_tagsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Server_tagsGroupByOutputType>[]
          }
          count: {
            args: Prisma.server_tagsCountArgs<ExtArgs>,
            result: $Utils.Optional<Server_tagsCountAggregateOutputType> | number
          }
        }
      }
      server_voters: {
        payload: Prisma.$server_votersPayload<ExtArgs>
        fields: Prisma.server_votersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.server_votersFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$server_votersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.server_votersFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$server_votersPayload>
          }
          findFirst: {
            args: Prisma.server_votersFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$server_votersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.server_votersFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$server_votersPayload>
          }
          findMany: {
            args: Prisma.server_votersFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$server_votersPayload>[]
          }
          create: {
            args: Prisma.server_votersCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$server_votersPayload>
          }
          createMany: {
            args: Prisma.server_votersCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.server_votersDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$server_votersPayload>
          }
          update: {
            args: Prisma.server_votersUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$server_votersPayload>
          }
          deleteMany: {
            args: Prisma.server_votersDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.server_votersUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.server_votersUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$server_votersPayload>
          }
          aggregate: {
            args: Prisma.Server_votersAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateServer_voters>
          }
          groupBy: {
            args: Prisma.server_votersGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Server_votersGroupByOutputType>[]
          }
          count: {
            args: Prisma.server_votersCountArgs<ExtArgs>,
            result: $Utils.Optional<Server_votersCountAggregateOutputType> | number
          }
        }
      }
      servers: {
        payload: Prisma.$serversPayload<ExtArgs>
        fields: Prisma.serversFieldRefs
        operations: {
          findUnique: {
            args: Prisma.serversFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$serversPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.serversFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$serversPayload>
          }
          findFirst: {
            args: Prisma.serversFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$serversPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.serversFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$serversPayload>
          }
          findMany: {
            args: Prisma.serversFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$serversPayload>[]
          }
          create: {
            args: Prisma.serversCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$serversPayload>
          }
          createMany: {
            args: Prisma.serversCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.serversDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$serversPayload>
          }
          update: {
            args: Prisma.serversUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$serversPayload>
          }
          deleteMany: {
            args: Prisma.serversDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.serversUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.serversUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$serversPayload>
          }
          aggregate: {
            args: Prisma.ServersAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateServers>
          }
          groupBy: {
            args: Prisma.serversGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ServersGroupByOutputType>[]
          }
          count: {
            args: Prisma.serversCountArgs<ExtArgs>,
            result: $Utils.Optional<ServersCountAggregateOutputType> | number
          }
        }
      }
      sessions: {
        payload: Prisma.$sessionsPayload<ExtArgs>
        fields: Prisma.sessionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.sessionsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.sessionsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>
          }
          findFirst: {
            args: Prisma.sessionsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.sessionsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>
          }
          findMany: {
            args: Prisma.sessionsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>[]
          }
          create: {
            args: Prisma.sessionsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>
          }
          createMany: {
            args: Prisma.sessionsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.sessionsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>
          }
          update: {
            args: Prisma.sessionsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>
          }
          deleteMany: {
            args: Prisma.sessionsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.sessionsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.sessionsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>
          }
          aggregate: {
            args: Prisma.SessionsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSessions>
          }
          groupBy: {
            args: Prisma.sessionsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SessionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.sessionsCountArgs<ExtArgs>,
            result: $Utils.Optional<SessionsCountAggregateOutputType> | number
          }
        }
      }
      user_bot_logs: {
        payload: Prisma.$user_bot_logsPayload<ExtArgs>
        fields: Prisma.user_bot_logsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.user_bot_logsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$user_bot_logsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.user_bot_logsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$user_bot_logsPayload>
          }
          findFirst: {
            args: Prisma.user_bot_logsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$user_bot_logsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.user_bot_logsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$user_bot_logsPayload>
          }
          findMany: {
            args: Prisma.user_bot_logsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$user_bot_logsPayload>[]
          }
          create: {
            args: Prisma.user_bot_logsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$user_bot_logsPayload>
          }
          createMany: {
            args: Prisma.user_bot_logsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.user_bot_logsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$user_bot_logsPayload>
          }
          update: {
            args: Prisma.user_bot_logsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$user_bot_logsPayload>
          }
          deleteMany: {
            args: Prisma.user_bot_logsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.user_bot_logsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.user_bot_logsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$user_bot_logsPayload>
          }
          aggregate: {
            args: Prisma.User_bot_logsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser_bot_logs>
          }
          groupBy: {
            args: Prisma.user_bot_logsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<User_bot_logsGroupByOutputType>[]
          }
          count: {
            args: Prisma.user_bot_logsCountArgs<ExtArgs>,
            result: $Utils.Optional<User_bot_logsCountAggregateOutputType> | number
          }
        }
      }
      user_connections: {
        payload: Prisma.$user_connectionsPayload<ExtArgs>
        fields: Prisma.user_connectionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.user_connectionsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$user_connectionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.user_connectionsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$user_connectionsPayload>
          }
          findFirst: {
            args: Prisma.user_connectionsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$user_connectionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.user_connectionsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$user_connectionsPayload>
          }
          findMany: {
            args: Prisma.user_connectionsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$user_connectionsPayload>[]
          }
          create: {
            args: Prisma.user_connectionsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$user_connectionsPayload>
          }
          createMany: {
            args: Prisma.user_connectionsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.user_connectionsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$user_connectionsPayload>
          }
          update: {
            args: Prisma.user_connectionsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$user_connectionsPayload>
          }
          deleteMany: {
            args: Prisma.user_connectionsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.user_connectionsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.user_connectionsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$user_connectionsPayload>
          }
          aggregate: {
            args: Prisma.User_connectionsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser_connections>
          }
          groupBy: {
            args: Prisma.user_connectionsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<User_connectionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.user_connectionsCountArgs<ExtArgs>,
            result: $Utils.Optional<User_connectionsCountAggregateOutputType> | number
          }
        }
      }
      user_server_vote_table: {
        payload: Prisma.$user_server_vote_tablePayload<ExtArgs>
        fields: Prisma.user_server_vote_tableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.user_server_vote_tableFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$user_server_vote_tablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.user_server_vote_tableFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$user_server_vote_tablePayload>
          }
          findFirst: {
            args: Prisma.user_server_vote_tableFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$user_server_vote_tablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.user_server_vote_tableFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$user_server_vote_tablePayload>
          }
          findMany: {
            args: Prisma.user_server_vote_tableFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$user_server_vote_tablePayload>[]
          }
          create: {
            args: Prisma.user_server_vote_tableCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$user_server_vote_tablePayload>
          }
          createMany: {
            args: Prisma.user_server_vote_tableCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.user_server_vote_tableDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$user_server_vote_tablePayload>
          }
          update: {
            args: Prisma.user_server_vote_tableUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$user_server_vote_tablePayload>
          }
          deleteMany: {
            args: Prisma.user_server_vote_tableDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.user_server_vote_tableUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.user_server_vote_tableUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$user_server_vote_tablePayload>
          }
          aggregate: {
            args: Prisma.User_server_vote_tableAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser_server_vote_table>
          }
          groupBy: {
            args: Prisma.user_server_vote_tableGroupByArgs<ExtArgs>,
            result: $Utils.Optional<User_server_vote_tableGroupByOutputType>[]
          }
          count: {
            args: Prisma.user_server_vote_tableCountArgs<ExtArgs>,
            result: $Utils.Optional<User_server_vote_tableCountAggregateOutputType> | number
          }
        }
      }
      user_vote_table: {
        payload: Prisma.$user_vote_tablePayload<ExtArgs>
        fields: Prisma.user_vote_tableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.user_vote_tableFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$user_vote_tablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.user_vote_tableFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$user_vote_tablePayload>
          }
          findFirst: {
            args: Prisma.user_vote_tableFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$user_vote_tablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.user_vote_tableFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$user_vote_tablePayload>
          }
          findMany: {
            args: Prisma.user_vote_tableFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$user_vote_tablePayload>[]
          }
          create: {
            args: Prisma.user_vote_tableCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$user_vote_tablePayload>
          }
          createMany: {
            args: Prisma.user_vote_tableCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.user_vote_tableDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$user_vote_tablePayload>
          }
          update: {
            args: Prisma.user_vote_tableUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$user_vote_tablePayload>
          }
          deleteMany: {
            args: Prisma.user_vote_tableDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.user_vote_tableUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.user_vote_tableUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$user_vote_tablePayload>
          }
          aggregate: {
            args: Prisma.User_vote_tableAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser_vote_table>
          }
          groupBy: {
            args: Prisma.user_vote_tableGroupByArgs<ExtArgs>,
            result: $Utils.Optional<User_vote_tableGroupByOutputType>[]
          }
          count: {
            args: Prisma.user_vote_tableCountArgs<ExtArgs>,
            result: $Utils.Optional<User_vote_tableCountAggregateOutputType> | number
          }
        }
      }
      users: {
        payload: Prisma.$usersPayload<ExtArgs>
        fields: Prisma.usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usersFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usersFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findFirst: {
            args: Prisma.usersFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usersFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findMany: {
            args: Prisma.usersFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          create: {
            args: Prisma.usersCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          createMany: {
            args: Prisma.usersCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.usersDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          update: {
            args: Prisma.usersUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          deleteMany: {
            args: Prisma.usersDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.usersUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.usersUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.usersGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.usersCountArgs<ExtArgs>,
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      vanity: {
        payload: Prisma.$vanityPayload<ExtArgs>
        fields: Prisma.vanityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.vanityFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$vanityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.vanityFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$vanityPayload>
          }
          findFirst: {
            args: Prisma.vanityFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$vanityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.vanityFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$vanityPayload>
          }
          findMany: {
            args: Prisma.vanityFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$vanityPayload>[]
          }
          create: {
            args: Prisma.vanityCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$vanityPayload>
          }
          createMany: {
            args: Prisma.vanityCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.vanityDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$vanityPayload>
          }
          update: {
            args: Prisma.vanityUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$vanityPayload>
          }
          deleteMany: {
            args: Prisma.vanityDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.vanityUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.vanityUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$vanityPayload>
          }
          aggregate: {
            args: Prisma.VanityAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateVanity>
          }
          groupBy: {
            args: Prisma.vanityGroupByArgs<ExtArgs>,
            result: $Utils.Optional<VanityGroupByOutputType>[]
          }
          count: {
            args: Prisma.vanityCountArgs<ExtArgs>,
            result: $Utils.Optional<VanityCountAggregateOutputType> | number
          }
        }
      }
      ws_events: {
        payload: Prisma.$ws_eventsPayload<ExtArgs>
        fields: Prisma.ws_eventsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ws_eventsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ws_eventsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ws_eventsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ws_eventsPayload>
          }
          findFirst: {
            args: Prisma.ws_eventsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ws_eventsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ws_eventsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ws_eventsPayload>
          }
          findMany: {
            args: Prisma.ws_eventsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ws_eventsPayload>[]
          }
          create: {
            args: Prisma.ws_eventsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ws_eventsPayload>
          }
          createMany: {
            args: Prisma.ws_eventsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ws_eventsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ws_eventsPayload>
          }
          update: {
            args: Prisma.ws_eventsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ws_eventsPayload>
          }
          deleteMany: {
            args: Prisma.ws_eventsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ws_eventsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ws_eventsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ws_eventsPayload>
          }
          aggregate: {
            args: Prisma.Ws_eventsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateWs_events>
          }
          groupBy: {
            args: Prisma.ws_eventsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Ws_eventsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ws_eventsCountArgs<ExtArgs>,
            result: $Utils.Optional<Ws_eventsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type Bot_list_tagsCountOutputType
   */

  export type Bot_list_tagsCountOutputType = {
    bot_tags: number
  }

  export type Bot_list_tagsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bot_tags?: boolean | Bot_list_tagsCountOutputTypeCountBot_tagsArgs
  }

  // Custom InputTypes

  /**
   * Bot_list_tagsCountOutputType without action
   */
  export type Bot_list_tagsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bot_list_tagsCountOutputType
     */
    select?: Bot_list_tagsCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * Bot_list_tagsCountOutputType without action
   */
  export type Bot_list_tagsCountOutputTypeCountBot_tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bot_tagsWhereInput
  }



  /**
   * Count Type BotsCountOutputType
   */

  export type BotsCountOutputType = {
    bot_commands: number
    bot_events: number
    bot_owner: number
    bot_promotions: number
    bot_tags: number
  }

  export type BotsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bot_commands?: boolean | BotsCountOutputTypeCountBot_commandsArgs
    bot_events?: boolean | BotsCountOutputTypeCountBot_eventsArgs
    bot_owner?: boolean | BotsCountOutputTypeCountBot_ownerArgs
    bot_promotions?: boolean | BotsCountOutputTypeCountBot_promotionsArgs
    bot_tags?: boolean | BotsCountOutputTypeCountBot_tagsArgs
  }

  // Custom InputTypes

  /**
   * BotsCountOutputType without action
   */
  export type BotsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotsCountOutputType
     */
    select?: BotsCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * BotsCountOutputType without action
   */
  export type BotsCountOutputTypeCountBot_commandsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bot_commandsWhereInput
  }


  /**
   * BotsCountOutputType without action
   */
  export type BotsCountOutputTypeCountBot_eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bot_eventsWhereInput
  }


  /**
   * BotsCountOutputType without action
   */
  export type BotsCountOutputTypeCountBot_ownerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bot_ownerWhereInput
  }


  /**
   * BotsCountOutputType without action
   */
  export type BotsCountOutputTypeCountBot_promotionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bot_promotionsWhereInput
  }


  /**
   * BotsCountOutputType without action
   */
  export type BotsCountOutputTypeCountBot_tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bot_tagsWhereInput
  }



  /**
   * Count Type Lynx_surveysCountOutputType
   */

  export type Lynx_surveysCountOutputType = {
    lynx_survey_responses: number
  }

  export type Lynx_surveysCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lynx_survey_responses?: boolean | Lynx_surveysCountOutputTypeCountLynx_survey_responsesArgs
  }

  // Custom InputTypes

  /**
   * Lynx_surveysCountOutputType without action
   */
  export type Lynx_surveysCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lynx_surveysCountOutputType
     */
    select?: Lynx_surveysCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * Lynx_surveysCountOutputType without action
   */
  export type Lynx_surveysCountOutputTypeCountLynx_survey_responsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: lynx_survey_responsesWhereInput
  }



  /**
   * Count Type ReviewsCountOutputType
   */

  export type ReviewsCountOutputType = {
    review_votes: number
    other_reviews: number
  }

  export type ReviewsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    review_votes?: boolean | ReviewsCountOutputTypeCountReview_votesArgs
    other_reviews?: boolean | ReviewsCountOutputTypeCountOther_reviewsArgs
  }

  // Custom InputTypes

  /**
   * ReviewsCountOutputType without action
   */
  export type ReviewsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewsCountOutputType
     */
    select?: ReviewsCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ReviewsCountOutputType without action
   */
  export type ReviewsCountOutputTypeCountReview_votesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: review_votesWhereInput
  }


  /**
   * ReviewsCountOutputType without action
   */
  export type ReviewsCountOutputTypeCountOther_reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reviewsWhereInput
  }



  /**
   * Count Type ServersCountOutputType
   */

  export type ServersCountOutputType = {
    server_audit_logs: number
  }

  export type ServersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    server_audit_logs?: boolean | ServersCountOutputTypeCountServer_audit_logsArgs
  }

  // Custom InputTypes

  /**
   * ServersCountOutputType without action
   */
  export type ServersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServersCountOutputType
     */
    select?: ServersCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ServersCountOutputType without action
   */
  export type ServersCountOutputTypeCountServer_audit_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: server_audit_logsWhereInput
  }



  /**
   * Count Type UsersCountOutputType
   */

  export type UsersCountOutputType = {
    bot_voters: number
    extra_data: number
    frostpaw_clients: number
    leave_of_absence: number
    lynx_apps: number
    lynx_logs: number
    lynx_ratings: number
    lynx_survey_responses: number
    push_notifications: number
    review_votes: number
    reviews: number
    server_audit_logs: number
    server_voters: number
    servers: number
    user_bot_logs: number
    user_connections: number
  }

  export type UsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bot_voters?: boolean | UsersCountOutputTypeCountBot_votersArgs
    extra_data?: boolean | UsersCountOutputTypeCountExtra_dataArgs
    frostpaw_clients?: boolean | UsersCountOutputTypeCountFrostpaw_clientsArgs
    leave_of_absence?: boolean | UsersCountOutputTypeCountLeave_of_absenceArgs
    lynx_apps?: boolean | UsersCountOutputTypeCountLynx_appsArgs
    lynx_logs?: boolean | UsersCountOutputTypeCountLynx_logsArgs
    lynx_ratings?: boolean | UsersCountOutputTypeCountLynx_ratingsArgs
    lynx_survey_responses?: boolean | UsersCountOutputTypeCountLynx_survey_responsesArgs
    push_notifications?: boolean | UsersCountOutputTypeCountPush_notificationsArgs
    review_votes?: boolean | UsersCountOutputTypeCountReview_votesArgs
    reviews?: boolean | UsersCountOutputTypeCountReviewsArgs
    server_audit_logs?: boolean | UsersCountOutputTypeCountServer_audit_logsArgs
    server_voters?: boolean | UsersCountOutputTypeCountServer_votersArgs
    servers?: boolean | UsersCountOutputTypeCountServersArgs
    user_bot_logs?: boolean | UsersCountOutputTypeCountUser_bot_logsArgs
    user_connections?: boolean | UsersCountOutputTypeCountUser_connectionsArgs
  }

  // Custom InputTypes

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountBot_votersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bot_votersWhereInput
  }


  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountExtra_dataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: extra_dataWhereInput
  }


  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountFrostpaw_clientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: frostpaw_clientsWhereInput
  }


  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountLeave_of_absenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: leave_of_absenceWhereInput
  }


  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountLynx_appsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: lynx_appsWhereInput
  }


  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountLynx_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: lynx_logsWhereInput
  }


  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountLynx_ratingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: lynx_ratingsWhereInput
  }


  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountLynx_survey_responsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: lynx_survey_responsesWhereInput
  }


  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountPush_notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: push_notificationsWhereInput
  }


  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountReview_votesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: review_votesWhereInput
  }


  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reviewsWhereInput
  }


  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountServer_audit_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: server_audit_logsWhereInput
  }


  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountServer_votersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: server_votersWhereInput
  }


  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountServersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: serversWhereInput
  }


  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountUser_bot_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_bot_logsWhereInput
  }


  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountUser_connectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_connectionsWhereInput
  }



  /**
   * Models
   */

  /**
   * Model bot_commands
   */

  export type AggregateBot_commands = {
    _count: Bot_commandsCountAggregateOutputType | null
    _avg: Bot_commandsAvgAggregateOutputType | null
    _sum: Bot_commandsSumAggregateOutputType | null
    _min: Bot_commandsMinAggregateOutputType | null
    _max: Bot_commandsMaxAggregateOutputType | null
  }

  export type Bot_commandsAvgAggregateOutputType = {
    bot_id: number | null
    cmd_type: number | null
  }

  export type Bot_commandsSumAggregateOutputType = {
    bot_id: bigint | null
    cmd_type: number | null
  }

  export type Bot_commandsMinAggregateOutputType = {
    id: string | null
    bot_id: bigint | null
    cmd_type: number | null
    name: string | null
    vote_locked: boolean | null
    description: string | null
    premium_only: boolean | null
    doc_link: string | null
    nsfw: boolean | null
    lynxtag: string | null
  }

  export type Bot_commandsMaxAggregateOutputType = {
    id: string | null
    bot_id: bigint | null
    cmd_type: number | null
    name: string | null
    vote_locked: boolean | null
    description: string | null
    premium_only: boolean | null
    doc_link: string | null
    nsfw: boolean | null
    lynxtag: string | null
  }

  export type Bot_commandsCountAggregateOutputType = {
    id: number
    bot_id: number
    cmd_type: number
    groups: number
    name: number
    vote_locked: number
    description: number
    args: number
    examples: number
    premium_only: number
    notes: number
    doc_link: number
    nsfw: number
    lynxtag: number
    _all: number
  }


  export type Bot_commandsAvgAggregateInputType = {
    bot_id?: true
    cmd_type?: true
  }

  export type Bot_commandsSumAggregateInputType = {
    bot_id?: true
    cmd_type?: true
  }

  export type Bot_commandsMinAggregateInputType = {
    id?: true
    bot_id?: true
    cmd_type?: true
    name?: true
    vote_locked?: true
    description?: true
    premium_only?: true
    doc_link?: true
    nsfw?: true
    lynxtag?: true
  }

  export type Bot_commandsMaxAggregateInputType = {
    id?: true
    bot_id?: true
    cmd_type?: true
    name?: true
    vote_locked?: true
    description?: true
    premium_only?: true
    doc_link?: true
    nsfw?: true
    lynxtag?: true
  }

  export type Bot_commandsCountAggregateInputType = {
    id?: true
    bot_id?: true
    cmd_type?: true
    groups?: true
    name?: true
    vote_locked?: true
    description?: true
    args?: true
    examples?: true
    premium_only?: true
    notes?: true
    doc_link?: true
    nsfw?: true
    lynxtag?: true
    _all?: true
  }

  export type Bot_commandsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bot_commands to aggregate.
     */
    where?: bot_commandsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bot_commands to fetch.
     */
    orderBy?: bot_commandsOrderByWithRelationInput | bot_commandsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: bot_commandsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bot_commands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bot_commands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned bot_commands
    **/
    _count?: true | Bot_commandsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Bot_commandsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Bot_commandsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Bot_commandsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Bot_commandsMaxAggregateInputType
  }

  export type GetBot_commandsAggregateType<T extends Bot_commandsAggregateArgs> = {
        [P in keyof T & keyof AggregateBot_commands]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBot_commands[P]>
      : GetScalarType<T[P], AggregateBot_commands[P]>
  }




  export type bot_commandsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bot_commandsWhereInput
    orderBy?: bot_commandsOrderByWithAggregationInput | bot_commandsOrderByWithAggregationInput[]
    by: Bot_commandsScalarFieldEnum[] | Bot_commandsScalarFieldEnum
    having?: bot_commandsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Bot_commandsCountAggregateInputType | true
    _avg?: Bot_commandsAvgAggregateInputType
    _sum?: Bot_commandsSumAggregateInputType
    _min?: Bot_commandsMinAggregateInputType
    _max?: Bot_commandsMaxAggregateInputType
  }

  export type Bot_commandsGroupByOutputType = {
    id: string
    bot_id: bigint
    cmd_type: number
    groups: string[]
    name: string
    vote_locked: boolean
    description: string
    args: string[]
    examples: string[]
    premium_only: boolean
    notes: string[]
    doc_link: string | null
    nsfw: boolean | null
    lynxtag: string
    _count: Bot_commandsCountAggregateOutputType | null
    _avg: Bot_commandsAvgAggregateOutputType | null
    _sum: Bot_commandsSumAggregateOutputType | null
    _min: Bot_commandsMinAggregateOutputType | null
    _max: Bot_commandsMaxAggregateOutputType | null
  }

  type GetBot_commandsGroupByPayload<T extends bot_commandsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Bot_commandsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Bot_commandsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Bot_commandsGroupByOutputType[P]>
            : GetScalarType<T[P], Bot_commandsGroupByOutputType[P]>
        }
      >
    >


  export type bot_commandsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bot_id?: boolean
    cmd_type?: boolean
    groups?: boolean
    name?: boolean
    vote_locked?: boolean
    description?: boolean
    args?: boolean
    examples?: boolean
    premium_only?: boolean
    notes?: boolean
    doc_link?: boolean
    nsfw?: boolean
    lynxtag?: boolean
    bots?: boolean | botsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bot_commands"]>

  export type bot_commandsSelectScalar = {
    id?: boolean
    bot_id?: boolean
    cmd_type?: boolean
    groups?: boolean
    name?: boolean
    vote_locked?: boolean
    description?: boolean
    args?: boolean
    examples?: boolean
    premium_only?: boolean
    notes?: boolean
    doc_link?: boolean
    nsfw?: boolean
    lynxtag?: boolean
  }

  export type bot_commandsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bots?: boolean | botsDefaultArgs<ExtArgs>
  }


  export type $bot_commandsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "bot_commands"
    objects: {
      bots: Prisma.$botsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bot_id: bigint
      cmd_type: number
      groups: string[]
      name: string
      vote_locked: boolean
      description: string
      args: string[]
      examples: string[]
      premium_only: boolean
      notes: string[]
      doc_link: string | null
      nsfw: boolean | null
      lynxtag: string
    }, ExtArgs["result"]["bot_commands"]>
    composites: {}
  }


  type bot_commandsGetPayload<S extends boolean | null | undefined | bot_commandsDefaultArgs> = $Result.GetResult<Prisma.$bot_commandsPayload, S>

  type bot_commandsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<bot_commandsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Bot_commandsCountAggregateInputType | true
    }

  export interface bot_commandsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['bot_commands'], meta: { name: 'bot_commands' } }
    /**
     * Find zero or one Bot_commands that matches the filter.
     * @param {bot_commandsFindUniqueArgs} args - Arguments to find a Bot_commands
     * @example
     * // Get one Bot_commands
     * const bot_commands = await prisma.bot_commands.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends bot_commandsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, bot_commandsFindUniqueArgs<ExtArgs>>
    ): Prisma__bot_commandsClient<$Result.GetResult<Prisma.$bot_commandsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Bot_commands that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {bot_commandsFindUniqueOrThrowArgs} args - Arguments to find a Bot_commands
     * @example
     * // Get one Bot_commands
     * const bot_commands = await prisma.bot_commands.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends bot_commandsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, bot_commandsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__bot_commandsClient<$Result.GetResult<Prisma.$bot_commandsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Bot_commands that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bot_commandsFindFirstArgs} args - Arguments to find a Bot_commands
     * @example
     * // Get one Bot_commands
     * const bot_commands = await prisma.bot_commands.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends bot_commandsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, bot_commandsFindFirstArgs<ExtArgs>>
    ): Prisma__bot_commandsClient<$Result.GetResult<Prisma.$bot_commandsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Bot_commands that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bot_commandsFindFirstOrThrowArgs} args - Arguments to find a Bot_commands
     * @example
     * // Get one Bot_commands
     * const bot_commands = await prisma.bot_commands.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends bot_commandsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, bot_commandsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__bot_commandsClient<$Result.GetResult<Prisma.$bot_commandsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Bot_commands that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bot_commandsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bot_commands
     * const bot_commands = await prisma.bot_commands.findMany()
     * 
     * // Get first 10 Bot_commands
     * const bot_commands = await prisma.bot_commands.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bot_commandsWithIdOnly = await prisma.bot_commands.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends bot_commandsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bot_commandsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bot_commandsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Bot_commands.
     * @param {bot_commandsCreateArgs} args - Arguments to create a Bot_commands.
     * @example
     * // Create one Bot_commands
     * const Bot_commands = await prisma.bot_commands.create({
     *   data: {
     *     // ... data to create a Bot_commands
     *   }
     * })
     * 
    **/
    create<T extends bot_commandsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, bot_commandsCreateArgs<ExtArgs>>
    ): Prisma__bot_commandsClient<$Result.GetResult<Prisma.$bot_commandsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Bot_commands.
     *     @param {bot_commandsCreateManyArgs} args - Arguments to create many Bot_commands.
     *     @example
     *     // Create many Bot_commands
     *     const bot_commands = await prisma.bot_commands.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends bot_commandsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bot_commandsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Bot_commands.
     * @param {bot_commandsDeleteArgs} args - Arguments to delete one Bot_commands.
     * @example
     * // Delete one Bot_commands
     * const Bot_commands = await prisma.bot_commands.delete({
     *   where: {
     *     // ... filter to delete one Bot_commands
     *   }
     * })
     * 
    **/
    delete<T extends bot_commandsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, bot_commandsDeleteArgs<ExtArgs>>
    ): Prisma__bot_commandsClient<$Result.GetResult<Prisma.$bot_commandsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Bot_commands.
     * @param {bot_commandsUpdateArgs} args - Arguments to update one Bot_commands.
     * @example
     * // Update one Bot_commands
     * const bot_commands = await prisma.bot_commands.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends bot_commandsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, bot_commandsUpdateArgs<ExtArgs>>
    ): Prisma__bot_commandsClient<$Result.GetResult<Prisma.$bot_commandsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Bot_commands.
     * @param {bot_commandsDeleteManyArgs} args - Arguments to filter Bot_commands to delete.
     * @example
     * // Delete a few Bot_commands
     * const { count } = await prisma.bot_commands.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends bot_commandsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bot_commandsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bot_commands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bot_commandsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bot_commands
     * const bot_commands = await prisma.bot_commands.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends bot_commandsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, bot_commandsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bot_commands.
     * @param {bot_commandsUpsertArgs} args - Arguments to update or create a Bot_commands.
     * @example
     * // Update or create a Bot_commands
     * const bot_commands = await prisma.bot_commands.upsert({
     *   create: {
     *     // ... data to create a Bot_commands
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bot_commands we want to update
     *   }
     * })
    **/
    upsert<T extends bot_commandsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, bot_commandsUpsertArgs<ExtArgs>>
    ): Prisma__bot_commandsClient<$Result.GetResult<Prisma.$bot_commandsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Bot_commands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bot_commandsCountArgs} args - Arguments to filter Bot_commands to count.
     * @example
     * // Count the number of Bot_commands
     * const count = await prisma.bot_commands.count({
     *   where: {
     *     // ... the filter for the Bot_commands we want to count
     *   }
     * })
    **/
    count<T extends bot_commandsCountArgs>(
      args?: Subset<T, bot_commandsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Bot_commandsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bot_commands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Bot_commandsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Bot_commandsAggregateArgs>(args: Subset<T, Bot_commandsAggregateArgs>): Prisma.PrismaPromise<GetBot_commandsAggregateType<T>>

    /**
     * Group by Bot_commands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bot_commandsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends bot_commandsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: bot_commandsGroupByArgs['orderBy'] }
        : { orderBy?: bot_commandsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, bot_commandsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBot_commandsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the bot_commands model
   */
  readonly fields: bot_commandsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for bot_commands.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__bot_commandsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    bots<T extends botsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, botsDefaultArgs<ExtArgs>>): Prisma__botsClient<$Result.GetResult<Prisma.$botsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the bot_commands model
   */ 
  interface bot_commandsFieldRefs {
    readonly id: FieldRef<"bot_commands", 'String'>
    readonly bot_id: FieldRef<"bot_commands", 'BigInt'>
    readonly cmd_type: FieldRef<"bot_commands", 'Int'>
    readonly groups: FieldRef<"bot_commands", 'String[]'>
    readonly name: FieldRef<"bot_commands", 'String'>
    readonly vote_locked: FieldRef<"bot_commands", 'Boolean'>
    readonly description: FieldRef<"bot_commands", 'String'>
    readonly args: FieldRef<"bot_commands", 'String[]'>
    readonly examples: FieldRef<"bot_commands", 'String[]'>
    readonly premium_only: FieldRef<"bot_commands", 'Boolean'>
    readonly notes: FieldRef<"bot_commands", 'String[]'>
    readonly doc_link: FieldRef<"bot_commands", 'String'>
    readonly nsfw: FieldRef<"bot_commands", 'Boolean'>
    readonly lynxtag: FieldRef<"bot_commands", 'String'>
  }
    

  // Custom InputTypes

  /**
   * bot_commands findUnique
   */
  export type bot_commandsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_commands
     */
    select?: bot_commandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bot_commandsInclude<ExtArgs> | null
    /**
     * Filter, which bot_commands to fetch.
     */
    where: bot_commandsWhereUniqueInput
  }


  /**
   * bot_commands findUniqueOrThrow
   */
  export type bot_commandsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_commands
     */
    select?: bot_commandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bot_commandsInclude<ExtArgs> | null
    /**
     * Filter, which bot_commands to fetch.
     */
    where: bot_commandsWhereUniqueInput
  }


  /**
   * bot_commands findFirst
   */
  export type bot_commandsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_commands
     */
    select?: bot_commandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bot_commandsInclude<ExtArgs> | null
    /**
     * Filter, which bot_commands to fetch.
     */
    where?: bot_commandsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bot_commands to fetch.
     */
    orderBy?: bot_commandsOrderByWithRelationInput | bot_commandsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bot_commands.
     */
    cursor?: bot_commandsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bot_commands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bot_commands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bot_commands.
     */
    distinct?: Bot_commandsScalarFieldEnum | Bot_commandsScalarFieldEnum[]
  }


  /**
   * bot_commands findFirstOrThrow
   */
  export type bot_commandsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_commands
     */
    select?: bot_commandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bot_commandsInclude<ExtArgs> | null
    /**
     * Filter, which bot_commands to fetch.
     */
    where?: bot_commandsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bot_commands to fetch.
     */
    orderBy?: bot_commandsOrderByWithRelationInput | bot_commandsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bot_commands.
     */
    cursor?: bot_commandsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bot_commands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bot_commands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bot_commands.
     */
    distinct?: Bot_commandsScalarFieldEnum | Bot_commandsScalarFieldEnum[]
  }


  /**
   * bot_commands findMany
   */
  export type bot_commandsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_commands
     */
    select?: bot_commandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bot_commandsInclude<ExtArgs> | null
    /**
     * Filter, which bot_commands to fetch.
     */
    where?: bot_commandsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bot_commands to fetch.
     */
    orderBy?: bot_commandsOrderByWithRelationInput | bot_commandsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing bot_commands.
     */
    cursor?: bot_commandsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bot_commands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bot_commands.
     */
    skip?: number
    distinct?: Bot_commandsScalarFieldEnum | Bot_commandsScalarFieldEnum[]
  }


  /**
   * bot_commands create
   */
  export type bot_commandsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_commands
     */
    select?: bot_commandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bot_commandsInclude<ExtArgs> | null
    /**
     * The data needed to create a bot_commands.
     */
    data: XOR<bot_commandsCreateInput, bot_commandsUncheckedCreateInput>
  }


  /**
   * bot_commands createMany
   */
  export type bot_commandsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many bot_commands.
     */
    data: bot_commandsCreateManyInput | bot_commandsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * bot_commands update
   */
  export type bot_commandsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_commands
     */
    select?: bot_commandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bot_commandsInclude<ExtArgs> | null
    /**
     * The data needed to update a bot_commands.
     */
    data: XOR<bot_commandsUpdateInput, bot_commandsUncheckedUpdateInput>
    /**
     * Choose, which bot_commands to update.
     */
    where: bot_commandsWhereUniqueInput
  }


  /**
   * bot_commands updateMany
   */
  export type bot_commandsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update bot_commands.
     */
    data: XOR<bot_commandsUpdateManyMutationInput, bot_commandsUncheckedUpdateManyInput>
    /**
     * Filter which bot_commands to update
     */
    where?: bot_commandsWhereInput
  }


  /**
   * bot_commands upsert
   */
  export type bot_commandsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_commands
     */
    select?: bot_commandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bot_commandsInclude<ExtArgs> | null
    /**
     * The filter to search for the bot_commands to update in case it exists.
     */
    where: bot_commandsWhereUniqueInput
    /**
     * In case the bot_commands found by the `where` argument doesn't exist, create a new bot_commands with this data.
     */
    create: XOR<bot_commandsCreateInput, bot_commandsUncheckedCreateInput>
    /**
     * In case the bot_commands was found with the provided `where` argument, update it with this data.
     */
    update: XOR<bot_commandsUpdateInput, bot_commandsUncheckedUpdateInput>
  }


  /**
   * bot_commands delete
   */
  export type bot_commandsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_commands
     */
    select?: bot_commandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bot_commandsInclude<ExtArgs> | null
    /**
     * Filter which bot_commands to delete.
     */
    where: bot_commandsWhereUniqueInput
  }


  /**
   * bot_commands deleteMany
   */
  export type bot_commandsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bot_commands to delete
     */
    where?: bot_commandsWhereInput
  }


  /**
   * bot_commands without action
   */
  export type bot_commandsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_commands
     */
    select?: bot_commandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bot_commandsInclude<ExtArgs> | null
  }



  /**
   * Model bot_events
   */

  export type AggregateBot_events = {
    _count: Bot_eventsCountAggregateOutputType | null
    _avg: Bot_eventsAvgAggregateOutputType | null
    _sum: Bot_eventsSumAggregateOutputType | null
    _min: Bot_eventsMinAggregateOutputType | null
    _max: Bot_eventsMaxAggregateOutputType | null
  }

  export type Bot_eventsAvgAggregateOutputType = {
    bot_id: number | null
    event_type: number | null
  }

  export type Bot_eventsSumAggregateOutputType = {
    bot_id: bigint | null
    event_type: number | null
  }

  export type Bot_eventsMinAggregateOutputType = {
    bot_id: bigint | null
    event_type: number | null
    ts: Date | null
    reason: string | null
    css: string | null
    id: string | null
    lynxtag: string | null
  }

  export type Bot_eventsMaxAggregateOutputType = {
    bot_id: bigint | null
    event_type: number | null
    ts: Date | null
    reason: string | null
    css: string | null
    id: string | null
    lynxtag: string | null
  }

  export type Bot_eventsCountAggregateOutputType = {
    bot_id: number
    event_type: number
    ts: number
    reason: number
    css: number
    id: number
    lynxtag: number
    _all: number
  }


  export type Bot_eventsAvgAggregateInputType = {
    bot_id?: true
    event_type?: true
  }

  export type Bot_eventsSumAggregateInputType = {
    bot_id?: true
    event_type?: true
  }

  export type Bot_eventsMinAggregateInputType = {
    bot_id?: true
    event_type?: true
    ts?: true
    reason?: true
    css?: true
    id?: true
    lynxtag?: true
  }

  export type Bot_eventsMaxAggregateInputType = {
    bot_id?: true
    event_type?: true
    ts?: true
    reason?: true
    css?: true
    id?: true
    lynxtag?: true
  }

  export type Bot_eventsCountAggregateInputType = {
    bot_id?: true
    event_type?: true
    ts?: true
    reason?: true
    css?: true
    id?: true
    lynxtag?: true
    _all?: true
  }

  export type Bot_eventsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bot_events to aggregate.
     */
    where?: bot_eventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bot_events to fetch.
     */
    orderBy?: bot_eventsOrderByWithRelationInput | bot_eventsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: bot_eventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bot_events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bot_events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned bot_events
    **/
    _count?: true | Bot_eventsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Bot_eventsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Bot_eventsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Bot_eventsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Bot_eventsMaxAggregateInputType
  }

  export type GetBot_eventsAggregateType<T extends Bot_eventsAggregateArgs> = {
        [P in keyof T & keyof AggregateBot_events]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBot_events[P]>
      : GetScalarType<T[P], AggregateBot_events[P]>
  }




  export type bot_eventsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bot_eventsWhereInput
    orderBy?: bot_eventsOrderByWithAggregationInput | bot_eventsOrderByWithAggregationInput[]
    by: Bot_eventsScalarFieldEnum[] | Bot_eventsScalarFieldEnum
    having?: bot_eventsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Bot_eventsCountAggregateInputType | true
    _avg?: Bot_eventsAvgAggregateInputType
    _sum?: Bot_eventsSumAggregateInputType
    _min?: Bot_eventsMinAggregateInputType
    _max?: Bot_eventsMaxAggregateInputType
  }

  export type Bot_eventsGroupByOutputType = {
    bot_id: bigint
    event_type: number
    ts: Date
    reason: string
    css: string
    id: string
    lynxtag: string
    _count: Bot_eventsCountAggregateOutputType | null
    _avg: Bot_eventsAvgAggregateOutputType | null
    _sum: Bot_eventsSumAggregateOutputType | null
    _min: Bot_eventsMinAggregateOutputType | null
    _max: Bot_eventsMaxAggregateOutputType | null
  }

  type GetBot_eventsGroupByPayload<T extends bot_eventsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Bot_eventsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Bot_eventsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Bot_eventsGroupByOutputType[P]>
            : GetScalarType<T[P], Bot_eventsGroupByOutputType[P]>
        }
      >
    >


  export type bot_eventsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    bot_id?: boolean
    event_type?: boolean
    ts?: boolean
    reason?: boolean
    css?: boolean
    id?: boolean
    lynxtag?: boolean
    bots?: boolean | botsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bot_events"]>

  export type bot_eventsSelectScalar = {
    bot_id?: boolean
    event_type?: boolean
    ts?: boolean
    reason?: boolean
    css?: boolean
    id?: boolean
    lynxtag?: boolean
  }

  export type bot_eventsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bots?: boolean | botsDefaultArgs<ExtArgs>
  }


  export type $bot_eventsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "bot_events"
    objects: {
      bots: Prisma.$botsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      bot_id: bigint
      event_type: number
      ts: Date
      reason: string
      css: string
      id: string
      lynxtag: string
    }, ExtArgs["result"]["bot_events"]>
    composites: {}
  }


  type bot_eventsGetPayload<S extends boolean | null | undefined | bot_eventsDefaultArgs> = $Result.GetResult<Prisma.$bot_eventsPayload, S>

  type bot_eventsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<bot_eventsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Bot_eventsCountAggregateInputType | true
    }

  export interface bot_eventsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['bot_events'], meta: { name: 'bot_events' } }
    /**
     * Find zero or one Bot_events that matches the filter.
     * @param {bot_eventsFindUniqueArgs} args - Arguments to find a Bot_events
     * @example
     * // Get one Bot_events
     * const bot_events = await prisma.bot_events.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends bot_eventsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, bot_eventsFindUniqueArgs<ExtArgs>>
    ): Prisma__bot_eventsClient<$Result.GetResult<Prisma.$bot_eventsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Bot_events that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {bot_eventsFindUniqueOrThrowArgs} args - Arguments to find a Bot_events
     * @example
     * // Get one Bot_events
     * const bot_events = await prisma.bot_events.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends bot_eventsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, bot_eventsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__bot_eventsClient<$Result.GetResult<Prisma.$bot_eventsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Bot_events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bot_eventsFindFirstArgs} args - Arguments to find a Bot_events
     * @example
     * // Get one Bot_events
     * const bot_events = await prisma.bot_events.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends bot_eventsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, bot_eventsFindFirstArgs<ExtArgs>>
    ): Prisma__bot_eventsClient<$Result.GetResult<Prisma.$bot_eventsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Bot_events that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bot_eventsFindFirstOrThrowArgs} args - Arguments to find a Bot_events
     * @example
     * // Get one Bot_events
     * const bot_events = await prisma.bot_events.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends bot_eventsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, bot_eventsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__bot_eventsClient<$Result.GetResult<Prisma.$bot_eventsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Bot_events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bot_eventsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bot_events
     * const bot_events = await prisma.bot_events.findMany()
     * 
     * // Get first 10 Bot_events
     * const bot_events = await prisma.bot_events.findMany({ take: 10 })
     * 
     * // Only select the `bot_id`
     * const bot_eventsWithBot_idOnly = await prisma.bot_events.findMany({ select: { bot_id: true } })
     * 
    **/
    findMany<T extends bot_eventsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bot_eventsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bot_eventsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Bot_events.
     * @param {bot_eventsCreateArgs} args - Arguments to create a Bot_events.
     * @example
     * // Create one Bot_events
     * const Bot_events = await prisma.bot_events.create({
     *   data: {
     *     // ... data to create a Bot_events
     *   }
     * })
     * 
    **/
    create<T extends bot_eventsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, bot_eventsCreateArgs<ExtArgs>>
    ): Prisma__bot_eventsClient<$Result.GetResult<Prisma.$bot_eventsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Bot_events.
     *     @param {bot_eventsCreateManyArgs} args - Arguments to create many Bot_events.
     *     @example
     *     // Create many Bot_events
     *     const bot_events = await prisma.bot_events.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends bot_eventsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bot_eventsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Bot_events.
     * @param {bot_eventsDeleteArgs} args - Arguments to delete one Bot_events.
     * @example
     * // Delete one Bot_events
     * const Bot_events = await prisma.bot_events.delete({
     *   where: {
     *     // ... filter to delete one Bot_events
     *   }
     * })
     * 
    **/
    delete<T extends bot_eventsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, bot_eventsDeleteArgs<ExtArgs>>
    ): Prisma__bot_eventsClient<$Result.GetResult<Prisma.$bot_eventsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Bot_events.
     * @param {bot_eventsUpdateArgs} args - Arguments to update one Bot_events.
     * @example
     * // Update one Bot_events
     * const bot_events = await prisma.bot_events.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends bot_eventsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, bot_eventsUpdateArgs<ExtArgs>>
    ): Prisma__bot_eventsClient<$Result.GetResult<Prisma.$bot_eventsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Bot_events.
     * @param {bot_eventsDeleteManyArgs} args - Arguments to filter Bot_events to delete.
     * @example
     * // Delete a few Bot_events
     * const { count } = await prisma.bot_events.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends bot_eventsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bot_eventsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bot_events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bot_eventsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bot_events
     * const bot_events = await prisma.bot_events.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends bot_eventsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, bot_eventsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bot_events.
     * @param {bot_eventsUpsertArgs} args - Arguments to update or create a Bot_events.
     * @example
     * // Update or create a Bot_events
     * const bot_events = await prisma.bot_events.upsert({
     *   create: {
     *     // ... data to create a Bot_events
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bot_events we want to update
     *   }
     * })
    **/
    upsert<T extends bot_eventsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, bot_eventsUpsertArgs<ExtArgs>>
    ): Prisma__bot_eventsClient<$Result.GetResult<Prisma.$bot_eventsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Bot_events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bot_eventsCountArgs} args - Arguments to filter Bot_events to count.
     * @example
     * // Count the number of Bot_events
     * const count = await prisma.bot_events.count({
     *   where: {
     *     // ... the filter for the Bot_events we want to count
     *   }
     * })
    **/
    count<T extends bot_eventsCountArgs>(
      args?: Subset<T, bot_eventsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Bot_eventsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bot_events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Bot_eventsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Bot_eventsAggregateArgs>(args: Subset<T, Bot_eventsAggregateArgs>): Prisma.PrismaPromise<GetBot_eventsAggregateType<T>>

    /**
     * Group by Bot_events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bot_eventsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends bot_eventsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: bot_eventsGroupByArgs['orderBy'] }
        : { orderBy?: bot_eventsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, bot_eventsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBot_eventsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the bot_events model
   */
  readonly fields: bot_eventsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for bot_events.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__bot_eventsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    bots<T extends botsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, botsDefaultArgs<ExtArgs>>): Prisma__botsClient<$Result.GetResult<Prisma.$botsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the bot_events model
   */ 
  interface bot_eventsFieldRefs {
    readonly bot_id: FieldRef<"bot_events", 'BigInt'>
    readonly event_type: FieldRef<"bot_events", 'Int'>
    readonly ts: FieldRef<"bot_events", 'DateTime'>
    readonly reason: FieldRef<"bot_events", 'String'>
    readonly css: FieldRef<"bot_events", 'String'>
    readonly id: FieldRef<"bot_events", 'String'>
    readonly lynxtag: FieldRef<"bot_events", 'String'>
  }
    

  // Custom InputTypes

  /**
   * bot_events findUnique
   */
  export type bot_eventsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_events
     */
    select?: bot_eventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bot_eventsInclude<ExtArgs> | null
    /**
     * Filter, which bot_events to fetch.
     */
    where: bot_eventsWhereUniqueInput
  }


  /**
   * bot_events findUniqueOrThrow
   */
  export type bot_eventsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_events
     */
    select?: bot_eventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bot_eventsInclude<ExtArgs> | null
    /**
     * Filter, which bot_events to fetch.
     */
    where: bot_eventsWhereUniqueInput
  }


  /**
   * bot_events findFirst
   */
  export type bot_eventsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_events
     */
    select?: bot_eventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bot_eventsInclude<ExtArgs> | null
    /**
     * Filter, which bot_events to fetch.
     */
    where?: bot_eventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bot_events to fetch.
     */
    orderBy?: bot_eventsOrderByWithRelationInput | bot_eventsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bot_events.
     */
    cursor?: bot_eventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bot_events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bot_events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bot_events.
     */
    distinct?: Bot_eventsScalarFieldEnum | Bot_eventsScalarFieldEnum[]
  }


  /**
   * bot_events findFirstOrThrow
   */
  export type bot_eventsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_events
     */
    select?: bot_eventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bot_eventsInclude<ExtArgs> | null
    /**
     * Filter, which bot_events to fetch.
     */
    where?: bot_eventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bot_events to fetch.
     */
    orderBy?: bot_eventsOrderByWithRelationInput | bot_eventsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bot_events.
     */
    cursor?: bot_eventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bot_events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bot_events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bot_events.
     */
    distinct?: Bot_eventsScalarFieldEnum | Bot_eventsScalarFieldEnum[]
  }


  /**
   * bot_events findMany
   */
  export type bot_eventsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_events
     */
    select?: bot_eventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bot_eventsInclude<ExtArgs> | null
    /**
     * Filter, which bot_events to fetch.
     */
    where?: bot_eventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bot_events to fetch.
     */
    orderBy?: bot_eventsOrderByWithRelationInput | bot_eventsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing bot_events.
     */
    cursor?: bot_eventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bot_events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bot_events.
     */
    skip?: number
    distinct?: Bot_eventsScalarFieldEnum | Bot_eventsScalarFieldEnum[]
  }


  /**
   * bot_events create
   */
  export type bot_eventsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_events
     */
    select?: bot_eventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bot_eventsInclude<ExtArgs> | null
    /**
     * The data needed to create a bot_events.
     */
    data: XOR<bot_eventsCreateInput, bot_eventsUncheckedCreateInput>
  }


  /**
   * bot_events createMany
   */
  export type bot_eventsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many bot_events.
     */
    data: bot_eventsCreateManyInput | bot_eventsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * bot_events update
   */
  export type bot_eventsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_events
     */
    select?: bot_eventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bot_eventsInclude<ExtArgs> | null
    /**
     * The data needed to update a bot_events.
     */
    data: XOR<bot_eventsUpdateInput, bot_eventsUncheckedUpdateInput>
    /**
     * Choose, which bot_events to update.
     */
    where: bot_eventsWhereUniqueInput
  }


  /**
   * bot_events updateMany
   */
  export type bot_eventsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update bot_events.
     */
    data: XOR<bot_eventsUpdateManyMutationInput, bot_eventsUncheckedUpdateManyInput>
    /**
     * Filter which bot_events to update
     */
    where?: bot_eventsWhereInput
  }


  /**
   * bot_events upsert
   */
  export type bot_eventsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_events
     */
    select?: bot_eventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bot_eventsInclude<ExtArgs> | null
    /**
     * The filter to search for the bot_events to update in case it exists.
     */
    where: bot_eventsWhereUniqueInput
    /**
     * In case the bot_events found by the `where` argument doesn't exist, create a new bot_events with this data.
     */
    create: XOR<bot_eventsCreateInput, bot_eventsUncheckedCreateInput>
    /**
     * In case the bot_events was found with the provided `where` argument, update it with this data.
     */
    update: XOR<bot_eventsUpdateInput, bot_eventsUncheckedUpdateInput>
  }


  /**
   * bot_events delete
   */
  export type bot_eventsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_events
     */
    select?: bot_eventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bot_eventsInclude<ExtArgs> | null
    /**
     * Filter which bot_events to delete.
     */
    where: bot_eventsWhereUniqueInput
  }


  /**
   * bot_events deleteMany
   */
  export type bot_eventsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bot_events to delete
     */
    where?: bot_eventsWhereInput
  }


  /**
   * bot_events without action
   */
  export type bot_eventsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_events
     */
    select?: bot_eventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bot_eventsInclude<ExtArgs> | null
  }



  /**
   * Model bot_list_feature
   */

  export type AggregateBot_list_feature = {
    _count: Bot_list_featureCountAggregateOutputType | null
    _avg: Bot_list_featureAvgAggregateOutputType | null
    _sum: Bot_list_featureSumAggregateOutputType | null
    _min: Bot_list_featureMinAggregateOutputType | null
    _max: Bot_list_featureMaxAggregateOutputType | null
  }

  export type Bot_list_featureAvgAggregateOutputType = {
    feature_id: number | null
    positive: number | null
  }

  export type Bot_list_featureSumAggregateOutputType = {
    feature_id: number | null
    positive: number | null
  }

  export type Bot_list_featureMinAggregateOutputType = {
    feature_id: number | null
    name: string | null
    iname: string | null
    description: string | null
    positive: number | null
    lynxtag: string | null
  }

  export type Bot_list_featureMaxAggregateOutputType = {
    feature_id: number | null
    name: string | null
    iname: string | null
    description: string | null
    positive: number | null
    lynxtag: string | null
  }

  export type Bot_list_featureCountAggregateOutputType = {
    feature_id: number
    name: number
    iname: number
    description: number
    positive: number
    lynxtag: number
    _all: number
  }


  export type Bot_list_featureAvgAggregateInputType = {
    feature_id?: true
    positive?: true
  }

  export type Bot_list_featureSumAggregateInputType = {
    feature_id?: true
    positive?: true
  }

  export type Bot_list_featureMinAggregateInputType = {
    feature_id?: true
    name?: true
    iname?: true
    description?: true
    positive?: true
    lynxtag?: true
  }

  export type Bot_list_featureMaxAggregateInputType = {
    feature_id?: true
    name?: true
    iname?: true
    description?: true
    positive?: true
    lynxtag?: true
  }

  export type Bot_list_featureCountAggregateInputType = {
    feature_id?: true
    name?: true
    iname?: true
    description?: true
    positive?: true
    lynxtag?: true
    _all?: true
  }

  export type Bot_list_featureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bot_list_feature to aggregate.
     */
    where?: bot_list_featureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bot_list_features to fetch.
     */
    orderBy?: bot_list_featureOrderByWithRelationInput | bot_list_featureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: bot_list_featureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bot_list_features from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bot_list_features.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned bot_list_features
    **/
    _count?: true | Bot_list_featureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Bot_list_featureAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Bot_list_featureSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Bot_list_featureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Bot_list_featureMaxAggregateInputType
  }

  export type GetBot_list_featureAggregateType<T extends Bot_list_featureAggregateArgs> = {
        [P in keyof T & keyof AggregateBot_list_feature]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBot_list_feature[P]>
      : GetScalarType<T[P], AggregateBot_list_feature[P]>
  }




  export type bot_list_featureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bot_list_featureWhereInput
    orderBy?: bot_list_featureOrderByWithAggregationInput | bot_list_featureOrderByWithAggregationInput[]
    by: Bot_list_featureScalarFieldEnum[] | Bot_list_featureScalarFieldEnum
    having?: bot_list_featureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Bot_list_featureCountAggregateInputType | true
    _avg?: Bot_list_featureAvgAggregateInputType
    _sum?: Bot_list_featureSumAggregateInputType
    _min?: Bot_list_featureMinAggregateInputType
    _max?: Bot_list_featureMaxAggregateInputType
  }

  export type Bot_list_featureGroupByOutputType = {
    feature_id: number
    name: string
    iname: string
    description: string | null
    positive: number | null
    lynxtag: string
    _count: Bot_list_featureCountAggregateOutputType | null
    _avg: Bot_list_featureAvgAggregateOutputType | null
    _sum: Bot_list_featureSumAggregateOutputType | null
    _min: Bot_list_featureMinAggregateOutputType | null
    _max: Bot_list_featureMaxAggregateOutputType | null
  }

  type GetBot_list_featureGroupByPayload<T extends bot_list_featureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Bot_list_featureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Bot_list_featureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Bot_list_featureGroupByOutputType[P]>
            : GetScalarType<T[P], Bot_list_featureGroupByOutputType[P]>
        }
      >
    >


  export type bot_list_featureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    feature_id?: boolean
    name?: boolean
    iname?: boolean
    description?: boolean
    positive?: boolean
    lynxtag?: boolean
  }, ExtArgs["result"]["bot_list_feature"]>

  export type bot_list_featureSelectScalar = {
    feature_id?: boolean
    name?: boolean
    iname?: boolean
    description?: boolean
    positive?: boolean
    lynxtag?: boolean
  }


  export type $bot_list_featurePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "bot_list_feature"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      feature_id: number
      name: string
      iname: string
      description: string | null
      positive: number | null
      lynxtag: string
    }, ExtArgs["result"]["bot_list_feature"]>
    composites: {}
  }


  type bot_list_featureGetPayload<S extends boolean | null | undefined | bot_list_featureDefaultArgs> = $Result.GetResult<Prisma.$bot_list_featurePayload, S>

  type bot_list_featureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<bot_list_featureFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Bot_list_featureCountAggregateInputType | true
    }

  export interface bot_list_featureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['bot_list_feature'], meta: { name: 'bot_list_feature' } }
    /**
     * Find zero or one Bot_list_feature that matches the filter.
     * @param {bot_list_featureFindUniqueArgs} args - Arguments to find a Bot_list_feature
     * @example
     * // Get one Bot_list_feature
     * const bot_list_feature = await prisma.bot_list_feature.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends bot_list_featureFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, bot_list_featureFindUniqueArgs<ExtArgs>>
    ): Prisma__bot_list_featureClient<$Result.GetResult<Prisma.$bot_list_featurePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Bot_list_feature that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {bot_list_featureFindUniqueOrThrowArgs} args - Arguments to find a Bot_list_feature
     * @example
     * // Get one Bot_list_feature
     * const bot_list_feature = await prisma.bot_list_feature.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends bot_list_featureFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, bot_list_featureFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__bot_list_featureClient<$Result.GetResult<Prisma.$bot_list_featurePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Bot_list_feature that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bot_list_featureFindFirstArgs} args - Arguments to find a Bot_list_feature
     * @example
     * // Get one Bot_list_feature
     * const bot_list_feature = await prisma.bot_list_feature.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends bot_list_featureFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, bot_list_featureFindFirstArgs<ExtArgs>>
    ): Prisma__bot_list_featureClient<$Result.GetResult<Prisma.$bot_list_featurePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Bot_list_feature that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bot_list_featureFindFirstOrThrowArgs} args - Arguments to find a Bot_list_feature
     * @example
     * // Get one Bot_list_feature
     * const bot_list_feature = await prisma.bot_list_feature.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends bot_list_featureFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, bot_list_featureFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__bot_list_featureClient<$Result.GetResult<Prisma.$bot_list_featurePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Bot_list_features that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bot_list_featureFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bot_list_features
     * const bot_list_features = await prisma.bot_list_feature.findMany()
     * 
     * // Get first 10 Bot_list_features
     * const bot_list_features = await prisma.bot_list_feature.findMany({ take: 10 })
     * 
     * // Only select the `feature_id`
     * const bot_list_featureWithFeature_idOnly = await prisma.bot_list_feature.findMany({ select: { feature_id: true } })
     * 
    **/
    findMany<T extends bot_list_featureFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bot_list_featureFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bot_list_featurePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Bot_list_feature.
     * @param {bot_list_featureCreateArgs} args - Arguments to create a Bot_list_feature.
     * @example
     * // Create one Bot_list_feature
     * const Bot_list_feature = await prisma.bot_list_feature.create({
     *   data: {
     *     // ... data to create a Bot_list_feature
     *   }
     * })
     * 
    **/
    create<T extends bot_list_featureCreateArgs<ExtArgs>>(
      args: SelectSubset<T, bot_list_featureCreateArgs<ExtArgs>>
    ): Prisma__bot_list_featureClient<$Result.GetResult<Prisma.$bot_list_featurePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Bot_list_features.
     *     @param {bot_list_featureCreateManyArgs} args - Arguments to create many Bot_list_features.
     *     @example
     *     // Create many Bot_list_features
     *     const bot_list_feature = await prisma.bot_list_feature.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends bot_list_featureCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bot_list_featureCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Bot_list_feature.
     * @param {bot_list_featureDeleteArgs} args - Arguments to delete one Bot_list_feature.
     * @example
     * // Delete one Bot_list_feature
     * const Bot_list_feature = await prisma.bot_list_feature.delete({
     *   where: {
     *     // ... filter to delete one Bot_list_feature
     *   }
     * })
     * 
    **/
    delete<T extends bot_list_featureDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, bot_list_featureDeleteArgs<ExtArgs>>
    ): Prisma__bot_list_featureClient<$Result.GetResult<Prisma.$bot_list_featurePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Bot_list_feature.
     * @param {bot_list_featureUpdateArgs} args - Arguments to update one Bot_list_feature.
     * @example
     * // Update one Bot_list_feature
     * const bot_list_feature = await prisma.bot_list_feature.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends bot_list_featureUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, bot_list_featureUpdateArgs<ExtArgs>>
    ): Prisma__bot_list_featureClient<$Result.GetResult<Prisma.$bot_list_featurePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Bot_list_features.
     * @param {bot_list_featureDeleteManyArgs} args - Arguments to filter Bot_list_features to delete.
     * @example
     * // Delete a few Bot_list_features
     * const { count } = await prisma.bot_list_feature.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends bot_list_featureDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bot_list_featureDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bot_list_features.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bot_list_featureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bot_list_features
     * const bot_list_feature = await prisma.bot_list_feature.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends bot_list_featureUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, bot_list_featureUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bot_list_feature.
     * @param {bot_list_featureUpsertArgs} args - Arguments to update or create a Bot_list_feature.
     * @example
     * // Update or create a Bot_list_feature
     * const bot_list_feature = await prisma.bot_list_feature.upsert({
     *   create: {
     *     // ... data to create a Bot_list_feature
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bot_list_feature we want to update
     *   }
     * })
    **/
    upsert<T extends bot_list_featureUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, bot_list_featureUpsertArgs<ExtArgs>>
    ): Prisma__bot_list_featureClient<$Result.GetResult<Prisma.$bot_list_featurePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Bot_list_features.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bot_list_featureCountArgs} args - Arguments to filter Bot_list_features to count.
     * @example
     * // Count the number of Bot_list_features
     * const count = await prisma.bot_list_feature.count({
     *   where: {
     *     // ... the filter for the Bot_list_features we want to count
     *   }
     * })
    **/
    count<T extends bot_list_featureCountArgs>(
      args?: Subset<T, bot_list_featureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Bot_list_featureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bot_list_feature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Bot_list_featureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Bot_list_featureAggregateArgs>(args: Subset<T, Bot_list_featureAggregateArgs>): Prisma.PrismaPromise<GetBot_list_featureAggregateType<T>>

    /**
     * Group by Bot_list_feature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bot_list_featureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends bot_list_featureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: bot_list_featureGroupByArgs['orderBy'] }
        : { orderBy?: bot_list_featureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, bot_list_featureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBot_list_featureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the bot_list_feature model
   */
  readonly fields: bot_list_featureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for bot_list_feature.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__bot_list_featureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the bot_list_feature model
   */ 
  interface bot_list_featureFieldRefs {
    readonly feature_id: FieldRef<"bot_list_feature", 'Int'>
    readonly name: FieldRef<"bot_list_feature", 'String'>
    readonly iname: FieldRef<"bot_list_feature", 'String'>
    readonly description: FieldRef<"bot_list_feature", 'String'>
    readonly positive: FieldRef<"bot_list_feature", 'Int'>
    readonly lynxtag: FieldRef<"bot_list_feature", 'String'>
  }
    

  // Custom InputTypes

  /**
   * bot_list_feature findUnique
   */
  export type bot_list_featureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_list_feature
     */
    select?: bot_list_featureSelect<ExtArgs> | null
    /**
     * Filter, which bot_list_feature to fetch.
     */
    where: bot_list_featureWhereUniqueInput
  }


  /**
   * bot_list_feature findUniqueOrThrow
   */
  export type bot_list_featureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_list_feature
     */
    select?: bot_list_featureSelect<ExtArgs> | null
    /**
     * Filter, which bot_list_feature to fetch.
     */
    where: bot_list_featureWhereUniqueInput
  }


  /**
   * bot_list_feature findFirst
   */
  export type bot_list_featureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_list_feature
     */
    select?: bot_list_featureSelect<ExtArgs> | null
    /**
     * Filter, which bot_list_feature to fetch.
     */
    where?: bot_list_featureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bot_list_features to fetch.
     */
    orderBy?: bot_list_featureOrderByWithRelationInput | bot_list_featureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bot_list_features.
     */
    cursor?: bot_list_featureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bot_list_features from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bot_list_features.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bot_list_features.
     */
    distinct?: Bot_list_featureScalarFieldEnum | Bot_list_featureScalarFieldEnum[]
  }


  /**
   * bot_list_feature findFirstOrThrow
   */
  export type bot_list_featureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_list_feature
     */
    select?: bot_list_featureSelect<ExtArgs> | null
    /**
     * Filter, which bot_list_feature to fetch.
     */
    where?: bot_list_featureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bot_list_features to fetch.
     */
    orderBy?: bot_list_featureOrderByWithRelationInput | bot_list_featureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bot_list_features.
     */
    cursor?: bot_list_featureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bot_list_features from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bot_list_features.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bot_list_features.
     */
    distinct?: Bot_list_featureScalarFieldEnum | Bot_list_featureScalarFieldEnum[]
  }


  /**
   * bot_list_feature findMany
   */
  export type bot_list_featureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_list_feature
     */
    select?: bot_list_featureSelect<ExtArgs> | null
    /**
     * Filter, which bot_list_features to fetch.
     */
    where?: bot_list_featureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bot_list_features to fetch.
     */
    orderBy?: bot_list_featureOrderByWithRelationInput | bot_list_featureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing bot_list_features.
     */
    cursor?: bot_list_featureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bot_list_features from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bot_list_features.
     */
    skip?: number
    distinct?: Bot_list_featureScalarFieldEnum | Bot_list_featureScalarFieldEnum[]
  }


  /**
   * bot_list_feature create
   */
  export type bot_list_featureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_list_feature
     */
    select?: bot_list_featureSelect<ExtArgs> | null
    /**
     * The data needed to create a bot_list_feature.
     */
    data: XOR<bot_list_featureCreateInput, bot_list_featureUncheckedCreateInput>
  }


  /**
   * bot_list_feature createMany
   */
  export type bot_list_featureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many bot_list_features.
     */
    data: bot_list_featureCreateManyInput | bot_list_featureCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * bot_list_feature update
   */
  export type bot_list_featureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_list_feature
     */
    select?: bot_list_featureSelect<ExtArgs> | null
    /**
     * The data needed to update a bot_list_feature.
     */
    data: XOR<bot_list_featureUpdateInput, bot_list_featureUncheckedUpdateInput>
    /**
     * Choose, which bot_list_feature to update.
     */
    where: bot_list_featureWhereUniqueInput
  }


  /**
   * bot_list_feature updateMany
   */
  export type bot_list_featureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update bot_list_features.
     */
    data: XOR<bot_list_featureUpdateManyMutationInput, bot_list_featureUncheckedUpdateManyInput>
    /**
     * Filter which bot_list_features to update
     */
    where?: bot_list_featureWhereInput
  }


  /**
   * bot_list_feature upsert
   */
  export type bot_list_featureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_list_feature
     */
    select?: bot_list_featureSelect<ExtArgs> | null
    /**
     * The filter to search for the bot_list_feature to update in case it exists.
     */
    where: bot_list_featureWhereUniqueInput
    /**
     * In case the bot_list_feature found by the `where` argument doesn't exist, create a new bot_list_feature with this data.
     */
    create: XOR<bot_list_featureCreateInput, bot_list_featureUncheckedCreateInput>
    /**
     * In case the bot_list_feature was found with the provided `where` argument, update it with this data.
     */
    update: XOR<bot_list_featureUpdateInput, bot_list_featureUncheckedUpdateInput>
  }


  /**
   * bot_list_feature delete
   */
  export type bot_list_featureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_list_feature
     */
    select?: bot_list_featureSelect<ExtArgs> | null
    /**
     * Filter which bot_list_feature to delete.
     */
    where: bot_list_featureWhereUniqueInput
  }


  /**
   * bot_list_feature deleteMany
   */
  export type bot_list_featureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bot_list_features to delete
     */
    where?: bot_list_featureWhereInput
  }


  /**
   * bot_list_feature without action
   */
  export type bot_list_featureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_list_feature
     */
    select?: bot_list_featureSelect<ExtArgs> | null
  }



  /**
   * Model bot_list_tags
   */

  export type AggregateBot_list_tags = {
    _count: Bot_list_tagsCountAggregateOutputType | null
    _min: Bot_list_tagsMinAggregateOutputType | null
    _max: Bot_list_tagsMaxAggregateOutputType | null
  }

  export type Bot_list_tagsMinAggregateOutputType = {
    id: string | null
    icon: string | null
    lynxtag: string | null
  }

  export type Bot_list_tagsMaxAggregateOutputType = {
    id: string | null
    icon: string | null
    lynxtag: string | null
  }

  export type Bot_list_tagsCountAggregateOutputType = {
    id: number
    icon: number
    lynxtag: number
    _all: number
  }


  export type Bot_list_tagsMinAggregateInputType = {
    id?: true
    icon?: true
    lynxtag?: true
  }

  export type Bot_list_tagsMaxAggregateInputType = {
    id?: true
    icon?: true
    lynxtag?: true
  }

  export type Bot_list_tagsCountAggregateInputType = {
    id?: true
    icon?: true
    lynxtag?: true
    _all?: true
  }

  export type Bot_list_tagsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bot_list_tags to aggregate.
     */
    where?: bot_list_tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bot_list_tags to fetch.
     */
    orderBy?: bot_list_tagsOrderByWithRelationInput | bot_list_tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: bot_list_tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bot_list_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bot_list_tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned bot_list_tags
    **/
    _count?: true | Bot_list_tagsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Bot_list_tagsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Bot_list_tagsMaxAggregateInputType
  }

  export type GetBot_list_tagsAggregateType<T extends Bot_list_tagsAggregateArgs> = {
        [P in keyof T & keyof AggregateBot_list_tags]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBot_list_tags[P]>
      : GetScalarType<T[P], AggregateBot_list_tags[P]>
  }




  export type bot_list_tagsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bot_list_tagsWhereInput
    orderBy?: bot_list_tagsOrderByWithAggregationInput | bot_list_tagsOrderByWithAggregationInput[]
    by: Bot_list_tagsScalarFieldEnum[] | Bot_list_tagsScalarFieldEnum
    having?: bot_list_tagsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Bot_list_tagsCountAggregateInputType | true
    _min?: Bot_list_tagsMinAggregateInputType
    _max?: Bot_list_tagsMaxAggregateInputType
  }

  export type Bot_list_tagsGroupByOutputType = {
    id: string
    icon: string
    lynxtag: string
    _count: Bot_list_tagsCountAggregateOutputType | null
    _min: Bot_list_tagsMinAggregateOutputType | null
    _max: Bot_list_tagsMaxAggregateOutputType | null
  }

  type GetBot_list_tagsGroupByPayload<T extends bot_list_tagsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Bot_list_tagsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Bot_list_tagsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Bot_list_tagsGroupByOutputType[P]>
            : GetScalarType<T[P], Bot_list_tagsGroupByOutputType[P]>
        }
      >
    >


  export type bot_list_tagsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    icon?: boolean
    lynxtag?: boolean
    bot_tags?: boolean | bot_list_tags$bot_tagsArgs<ExtArgs>
    _count?: boolean | Bot_list_tagsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bot_list_tags"]>

  export type bot_list_tagsSelectScalar = {
    id?: boolean
    icon?: boolean
    lynxtag?: boolean
  }

  export type bot_list_tagsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bot_tags?: boolean | bot_list_tags$bot_tagsArgs<ExtArgs>
    _count?: boolean | Bot_list_tagsCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $bot_list_tagsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "bot_list_tags"
    objects: {
      bot_tags: Prisma.$bot_tagsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      icon: string
      lynxtag: string
    }, ExtArgs["result"]["bot_list_tags"]>
    composites: {}
  }


  type bot_list_tagsGetPayload<S extends boolean | null | undefined | bot_list_tagsDefaultArgs> = $Result.GetResult<Prisma.$bot_list_tagsPayload, S>

  type bot_list_tagsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<bot_list_tagsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Bot_list_tagsCountAggregateInputType | true
    }

  export interface bot_list_tagsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['bot_list_tags'], meta: { name: 'bot_list_tags' } }
    /**
     * Find zero or one Bot_list_tags that matches the filter.
     * @param {bot_list_tagsFindUniqueArgs} args - Arguments to find a Bot_list_tags
     * @example
     * // Get one Bot_list_tags
     * const bot_list_tags = await prisma.bot_list_tags.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends bot_list_tagsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, bot_list_tagsFindUniqueArgs<ExtArgs>>
    ): Prisma__bot_list_tagsClient<$Result.GetResult<Prisma.$bot_list_tagsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Bot_list_tags that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {bot_list_tagsFindUniqueOrThrowArgs} args - Arguments to find a Bot_list_tags
     * @example
     * // Get one Bot_list_tags
     * const bot_list_tags = await prisma.bot_list_tags.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends bot_list_tagsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, bot_list_tagsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__bot_list_tagsClient<$Result.GetResult<Prisma.$bot_list_tagsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Bot_list_tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bot_list_tagsFindFirstArgs} args - Arguments to find a Bot_list_tags
     * @example
     * // Get one Bot_list_tags
     * const bot_list_tags = await prisma.bot_list_tags.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends bot_list_tagsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, bot_list_tagsFindFirstArgs<ExtArgs>>
    ): Prisma__bot_list_tagsClient<$Result.GetResult<Prisma.$bot_list_tagsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Bot_list_tags that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bot_list_tagsFindFirstOrThrowArgs} args - Arguments to find a Bot_list_tags
     * @example
     * // Get one Bot_list_tags
     * const bot_list_tags = await prisma.bot_list_tags.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends bot_list_tagsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, bot_list_tagsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__bot_list_tagsClient<$Result.GetResult<Prisma.$bot_list_tagsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Bot_list_tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bot_list_tagsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bot_list_tags
     * const bot_list_tags = await prisma.bot_list_tags.findMany()
     * 
     * // Get first 10 Bot_list_tags
     * const bot_list_tags = await prisma.bot_list_tags.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bot_list_tagsWithIdOnly = await prisma.bot_list_tags.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends bot_list_tagsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bot_list_tagsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bot_list_tagsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Bot_list_tags.
     * @param {bot_list_tagsCreateArgs} args - Arguments to create a Bot_list_tags.
     * @example
     * // Create one Bot_list_tags
     * const Bot_list_tags = await prisma.bot_list_tags.create({
     *   data: {
     *     // ... data to create a Bot_list_tags
     *   }
     * })
     * 
    **/
    create<T extends bot_list_tagsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, bot_list_tagsCreateArgs<ExtArgs>>
    ): Prisma__bot_list_tagsClient<$Result.GetResult<Prisma.$bot_list_tagsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Bot_list_tags.
     *     @param {bot_list_tagsCreateManyArgs} args - Arguments to create many Bot_list_tags.
     *     @example
     *     // Create many Bot_list_tags
     *     const bot_list_tags = await prisma.bot_list_tags.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends bot_list_tagsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bot_list_tagsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Bot_list_tags.
     * @param {bot_list_tagsDeleteArgs} args - Arguments to delete one Bot_list_tags.
     * @example
     * // Delete one Bot_list_tags
     * const Bot_list_tags = await prisma.bot_list_tags.delete({
     *   where: {
     *     // ... filter to delete one Bot_list_tags
     *   }
     * })
     * 
    **/
    delete<T extends bot_list_tagsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, bot_list_tagsDeleteArgs<ExtArgs>>
    ): Prisma__bot_list_tagsClient<$Result.GetResult<Prisma.$bot_list_tagsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Bot_list_tags.
     * @param {bot_list_tagsUpdateArgs} args - Arguments to update one Bot_list_tags.
     * @example
     * // Update one Bot_list_tags
     * const bot_list_tags = await prisma.bot_list_tags.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends bot_list_tagsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, bot_list_tagsUpdateArgs<ExtArgs>>
    ): Prisma__bot_list_tagsClient<$Result.GetResult<Prisma.$bot_list_tagsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Bot_list_tags.
     * @param {bot_list_tagsDeleteManyArgs} args - Arguments to filter Bot_list_tags to delete.
     * @example
     * // Delete a few Bot_list_tags
     * const { count } = await prisma.bot_list_tags.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends bot_list_tagsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bot_list_tagsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bot_list_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bot_list_tagsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bot_list_tags
     * const bot_list_tags = await prisma.bot_list_tags.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends bot_list_tagsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, bot_list_tagsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bot_list_tags.
     * @param {bot_list_tagsUpsertArgs} args - Arguments to update or create a Bot_list_tags.
     * @example
     * // Update or create a Bot_list_tags
     * const bot_list_tags = await prisma.bot_list_tags.upsert({
     *   create: {
     *     // ... data to create a Bot_list_tags
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bot_list_tags we want to update
     *   }
     * })
    **/
    upsert<T extends bot_list_tagsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, bot_list_tagsUpsertArgs<ExtArgs>>
    ): Prisma__bot_list_tagsClient<$Result.GetResult<Prisma.$bot_list_tagsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Bot_list_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bot_list_tagsCountArgs} args - Arguments to filter Bot_list_tags to count.
     * @example
     * // Count the number of Bot_list_tags
     * const count = await prisma.bot_list_tags.count({
     *   where: {
     *     // ... the filter for the Bot_list_tags we want to count
     *   }
     * })
    **/
    count<T extends bot_list_tagsCountArgs>(
      args?: Subset<T, bot_list_tagsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Bot_list_tagsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bot_list_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Bot_list_tagsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Bot_list_tagsAggregateArgs>(args: Subset<T, Bot_list_tagsAggregateArgs>): Prisma.PrismaPromise<GetBot_list_tagsAggregateType<T>>

    /**
     * Group by Bot_list_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bot_list_tagsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends bot_list_tagsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: bot_list_tagsGroupByArgs['orderBy'] }
        : { orderBy?: bot_list_tagsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, bot_list_tagsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBot_list_tagsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the bot_list_tags model
   */
  readonly fields: bot_list_tagsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for bot_list_tags.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__bot_list_tagsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    bot_tags<T extends bot_list_tags$bot_tagsArgs<ExtArgs> = {}>(args?: Subset<T, bot_list_tags$bot_tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bot_tagsPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the bot_list_tags model
   */ 
  interface bot_list_tagsFieldRefs {
    readonly id: FieldRef<"bot_list_tags", 'String'>
    readonly icon: FieldRef<"bot_list_tags", 'String'>
    readonly lynxtag: FieldRef<"bot_list_tags", 'String'>
  }
    

  // Custom InputTypes

  /**
   * bot_list_tags findUnique
   */
  export type bot_list_tagsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_list_tags
     */
    select?: bot_list_tagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bot_list_tagsInclude<ExtArgs> | null
    /**
     * Filter, which bot_list_tags to fetch.
     */
    where: bot_list_tagsWhereUniqueInput
  }


  /**
   * bot_list_tags findUniqueOrThrow
   */
  export type bot_list_tagsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_list_tags
     */
    select?: bot_list_tagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bot_list_tagsInclude<ExtArgs> | null
    /**
     * Filter, which bot_list_tags to fetch.
     */
    where: bot_list_tagsWhereUniqueInput
  }


  /**
   * bot_list_tags findFirst
   */
  export type bot_list_tagsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_list_tags
     */
    select?: bot_list_tagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bot_list_tagsInclude<ExtArgs> | null
    /**
     * Filter, which bot_list_tags to fetch.
     */
    where?: bot_list_tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bot_list_tags to fetch.
     */
    orderBy?: bot_list_tagsOrderByWithRelationInput | bot_list_tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bot_list_tags.
     */
    cursor?: bot_list_tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bot_list_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bot_list_tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bot_list_tags.
     */
    distinct?: Bot_list_tagsScalarFieldEnum | Bot_list_tagsScalarFieldEnum[]
  }


  /**
   * bot_list_tags findFirstOrThrow
   */
  export type bot_list_tagsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_list_tags
     */
    select?: bot_list_tagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bot_list_tagsInclude<ExtArgs> | null
    /**
     * Filter, which bot_list_tags to fetch.
     */
    where?: bot_list_tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bot_list_tags to fetch.
     */
    orderBy?: bot_list_tagsOrderByWithRelationInput | bot_list_tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bot_list_tags.
     */
    cursor?: bot_list_tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bot_list_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bot_list_tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bot_list_tags.
     */
    distinct?: Bot_list_tagsScalarFieldEnum | Bot_list_tagsScalarFieldEnum[]
  }


  /**
   * bot_list_tags findMany
   */
  export type bot_list_tagsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_list_tags
     */
    select?: bot_list_tagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bot_list_tagsInclude<ExtArgs> | null
    /**
     * Filter, which bot_list_tags to fetch.
     */
    where?: bot_list_tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bot_list_tags to fetch.
     */
    orderBy?: bot_list_tagsOrderByWithRelationInput | bot_list_tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing bot_list_tags.
     */
    cursor?: bot_list_tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bot_list_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bot_list_tags.
     */
    skip?: number
    distinct?: Bot_list_tagsScalarFieldEnum | Bot_list_tagsScalarFieldEnum[]
  }


  /**
   * bot_list_tags create
   */
  export type bot_list_tagsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_list_tags
     */
    select?: bot_list_tagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bot_list_tagsInclude<ExtArgs> | null
    /**
     * The data needed to create a bot_list_tags.
     */
    data: XOR<bot_list_tagsCreateInput, bot_list_tagsUncheckedCreateInput>
  }


  /**
   * bot_list_tags createMany
   */
  export type bot_list_tagsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many bot_list_tags.
     */
    data: bot_list_tagsCreateManyInput | bot_list_tagsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * bot_list_tags update
   */
  export type bot_list_tagsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_list_tags
     */
    select?: bot_list_tagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bot_list_tagsInclude<ExtArgs> | null
    /**
     * The data needed to update a bot_list_tags.
     */
    data: XOR<bot_list_tagsUpdateInput, bot_list_tagsUncheckedUpdateInput>
    /**
     * Choose, which bot_list_tags to update.
     */
    where: bot_list_tagsWhereUniqueInput
  }


  /**
   * bot_list_tags updateMany
   */
  export type bot_list_tagsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update bot_list_tags.
     */
    data: XOR<bot_list_tagsUpdateManyMutationInput, bot_list_tagsUncheckedUpdateManyInput>
    /**
     * Filter which bot_list_tags to update
     */
    where?: bot_list_tagsWhereInput
  }


  /**
   * bot_list_tags upsert
   */
  export type bot_list_tagsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_list_tags
     */
    select?: bot_list_tagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bot_list_tagsInclude<ExtArgs> | null
    /**
     * The filter to search for the bot_list_tags to update in case it exists.
     */
    where: bot_list_tagsWhereUniqueInput
    /**
     * In case the bot_list_tags found by the `where` argument doesn't exist, create a new bot_list_tags with this data.
     */
    create: XOR<bot_list_tagsCreateInput, bot_list_tagsUncheckedCreateInput>
    /**
     * In case the bot_list_tags was found with the provided `where` argument, update it with this data.
     */
    update: XOR<bot_list_tagsUpdateInput, bot_list_tagsUncheckedUpdateInput>
  }


  /**
   * bot_list_tags delete
   */
  export type bot_list_tagsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_list_tags
     */
    select?: bot_list_tagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bot_list_tagsInclude<ExtArgs> | null
    /**
     * Filter which bot_list_tags to delete.
     */
    where: bot_list_tagsWhereUniqueInput
  }


  /**
   * bot_list_tags deleteMany
   */
  export type bot_list_tagsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bot_list_tags to delete
     */
    where?: bot_list_tagsWhereInput
  }


  /**
   * bot_list_tags.bot_tags
   */
  export type bot_list_tags$bot_tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_tags
     */
    select?: bot_tagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bot_tagsInclude<ExtArgs> | null
    where?: bot_tagsWhereInput
    orderBy?: bot_tagsOrderByWithRelationInput | bot_tagsOrderByWithRelationInput[]
    cursor?: bot_tagsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Bot_tagsScalarFieldEnum | Bot_tagsScalarFieldEnum[]
  }


  /**
   * bot_list_tags without action
   */
  export type bot_list_tagsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_list_tags
     */
    select?: bot_list_tagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bot_list_tagsInclude<ExtArgs> | null
  }



  /**
   * Model bot_owner
   */

  export type AggregateBot_owner = {
    _count: Bot_ownerCountAggregateOutputType | null
    _avg: Bot_ownerAvgAggregateOutputType | null
    _sum: Bot_ownerSumAggregateOutputType | null
    _min: Bot_ownerMinAggregateOutputType | null
    _max: Bot_ownerMaxAggregateOutputType | null
  }

  export type Bot_ownerAvgAggregateOutputType = {
    bot_id: number | null
    owner: number | null
    id: number | null
  }

  export type Bot_ownerSumAggregateOutputType = {
    bot_id: bigint | null
    owner: bigint | null
    id: number | null
  }

  export type Bot_ownerMinAggregateOutputType = {
    bot_id: bigint | null
    owner: bigint | null
    main: boolean | null
    id: number | null
    lynxtag: string | null
  }

  export type Bot_ownerMaxAggregateOutputType = {
    bot_id: bigint | null
    owner: bigint | null
    main: boolean | null
    id: number | null
    lynxtag: string | null
  }

  export type Bot_ownerCountAggregateOutputType = {
    bot_id: number
    owner: number
    main: number
    id: number
    lynxtag: number
    _all: number
  }


  export type Bot_ownerAvgAggregateInputType = {
    bot_id?: true
    owner?: true
    id?: true
  }

  export type Bot_ownerSumAggregateInputType = {
    bot_id?: true
    owner?: true
    id?: true
  }

  export type Bot_ownerMinAggregateInputType = {
    bot_id?: true
    owner?: true
    main?: true
    id?: true
    lynxtag?: true
  }

  export type Bot_ownerMaxAggregateInputType = {
    bot_id?: true
    owner?: true
    main?: true
    id?: true
    lynxtag?: true
  }

  export type Bot_ownerCountAggregateInputType = {
    bot_id?: true
    owner?: true
    main?: true
    id?: true
    lynxtag?: true
    _all?: true
  }

  export type Bot_ownerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bot_owner to aggregate.
     */
    where?: bot_ownerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bot_owners to fetch.
     */
    orderBy?: bot_ownerOrderByWithRelationInput | bot_ownerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: bot_ownerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bot_owners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bot_owners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned bot_owners
    **/
    _count?: true | Bot_ownerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Bot_ownerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Bot_ownerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Bot_ownerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Bot_ownerMaxAggregateInputType
  }

  export type GetBot_ownerAggregateType<T extends Bot_ownerAggregateArgs> = {
        [P in keyof T & keyof AggregateBot_owner]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBot_owner[P]>
      : GetScalarType<T[P], AggregateBot_owner[P]>
  }




  export type bot_ownerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bot_ownerWhereInput
    orderBy?: bot_ownerOrderByWithAggregationInput | bot_ownerOrderByWithAggregationInput[]
    by: Bot_ownerScalarFieldEnum[] | Bot_ownerScalarFieldEnum
    having?: bot_ownerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Bot_ownerCountAggregateInputType | true
    _avg?: Bot_ownerAvgAggregateInputType
    _sum?: Bot_ownerSumAggregateInputType
    _min?: Bot_ownerMinAggregateInputType
    _max?: Bot_ownerMaxAggregateInputType
  }

  export type Bot_ownerGroupByOutputType = {
    bot_id: bigint
    owner: bigint
    main: boolean | null
    id: number
    lynxtag: string
    _count: Bot_ownerCountAggregateOutputType | null
    _avg: Bot_ownerAvgAggregateOutputType | null
    _sum: Bot_ownerSumAggregateOutputType | null
    _min: Bot_ownerMinAggregateOutputType | null
    _max: Bot_ownerMaxAggregateOutputType | null
  }

  type GetBot_ownerGroupByPayload<T extends bot_ownerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Bot_ownerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Bot_ownerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Bot_ownerGroupByOutputType[P]>
            : GetScalarType<T[P], Bot_ownerGroupByOutputType[P]>
        }
      >
    >


  export type bot_ownerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    bot_id?: boolean
    owner?: boolean
    main?: boolean
    id?: boolean
    lynxtag?: boolean
    bots?: boolean | botsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bot_owner"]>

  export type bot_ownerSelectScalar = {
    bot_id?: boolean
    owner?: boolean
    main?: boolean
    id?: boolean
    lynxtag?: boolean
  }

  export type bot_ownerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bots?: boolean | botsDefaultArgs<ExtArgs>
  }


  export type $bot_ownerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "bot_owner"
    objects: {
      bots: Prisma.$botsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      bot_id: bigint
      owner: bigint
      main: boolean | null
      id: number
      lynxtag: string
    }, ExtArgs["result"]["bot_owner"]>
    composites: {}
  }


  type bot_ownerGetPayload<S extends boolean | null | undefined | bot_ownerDefaultArgs> = $Result.GetResult<Prisma.$bot_ownerPayload, S>

  type bot_ownerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<bot_ownerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Bot_ownerCountAggregateInputType | true
    }

  export interface bot_ownerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['bot_owner'], meta: { name: 'bot_owner' } }
    /**
     * Find zero or one Bot_owner that matches the filter.
     * @param {bot_ownerFindUniqueArgs} args - Arguments to find a Bot_owner
     * @example
     * // Get one Bot_owner
     * const bot_owner = await prisma.bot_owner.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends bot_ownerFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, bot_ownerFindUniqueArgs<ExtArgs>>
    ): Prisma__bot_ownerClient<$Result.GetResult<Prisma.$bot_ownerPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Bot_owner that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {bot_ownerFindUniqueOrThrowArgs} args - Arguments to find a Bot_owner
     * @example
     * // Get one Bot_owner
     * const bot_owner = await prisma.bot_owner.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends bot_ownerFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, bot_ownerFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__bot_ownerClient<$Result.GetResult<Prisma.$bot_ownerPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Bot_owner that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bot_ownerFindFirstArgs} args - Arguments to find a Bot_owner
     * @example
     * // Get one Bot_owner
     * const bot_owner = await prisma.bot_owner.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends bot_ownerFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, bot_ownerFindFirstArgs<ExtArgs>>
    ): Prisma__bot_ownerClient<$Result.GetResult<Prisma.$bot_ownerPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Bot_owner that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bot_ownerFindFirstOrThrowArgs} args - Arguments to find a Bot_owner
     * @example
     * // Get one Bot_owner
     * const bot_owner = await prisma.bot_owner.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends bot_ownerFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, bot_ownerFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__bot_ownerClient<$Result.GetResult<Prisma.$bot_ownerPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Bot_owners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bot_ownerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bot_owners
     * const bot_owners = await prisma.bot_owner.findMany()
     * 
     * // Get first 10 Bot_owners
     * const bot_owners = await prisma.bot_owner.findMany({ take: 10 })
     * 
     * // Only select the `bot_id`
     * const bot_ownerWithBot_idOnly = await prisma.bot_owner.findMany({ select: { bot_id: true } })
     * 
    **/
    findMany<T extends bot_ownerFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bot_ownerFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bot_ownerPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Bot_owner.
     * @param {bot_ownerCreateArgs} args - Arguments to create a Bot_owner.
     * @example
     * // Create one Bot_owner
     * const Bot_owner = await prisma.bot_owner.create({
     *   data: {
     *     // ... data to create a Bot_owner
     *   }
     * })
     * 
    **/
    create<T extends bot_ownerCreateArgs<ExtArgs>>(
      args: SelectSubset<T, bot_ownerCreateArgs<ExtArgs>>
    ): Prisma__bot_ownerClient<$Result.GetResult<Prisma.$bot_ownerPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Bot_owners.
     *     @param {bot_ownerCreateManyArgs} args - Arguments to create many Bot_owners.
     *     @example
     *     // Create many Bot_owners
     *     const bot_owner = await prisma.bot_owner.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends bot_ownerCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bot_ownerCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Bot_owner.
     * @param {bot_ownerDeleteArgs} args - Arguments to delete one Bot_owner.
     * @example
     * // Delete one Bot_owner
     * const Bot_owner = await prisma.bot_owner.delete({
     *   where: {
     *     // ... filter to delete one Bot_owner
     *   }
     * })
     * 
    **/
    delete<T extends bot_ownerDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, bot_ownerDeleteArgs<ExtArgs>>
    ): Prisma__bot_ownerClient<$Result.GetResult<Prisma.$bot_ownerPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Bot_owner.
     * @param {bot_ownerUpdateArgs} args - Arguments to update one Bot_owner.
     * @example
     * // Update one Bot_owner
     * const bot_owner = await prisma.bot_owner.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends bot_ownerUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, bot_ownerUpdateArgs<ExtArgs>>
    ): Prisma__bot_ownerClient<$Result.GetResult<Prisma.$bot_ownerPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Bot_owners.
     * @param {bot_ownerDeleteManyArgs} args - Arguments to filter Bot_owners to delete.
     * @example
     * // Delete a few Bot_owners
     * const { count } = await prisma.bot_owner.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends bot_ownerDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bot_ownerDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bot_owners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bot_ownerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bot_owners
     * const bot_owner = await prisma.bot_owner.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends bot_ownerUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, bot_ownerUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bot_owner.
     * @param {bot_ownerUpsertArgs} args - Arguments to update or create a Bot_owner.
     * @example
     * // Update or create a Bot_owner
     * const bot_owner = await prisma.bot_owner.upsert({
     *   create: {
     *     // ... data to create a Bot_owner
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bot_owner we want to update
     *   }
     * })
    **/
    upsert<T extends bot_ownerUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, bot_ownerUpsertArgs<ExtArgs>>
    ): Prisma__bot_ownerClient<$Result.GetResult<Prisma.$bot_ownerPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Bot_owners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bot_ownerCountArgs} args - Arguments to filter Bot_owners to count.
     * @example
     * // Count the number of Bot_owners
     * const count = await prisma.bot_owner.count({
     *   where: {
     *     // ... the filter for the Bot_owners we want to count
     *   }
     * })
    **/
    count<T extends bot_ownerCountArgs>(
      args?: Subset<T, bot_ownerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Bot_ownerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bot_owner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Bot_ownerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Bot_ownerAggregateArgs>(args: Subset<T, Bot_ownerAggregateArgs>): Prisma.PrismaPromise<GetBot_ownerAggregateType<T>>

    /**
     * Group by Bot_owner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bot_ownerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends bot_ownerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: bot_ownerGroupByArgs['orderBy'] }
        : { orderBy?: bot_ownerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, bot_ownerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBot_ownerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the bot_owner model
   */
  readonly fields: bot_ownerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for bot_owner.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__bot_ownerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    bots<T extends botsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, botsDefaultArgs<ExtArgs>>): Prisma__botsClient<$Result.GetResult<Prisma.$botsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the bot_owner model
   */ 
  interface bot_ownerFieldRefs {
    readonly bot_id: FieldRef<"bot_owner", 'BigInt'>
    readonly owner: FieldRef<"bot_owner", 'BigInt'>
    readonly main: FieldRef<"bot_owner", 'Boolean'>
    readonly id: FieldRef<"bot_owner", 'Int'>
    readonly lynxtag: FieldRef<"bot_owner", 'String'>
  }
    

  // Custom InputTypes

  /**
   * bot_owner findUnique
   */
  export type bot_ownerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_owner
     */
    select?: bot_ownerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bot_ownerInclude<ExtArgs> | null
    /**
     * Filter, which bot_owner to fetch.
     */
    where: bot_ownerWhereUniqueInput
  }


  /**
   * bot_owner findUniqueOrThrow
   */
  export type bot_ownerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_owner
     */
    select?: bot_ownerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bot_ownerInclude<ExtArgs> | null
    /**
     * Filter, which bot_owner to fetch.
     */
    where: bot_ownerWhereUniqueInput
  }


  /**
   * bot_owner findFirst
   */
  export type bot_ownerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_owner
     */
    select?: bot_ownerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bot_ownerInclude<ExtArgs> | null
    /**
     * Filter, which bot_owner to fetch.
     */
    where?: bot_ownerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bot_owners to fetch.
     */
    orderBy?: bot_ownerOrderByWithRelationInput | bot_ownerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bot_owners.
     */
    cursor?: bot_ownerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bot_owners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bot_owners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bot_owners.
     */
    distinct?: Bot_ownerScalarFieldEnum | Bot_ownerScalarFieldEnum[]
  }


  /**
   * bot_owner findFirstOrThrow
   */
  export type bot_ownerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_owner
     */
    select?: bot_ownerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bot_ownerInclude<ExtArgs> | null
    /**
     * Filter, which bot_owner to fetch.
     */
    where?: bot_ownerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bot_owners to fetch.
     */
    orderBy?: bot_ownerOrderByWithRelationInput | bot_ownerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bot_owners.
     */
    cursor?: bot_ownerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bot_owners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bot_owners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bot_owners.
     */
    distinct?: Bot_ownerScalarFieldEnum | Bot_ownerScalarFieldEnum[]
  }


  /**
   * bot_owner findMany
   */
  export type bot_ownerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_owner
     */
    select?: bot_ownerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bot_ownerInclude<ExtArgs> | null
    /**
     * Filter, which bot_owners to fetch.
     */
    where?: bot_ownerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bot_owners to fetch.
     */
    orderBy?: bot_ownerOrderByWithRelationInput | bot_ownerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing bot_owners.
     */
    cursor?: bot_ownerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bot_owners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bot_owners.
     */
    skip?: number
    distinct?: Bot_ownerScalarFieldEnum | Bot_ownerScalarFieldEnum[]
  }


  /**
   * bot_owner create
   */
  export type bot_ownerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_owner
     */
    select?: bot_ownerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bot_ownerInclude<ExtArgs> | null
    /**
     * The data needed to create a bot_owner.
     */
    data: XOR<bot_ownerCreateInput, bot_ownerUncheckedCreateInput>
  }


  /**
   * bot_owner createMany
   */
  export type bot_ownerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many bot_owners.
     */
    data: bot_ownerCreateManyInput | bot_ownerCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * bot_owner update
   */
  export type bot_ownerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_owner
     */
    select?: bot_ownerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bot_ownerInclude<ExtArgs> | null
    /**
     * The data needed to update a bot_owner.
     */
    data: XOR<bot_ownerUpdateInput, bot_ownerUncheckedUpdateInput>
    /**
     * Choose, which bot_owner to update.
     */
    where: bot_ownerWhereUniqueInput
  }


  /**
   * bot_owner updateMany
   */
  export type bot_ownerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update bot_owners.
     */
    data: XOR<bot_ownerUpdateManyMutationInput, bot_ownerUncheckedUpdateManyInput>
    /**
     * Filter which bot_owners to update
     */
    where?: bot_ownerWhereInput
  }


  /**
   * bot_owner upsert
   */
  export type bot_ownerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_owner
     */
    select?: bot_ownerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bot_ownerInclude<ExtArgs> | null
    /**
     * The filter to search for the bot_owner to update in case it exists.
     */
    where: bot_ownerWhereUniqueInput
    /**
     * In case the bot_owner found by the `where` argument doesn't exist, create a new bot_owner with this data.
     */
    create: XOR<bot_ownerCreateInput, bot_ownerUncheckedCreateInput>
    /**
     * In case the bot_owner was found with the provided `where` argument, update it with this data.
     */
    update: XOR<bot_ownerUpdateInput, bot_ownerUncheckedUpdateInput>
  }


  /**
   * bot_owner delete
   */
  export type bot_ownerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_owner
     */
    select?: bot_ownerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bot_ownerInclude<ExtArgs> | null
    /**
     * Filter which bot_owner to delete.
     */
    where: bot_ownerWhereUniqueInput
  }


  /**
   * bot_owner deleteMany
   */
  export type bot_ownerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bot_owners to delete
     */
    where?: bot_ownerWhereInput
  }


  /**
   * bot_owner without action
   */
  export type bot_ownerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_owner
     */
    select?: bot_ownerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bot_ownerInclude<ExtArgs> | null
  }



  /**
   * Model bot_packs
   */

  export type AggregateBot_packs = {
    _count: Bot_packsCountAggregateOutputType | null
    _avg: Bot_packsAvgAggregateOutputType | null
    _sum: Bot_packsSumAggregateOutputType | null
    _min: Bot_packsMinAggregateOutputType | null
    _max: Bot_packsMaxAggregateOutputType | null
  }

  export type Bot_packsAvgAggregateOutputType = {
    owner: number | null
    bots: number | null
  }

  export type Bot_packsSumAggregateOutputType = {
    owner: bigint | null
    bots: bigint[]
  }

  export type Bot_packsMinAggregateOutputType = {
    id: string | null
    icon: string | null
    banner: string | null
    owner: bigint | null
    description: string | null
    name: string | null
    created_at: Date | null
    lynxtag: string | null
  }

  export type Bot_packsMaxAggregateOutputType = {
    id: string | null
    icon: string | null
    banner: string | null
    owner: bigint | null
    description: string | null
    name: string | null
    created_at: Date | null
    lynxtag: string | null
  }

  export type Bot_packsCountAggregateOutputType = {
    id: number
    icon: number
    banner: number
    owner: number
    bots: number
    description: number
    name: number
    created_at: number
    lynxtag: number
    _all: number
  }


  export type Bot_packsAvgAggregateInputType = {
    owner?: true
    bots?: true
  }

  export type Bot_packsSumAggregateInputType = {
    owner?: true
    bots?: true
  }

  export type Bot_packsMinAggregateInputType = {
    id?: true
    icon?: true
    banner?: true
    owner?: true
    description?: true
    name?: true
    created_at?: true
    lynxtag?: true
  }

  export type Bot_packsMaxAggregateInputType = {
    id?: true
    icon?: true
    banner?: true
    owner?: true
    description?: true
    name?: true
    created_at?: true
    lynxtag?: true
  }

  export type Bot_packsCountAggregateInputType = {
    id?: true
    icon?: true
    banner?: true
    owner?: true
    bots?: true
    description?: true
    name?: true
    created_at?: true
    lynxtag?: true
    _all?: true
  }

  export type Bot_packsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bot_packs to aggregate.
     */
    where?: bot_packsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bot_packs to fetch.
     */
    orderBy?: bot_packsOrderByWithRelationInput | bot_packsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: bot_packsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bot_packs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bot_packs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned bot_packs
    **/
    _count?: true | Bot_packsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Bot_packsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Bot_packsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Bot_packsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Bot_packsMaxAggregateInputType
  }

  export type GetBot_packsAggregateType<T extends Bot_packsAggregateArgs> = {
        [P in keyof T & keyof AggregateBot_packs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBot_packs[P]>
      : GetScalarType<T[P], AggregateBot_packs[P]>
  }




  export type bot_packsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bot_packsWhereInput
    orderBy?: bot_packsOrderByWithAggregationInput | bot_packsOrderByWithAggregationInput[]
    by: Bot_packsScalarFieldEnum[] | Bot_packsScalarFieldEnum
    having?: bot_packsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Bot_packsCountAggregateInputType | true
    _avg?: Bot_packsAvgAggregateInputType
    _sum?: Bot_packsSumAggregateInputType
    _min?: Bot_packsMinAggregateInputType
    _max?: Bot_packsMaxAggregateInputType
  }

  export type Bot_packsGroupByOutputType = {
    id: string
    icon: string | null
    banner: string | null
    owner: bigint
    bots: bigint[]
    description: string
    name: string
    created_at: Date | null
    lynxtag: string
    _count: Bot_packsCountAggregateOutputType | null
    _avg: Bot_packsAvgAggregateOutputType | null
    _sum: Bot_packsSumAggregateOutputType | null
    _min: Bot_packsMinAggregateOutputType | null
    _max: Bot_packsMaxAggregateOutputType | null
  }

  type GetBot_packsGroupByPayload<T extends bot_packsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Bot_packsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Bot_packsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Bot_packsGroupByOutputType[P]>
            : GetScalarType<T[P], Bot_packsGroupByOutputType[P]>
        }
      >
    >


  export type bot_packsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    icon?: boolean
    banner?: boolean
    owner?: boolean
    bots?: boolean
    description?: boolean
    name?: boolean
    created_at?: boolean
    lynxtag?: boolean
  }, ExtArgs["result"]["bot_packs"]>

  export type bot_packsSelectScalar = {
    id?: boolean
    icon?: boolean
    banner?: boolean
    owner?: boolean
    bots?: boolean
    description?: boolean
    name?: boolean
    created_at?: boolean
    lynxtag?: boolean
  }


  export type $bot_packsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "bot_packs"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      icon: string | null
      banner: string | null
      owner: bigint
      bots: bigint[]
      description: string
      name: string
      created_at: Date | null
      lynxtag: string
    }, ExtArgs["result"]["bot_packs"]>
    composites: {}
  }


  type bot_packsGetPayload<S extends boolean | null | undefined | bot_packsDefaultArgs> = $Result.GetResult<Prisma.$bot_packsPayload, S>

  type bot_packsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<bot_packsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Bot_packsCountAggregateInputType | true
    }

  export interface bot_packsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['bot_packs'], meta: { name: 'bot_packs' } }
    /**
     * Find zero or one Bot_packs that matches the filter.
     * @param {bot_packsFindUniqueArgs} args - Arguments to find a Bot_packs
     * @example
     * // Get one Bot_packs
     * const bot_packs = await prisma.bot_packs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends bot_packsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, bot_packsFindUniqueArgs<ExtArgs>>
    ): Prisma__bot_packsClient<$Result.GetResult<Prisma.$bot_packsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Bot_packs that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {bot_packsFindUniqueOrThrowArgs} args - Arguments to find a Bot_packs
     * @example
     * // Get one Bot_packs
     * const bot_packs = await prisma.bot_packs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends bot_packsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, bot_packsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__bot_packsClient<$Result.GetResult<Prisma.$bot_packsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Bot_packs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bot_packsFindFirstArgs} args - Arguments to find a Bot_packs
     * @example
     * // Get one Bot_packs
     * const bot_packs = await prisma.bot_packs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends bot_packsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, bot_packsFindFirstArgs<ExtArgs>>
    ): Prisma__bot_packsClient<$Result.GetResult<Prisma.$bot_packsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Bot_packs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bot_packsFindFirstOrThrowArgs} args - Arguments to find a Bot_packs
     * @example
     * // Get one Bot_packs
     * const bot_packs = await prisma.bot_packs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends bot_packsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, bot_packsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__bot_packsClient<$Result.GetResult<Prisma.$bot_packsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Bot_packs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bot_packsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bot_packs
     * const bot_packs = await prisma.bot_packs.findMany()
     * 
     * // Get first 10 Bot_packs
     * const bot_packs = await prisma.bot_packs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bot_packsWithIdOnly = await prisma.bot_packs.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends bot_packsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bot_packsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bot_packsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Bot_packs.
     * @param {bot_packsCreateArgs} args - Arguments to create a Bot_packs.
     * @example
     * // Create one Bot_packs
     * const Bot_packs = await prisma.bot_packs.create({
     *   data: {
     *     // ... data to create a Bot_packs
     *   }
     * })
     * 
    **/
    create<T extends bot_packsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, bot_packsCreateArgs<ExtArgs>>
    ): Prisma__bot_packsClient<$Result.GetResult<Prisma.$bot_packsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Bot_packs.
     *     @param {bot_packsCreateManyArgs} args - Arguments to create many Bot_packs.
     *     @example
     *     // Create many Bot_packs
     *     const bot_packs = await prisma.bot_packs.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends bot_packsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bot_packsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Bot_packs.
     * @param {bot_packsDeleteArgs} args - Arguments to delete one Bot_packs.
     * @example
     * // Delete one Bot_packs
     * const Bot_packs = await prisma.bot_packs.delete({
     *   where: {
     *     // ... filter to delete one Bot_packs
     *   }
     * })
     * 
    **/
    delete<T extends bot_packsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, bot_packsDeleteArgs<ExtArgs>>
    ): Prisma__bot_packsClient<$Result.GetResult<Prisma.$bot_packsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Bot_packs.
     * @param {bot_packsUpdateArgs} args - Arguments to update one Bot_packs.
     * @example
     * // Update one Bot_packs
     * const bot_packs = await prisma.bot_packs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends bot_packsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, bot_packsUpdateArgs<ExtArgs>>
    ): Prisma__bot_packsClient<$Result.GetResult<Prisma.$bot_packsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Bot_packs.
     * @param {bot_packsDeleteManyArgs} args - Arguments to filter Bot_packs to delete.
     * @example
     * // Delete a few Bot_packs
     * const { count } = await prisma.bot_packs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends bot_packsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bot_packsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bot_packs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bot_packsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bot_packs
     * const bot_packs = await prisma.bot_packs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends bot_packsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, bot_packsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bot_packs.
     * @param {bot_packsUpsertArgs} args - Arguments to update or create a Bot_packs.
     * @example
     * // Update or create a Bot_packs
     * const bot_packs = await prisma.bot_packs.upsert({
     *   create: {
     *     // ... data to create a Bot_packs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bot_packs we want to update
     *   }
     * })
    **/
    upsert<T extends bot_packsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, bot_packsUpsertArgs<ExtArgs>>
    ): Prisma__bot_packsClient<$Result.GetResult<Prisma.$bot_packsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Bot_packs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bot_packsCountArgs} args - Arguments to filter Bot_packs to count.
     * @example
     * // Count the number of Bot_packs
     * const count = await prisma.bot_packs.count({
     *   where: {
     *     // ... the filter for the Bot_packs we want to count
     *   }
     * })
    **/
    count<T extends bot_packsCountArgs>(
      args?: Subset<T, bot_packsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Bot_packsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bot_packs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Bot_packsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Bot_packsAggregateArgs>(args: Subset<T, Bot_packsAggregateArgs>): Prisma.PrismaPromise<GetBot_packsAggregateType<T>>

    /**
     * Group by Bot_packs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bot_packsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends bot_packsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: bot_packsGroupByArgs['orderBy'] }
        : { orderBy?: bot_packsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, bot_packsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBot_packsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the bot_packs model
   */
  readonly fields: bot_packsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for bot_packs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__bot_packsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the bot_packs model
   */ 
  interface bot_packsFieldRefs {
    readonly id: FieldRef<"bot_packs", 'String'>
    readonly icon: FieldRef<"bot_packs", 'String'>
    readonly banner: FieldRef<"bot_packs", 'String'>
    readonly owner: FieldRef<"bot_packs", 'BigInt'>
    readonly bots: FieldRef<"bot_packs", 'BigInt[]'>
    readonly description: FieldRef<"bot_packs", 'String'>
    readonly name: FieldRef<"bot_packs", 'String'>
    readonly created_at: FieldRef<"bot_packs", 'DateTime'>
    readonly lynxtag: FieldRef<"bot_packs", 'String'>
  }
    

  // Custom InputTypes

  /**
   * bot_packs findUnique
   */
  export type bot_packsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_packs
     */
    select?: bot_packsSelect<ExtArgs> | null
    /**
     * Filter, which bot_packs to fetch.
     */
    where: bot_packsWhereUniqueInput
  }


  /**
   * bot_packs findUniqueOrThrow
   */
  export type bot_packsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_packs
     */
    select?: bot_packsSelect<ExtArgs> | null
    /**
     * Filter, which bot_packs to fetch.
     */
    where: bot_packsWhereUniqueInput
  }


  /**
   * bot_packs findFirst
   */
  export type bot_packsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_packs
     */
    select?: bot_packsSelect<ExtArgs> | null
    /**
     * Filter, which bot_packs to fetch.
     */
    where?: bot_packsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bot_packs to fetch.
     */
    orderBy?: bot_packsOrderByWithRelationInput | bot_packsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bot_packs.
     */
    cursor?: bot_packsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bot_packs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bot_packs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bot_packs.
     */
    distinct?: Bot_packsScalarFieldEnum | Bot_packsScalarFieldEnum[]
  }


  /**
   * bot_packs findFirstOrThrow
   */
  export type bot_packsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_packs
     */
    select?: bot_packsSelect<ExtArgs> | null
    /**
     * Filter, which bot_packs to fetch.
     */
    where?: bot_packsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bot_packs to fetch.
     */
    orderBy?: bot_packsOrderByWithRelationInput | bot_packsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bot_packs.
     */
    cursor?: bot_packsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bot_packs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bot_packs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bot_packs.
     */
    distinct?: Bot_packsScalarFieldEnum | Bot_packsScalarFieldEnum[]
  }


  /**
   * bot_packs findMany
   */
  export type bot_packsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_packs
     */
    select?: bot_packsSelect<ExtArgs> | null
    /**
     * Filter, which bot_packs to fetch.
     */
    where?: bot_packsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bot_packs to fetch.
     */
    orderBy?: bot_packsOrderByWithRelationInput | bot_packsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing bot_packs.
     */
    cursor?: bot_packsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bot_packs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bot_packs.
     */
    skip?: number
    distinct?: Bot_packsScalarFieldEnum | Bot_packsScalarFieldEnum[]
  }


  /**
   * bot_packs create
   */
  export type bot_packsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_packs
     */
    select?: bot_packsSelect<ExtArgs> | null
    /**
     * The data needed to create a bot_packs.
     */
    data: XOR<bot_packsCreateInput, bot_packsUncheckedCreateInput>
  }


  /**
   * bot_packs createMany
   */
  export type bot_packsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many bot_packs.
     */
    data: bot_packsCreateManyInput | bot_packsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * bot_packs update
   */
  export type bot_packsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_packs
     */
    select?: bot_packsSelect<ExtArgs> | null
    /**
     * The data needed to update a bot_packs.
     */
    data: XOR<bot_packsUpdateInput, bot_packsUncheckedUpdateInput>
    /**
     * Choose, which bot_packs to update.
     */
    where: bot_packsWhereUniqueInput
  }


  /**
   * bot_packs updateMany
   */
  export type bot_packsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update bot_packs.
     */
    data: XOR<bot_packsUpdateManyMutationInput, bot_packsUncheckedUpdateManyInput>
    /**
     * Filter which bot_packs to update
     */
    where?: bot_packsWhereInput
  }


  /**
   * bot_packs upsert
   */
  export type bot_packsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_packs
     */
    select?: bot_packsSelect<ExtArgs> | null
    /**
     * The filter to search for the bot_packs to update in case it exists.
     */
    where: bot_packsWhereUniqueInput
    /**
     * In case the bot_packs found by the `where` argument doesn't exist, create a new bot_packs with this data.
     */
    create: XOR<bot_packsCreateInput, bot_packsUncheckedCreateInput>
    /**
     * In case the bot_packs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<bot_packsUpdateInput, bot_packsUncheckedUpdateInput>
  }


  /**
   * bot_packs delete
   */
  export type bot_packsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_packs
     */
    select?: bot_packsSelect<ExtArgs> | null
    /**
     * Filter which bot_packs to delete.
     */
    where: bot_packsWhereUniqueInput
  }


  /**
   * bot_packs deleteMany
   */
  export type bot_packsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bot_packs to delete
     */
    where?: bot_packsWhereInput
  }


  /**
   * bot_packs without action
   */
  export type bot_packsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_packs
     */
    select?: bot_packsSelect<ExtArgs> | null
  }



  /**
   * Model bot_promotions
   */

  export type AggregateBot_promotions = {
    _count: Bot_promotionsCountAggregateOutputType | null
    _avg: Bot_promotionsAvgAggregateOutputType | null
    _sum: Bot_promotionsSumAggregateOutputType | null
    _min: Bot_promotionsMinAggregateOutputType | null
    _max: Bot_promotionsMaxAggregateOutputType | null
  }

  export type Bot_promotionsAvgAggregateOutputType = {
    bot_id: number | null
    type: number | null
  }

  export type Bot_promotionsSumAggregateOutputType = {
    bot_id: bigint | null
    type: number | null
  }

  export type Bot_promotionsMinAggregateOutputType = {
    id: string | null
    bot_id: bigint | null
    title: string | null
    info: string | null
    css: string | null
    type: number | null
    lynxtag: string | null
  }

  export type Bot_promotionsMaxAggregateOutputType = {
    id: string | null
    bot_id: bigint | null
    title: string | null
    info: string | null
    css: string | null
    type: number | null
    lynxtag: string | null
  }

  export type Bot_promotionsCountAggregateOutputType = {
    id: number
    bot_id: number
    title: number
    info: number
    css: number
    type: number
    lynxtag: number
    _all: number
  }


  export type Bot_promotionsAvgAggregateInputType = {
    bot_id?: true
    type?: true
  }

  export type Bot_promotionsSumAggregateInputType = {
    bot_id?: true
    type?: true
  }

  export type Bot_promotionsMinAggregateInputType = {
    id?: true
    bot_id?: true
    title?: true
    info?: true
    css?: true
    type?: true
    lynxtag?: true
  }

  export type Bot_promotionsMaxAggregateInputType = {
    id?: true
    bot_id?: true
    title?: true
    info?: true
    css?: true
    type?: true
    lynxtag?: true
  }

  export type Bot_promotionsCountAggregateInputType = {
    id?: true
    bot_id?: true
    title?: true
    info?: true
    css?: true
    type?: true
    lynxtag?: true
    _all?: true
  }

  export type Bot_promotionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bot_promotions to aggregate.
     */
    where?: bot_promotionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bot_promotions to fetch.
     */
    orderBy?: bot_promotionsOrderByWithRelationInput | bot_promotionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: bot_promotionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bot_promotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bot_promotions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned bot_promotions
    **/
    _count?: true | Bot_promotionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Bot_promotionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Bot_promotionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Bot_promotionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Bot_promotionsMaxAggregateInputType
  }

  export type GetBot_promotionsAggregateType<T extends Bot_promotionsAggregateArgs> = {
        [P in keyof T & keyof AggregateBot_promotions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBot_promotions[P]>
      : GetScalarType<T[P], AggregateBot_promotions[P]>
  }




  export type bot_promotionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bot_promotionsWhereInput
    orderBy?: bot_promotionsOrderByWithAggregationInput | bot_promotionsOrderByWithAggregationInput[]
    by: Bot_promotionsScalarFieldEnum[] | Bot_promotionsScalarFieldEnum
    having?: bot_promotionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Bot_promotionsCountAggregateInputType | true
    _avg?: Bot_promotionsAvgAggregateInputType
    _sum?: Bot_promotionsSumAggregateInputType
    _min?: Bot_promotionsMinAggregateInputType
    _max?: Bot_promotionsMaxAggregateInputType
  }

  export type Bot_promotionsGroupByOutputType = {
    id: string
    bot_id: bigint | null
    title: string | null
    info: string | null
    css: string | null
    type: number | null
    lynxtag: string
    _count: Bot_promotionsCountAggregateOutputType | null
    _avg: Bot_promotionsAvgAggregateOutputType | null
    _sum: Bot_promotionsSumAggregateOutputType | null
    _min: Bot_promotionsMinAggregateOutputType | null
    _max: Bot_promotionsMaxAggregateOutputType | null
  }

  type GetBot_promotionsGroupByPayload<T extends bot_promotionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Bot_promotionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Bot_promotionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Bot_promotionsGroupByOutputType[P]>
            : GetScalarType<T[P], Bot_promotionsGroupByOutputType[P]>
        }
      >
    >


  export type bot_promotionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bot_id?: boolean
    title?: boolean
    info?: boolean
    css?: boolean
    type?: boolean
    lynxtag?: boolean
    bots?: boolean | bot_promotions$botsArgs<ExtArgs>
  }, ExtArgs["result"]["bot_promotions"]>

  export type bot_promotionsSelectScalar = {
    id?: boolean
    bot_id?: boolean
    title?: boolean
    info?: boolean
    css?: boolean
    type?: boolean
    lynxtag?: boolean
  }

  export type bot_promotionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bots?: boolean | bot_promotions$botsArgs<ExtArgs>
  }


  export type $bot_promotionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "bot_promotions"
    objects: {
      bots: Prisma.$botsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bot_id: bigint | null
      title: string | null
      info: string | null
      css: string | null
      type: number | null
      lynxtag: string
    }, ExtArgs["result"]["bot_promotions"]>
    composites: {}
  }


  type bot_promotionsGetPayload<S extends boolean | null | undefined | bot_promotionsDefaultArgs> = $Result.GetResult<Prisma.$bot_promotionsPayload, S>

  type bot_promotionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<bot_promotionsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Bot_promotionsCountAggregateInputType | true
    }

  export interface bot_promotionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['bot_promotions'], meta: { name: 'bot_promotions' } }
    /**
     * Find zero or one Bot_promotions that matches the filter.
     * @param {bot_promotionsFindUniqueArgs} args - Arguments to find a Bot_promotions
     * @example
     * // Get one Bot_promotions
     * const bot_promotions = await prisma.bot_promotions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends bot_promotionsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, bot_promotionsFindUniqueArgs<ExtArgs>>
    ): Prisma__bot_promotionsClient<$Result.GetResult<Prisma.$bot_promotionsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Bot_promotions that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {bot_promotionsFindUniqueOrThrowArgs} args - Arguments to find a Bot_promotions
     * @example
     * // Get one Bot_promotions
     * const bot_promotions = await prisma.bot_promotions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends bot_promotionsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, bot_promotionsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__bot_promotionsClient<$Result.GetResult<Prisma.$bot_promotionsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Bot_promotions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bot_promotionsFindFirstArgs} args - Arguments to find a Bot_promotions
     * @example
     * // Get one Bot_promotions
     * const bot_promotions = await prisma.bot_promotions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends bot_promotionsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, bot_promotionsFindFirstArgs<ExtArgs>>
    ): Prisma__bot_promotionsClient<$Result.GetResult<Prisma.$bot_promotionsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Bot_promotions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bot_promotionsFindFirstOrThrowArgs} args - Arguments to find a Bot_promotions
     * @example
     * // Get one Bot_promotions
     * const bot_promotions = await prisma.bot_promotions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends bot_promotionsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, bot_promotionsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__bot_promotionsClient<$Result.GetResult<Prisma.$bot_promotionsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Bot_promotions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bot_promotionsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bot_promotions
     * const bot_promotions = await prisma.bot_promotions.findMany()
     * 
     * // Get first 10 Bot_promotions
     * const bot_promotions = await prisma.bot_promotions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bot_promotionsWithIdOnly = await prisma.bot_promotions.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends bot_promotionsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bot_promotionsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bot_promotionsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Bot_promotions.
     * @param {bot_promotionsCreateArgs} args - Arguments to create a Bot_promotions.
     * @example
     * // Create one Bot_promotions
     * const Bot_promotions = await prisma.bot_promotions.create({
     *   data: {
     *     // ... data to create a Bot_promotions
     *   }
     * })
     * 
    **/
    create<T extends bot_promotionsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, bot_promotionsCreateArgs<ExtArgs>>
    ): Prisma__bot_promotionsClient<$Result.GetResult<Prisma.$bot_promotionsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Bot_promotions.
     *     @param {bot_promotionsCreateManyArgs} args - Arguments to create many Bot_promotions.
     *     @example
     *     // Create many Bot_promotions
     *     const bot_promotions = await prisma.bot_promotions.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends bot_promotionsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bot_promotionsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Bot_promotions.
     * @param {bot_promotionsDeleteArgs} args - Arguments to delete one Bot_promotions.
     * @example
     * // Delete one Bot_promotions
     * const Bot_promotions = await prisma.bot_promotions.delete({
     *   where: {
     *     // ... filter to delete one Bot_promotions
     *   }
     * })
     * 
    **/
    delete<T extends bot_promotionsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, bot_promotionsDeleteArgs<ExtArgs>>
    ): Prisma__bot_promotionsClient<$Result.GetResult<Prisma.$bot_promotionsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Bot_promotions.
     * @param {bot_promotionsUpdateArgs} args - Arguments to update one Bot_promotions.
     * @example
     * // Update one Bot_promotions
     * const bot_promotions = await prisma.bot_promotions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends bot_promotionsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, bot_promotionsUpdateArgs<ExtArgs>>
    ): Prisma__bot_promotionsClient<$Result.GetResult<Prisma.$bot_promotionsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Bot_promotions.
     * @param {bot_promotionsDeleteManyArgs} args - Arguments to filter Bot_promotions to delete.
     * @example
     * // Delete a few Bot_promotions
     * const { count } = await prisma.bot_promotions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends bot_promotionsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bot_promotionsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bot_promotions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bot_promotionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bot_promotions
     * const bot_promotions = await prisma.bot_promotions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends bot_promotionsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, bot_promotionsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bot_promotions.
     * @param {bot_promotionsUpsertArgs} args - Arguments to update or create a Bot_promotions.
     * @example
     * // Update or create a Bot_promotions
     * const bot_promotions = await prisma.bot_promotions.upsert({
     *   create: {
     *     // ... data to create a Bot_promotions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bot_promotions we want to update
     *   }
     * })
    **/
    upsert<T extends bot_promotionsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, bot_promotionsUpsertArgs<ExtArgs>>
    ): Prisma__bot_promotionsClient<$Result.GetResult<Prisma.$bot_promotionsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Bot_promotions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bot_promotionsCountArgs} args - Arguments to filter Bot_promotions to count.
     * @example
     * // Count the number of Bot_promotions
     * const count = await prisma.bot_promotions.count({
     *   where: {
     *     // ... the filter for the Bot_promotions we want to count
     *   }
     * })
    **/
    count<T extends bot_promotionsCountArgs>(
      args?: Subset<T, bot_promotionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Bot_promotionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bot_promotions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Bot_promotionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Bot_promotionsAggregateArgs>(args: Subset<T, Bot_promotionsAggregateArgs>): Prisma.PrismaPromise<GetBot_promotionsAggregateType<T>>

    /**
     * Group by Bot_promotions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bot_promotionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends bot_promotionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: bot_promotionsGroupByArgs['orderBy'] }
        : { orderBy?: bot_promotionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, bot_promotionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBot_promotionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the bot_promotions model
   */
  readonly fields: bot_promotionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for bot_promotions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__bot_promotionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    bots<T extends bot_promotions$botsArgs<ExtArgs> = {}>(args?: Subset<T, bot_promotions$botsArgs<ExtArgs>>): Prisma__botsClient<$Result.GetResult<Prisma.$botsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the bot_promotions model
   */ 
  interface bot_promotionsFieldRefs {
    readonly id: FieldRef<"bot_promotions", 'String'>
    readonly bot_id: FieldRef<"bot_promotions", 'BigInt'>
    readonly title: FieldRef<"bot_promotions", 'String'>
    readonly info: FieldRef<"bot_promotions", 'String'>
    readonly css: FieldRef<"bot_promotions", 'String'>
    readonly type: FieldRef<"bot_promotions", 'Int'>
    readonly lynxtag: FieldRef<"bot_promotions", 'String'>
  }
    

  // Custom InputTypes

  /**
   * bot_promotions findUnique
   */
  export type bot_promotionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_promotions
     */
    select?: bot_promotionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bot_promotionsInclude<ExtArgs> | null
    /**
     * Filter, which bot_promotions to fetch.
     */
    where: bot_promotionsWhereUniqueInput
  }


  /**
   * bot_promotions findUniqueOrThrow
   */
  export type bot_promotionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_promotions
     */
    select?: bot_promotionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bot_promotionsInclude<ExtArgs> | null
    /**
     * Filter, which bot_promotions to fetch.
     */
    where: bot_promotionsWhereUniqueInput
  }


  /**
   * bot_promotions findFirst
   */
  export type bot_promotionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_promotions
     */
    select?: bot_promotionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bot_promotionsInclude<ExtArgs> | null
    /**
     * Filter, which bot_promotions to fetch.
     */
    where?: bot_promotionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bot_promotions to fetch.
     */
    orderBy?: bot_promotionsOrderByWithRelationInput | bot_promotionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bot_promotions.
     */
    cursor?: bot_promotionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bot_promotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bot_promotions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bot_promotions.
     */
    distinct?: Bot_promotionsScalarFieldEnum | Bot_promotionsScalarFieldEnum[]
  }


  /**
   * bot_promotions findFirstOrThrow
   */
  export type bot_promotionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_promotions
     */
    select?: bot_promotionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bot_promotionsInclude<ExtArgs> | null
    /**
     * Filter, which bot_promotions to fetch.
     */
    where?: bot_promotionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bot_promotions to fetch.
     */
    orderBy?: bot_promotionsOrderByWithRelationInput | bot_promotionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bot_promotions.
     */
    cursor?: bot_promotionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bot_promotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bot_promotions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bot_promotions.
     */
    distinct?: Bot_promotionsScalarFieldEnum | Bot_promotionsScalarFieldEnum[]
  }


  /**
   * bot_promotions findMany
   */
  export type bot_promotionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_promotions
     */
    select?: bot_promotionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bot_promotionsInclude<ExtArgs> | null
    /**
     * Filter, which bot_promotions to fetch.
     */
    where?: bot_promotionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bot_promotions to fetch.
     */
    orderBy?: bot_promotionsOrderByWithRelationInput | bot_promotionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing bot_promotions.
     */
    cursor?: bot_promotionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bot_promotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bot_promotions.
     */
    skip?: number
    distinct?: Bot_promotionsScalarFieldEnum | Bot_promotionsScalarFieldEnum[]
  }


  /**
   * bot_promotions create
   */
  export type bot_promotionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_promotions
     */
    select?: bot_promotionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bot_promotionsInclude<ExtArgs> | null
    /**
     * The data needed to create a bot_promotions.
     */
    data?: XOR<bot_promotionsCreateInput, bot_promotionsUncheckedCreateInput>
  }


  /**
   * bot_promotions createMany
   */
  export type bot_promotionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many bot_promotions.
     */
    data: bot_promotionsCreateManyInput | bot_promotionsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * bot_promotions update
   */
  export type bot_promotionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_promotions
     */
    select?: bot_promotionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bot_promotionsInclude<ExtArgs> | null
    /**
     * The data needed to update a bot_promotions.
     */
    data: XOR<bot_promotionsUpdateInput, bot_promotionsUncheckedUpdateInput>
    /**
     * Choose, which bot_promotions to update.
     */
    where: bot_promotionsWhereUniqueInput
  }


  /**
   * bot_promotions updateMany
   */
  export type bot_promotionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update bot_promotions.
     */
    data: XOR<bot_promotionsUpdateManyMutationInput, bot_promotionsUncheckedUpdateManyInput>
    /**
     * Filter which bot_promotions to update
     */
    where?: bot_promotionsWhereInput
  }


  /**
   * bot_promotions upsert
   */
  export type bot_promotionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_promotions
     */
    select?: bot_promotionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bot_promotionsInclude<ExtArgs> | null
    /**
     * The filter to search for the bot_promotions to update in case it exists.
     */
    where: bot_promotionsWhereUniqueInput
    /**
     * In case the bot_promotions found by the `where` argument doesn't exist, create a new bot_promotions with this data.
     */
    create: XOR<bot_promotionsCreateInput, bot_promotionsUncheckedCreateInput>
    /**
     * In case the bot_promotions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<bot_promotionsUpdateInput, bot_promotionsUncheckedUpdateInput>
  }


  /**
   * bot_promotions delete
   */
  export type bot_promotionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_promotions
     */
    select?: bot_promotionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bot_promotionsInclude<ExtArgs> | null
    /**
     * Filter which bot_promotions to delete.
     */
    where: bot_promotionsWhereUniqueInput
  }


  /**
   * bot_promotions deleteMany
   */
  export type bot_promotionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bot_promotions to delete
     */
    where?: bot_promotionsWhereInput
  }


  /**
   * bot_promotions.bots
   */
  export type bot_promotions$botsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bots
     */
    select?: botsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: botsInclude<ExtArgs> | null
    where?: botsWhereInput
  }


  /**
   * bot_promotions without action
   */
  export type bot_promotionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_promotions
     */
    select?: bot_promotionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bot_promotionsInclude<ExtArgs> | null
  }



  /**
   * Model bot_stats_votes_pm
   */

  export type AggregateBot_stats_votes_pm = {
    _count: Bot_stats_votes_pmCountAggregateOutputType | null
    _avg: Bot_stats_votes_pmAvgAggregateOutputType | null
    _sum: Bot_stats_votes_pmSumAggregateOutputType | null
    _min: Bot_stats_votes_pmMinAggregateOutputType | null
    _max: Bot_stats_votes_pmMaxAggregateOutputType | null
  }

  export type Bot_stats_votes_pmAvgAggregateOutputType = {
    bot_id: number | null
    votes: number | null
    epoch: number | null
  }

  export type Bot_stats_votes_pmSumAggregateOutputType = {
    bot_id: bigint | null
    votes: bigint | null
    epoch: bigint | null
  }

  export type Bot_stats_votes_pmMinAggregateOutputType = {
    bot_id: bigint | null
    votes: bigint | null
    epoch: bigint | null
    lynxtag: string | null
  }

  export type Bot_stats_votes_pmMaxAggregateOutputType = {
    bot_id: bigint | null
    votes: bigint | null
    epoch: bigint | null
    lynxtag: string | null
  }

  export type Bot_stats_votes_pmCountAggregateOutputType = {
    bot_id: number
    votes: number
    epoch: number
    lynxtag: number
    _all: number
  }


  export type Bot_stats_votes_pmAvgAggregateInputType = {
    bot_id?: true
    votes?: true
    epoch?: true
  }

  export type Bot_stats_votes_pmSumAggregateInputType = {
    bot_id?: true
    votes?: true
    epoch?: true
  }

  export type Bot_stats_votes_pmMinAggregateInputType = {
    bot_id?: true
    votes?: true
    epoch?: true
    lynxtag?: true
  }

  export type Bot_stats_votes_pmMaxAggregateInputType = {
    bot_id?: true
    votes?: true
    epoch?: true
    lynxtag?: true
  }

  export type Bot_stats_votes_pmCountAggregateInputType = {
    bot_id?: true
    votes?: true
    epoch?: true
    lynxtag?: true
    _all?: true
  }

  export type Bot_stats_votes_pmAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bot_stats_votes_pm to aggregate.
     */
    where?: bot_stats_votes_pmWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bot_stats_votes_pms to fetch.
     */
    orderBy?: bot_stats_votes_pmOrderByWithRelationInput | bot_stats_votes_pmOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: bot_stats_votes_pmWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bot_stats_votes_pms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bot_stats_votes_pms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned bot_stats_votes_pms
    **/
    _count?: true | Bot_stats_votes_pmCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Bot_stats_votes_pmAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Bot_stats_votes_pmSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Bot_stats_votes_pmMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Bot_stats_votes_pmMaxAggregateInputType
  }

  export type GetBot_stats_votes_pmAggregateType<T extends Bot_stats_votes_pmAggregateArgs> = {
        [P in keyof T & keyof AggregateBot_stats_votes_pm]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBot_stats_votes_pm[P]>
      : GetScalarType<T[P], AggregateBot_stats_votes_pm[P]>
  }




  export type bot_stats_votes_pmGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bot_stats_votes_pmWhereInput
    orderBy?: bot_stats_votes_pmOrderByWithAggregationInput | bot_stats_votes_pmOrderByWithAggregationInput[]
    by: Bot_stats_votes_pmScalarFieldEnum[] | Bot_stats_votes_pmScalarFieldEnum
    having?: bot_stats_votes_pmScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Bot_stats_votes_pmCountAggregateInputType | true
    _avg?: Bot_stats_votes_pmAvgAggregateInputType
    _sum?: Bot_stats_votes_pmSumAggregateInputType
    _min?: Bot_stats_votes_pmMinAggregateInputType
    _max?: Bot_stats_votes_pmMaxAggregateInputType
  }

  export type Bot_stats_votes_pmGroupByOutputType = {
    bot_id: bigint | null
    votes: bigint | null
    epoch: bigint | null
    lynxtag: string
    _count: Bot_stats_votes_pmCountAggregateOutputType | null
    _avg: Bot_stats_votes_pmAvgAggregateOutputType | null
    _sum: Bot_stats_votes_pmSumAggregateOutputType | null
    _min: Bot_stats_votes_pmMinAggregateOutputType | null
    _max: Bot_stats_votes_pmMaxAggregateOutputType | null
  }

  type GetBot_stats_votes_pmGroupByPayload<T extends bot_stats_votes_pmGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Bot_stats_votes_pmGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Bot_stats_votes_pmGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Bot_stats_votes_pmGroupByOutputType[P]>
            : GetScalarType<T[P], Bot_stats_votes_pmGroupByOutputType[P]>
        }
      >
    >


  export type bot_stats_votes_pmSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    bot_id?: boolean
    votes?: boolean
    epoch?: boolean
    lynxtag?: boolean
  }, ExtArgs["result"]["bot_stats_votes_pm"]>

  export type bot_stats_votes_pmSelectScalar = {
    bot_id?: boolean
    votes?: boolean
    epoch?: boolean
    lynxtag?: boolean
  }


  export type $bot_stats_votes_pmPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "bot_stats_votes_pm"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      bot_id: bigint | null
      votes: bigint | null
      epoch: bigint | null
      lynxtag: string
    }, ExtArgs["result"]["bot_stats_votes_pm"]>
    composites: {}
  }


  type bot_stats_votes_pmGetPayload<S extends boolean | null | undefined | bot_stats_votes_pmDefaultArgs> = $Result.GetResult<Prisma.$bot_stats_votes_pmPayload, S>

  type bot_stats_votes_pmCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<bot_stats_votes_pmFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Bot_stats_votes_pmCountAggregateInputType | true
    }

  export interface bot_stats_votes_pmDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['bot_stats_votes_pm'], meta: { name: 'bot_stats_votes_pm' } }
    /**
     * Find zero or one Bot_stats_votes_pm that matches the filter.
     * @param {bot_stats_votes_pmFindUniqueArgs} args - Arguments to find a Bot_stats_votes_pm
     * @example
     * // Get one Bot_stats_votes_pm
     * const bot_stats_votes_pm = await prisma.bot_stats_votes_pm.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends bot_stats_votes_pmFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, bot_stats_votes_pmFindUniqueArgs<ExtArgs>>
    ): Prisma__bot_stats_votes_pmClient<$Result.GetResult<Prisma.$bot_stats_votes_pmPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Bot_stats_votes_pm that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {bot_stats_votes_pmFindUniqueOrThrowArgs} args - Arguments to find a Bot_stats_votes_pm
     * @example
     * // Get one Bot_stats_votes_pm
     * const bot_stats_votes_pm = await prisma.bot_stats_votes_pm.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends bot_stats_votes_pmFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, bot_stats_votes_pmFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__bot_stats_votes_pmClient<$Result.GetResult<Prisma.$bot_stats_votes_pmPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Bot_stats_votes_pm that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bot_stats_votes_pmFindFirstArgs} args - Arguments to find a Bot_stats_votes_pm
     * @example
     * // Get one Bot_stats_votes_pm
     * const bot_stats_votes_pm = await prisma.bot_stats_votes_pm.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends bot_stats_votes_pmFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, bot_stats_votes_pmFindFirstArgs<ExtArgs>>
    ): Prisma__bot_stats_votes_pmClient<$Result.GetResult<Prisma.$bot_stats_votes_pmPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Bot_stats_votes_pm that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bot_stats_votes_pmFindFirstOrThrowArgs} args - Arguments to find a Bot_stats_votes_pm
     * @example
     * // Get one Bot_stats_votes_pm
     * const bot_stats_votes_pm = await prisma.bot_stats_votes_pm.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends bot_stats_votes_pmFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, bot_stats_votes_pmFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__bot_stats_votes_pmClient<$Result.GetResult<Prisma.$bot_stats_votes_pmPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Bot_stats_votes_pms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bot_stats_votes_pmFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bot_stats_votes_pms
     * const bot_stats_votes_pms = await prisma.bot_stats_votes_pm.findMany()
     * 
     * // Get first 10 Bot_stats_votes_pms
     * const bot_stats_votes_pms = await prisma.bot_stats_votes_pm.findMany({ take: 10 })
     * 
     * // Only select the `bot_id`
     * const bot_stats_votes_pmWithBot_idOnly = await prisma.bot_stats_votes_pm.findMany({ select: { bot_id: true } })
     * 
    **/
    findMany<T extends bot_stats_votes_pmFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bot_stats_votes_pmFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bot_stats_votes_pmPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Bot_stats_votes_pm.
     * @param {bot_stats_votes_pmCreateArgs} args - Arguments to create a Bot_stats_votes_pm.
     * @example
     * // Create one Bot_stats_votes_pm
     * const Bot_stats_votes_pm = await prisma.bot_stats_votes_pm.create({
     *   data: {
     *     // ... data to create a Bot_stats_votes_pm
     *   }
     * })
     * 
    **/
    create<T extends bot_stats_votes_pmCreateArgs<ExtArgs>>(
      args: SelectSubset<T, bot_stats_votes_pmCreateArgs<ExtArgs>>
    ): Prisma__bot_stats_votes_pmClient<$Result.GetResult<Prisma.$bot_stats_votes_pmPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Bot_stats_votes_pms.
     *     @param {bot_stats_votes_pmCreateManyArgs} args - Arguments to create many Bot_stats_votes_pms.
     *     @example
     *     // Create many Bot_stats_votes_pms
     *     const bot_stats_votes_pm = await prisma.bot_stats_votes_pm.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends bot_stats_votes_pmCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bot_stats_votes_pmCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Bot_stats_votes_pm.
     * @param {bot_stats_votes_pmDeleteArgs} args - Arguments to delete one Bot_stats_votes_pm.
     * @example
     * // Delete one Bot_stats_votes_pm
     * const Bot_stats_votes_pm = await prisma.bot_stats_votes_pm.delete({
     *   where: {
     *     // ... filter to delete one Bot_stats_votes_pm
     *   }
     * })
     * 
    **/
    delete<T extends bot_stats_votes_pmDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, bot_stats_votes_pmDeleteArgs<ExtArgs>>
    ): Prisma__bot_stats_votes_pmClient<$Result.GetResult<Prisma.$bot_stats_votes_pmPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Bot_stats_votes_pm.
     * @param {bot_stats_votes_pmUpdateArgs} args - Arguments to update one Bot_stats_votes_pm.
     * @example
     * // Update one Bot_stats_votes_pm
     * const bot_stats_votes_pm = await prisma.bot_stats_votes_pm.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends bot_stats_votes_pmUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, bot_stats_votes_pmUpdateArgs<ExtArgs>>
    ): Prisma__bot_stats_votes_pmClient<$Result.GetResult<Prisma.$bot_stats_votes_pmPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Bot_stats_votes_pms.
     * @param {bot_stats_votes_pmDeleteManyArgs} args - Arguments to filter Bot_stats_votes_pms to delete.
     * @example
     * // Delete a few Bot_stats_votes_pms
     * const { count } = await prisma.bot_stats_votes_pm.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends bot_stats_votes_pmDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bot_stats_votes_pmDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bot_stats_votes_pms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bot_stats_votes_pmUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bot_stats_votes_pms
     * const bot_stats_votes_pm = await prisma.bot_stats_votes_pm.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends bot_stats_votes_pmUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, bot_stats_votes_pmUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bot_stats_votes_pm.
     * @param {bot_stats_votes_pmUpsertArgs} args - Arguments to update or create a Bot_stats_votes_pm.
     * @example
     * // Update or create a Bot_stats_votes_pm
     * const bot_stats_votes_pm = await prisma.bot_stats_votes_pm.upsert({
     *   create: {
     *     // ... data to create a Bot_stats_votes_pm
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bot_stats_votes_pm we want to update
     *   }
     * })
    **/
    upsert<T extends bot_stats_votes_pmUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, bot_stats_votes_pmUpsertArgs<ExtArgs>>
    ): Prisma__bot_stats_votes_pmClient<$Result.GetResult<Prisma.$bot_stats_votes_pmPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Bot_stats_votes_pms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bot_stats_votes_pmCountArgs} args - Arguments to filter Bot_stats_votes_pms to count.
     * @example
     * // Count the number of Bot_stats_votes_pms
     * const count = await prisma.bot_stats_votes_pm.count({
     *   where: {
     *     // ... the filter for the Bot_stats_votes_pms we want to count
     *   }
     * })
    **/
    count<T extends bot_stats_votes_pmCountArgs>(
      args?: Subset<T, bot_stats_votes_pmCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Bot_stats_votes_pmCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bot_stats_votes_pm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Bot_stats_votes_pmAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Bot_stats_votes_pmAggregateArgs>(args: Subset<T, Bot_stats_votes_pmAggregateArgs>): Prisma.PrismaPromise<GetBot_stats_votes_pmAggregateType<T>>

    /**
     * Group by Bot_stats_votes_pm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bot_stats_votes_pmGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends bot_stats_votes_pmGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: bot_stats_votes_pmGroupByArgs['orderBy'] }
        : { orderBy?: bot_stats_votes_pmGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, bot_stats_votes_pmGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBot_stats_votes_pmGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the bot_stats_votes_pm model
   */
  readonly fields: bot_stats_votes_pmFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for bot_stats_votes_pm.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__bot_stats_votes_pmClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the bot_stats_votes_pm model
   */ 
  interface bot_stats_votes_pmFieldRefs {
    readonly bot_id: FieldRef<"bot_stats_votes_pm", 'BigInt'>
    readonly votes: FieldRef<"bot_stats_votes_pm", 'BigInt'>
    readonly epoch: FieldRef<"bot_stats_votes_pm", 'BigInt'>
    readonly lynxtag: FieldRef<"bot_stats_votes_pm", 'String'>
  }
    

  // Custom InputTypes

  /**
   * bot_stats_votes_pm findUnique
   */
  export type bot_stats_votes_pmFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_stats_votes_pm
     */
    select?: bot_stats_votes_pmSelect<ExtArgs> | null
    /**
     * Filter, which bot_stats_votes_pm to fetch.
     */
    where: bot_stats_votes_pmWhereUniqueInput
  }


  /**
   * bot_stats_votes_pm findUniqueOrThrow
   */
  export type bot_stats_votes_pmFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_stats_votes_pm
     */
    select?: bot_stats_votes_pmSelect<ExtArgs> | null
    /**
     * Filter, which bot_stats_votes_pm to fetch.
     */
    where: bot_stats_votes_pmWhereUniqueInput
  }


  /**
   * bot_stats_votes_pm findFirst
   */
  export type bot_stats_votes_pmFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_stats_votes_pm
     */
    select?: bot_stats_votes_pmSelect<ExtArgs> | null
    /**
     * Filter, which bot_stats_votes_pm to fetch.
     */
    where?: bot_stats_votes_pmWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bot_stats_votes_pms to fetch.
     */
    orderBy?: bot_stats_votes_pmOrderByWithRelationInput | bot_stats_votes_pmOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bot_stats_votes_pms.
     */
    cursor?: bot_stats_votes_pmWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bot_stats_votes_pms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bot_stats_votes_pms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bot_stats_votes_pms.
     */
    distinct?: Bot_stats_votes_pmScalarFieldEnum | Bot_stats_votes_pmScalarFieldEnum[]
  }


  /**
   * bot_stats_votes_pm findFirstOrThrow
   */
  export type bot_stats_votes_pmFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_stats_votes_pm
     */
    select?: bot_stats_votes_pmSelect<ExtArgs> | null
    /**
     * Filter, which bot_stats_votes_pm to fetch.
     */
    where?: bot_stats_votes_pmWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bot_stats_votes_pms to fetch.
     */
    orderBy?: bot_stats_votes_pmOrderByWithRelationInput | bot_stats_votes_pmOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bot_stats_votes_pms.
     */
    cursor?: bot_stats_votes_pmWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bot_stats_votes_pms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bot_stats_votes_pms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bot_stats_votes_pms.
     */
    distinct?: Bot_stats_votes_pmScalarFieldEnum | Bot_stats_votes_pmScalarFieldEnum[]
  }


  /**
   * bot_stats_votes_pm findMany
   */
  export type bot_stats_votes_pmFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_stats_votes_pm
     */
    select?: bot_stats_votes_pmSelect<ExtArgs> | null
    /**
     * Filter, which bot_stats_votes_pms to fetch.
     */
    where?: bot_stats_votes_pmWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bot_stats_votes_pms to fetch.
     */
    orderBy?: bot_stats_votes_pmOrderByWithRelationInput | bot_stats_votes_pmOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing bot_stats_votes_pms.
     */
    cursor?: bot_stats_votes_pmWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bot_stats_votes_pms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bot_stats_votes_pms.
     */
    skip?: number
    distinct?: Bot_stats_votes_pmScalarFieldEnum | Bot_stats_votes_pmScalarFieldEnum[]
  }


  /**
   * bot_stats_votes_pm create
   */
  export type bot_stats_votes_pmCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_stats_votes_pm
     */
    select?: bot_stats_votes_pmSelect<ExtArgs> | null
    /**
     * The data needed to create a bot_stats_votes_pm.
     */
    data?: XOR<bot_stats_votes_pmCreateInput, bot_stats_votes_pmUncheckedCreateInput>
  }


  /**
   * bot_stats_votes_pm createMany
   */
  export type bot_stats_votes_pmCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many bot_stats_votes_pms.
     */
    data: bot_stats_votes_pmCreateManyInput | bot_stats_votes_pmCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * bot_stats_votes_pm update
   */
  export type bot_stats_votes_pmUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_stats_votes_pm
     */
    select?: bot_stats_votes_pmSelect<ExtArgs> | null
    /**
     * The data needed to update a bot_stats_votes_pm.
     */
    data: XOR<bot_stats_votes_pmUpdateInput, bot_stats_votes_pmUncheckedUpdateInput>
    /**
     * Choose, which bot_stats_votes_pm to update.
     */
    where: bot_stats_votes_pmWhereUniqueInput
  }


  /**
   * bot_stats_votes_pm updateMany
   */
  export type bot_stats_votes_pmUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update bot_stats_votes_pms.
     */
    data: XOR<bot_stats_votes_pmUpdateManyMutationInput, bot_stats_votes_pmUncheckedUpdateManyInput>
    /**
     * Filter which bot_stats_votes_pms to update
     */
    where?: bot_stats_votes_pmWhereInput
  }


  /**
   * bot_stats_votes_pm upsert
   */
  export type bot_stats_votes_pmUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_stats_votes_pm
     */
    select?: bot_stats_votes_pmSelect<ExtArgs> | null
    /**
     * The filter to search for the bot_stats_votes_pm to update in case it exists.
     */
    where: bot_stats_votes_pmWhereUniqueInput
    /**
     * In case the bot_stats_votes_pm found by the `where` argument doesn't exist, create a new bot_stats_votes_pm with this data.
     */
    create: XOR<bot_stats_votes_pmCreateInput, bot_stats_votes_pmUncheckedCreateInput>
    /**
     * In case the bot_stats_votes_pm was found with the provided `where` argument, update it with this data.
     */
    update: XOR<bot_stats_votes_pmUpdateInput, bot_stats_votes_pmUncheckedUpdateInput>
  }


  /**
   * bot_stats_votes_pm delete
   */
  export type bot_stats_votes_pmDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_stats_votes_pm
     */
    select?: bot_stats_votes_pmSelect<ExtArgs> | null
    /**
     * Filter which bot_stats_votes_pm to delete.
     */
    where: bot_stats_votes_pmWhereUniqueInput
  }


  /**
   * bot_stats_votes_pm deleteMany
   */
  export type bot_stats_votes_pmDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bot_stats_votes_pms to delete
     */
    where?: bot_stats_votes_pmWhereInput
  }


  /**
   * bot_stats_votes_pm without action
   */
  export type bot_stats_votes_pmDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_stats_votes_pm
     */
    select?: bot_stats_votes_pmSelect<ExtArgs> | null
  }



  /**
   * Model bot_tags
   */

  export type AggregateBot_tags = {
    _count: Bot_tagsCountAggregateOutputType | null
    _avg: Bot_tagsAvgAggregateOutputType | null
    _sum: Bot_tagsSumAggregateOutputType | null
    _min: Bot_tagsMinAggregateOutputType | null
    _max: Bot_tagsMaxAggregateOutputType | null
  }

  export type Bot_tagsAvgAggregateOutputType = {
    bot_id: number | null
    id: number | null
  }

  export type Bot_tagsSumAggregateOutputType = {
    bot_id: bigint | null
    id: number | null
  }

  export type Bot_tagsMinAggregateOutputType = {
    bot_id: bigint | null
    tag: string | null
    id: number | null
    lynxtag: string | null
  }

  export type Bot_tagsMaxAggregateOutputType = {
    bot_id: bigint | null
    tag: string | null
    id: number | null
    lynxtag: string | null
  }

  export type Bot_tagsCountAggregateOutputType = {
    bot_id: number
    tag: number
    id: number
    lynxtag: number
    _all: number
  }


  export type Bot_tagsAvgAggregateInputType = {
    bot_id?: true
    id?: true
  }

  export type Bot_tagsSumAggregateInputType = {
    bot_id?: true
    id?: true
  }

  export type Bot_tagsMinAggregateInputType = {
    bot_id?: true
    tag?: true
    id?: true
    lynxtag?: true
  }

  export type Bot_tagsMaxAggregateInputType = {
    bot_id?: true
    tag?: true
    id?: true
    lynxtag?: true
  }

  export type Bot_tagsCountAggregateInputType = {
    bot_id?: true
    tag?: true
    id?: true
    lynxtag?: true
    _all?: true
  }

  export type Bot_tagsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bot_tags to aggregate.
     */
    where?: bot_tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bot_tags to fetch.
     */
    orderBy?: bot_tagsOrderByWithRelationInput | bot_tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: bot_tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bot_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bot_tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned bot_tags
    **/
    _count?: true | Bot_tagsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Bot_tagsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Bot_tagsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Bot_tagsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Bot_tagsMaxAggregateInputType
  }

  export type GetBot_tagsAggregateType<T extends Bot_tagsAggregateArgs> = {
        [P in keyof T & keyof AggregateBot_tags]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBot_tags[P]>
      : GetScalarType<T[P], AggregateBot_tags[P]>
  }




  export type bot_tagsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bot_tagsWhereInput
    orderBy?: bot_tagsOrderByWithAggregationInput | bot_tagsOrderByWithAggregationInput[]
    by: Bot_tagsScalarFieldEnum[] | Bot_tagsScalarFieldEnum
    having?: bot_tagsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Bot_tagsCountAggregateInputType | true
    _avg?: Bot_tagsAvgAggregateInputType
    _sum?: Bot_tagsSumAggregateInputType
    _min?: Bot_tagsMinAggregateInputType
    _max?: Bot_tagsMaxAggregateInputType
  }

  export type Bot_tagsGroupByOutputType = {
    bot_id: bigint
    tag: string
    id: number
    lynxtag: string
    _count: Bot_tagsCountAggregateOutputType | null
    _avg: Bot_tagsAvgAggregateOutputType | null
    _sum: Bot_tagsSumAggregateOutputType | null
    _min: Bot_tagsMinAggregateOutputType | null
    _max: Bot_tagsMaxAggregateOutputType | null
  }

  type GetBot_tagsGroupByPayload<T extends bot_tagsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Bot_tagsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Bot_tagsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Bot_tagsGroupByOutputType[P]>
            : GetScalarType<T[P], Bot_tagsGroupByOutputType[P]>
        }
      >
    >


  export type bot_tagsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    bot_id?: boolean
    tag?: boolean
    id?: boolean
    lynxtag?: boolean
    bots?: boolean | botsDefaultArgs<ExtArgs>
    bot_list_tags?: boolean | bot_list_tagsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bot_tags"]>

  export type bot_tagsSelectScalar = {
    bot_id?: boolean
    tag?: boolean
    id?: boolean
    lynxtag?: boolean
  }

  export type bot_tagsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bots?: boolean | botsDefaultArgs<ExtArgs>
    bot_list_tags?: boolean | bot_list_tagsDefaultArgs<ExtArgs>
  }


  export type $bot_tagsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "bot_tags"
    objects: {
      bots: Prisma.$botsPayload<ExtArgs>
      bot_list_tags: Prisma.$bot_list_tagsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      bot_id: bigint
      tag: string
      id: number
      lynxtag: string
    }, ExtArgs["result"]["bot_tags"]>
    composites: {}
  }


  type bot_tagsGetPayload<S extends boolean | null | undefined | bot_tagsDefaultArgs> = $Result.GetResult<Prisma.$bot_tagsPayload, S>

  type bot_tagsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<bot_tagsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Bot_tagsCountAggregateInputType | true
    }

  export interface bot_tagsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['bot_tags'], meta: { name: 'bot_tags' } }
    /**
     * Find zero or one Bot_tags that matches the filter.
     * @param {bot_tagsFindUniqueArgs} args - Arguments to find a Bot_tags
     * @example
     * // Get one Bot_tags
     * const bot_tags = await prisma.bot_tags.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends bot_tagsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, bot_tagsFindUniqueArgs<ExtArgs>>
    ): Prisma__bot_tagsClient<$Result.GetResult<Prisma.$bot_tagsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Bot_tags that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {bot_tagsFindUniqueOrThrowArgs} args - Arguments to find a Bot_tags
     * @example
     * // Get one Bot_tags
     * const bot_tags = await prisma.bot_tags.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends bot_tagsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, bot_tagsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__bot_tagsClient<$Result.GetResult<Prisma.$bot_tagsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Bot_tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bot_tagsFindFirstArgs} args - Arguments to find a Bot_tags
     * @example
     * // Get one Bot_tags
     * const bot_tags = await prisma.bot_tags.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends bot_tagsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, bot_tagsFindFirstArgs<ExtArgs>>
    ): Prisma__bot_tagsClient<$Result.GetResult<Prisma.$bot_tagsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Bot_tags that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bot_tagsFindFirstOrThrowArgs} args - Arguments to find a Bot_tags
     * @example
     * // Get one Bot_tags
     * const bot_tags = await prisma.bot_tags.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends bot_tagsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, bot_tagsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__bot_tagsClient<$Result.GetResult<Prisma.$bot_tagsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Bot_tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bot_tagsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bot_tags
     * const bot_tags = await prisma.bot_tags.findMany()
     * 
     * // Get first 10 Bot_tags
     * const bot_tags = await prisma.bot_tags.findMany({ take: 10 })
     * 
     * // Only select the `bot_id`
     * const bot_tagsWithBot_idOnly = await prisma.bot_tags.findMany({ select: { bot_id: true } })
     * 
    **/
    findMany<T extends bot_tagsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bot_tagsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bot_tagsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Bot_tags.
     * @param {bot_tagsCreateArgs} args - Arguments to create a Bot_tags.
     * @example
     * // Create one Bot_tags
     * const Bot_tags = await prisma.bot_tags.create({
     *   data: {
     *     // ... data to create a Bot_tags
     *   }
     * })
     * 
    **/
    create<T extends bot_tagsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, bot_tagsCreateArgs<ExtArgs>>
    ): Prisma__bot_tagsClient<$Result.GetResult<Prisma.$bot_tagsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Bot_tags.
     *     @param {bot_tagsCreateManyArgs} args - Arguments to create many Bot_tags.
     *     @example
     *     // Create many Bot_tags
     *     const bot_tags = await prisma.bot_tags.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends bot_tagsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bot_tagsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Bot_tags.
     * @param {bot_tagsDeleteArgs} args - Arguments to delete one Bot_tags.
     * @example
     * // Delete one Bot_tags
     * const Bot_tags = await prisma.bot_tags.delete({
     *   where: {
     *     // ... filter to delete one Bot_tags
     *   }
     * })
     * 
    **/
    delete<T extends bot_tagsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, bot_tagsDeleteArgs<ExtArgs>>
    ): Prisma__bot_tagsClient<$Result.GetResult<Prisma.$bot_tagsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Bot_tags.
     * @param {bot_tagsUpdateArgs} args - Arguments to update one Bot_tags.
     * @example
     * // Update one Bot_tags
     * const bot_tags = await prisma.bot_tags.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends bot_tagsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, bot_tagsUpdateArgs<ExtArgs>>
    ): Prisma__bot_tagsClient<$Result.GetResult<Prisma.$bot_tagsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Bot_tags.
     * @param {bot_tagsDeleteManyArgs} args - Arguments to filter Bot_tags to delete.
     * @example
     * // Delete a few Bot_tags
     * const { count } = await prisma.bot_tags.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends bot_tagsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bot_tagsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bot_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bot_tagsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bot_tags
     * const bot_tags = await prisma.bot_tags.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends bot_tagsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, bot_tagsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bot_tags.
     * @param {bot_tagsUpsertArgs} args - Arguments to update or create a Bot_tags.
     * @example
     * // Update or create a Bot_tags
     * const bot_tags = await prisma.bot_tags.upsert({
     *   create: {
     *     // ... data to create a Bot_tags
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bot_tags we want to update
     *   }
     * })
    **/
    upsert<T extends bot_tagsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, bot_tagsUpsertArgs<ExtArgs>>
    ): Prisma__bot_tagsClient<$Result.GetResult<Prisma.$bot_tagsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Bot_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bot_tagsCountArgs} args - Arguments to filter Bot_tags to count.
     * @example
     * // Count the number of Bot_tags
     * const count = await prisma.bot_tags.count({
     *   where: {
     *     // ... the filter for the Bot_tags we want to count
     *   }
     * })
    **/
    count<T extends bot_tagsCountArgs>(
      args?: Subset<T, bot_tagsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Bot_tagsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bot_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Bot_tagsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Bot_tagsAggregateArgs>(args: Subset<T, Bot_tagsAggregateArgs>): Prisma.PrismaPromise<GetBot_tagsAggregateType<T>>

    /**
     * Group by Bot_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bot_tagsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends bot_tagsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: bot_tagsGroupByArgs['orderBy'] }
        : { orderBy?: bot_tagsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, bot_tagsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBot_tagsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the bot_tags model
   */
  readonly fields: bot_tagsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for bot_tags.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__bot_tagsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    bots<T extends botsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, botsDefaultArgs<ExtArgs>>): Prisma__botsClient<$Result.GetResult<Prisma.$botsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    bot_list_tags<T extends bot_list_tagsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, bot_list_tagsDefaultArgs<ExtArgs>>): Prisma__bot_list_tagsClient<$Result.GetResult<Prisma.$bot_list_tagsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the bot_tags model
   */ 
  interface bot_tagsFieldRefs {
    readonly bot_id: FieldRef<"bot_tags", 'BigInt'>
    readonly tag: FieldRef<"bot_tags", 'String'>
    readonly id: FieldRef<"bot_tags", 'Int'>
    readonly lynxtag: FieldRef<"bot_tags", 'String'>
  }
    

  // Custom InputTypes

  /**
   * bot_tags findUnique
   */
  export type bot_tagsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_tags
     */
    select?: bot_tagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bot_tagsInclude<ExtArgs> | null
    /**
     * Filter, which bot_tags to fetch.
     */
    where: bot_tagsWhereUniqueInput
  }


  /**
   * bot_tags findUniqueOrThrow
   */
  export type bot_tagsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_tags
     */
    select?: bot_tagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bot_tagsInclude<ExtArgs> | null
    /**
     * Filter, which bot_tags to fetch.
     */
    where: bot_tagsWhereUniqueInput
  }


  /**
   * bot_tags findFirst
   */
  export type bot_tagsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_tags
     */
    select?: bot_tagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bot_tagsInclude<ExtArgs> | null
    /**
     * Filter, which bot_tags to fetch.
     */
    where?: bot_tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bot_tags to fetch.
     */
    orderBy?: bot_tagsOrderByWithRelationInput | bot_tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bot_tags.
     */
    cursor?: bot_tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bot_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bot_tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bot_tags.
     */
    distinct?: Bot_tagsScalarFieldEnum | Bot_tagsScalarFieldEnum[]
  }


  /**
   * bot_tags findFirstOrThrow
   */
  export type bot_tagsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_tags
     */
    select?: bot_tagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bot_tagsInclude<ExtArgs> | null
    /**
     * Filter, which bot_tags to fetch.
     */
    where?: bot_tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bot_tags to fetch.
     */
    orderBy?: bot_tagsOrderByWithRelationInput | bot_tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bot_tags.
     */
    cursor?: bot_tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bot_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bot_tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bot_tags.
     */
    distinct?: Bot_tagsScalarFieldEnum | Bot_tagsScalarFieldEnum[]
  }


  /**
   * bot_tags findMany
   */
  export type bot_tagsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_tags
     */
    select?: bot_tagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bot_tagsInclude<ExtArgs> | null
    /**
     * Filter, which bot_tags to fetch.
     */
    where?: bot_tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bot_tags to fetch.
     */
    orderBy?: bot_tagsOrderByWithRelationInput | bot_tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing bot_tags.
     */
    cursor?: bot_tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bot_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bot_tags.
     */
    skip?: number
    distinct?: Bot_tagsScalarFieldEnum | Bot_tagsScalarFieldEnum[]
  }


  /**
   * bot_tags create
   */
  export type bot_tagsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_tags
     */
    select?: bot_tagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bot_tagsInclude<ExtArgs> | null
    /**
     * The data needed to create a bot_tags.
     */
    data: XOR<bot_tagsCreateInput, bot_tagsUncheckedCreateInput>
  }


  /**
   * bot_tags createMany
   */
  export type bot_tagsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many bot_tags.
     */
    data: bot_tagsCreateManyInput | bot_tagsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * bot_tags update
   */
  export type bot_tagsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_tags
     */
    select?: bot_tagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bot_tagsInclude<ExtArgs> | null
    /**
     * The data needed to update a bot_tags.
     */
    data: XOR<bot_tagsUpdateInput, bot_tagsUncheckedUpdateInput>
    /**
     * Choose, which bot_tags to update.
     */
    where: bot_tagsWhereUniqueInput
  }


  /**
   * bot_tags updateMany
   */
  export type bot_tagsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update bot_tags.
     */
    data: XOR<bot_tagsUpdateManyMutationInput, bot_tagsUncheckedUpdateManyInput>
    /**
     * Filter which bot_tags to update
     */
    where?: bot_tagsWhereInput
  }


  /**
   * bot_tags upsert
   */
  export type bot_tagsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_tags
     */
    select?: bot_tagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bot_tagsInclude<ExtArgs> | null
    /**
     * The filter to search for the bot_tags to update in case it exists.
     */
    where: bot_tagsWhereUniqueInput
    /**
     * In case the bot_tags found by the `where` argument doesn't exist, create a new bot_tags with this data.
     */
    create: XOR<bot_tagsCreateInput, bot_tagsUncheckedCreateInput>
    /**
     * In case the bot_tags was found with the provided `where` argument, update it with this data.
     */
    update: XOR<bot_tagsUpdateInput, bot_tagsUncheckedUpdateInput>
  }


  /**
   * bot_tags delete
   */
  export type bot_tagsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_tags
     */
    select?: bot_tagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bot_tagsInclude<ExtArgs> | null
    /**
     * Filter which bot_tags to delete.
     */
    where: bot_tagsWhereUniqueInput
  }


  /**
   * bot_tags deleteMany
   */
  export type bot_tagsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bot_tags to delete
     */
    where?: bot_tagsWhereInput
  }


  /**
   * bot_tags without action
   */
  export type bot_tagsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_tags
     */
    select?: bot_tagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bot_tagsInclude<ExtArgs> | null
  }



  /**
   * Model bot_voters
   */

  export type AggregateBot_voters = {
    _count: Bot_votersCountAggregateOutputType | null
    _avg: Bot_votersAvgAggregateOutputType | null
    _sum: Bot_votersSumAggregateOutputType | null
    _min: Bot_votersMinAggregateOutputType | null
    _max: Bot_votersMaxAggregateOutputType | null
  }

  export type Bot_votersAvgAggregateOutputType = {
    bot_id: number | null
    user_id: number | null
  }

  export type Bot_votersSumAggregateOutputType = {
    bot_id: bigint | null
    user_id: bigint | null
  }

  export type Bot_votersMinAggregateOutputType = {
    bot_id: bigint | null
    user_id: bigint | null
    lynxtag: string | null
  }

  export type Bot_votersMaxAggregateOutputType = {
    bot_id: bigint | null
    user_id: bigint | null
    lynxtag: string | null
  }

  export type Bot_votersCountAggregateOutputType = {
    bot_id: number
    user_id: number
    timestamps: number
    lynxtag: number
    _all: number
  }


  export type Bot_votersAvgAggregateInputType = {
    bot_id?: true
    user_id?: true
  }

  export type Bot_votersSumAggregateInputType = {
    bot_id?: true
    user_id?: true
  }

  export type Bot_votersMinAggregateInputType = {
    bot_id?: true
    user_id?: true
    lynxtag?: true
  }

  export type Bot_votersMaxAggregateInputType = {
    bot_id?: true
    user_id?: true
    lynxtag?: true
  }

  export type Bot_votersCountAggregateInputType = {
    bot_id?: true
    user_id?: true
    timestamps?: true
    lynxtag?: true
    _all?: true
  }

  export type Bot_votersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bot_voters to aggregate.
     */
    where?: bot_votersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bot_voters to fetch.
     */
    orderBy?: bot_votersOrderByWithRelationInput | bot_votersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: bot_votersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bot_voters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bot_voters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned bot_voters
    **/
    _count?: true | Bot_votersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Bot_votersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Bot_votersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Bot_votersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Bot_votersMaxAggregateInputType
  }

  export type GetBot_votersAggregateType<T extends Bot_votersAggregateArgs> = {
        [P in keyof T & keyof AggregateBot_voters]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBot_voters[P]>
      : GetScalarType<T[P], AggregateBot_voters[P]>
  }




  export type bot_votersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bot_votersWhereInput
    orderBy?: bot_votersOrderByWithAggregationInput | bot_votersOrderByWithAggregationInput[]
    by: Bot_votersScalarFieldEnum[] | Bot_votersScalarFieldEnum
    having?: bot_votersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Bot_votersCountAggregateInputType | true
    _avg?: Bot_votersAvgAggregateInputType
    _sum?: Bot_votersSumAggregateInputType
    _min?: Bot_votersMinAggregateInputType
    _max?: Bot_votersMaxAggregateInputType
  }

  export type Bot_votersGroupByOutputType = {
    bot_id: bigint
    user_id: bigint
    timestamps: Date[]
    lynxtag: string
    _count: Bot_votersCountAggregateOutputType | null
    _avg: Bot_votersAvgAggregateOutputType | null
    _sum: Bot_votersSumAggregateOutputType | null
    _min: Bot_votersMinAggregateOutputType | null
    _max: Bot_votersMaxAggregateOutputType | null
  }

  type GetBot_votersGroupByPayload<T extends bot_votersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Bot_votersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Bot_votersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Bot_votersGroupByOutputType[P]>
            : GetScalarType<T[P], Bot_votersGroupByOutputType[P]>
        }
      >
    >


  export type bot_votersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    bot_id?: boolean
    user_id?: boolean
    timestamps?: boolean
    lynxtag?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bot_voters"]>

  export type bot_votersSelectScalar = {
    bot_id?: boolean
    user_id?: boolean
    timestamps?: boolean
    lynxtag?: boolean
  }

  export type bot_votersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }


  export type $bot_votersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "bot_voters"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      bot_id: bigint
      user_id: bigint
      timestamps: Date[]
      lynxtag: string
    }, ExtArgs["result"]["bot_voters"]>
    composites: {}
  }


  type bot_votersGetPayload<S extends boolean | null | undefined | bot_votersDefaultArgs> = $Result.GetResult<Prisma.$bot_votersPayload, S>

  type bot_votersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<bot_votersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Bot_votersCountAggregateInputType | true
    }

  export interface bot_votersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['bot_voters'], meta: { name: 'bot_voters' } }
    /**
     * Find zero or one Bot_voters that matches the filter.
     * @param {bot_votersFindUniqueArgs} args - Arguments to find a Bot_voters
     * @example
     * // Get one Bot_voters
     * const bot_voters = await prisma.bot_voters.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends bot_votersFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, bot_votersFindUniqueArgs<ExtArgs>>
    ): Prisma__bot_votersClient<$Result.GetResult<Prisma.$bot_votersPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Bot_voters that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {bot_votersFindUniqueOrThrowArgs} args - Arguments to find a Bot_voters
     * @example
     * // Get one Bot_voters
     * const bot_voters = await prisma.bot_voters.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends bot_votersFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, bot_votersFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__bot_votersClient<$Result.GetResult<Prisma.$bot_votersPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Bot_voters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bot_votersFindFirstArgs} args - Arguments to find a Bot_voters
     * @example
     * // Get one Bot_voters
     * const bot_voters = await prisma.bot_voters.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends bot_votersFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, bot_votersFindFirstArgs<ExtArgs>>
    ): Prisma__bot_votersClient<$Result.GetResult<Prisma.$bot_votersPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Bot_voters that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bot_votersFindFirstOrThrowArgs} args - Arguments to find a Bot_voters
     * @example
     * // Get one Bot_voters
     * const bot_voters = await prisma.bot_voters.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends bot_votersFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, bot_votersFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__bot_votersClient<$Result.GetResult<Prisma.$bot_votersPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Bot_voters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bot_votersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bot_voters
     * const bot_voters = await prisma.bot_voters.findMany()
     * 
     * // Get first 10 Bot_voters
     * const bot_voters = await prisma.bot_voters.findMany({ take: 10 })
     * 
     * // Only select the `bot_id`
     * const bot_votersWithBot_idOnly = await prisma.bot_voters.findMany({ select: { bot_id: true } })
     * 
    **/
    findMany<T extends bot_votersFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bot_votersFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bot_votersPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Bot_voters.
     * @param {bot_votersCreateArgs} args - Arguments to create a Bot_voters.
     * @example
     * // Create one Bot_voters
     * const Bot_voters = await prisma.bot_voters.create({
     *   data: {
     *     // ... data to create a Bot_voters
     *   }
     * })
     * 
    **/
    create<T extends bot_votersCreateArgs<ExtArgs>>(
      args: SelectSubset<T, bot_votersCreateArgs<ExtArgs>>
    ): Prisma__bot_votersClient<$Result.GetResult<Prisma.$bot_votersPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Bot_voters.
     *     @param {bot_votersCreateManyArgs} args - Arguments to create many Bot_voters.
     *     @example
     *     // Create many Bot_voters
     *     const bot_voters = await prisma.bot_voters.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends bot_votersCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bot_votersCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Bot_voters.
     * @param {bot_votersDeleteArgs} args - Arguments to delete one Bot_voters.
     * @example
     * // Delete one Bot_voters
     * const Bot_voters = await prisma.bot_voters.delete({
     *   where: {
     *     // ... filter to delete one Bot_voters
     *   }
     * })
     * 
    **/
    delete<T extends bot_votersDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, bot_votersDeleteArgs<ExtArgs>>
    ): Prisma__bot_votersClient<$Result.GetResult<Prisma.$bot_votersPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Bot_voters.
     * @param {bot_votersUpdateArgs} args - Arguments to update one Bot_voters.
     * @example
     * // Update one Bot_voters
     * const bot_voters = await prisma.bot_voters.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends bot_votersUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, bot_votersUpdateArgs<ExtArgs>>
    ): Prisma__bot_votersClient<$Result.GetResult<Prisma.$bot_votersPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Bot_voters.
     * @param {bot_votersDeleteManyArgs} args - Arguments to filter Bot_voters to delete.
     * @example
     * // Delete a few Bot_voters
     * const { count } = await prisma.bot_voters.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends bot_votersDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bot_votersDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bot_voters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bot_votersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bot_voters
     * const bot_voters = await prisma.bot_voters.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends bot_votersUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, bot_votersUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bot_voters.
     * @param {bot_votersUpsertArgs} args - Arguments to update or create a Bot_voters.
     * @example
     * // Update or create a Bot_voters
     * const bot_voters = await prisma.bot_voters.upsert({
     *   create: {
     *     // ... data to create a Bot_voters
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bot_voters we want to update
     *   }
     * })
    **/
    upsert<T extends bot_votersUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, bot_votersUpsertArgs<ExtArgs>>
    ): Prisma__bot_votersClient<$Result.GetResult<Prisma.$bot_votersPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Bot_voters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bot_votersCountArgs} args - Arguments to filter Bot_voters to count.
     * @example
     * // Count the number of Bot_voters
     * const count = await prisma.bot_voters.count({
     *   where: {
     *     // ... the filter for the Bot_voters we want to count
     *   }
     * })
    **/
    count<T extends bot_votersCountArgs>(
      args?: Subset<T, bot_votersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Bot_votersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bot_voters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Bot_votersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Bot_votersAggregateArgs>(args: Subset<T, Bot_votersAggregateArgs>): Prisma.PrismaPromise<GetBot_votersAggregateType<T>>

    /**
     * Group by Bot_voters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bot_votersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends bot_votersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: bot_votersGroupByArgs['orderBy'] }
        : { orderBy?: bot_votersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, bot_votersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBot_votersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the bot_voters model
   */
  readonly fields: bot_votersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for bot_voters.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__bot_votersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the bot_voters model
   */ 
  interface bot_votersFieldRefs {
    readonly bot_id: FieldRef<"bot_voters", 'BigInt'>
    readonly user_id: FieldRef<"bot_voters", 'BigInt'>
    readonly timestamps: FieldRef<"bot_voters", 'DateTime[]'>
    readonly lynxtag: FieldRef<"bot_voters", 'String'>
  }
    

  // Custom InputTypes

  /**
   * bot_voters findUnique
   */
  export type bot_votersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_voters
     */
    select?: bot_votersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bot_votersInclude<ExtArgs> | null
    /**
     * Filter, which bot_voters to fetch.
     */
    where: bot_votersWhereUniqueInput
  }


  /**
   * bot_voters findUniqueOrThrow
   */
  export type bot_votersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_voters
     */
    select?: bot_votersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bot_votersInclude<ExtArgs> | null
    /**
     * Filter, which bot_voters to fetch.
     */
    where: bot_votersWhereUniqueInput
  }


  /**
   * bot_voters findFirst
   */
  export type bot_votersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_voters
     */
    select?: bot_votersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bot_votersInclude<ExtArgs> | null
    /**
     * Filter, which bot_voters to fetch.
     */
    where?: bot_votersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bot_voters to fetch.
     */
    orderBy?: bot_votersOrderByWithRelationInput | bot_votersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bot_voters.
     */
    cursor?: bot_votersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bot_voters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bot_voters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bot_voters.
     */
    distinct?: Bot_votersScalarFieldEnum | Bot_votersScalarFieldEnum[]
  }


  /**
   * bot_voters findFirstOrThrow
   */
  export type bot_votersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_voters
     */
    select?: bot_votersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bot_votersInclude<ExtArgs> | null
    /**
     * Filter, which bot_voters to fetch.
     */
    where?: bot_votersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bot_voters to fetch.
     */
    orderBy?: bot_votersOrderByWithRelationInput | bot_votersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bot_voters.
     */
    cursor?: bot_votersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bot_voters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bot_voters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bot_voters.
     */
    distinct?: Bot_votersScalarFieldEnum | Bot_votersScalarFieldEnum[]
  }


  /**
   * bot_voters findMany
   */
  export type bot_votersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_voters
     */
    select?: bot_votersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bot_votersInclude<ExtArgs> | null
    /**
     * Filter, which bot_voters to fetch.
     */
    where?: bot_votersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bot_voters to fetch.
     */
    orderBy?: bot_votersOrderByWithRelationInput | bot_votersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing bot_voters.
     */
    cursor?: bot_votersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bot_voters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bot_voters.
     */
    skip?: number
    distinct?: Bot_votersScalarFieldEnum | Bot_votersScalarFieldEnum[]
  }


  /**
   * bot_voters create
   */
  export type bot_votersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_voters
     */
    select?: bot_votersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bot_votersInclude<ExtArgs> | null
    /**
     * The data needed to create a bot_voters.
     */
    data: XOR<bot_votersCreateInput, bot_votersUncheckedCreateInput>
  }


  /**
   * bot_voters createMany
   */
  export type bot_votersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many bot_voters.
     */
    data: bot_votersCreateManyInput | bot_votersCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * bot_voters update
   */
  export type bot_votersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_voters
     */
    select?: bot_votersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bot_votersInclude<ExtArgs> | null
    /**
     * The data needed to update a bot_voters.
     */
    data: XOR<bot_votersUpdateInput, bot_votersUncheckedUpdateInput>
    /**
     * Choose, which bot_voters to update.
     */
    where: bot_votersWhereUniqueInput
  }


  /**
   * bot_voters updateMany
   */
  export type bot_votersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update bot_voters.
     */
    data: XOR<bot_votersUpdateManyMutationInput, bot_votersUncheckedUpdateManyInput>
    /**
     * Filter which bot_voters to update
     */
    where?: bot_votersWhereInput
  }


  /**
   * bot_voters upsert
   */
  export type bot_votersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_voters
     */
    select?: bot_votersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bot_votersInclude<ExtArgs> | null
    /**
     * The filter to search for the bot_voters to update in case it exists.
     */
    where: bot_votersWhereUniqueInput
    /**
     * In case the bot_voters found by the `where` argument doesn't exist, create a new bot_voters with this data.
     */
    create: XOR<bot_votersCreateInput, bot_votersUncheckedCreateInput>
    /**
     * In case the bot_voters was found with the provided `where` argument, update it with this data.
     */
    update: XOR<bot_votersUpdateInput, bot_votersUncheckedUpdateInput>
  }


  /**
   * bot_voters delete
   */
  export type bot_votersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_voters
     */
    select?: bot_votersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bot_votersInclude<ExtArgs> | null
    /**
     * Filter which bot_voters to delete.
     */
    where: bot_votersWhereUniqueInput
  }


  /**
   * bot_voters deleteMany
   */
  export type bot_votersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bot_voters to delete
     */
    where?: bot_votersWhereInput
  }


  /**
   * bot_voters without action
   */
  export type bot_votersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_voters
     */
    select?: bot_votersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bot_votersInclude<ExtArgs> | null
  }



  /**
   * Model bots
   */

  export type AggregateBots = {
    _count: BotsCountAggregateOutputType | null
    _avg: BotsAvgAggregateOutputType | null
    _sum: BotsSumAggregateOutputType | null
    _min: BotsMinAggregateOutputType | null
    _max: BotsMaxAggregateOutputType | null
  }

  export type BotsAvgAggregateOutputType = {
    bot_id: number | null
    votes: number | null
    guild_count: number | null
    shard_count: number | null
    invite_amount: number | null
    user_count: number | null
    shards: number | null
    state: number | null
    long_description_type: number | null
    verifier: number | null
    webhook_type: number | null
    id: number | null
    total_votes: number | null
    client_id: number | null
    flags: number | null
    uptime_checks_total: number | null
    uptime_checks_failed: number | null
    page_style: number | null
  }

  export type BotsSumAggregateOutputType = {
    bot_id: bigint | null
    votes: bigint | null
    guild_count: bigint | null
    shard_count: bigint | null
    invite_amount: number | null
    user_count: bigint | null
    shards: number[]
    state: number | null
    long_description_type: number | null
    verifier: bigint | null
    webhook_type: number | null
    id: bigint | null
    total_votes: bigint | null
    client_id: bigint | null
    flags: number[]
    uptime_checks_total: number | null
    uptime_checks_failed: number | null
    page_style: number | null
  }

  export type BotsMinAggregateOutputType = {
    bot_id: bigint | null
    votes: bigint | null
    guild_count: bigint | null
    shard_count: bigint | null
    bot_library: string | null
    webhook: string | null
    description: string | null
    long_description: string | null
    prefix: string | null
    api_token: string | null
    banner_card: string | null
    created_at: Date | null
    invite: string | null
    invite_amount: number | null
    user_count: bigint | null
    css: string | null
    username_cached: string | null
    state: number | null
    long_description_type: number | null
    verifier: bigint | null
    last_stats_post: Date | null
    webhook_secret: string | null
    webhook_type: number | null
    di_text: string | null
    id: bigint | null
    banner_page: string | null
    total_votes: bigint | null
    client_id: bigint | null
    uptime_checks_total: number | null
    uptime_checks_failed: number | null
    page_style: number | null
    webhook_hmac_only: boolean | null
    last_updated_at: Date | null
    avatar_cached: string | null
    disc_cached: string | null
    lynxtag: string | null
  }

  export type BotsMaxAggregateOutputType = {
    bot_id: bigint | null
    votes: bigint | null
    guild_count: bigint | null
    shard_count: bigint | null
    bot_library: string | null
    webhook: string | null
    description: string | null
    long_description: string | null
    prefix: string | null
    api_token: string | null
    banner_card: string | null
    created_at: Date | null
    invite: string | null
    invite_amount: number | null
    user_count: bigint | null
    css: string | null
    username_cached: string | null
    state: number | null
    long_description_type: number | null
    verifier: bigint | null
    last_stats_post: Date | null
    webhook_secret: string | null
    webhook_type: number | null
    di_text: string | null
    id: bigint | null
    banner_page: string | null
    total_votes: bigint | null
    client_id: bigint | null
    uptime_checks_total: number | null
    uptime_checks_failed: number | null
    page_style: number | null
    webhook_hmac_only: boolean | null
    last_updated_at: Date | null
    avatar_cached: string | null
    disc_cached: string | null
    lynxtag: string | null
  }

  export type BotsCountAggregateOutputType = {
    bot_id: number
    votes: number
    guild_count: number
    shard_count: number
    bot_library: number
    webhook: number
    description: number
    long_description: number
    prefix: number
    api_token: number
    banner_card: number
    created_at: number
    invite: number
    features: number
    invite_amount: number
    user_count: number
    css: number
    shards: number
    username_cached: number
    state: number
    long_description_type: number
    verifier: number
    last_stats_post: number
    webhook_secret: number
    webhook_type: number
    di_text: number
    id: number
    banner_page: number
    total_votes: number
    client_id: number
    flags: number
    uptime_checks_total: number
    uptime_checks_failed: number
    page_style: number
    webhook_hmac_only: number
    last_updated_at: number
    avatar_cached: number
    disc_cached: number
    extra_links: number
    lynxtag: number
    _all: number
  }


  export type BotsAvgAggregateInputType = {
    bot_id?: true
    votes?: true
    guild_count?: true
    shard_count?: true
    invite_amount?: true
    user_count?: true
    shards?: true
    state?: true
    long_description_type?: true
    verifier?: true
    webhook_type?: true
    id?: true
    total_votes?: true
    client_id?: true
    flags?: true
    uptime_checks_total?: true
    uptime_checks_failed?: true
    page_style?: true
  }

  export type BotsSumAggregateInputType = {
    bot_id?: true
    votes?: true
    guild_count?: true
    shard_count?: true
    invite_amount?: true
    user_count?: true
    shards?: true
    state?: true
    long_description_type?: true
    verifier?: true
    webhook_type?: true
    id?: true
    total_votes?: true
    client_id?: true
    flags?: true
    uptime_checks_total?: true
    uptime_checks_failed?: true
    page_style?: true
  }

  export type BotsMinAggregateInputType = {
    bot_id?: true
    votes?: true
    guild_count?: true
    shard_count?: true
    bot_library?: true
    webhook?: true
    description?: true
    long_description?: true
    prefix?: true
    api_token?: true
    banner_card?: true
    created_at?: true
    invite?: true
    invite_amount?: true
    user_count?: true
    css?: true
    username_cached?: true
    state?: true
    long_description_type?: true
    verifier?: true
    last_stats_post?: true
    webhook_secret?: true
    webhook_type?: true
    di_text?: true
    id?: true
    banner_page?: true
    total_votes?: true
    client_id?: true
    uptime_checks_total?: true
    uptime_checks_failed?: true
    page_style?: true
    webhook_hmac_only?: true
    last_updated_at?: true
    avatar_cached?: true
    disc_cached?: true
    lynxtag?: true
  }

  export type BotsMaxAggregateInputType = {
    bot_id?: true
    votes?: true
    guild_count?: true
    shard_count?: true
    bot_library?: true
    webhook?: true
    description?: true
    long_description?: true
    prefix?: true
    api_token?: true
    banner_card?: true
    created_at?: true
    invite?: true
    invite_amount?: true
    user_count?: true
    css?: true
    username_cached?: true
    state?: true
    long_description_type?: true
    verifier?: true
    last_stats_post?: true
    webhook_secret?: true
    webhook_type?: true
    di_text?: true
    id?: true
    banner_page?: true
    total_votes?: true
    client_id?: true
    uptime_checks_total?: true
    uptime_checks_failed?: true
    page_style?: true
    webhook_hmac_only?: true
    last_updated_at?: true
    avatar_cached?: true
    disc_cached?: true
    lynxtag?: true
  }

  export type BotsCountAggregateInputType = {
    bot_id?: true
    votes?: true
    guild_count?: true
    shard_count?: true
    bot_library?: true
    webhook?: true
    description?: true
    long_description?: true
    prefix?: true
    api_token?: true
    banner_card?: true
    created_at?: true
    invite?: true
    features?: true
    invite_amount?: true
    user_count?: true
    css?: true
    shards?: true
    username_cached?: true
    state?: true
    long_description_type?: true
    verifier?: true
    last_stats_post?: true
    webhook_secret?: true
    webhook_type?: true
    di_text?: true
    id?: true
    banner_page?: true
    total_votes?: true
    client_id?: true
    flags?: true
    uptime_checks_total?: true
    uptime_checks_failed?: true
    page_style?: true
    webhook_hmac_only?: true
    last_updated_at?: true
    avatar_cached?: true
    disc_cached?: true
    extra_links?: true
    lynxtag?: true
    _all?: true
  }

  export type BotsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bots to aggregate.
     */
    where?: botsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bots to fetch.
     */
    orderBy?: botsOrderByWithRelationInput | botsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: botsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned bots
    **/
    _count?: true | BotsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BotsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BotsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BotsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BotsMaxAggregateInputType
  }

  export type GetBotsAggregateType<T extends BotsAggregateArgs> = {
        [P in keyof T & keyof AggregateBots]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBots[P]>
      : GetScalarType<T[P], AggregateBots[P]>
  }




  export type botsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: botsWhereInput
    orderBy?: botsOrderByWithAggregationInput | botsOrderByWithAggregationInput[]
    by: BotsScalarFieldEnum[] | BotsScalarFieldEnum
    having?: botsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BotsCountAggregateInputType | true
    _avg?: BotsAvgAggregateInputType
    _sum?: BotsSumAggregateInputType
    _min?: BotsMinAggregateInputType
    _max?: BotsMaxAggregateInputType
  }

  export type BotsGroupByOutputType = {
    bot_id: bigint
    votes: bigint | null
    guild_count: bigint | null
    shard_count: bigint | null
    bot_library: string | null
    webhook: string | null
    description: string
    long_description: string
    prefix: string | null
    api_token: string | null
    banner_card: string | null
    created_at: Date
    invite: string
    features: string[]
    invite_amount: number | null
    user_count: bigint | null
    css: string | null
    shards: number[]
    username_cached: string
    state: number
    long_description_type: number
    verifier: bigint | null
    last_stats_post: Date
    webhook_secret: string | null
    webhook_type: number | null
    di_text: string | null
    id: bigint
    banner_page: string | null
    total_votes: bigint | null
    client_id: bigint | null
    flags: number[]
    uptime_checks_total: number | null
    uptime_checks_failed: number | null
    page_style: number
    webhook_hmac_only: boolean | null
    last_updated_at: Date
    avatar_cached: string
    disc_cached: string
    extra_links: JsonValue
    lynxtag: string
    _count: BotsCountAggregateOutputType | null
    _avg: BotsAvgAggregateOutputType | null
    _sum: BotsSumAggregateOutputType | null
    _min: BotsMinAggregateOutputType | null
    _max: BotsMaxAggregateOutputType | null
  }

  type GetBotsGroupByPayload<T extends botsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BotsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BotsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BotsGroupByOutputType[P]>
            : GetScalarType<T[P], BotsGroupByOutputType[P]>
        }
      >
    >


  export type botsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    bot_id?: boolean
    votes?: boolean
    guild_count?: boolean
    shard_count?: boolean
    bot_library?: boolean
    webhook?: boolean
    description?: boolean
    long_description?: boolean
    prefix?: boolean
    api_token?: boolean
    banner_card?: boolean
    created_at?: boolean
    invite?: boolean
    features?: boolean
    invite_amount?: boolean
    user_count?: boolean
    css?: boolean
    shards?: boolean
    username_cached?: boolean
    state?: boolean
    long_description_type?: boolean
    verifier?: boolean
    last_stats_post?: boolean
    webhook_secret?: boolean
    webhook_type?: boolean
    di_text?: boolean
    id?: boolean
    banner_page?: boolean
    total_votes?: boolean
    client_id?: boolean
    flags?: boolean
    uptime_checks_total?: boolean
    uptime_checks_failed?: boolean
    page_style?: boolean
    webhook_hmac_only?: boolean
    last_updated_at?: boolean
    avatar_cached?: boolean
    disc_cached?: boolean
    extra_links?: boolean
    lynxtag?: boolean
    bot_commands?: boolean | bots$bot_commandsArgs<ExtArgs>
    bot_events?: boolean | bots$bot_eventsArgs<ExtArgs>
    bot_owner?: boolean | bots$bot_ownerArgs<ExtArgs>
    bot_promotions?: boolean | bots$bot_promotionsArgs<ExtArgs>
    bot_tags?: boolean | bots$bot_tagsArgs<ExtArgs>
    _count?: boolean | BotsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bots"]>

  export type botsSelectScalar = {
    bot_id?: boolean
    votes?: boolean
    guild_count?: boolean
    shard_count?: boolean
    bot_library?: boolean
    webhook?: boolean
    description?: boolean
    long_description?: boolean
    prefix?: boolean
    api_token?: boolean
    banner_card?: boolean
    created_at?: boolean
    invite?: boolean
    features?: boolean
    invite_amount?: boolean
    user_count?: boolean
    css?: boolean
    shards?: boolean
    username_cached?: boolean
    state?: boolean
    long_description_type?: boolean
    verifier?: boolean
    last_stats_post?: boolean
    webhook_secret?: boolean
    webhook_type?: boolean
    di_text?: boolean
    id?: boolean
    banner_page?: boolean
    total_votes?: boolean
    client_id?: boolean
    flags?: boolean
    uptime_checks_total?: boolean
    uptime_checks_failed?: boolean
    page_style?: boolean
    webhook_hmac_only?: boolean
    last_updated_at?: boolean
    avatar_cached?: boolean
    disc_cached?: boolean
    extra_links?: boolean
    lynxtag?: boolean
  }

  export type botsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bot_commands?: boolean | bots$bot_commandsArgs<ExtArgs>
    bot_events?: boolean | bots$bot_eventsArgs<ExtArgs>
    bot_owner?: boolean | bots$bot_ownerArgs<ExtArgs>
    bot_promotions?: boolean | bots$bot_promotionsArgs<ExtArgs>
    bot_tags?: boolean | bots$bot_tagsArgs<ExtArgs>
    _count?: boolean | BotsCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $botsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "bots"
    objects: {
      bot_commands: Prisma.$bot_commandsPayload<ExtArgs>[]
      bot_events: Prisma.$bot_eventsPayload<ExtArgs>[]
      bot_owner: Prisma.$bot_ownerPayload<ExtArgs>[]
      bot_promotions: Prisma.$bot_promotionsPayload<ExtArgs>[]
      bot_tags: Prisma.$bot_tagsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      bot_id: bigint
      votes: bigint | null
      guild_count: bigint | null
      shard_count: bigint | null
      bot_library: string | null
      webhook: string | null
      description: string
      long_description: string
      prefix: string | null
      api_token: string | null
      banner_card: string | null
      created_at: Date
      invite: string
      features: string[]
      invite_amount: number | null
      user_count: bigint | null
      css: string | null
      shards: number[]
      username_cached: string
      state: number
      long_description_type: number
      verifier: bigint | null
      last_stats_post: Date
      webhook_secret: string | null
      webhook_type: number | null
      di_text: string | null
      id: bigint
      banner_page: string | null
      total_votes: bigint | null
      client_id: bigint | null
      flags: number[]
      uptime_checks_total: number | null
      uptime_checks_failed: number | null
      page_style: number
      webhook_hmac_only: boolean | null
      last_updated_at: Date
      avatar_cached: string
      disc_cached: string
      extra_links: Prisma.JsonValue
      lynxtag: string
    }, ExtArgs["result"]["bots"]>
    composites: {}
  }


  type botsGetPayload<S extends boolean | null | undefined | botsDefaultArgs> = $Result.GetResult<Prisma.$botsPayload, S>

  type botsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<botsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BotsCountAggregateInputType | true
    }

  export interface botsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['bots'], meta: { name: 'bots' } }
    /**
     * Find zero or one Bots that matches the filter.
     * @param {botsFindUniqueArgs} args - Arguments to find a Bots
     * @example
     * // Get one Bots
     * const bots = await prisma.bots.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends botsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, botsFindUniqueArgs<ExtArgs>>
    ): Prisma__botsClient<$Result.GetResult<Prisma.$botsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Bots that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {botsFindUniqueOrThrowArgs} args - Arguments to find a Bots
     * @example
     * // Get one Bots
     * const bots = await prisma.bots.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends botsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, botsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__botsClient<$Result.GetResult<Prisma.$botsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Bots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {botsFindFirstArgs} args - Arguments to find a Bots
     * @example
     * // Get one Bots
     * const bots = await prisma.bots.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends botsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, botsFindFirstArgs<ExtArgs>>
    ): Prisma__botsClient<$Result.GetResult<Prisma.$botsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Bots that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {botsFindFirstOrThrowArgs} args - Arguments to find a Bots
     * @example
     * // Get one Bots
     * const bots = await prisma.bots.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends botsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, botsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__botsClient<$Result.GetResult<Prisma.$botsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Bots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {botsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bots
     * const bots = await prisma.bots.findMany()
     * 
     * // Get first 10 Bots
     * const bots = await prisma.bots.findMany({ take: 10 })
     * 
     * // Only select the `bot_id`
     * const botsWithBot_idOnly = await prisma.bots.findMany({ select: { bot_id: true } })
     * 
    **/
    findMany<T extends botsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, botsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$botsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Bots.
     * @param {botsCreateArgs} args - Arguments to create a Bots.
     * @example
     * // Create one Bots
     * const Bots = await prisma.bots.create({
     *   data: {
     *     // ... data to create a Bots
     *   }
     * })
     * 
    **/
    create<T extends botsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, botsCreateArgs<ExtArgs>>
    ): Prisma__botsClient<$Result.GetResult<Prisma.$botsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Bots.
     *     @param {botsCreateManyArgs} args - Arguments to create many Bots.
     *     @example
     *     // Create many Bots
     *     const bots = await prisma.bots.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends botsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, botsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Bots.
     * @param {botsDeleteArgs} args - Arguments to delete one Bots.
     * @example
     * // Delete one Bots
     * const Bots = await prisma.bots.delete({
     *   where: {
     *     // ... filter to delete one Bots
     *   }
     * })
     * 
    **/
    delete<T extends botsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, botsDeleteArgs<ExtArgs>>
    ): Prisma__botsClient<$Result.GetResult<Prisma.$botsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Bots.
     * @param {botsUpdateArgs} args - Arguments to update one Bots.
     * @example
     * // Update one Bots
     * const bots = await prisma.bots.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends botsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, botsUpdateArgs<ExtArgs>>
    ): Prisma__botsClient<$Result.GetResult<Prisma.$botsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Bots.
     * @param {botsDeleteManyArgs} args - Arguments to filter Bots to delete.
     * @example
     * // Delete a few Bots
     * const { count } = await prisma.bots.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends botsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, botsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {botsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bots
     * const bots = await prisma.bots.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends botsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, botsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bots.
     * @param {botsUpsertArgs} args - Arguments to update or create a Bots.
     * @example
     * // Update or create a Bots
     * const bots = await prisma.bots.upsert({
     *   create: {
     *     // ... data to create a Bots
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bots we want to update
     *   }
     * })
    **/
    upsert<T extends botsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, botsUpsertArgs<ExtArgs>>
    ): Prisma__botsClient<$Result.GetResult<Prisma.$botsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Bots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {botsCountArgs} args - Arguments to filter Bots to count.
     * @example
     * // Count the number of Bots
     * const count = await prisma.bots.count({
     *   where: {
     *     // ... the filter for the Bots we want to count
     *   }
     * })
    **/
    count<T extends botsCountArgs>(
      args?: Subset<T, botsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BotsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BotsAggregateArgs>(args: Subset<T, BotsAggregateArgs>): Prisma.PrismaPromise<GetBotsAggregateType<T>>

    /**
     * Group by Bots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {botsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends botsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: botsGroupByArgs['orderBy'] }
        : { orderBy?: botsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, botsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBotsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the bots model
   */
  readonly fields: botsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for bots.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__botsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    bot_commands<T extends bots$bot_commandsArgs<ExtArgs> = {}>(args?: Subset<T, bots$bot_commandsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bot_commandsPayload<ExtArgs>, T, 'findMany'> | Null>;

    bot_events<T extends bots$bot_eventsArgs<ExtArgs> = {}>(args?: Subset<T, bots$bot_eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bot_eventsPayload<ExtArgs>, T, 'findMany'> | Null>;

    bot_owner<T extends bots$bot_ownerArgs<ExtArgs> = {}>(args?: Subset<T, bots$bot_ownerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bot_ownerPayload<ExtArgs>, T, 'findMany'> | Null>;

    bot_promotions<T extends bots$bot_promotionsArgs<ExtArgs> = {}>(args?: Subset<T, bots$bot_promotionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bot_promotionsPayload<ExtArgs>, T, 'findMany'> | Null>;

    bot_tags<T extends bots$bot_tagsArgs<ExtArgs> = {}>(args?: Subset<T, bots$bot_tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bot_tagsPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the bots model
   */ 
  interface botsFieldRefs {
    readonly bot_id: FieldRef<"bots", 'BigInt'>
    readonly votes: FieldRef<"bots", 'BigInt'>
    readonly guild_count: FieldRef<"bots", 'BigInt'>
    readonly shard_count: FieldRef<"bots", 'BigInt'>
    readonly bot_library: FieldRef<"bots", 'String'>
    readonly webhook: FieldRef<"bots", 'String'>
    readonly description: FieldRef<"bots", 'String'>
    readonly long_description: FieldRef<"bots", 'String'>
    readonly prefix: FieldRef<"bots", 'String'>
    readonly api_token: FieldRef<"bots", 'String'>
    readonly banner_card: FieldRef<"bots", 'String'>
    readonly created_at: FieldRef<"bots", 'DateTime'>
    readonly invite: FieldRef<"bots", 'String'>
    readonly features: FieldRef<"bots", 'String[]'>
    readonly invite_amount: FieldRef<"bots", 'Int'>
    readonly user_count: FieldRef<"bots", 'BigInt'>
    readonly css: FieldRef<"bots", 'String'>
    readonly shards: FieldRef<"bots", 'Int[]'>
    readonly username_cached: FieldRef<"bots", 'String'>
    readonly state: FieldRef<"bots", 'Int'>
    readonly long_description_type: FieldRef<"bots", 'Int'>
    readonly verifier: FieldRef<"bots", 'BigInt'>
    readonly last_stats_post: FieldRef<"bots", 'DateTime'>
    readonly webhook_secret: FieldRef<"bots", 'String'>
    readonly webhook_type: FieldRef<"bots", 'Int'>
    readonly di_text: FieldRef<"bots", 'String'>
    readonly id: FieldRef<"bots", 'BigInt'>
    readonly banner_page: FieldRef<"bots", 'String'>
    readonly total_votes: FieldRef<"bots", 'BigInt'>
    readonly client_id: FieldRef<"bots", 'BigInt'>
    readonly flags: FieldRef<"bots", 'Int[]'>
    readonly uptime_checks_total: FieldRef<"bots", 'Int'>
    readonly uptime_checks_failed: FieldRef<"bots", 'Int'>
    readonly page_style: FieldRef<"bots", 'Int'>
    readonly webhook_hmac_only: FieldRef<"bots", 'Boolean'>
    readonly last_updated_at: FieldRef<"bots", 'DateTime'>
    readonly avatar_cached: FieldRef<"bots", 'String'>
    readonly disc_cached: FieldRef<"bots", 'String'>
    readonly extra_links: FieldRef<"bots", 'Json'>
    readonly lynxtag: FieldRef<"bots", 'String'>
  }
    

  // Custom InputTypes

  /**
   * bots findUnique
   */
  export type botsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bots
     */
    select?: botsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: botsInclude<ExtArgs> | null
    /**
     * Filter, which bots to fetch.
     */
    where: botsWhereUniqueInput
  }


  /**
   * bots findUniqueOrThrow
   */
  export type botsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bots
     */
    select?: botsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: botsInclude<ExtArgs> | null
    /**
     * Filter, which bots to fetch.
     */
    where: botsWhereUniqueInput
  }


  /**
   * bots findFirst
   */
  export type botsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bots
     */
    select?: botsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: botsInclude<ExtArgs> | null
    /**
     * Filter, which bots to fetch.
     */
    where?: botsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bots to fetch.
     */
    orderBy?: botsOrderByWithRelationInput | botsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bots.
     */
    cursor?: botsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bots.
     */
    distinct?: BotsScalarFieldEnum | BotsScalarFieldEnum[]
  }


  /**
   * bots findFirstOrThrow
   */
  export type botsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bots
     */
    select?: botsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: botsInclude<ExtArgs> | null
    /**
     * Filter, which bots to fetch.
     */
    where?: botsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bots to fetch.
     */
    orderBy?: botsOrderByWithRelationInput | botsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bots.
     */
    cursor?: botsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bots.
     */
    distinct?: BotsScalarFieldEnum | BotsScalarFieldEnum[]
  }


  /**
   * bots findMany
   */
  export type botsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bots
     */
    select?: botsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: botsInclude<ExtArgs> | null
    /**
     * Filter, which bots to fetch.
     */
    where?: botsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bots to fetch.
     */
    orderBy?: botsOrderByWithRelationInput | botsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing bots.
     */
    cursor?: botsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bots.
     */
    skip?: number
    distinct?: BotsScalarFieldEnum | BotsScalarFieldEnum[]
  }


  /**
   * bots create
   */
  export type botsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bots
     */
    select?: botsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: botsInclude<ExtArgs> | null
    /**
     * The data needed to create a bots.
     */
    data: XOR<botsCreateInput, botsUncheckedCreateInput>
  }


  /**
   * bots createMany
   */
  export type botsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many bots.
     */
    data: botsCreateManyInput | botsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * bots update
   */
  export type botsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bots
     */
    select?: botsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: botsInclude<ExtArgs> | null
    /**
     * The data needed to update a bots.
     */
    data: XOR<botsUpdateInput, botsUncheckedUpdateInput>
    /**
     * Choose, which bots to update.
     */
    where: botsWhereUniqueInput
  }


  /**
   * bots updateMany
   */
  export type botsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update bots.
     */
    data: XOR<botsUpdateManyMutationInput, botsUncheckedUpdateManyInput>
    /**
     * Filter which bots to update
     */
    where?: botsWhereInput
  }


  /**
   * bots upsert
   */
  export type botsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bots
     */
    select?: botsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: botsInclude<ExtArgs> | null
    /**
     * The filter to search for the bots to update in case it exists.
     */
    where: botsWhereUniqueInput
    /**
     * In case the bots found by the `where` argument doesn't exist, create a new bots with this data.
     */
    create: XOR<botsCreateInput, botsUncheckedCreateInput>
    /**
     * In case the bots was found with the provided `where` argument, update it with this data.
     */
    update: XOR<botsUpdateInput, botsUncheckedUpdateInput>
  }


  /**
   * bots delete
   */
  export type botsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bots
     */
    select?: botsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: botsInclude<ExtArgs> | null
    /**
     * Filter which bots to delete.
     */
    where: botsWhereUniqueInput
  }


  /**
   * bots deleteMany
   */
  export type botsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bots to delete
     */
    where?: botsWhereInput
  }


  /**
   * bots.bot_commands
   */
  export type bots$bot_commandsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_commands
     */
    select?: bot_commandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bot_commandsInclude<ExtArgs> | null
    where?: bot_commandsWhereInput
    orderBy?: bot_commandsOrderByWithRelationInput | bot_commandsOrderByWithRelationInput[]
    cursor?: bot_commandsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Bot_commandsScalarFieldEnum | Bot_commandsScalarFieldEnum[]
  }


  /**
   * bots.bot_events
   */
  export type bots$bot_eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_events
     */
    select?: bot_eventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bot_eventsInclude<ExtArgs> | null
    where?: bot_eventsWhereInput
    orderBy?: bot_eventsOrderByWithRelationInput | bot_eventsOrderByWithRelationInput[]
    cursor?: bot_eventsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Bot_eventsScalarFieldEnum | Bot_eventsScalarFieldEnum[]
  }


  /**
   * bots.bot_owner
   */
  export type bots$bot_ownerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_owner
     */
    select?: bot_ownerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bot_ownerInclude<ExtArgs> | null
    where?: bot_ownerWhereInput
    orderBy?: bot_ownerOrderByWithRelationInput | bot_ownerOrderByWithRelationInput[]
    cursor?: bot_ownerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Bot_ownerScalarFieldEnum | Bot_ownerScalarFieldEnum[]
  }


  /**
   * bots.bot_promotions
   */
  export type bots$bot_promotionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_promotions
     */
    select?: bot_promotionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bot_promotionsInclude<ExtArgs> | null
    where?: bot_promotionsWhereInput
    orderBy?: bot_promotionsOrderByWithRelationInput | bot_promotionsOrderByWithRelationInput[]
    cursor?: bot_promotionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Bot_promotionsScalarFieldEnum | Bot_promotionsScalarFieldEnum[]
  }


  /**
   * bots.bot_tags
   */
  export type bots$bot_tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_tags
     */
    select?: bot_tagsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bot_tagsInclude<ExtArgs> | null
    where?: bot_tagsWhereInput
    orderBy?: bot_tagsOrderByWithRelationInput | bot_tagsOrderByWithRelationInput[]
    cursor?: bot_tagsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Bot_tagsScalarFieldEnum | Bot_tagsScalarFieldEnum[]
  }


  /**
   * bots without action
   */
  export type botsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bots
     */
    select?: botsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: botsInclude<ExtArgs> | null
  }



  /**
   * Model extra_data
   */

  export type AggregateExtra_data = {
    _count: Extra_dataCountAggregateOutputType | null
    _avg: Extra_dataAvgAggregateOutputType | null
    _sum: Extra_dataSumAggregateOutputType | null
    _min: Extra_dataMinAggregateOutputType | null
    _max: Extra_dataMaxAggregateOutputType | null
  }

  export type Extra_dataAvgAggregateOutputType = {
    user_id: number | null
  }

  export type Extra_dataSumAggregateOutputType = {
    user_id: bigint | null
  }

  export type Extra_dataMinAggregateOutputType = {
    name: string | null
    user_id: bigint | null
    lynxtag: string | null
  }

  export type Extra_dataMaxAggregateOutputType = {
    name: string | null
    user_id: bigint | null
    lynxtag: string | null
  }

  export type Extra_dataCountAggregateOutputType = {
    name: number
    value: number
    user_id: number
    lynxtag: number
    _all: number
  }


  export type Extra_dataAvgAggregateInputType = {
    user_id?: true
  }

  export type Extra_dataSumAggregateInputType = {
    user_id?: true
  }

  export type Extra_dataMinAggregateInputType = {
    name?: true
    user_id?: true
    lynxtag?: true
  }

  export type Extra_dataMaxAggregateInputType = {
    name?: true
    user_id?: true
    lynxtag?: true
  }

  export type Extra_dataCountAggregateInputType = {
    name?: true
    value?: true
    user_id?: true
    lynxtag?: true
    _all?: true
  }

  export type Extra_dataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which extra_data to aggregate.
     */
    where?: extra_dataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of extra_data to fetch.
     */
    orderBy?: extra_dataOrderByWithRelationInput | extra_dataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: extra_dataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` extra_data from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` extra_data.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned extra_data
    **/
    _count?: true | Extra_dataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Extra_dataAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Extra_dataSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Extra_dataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Extra_dataMaxAggregateInputType
  }

  export type GetExtra_dataAggregateType<T extends Extra_dataAggregateArgs> = {
        [P in keyof T & keyof AggregateExtra_data]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExtra_data[P]>
      : GetScalarType<T[P], AggregateExtra_data[P]>
  }




  export type extra_dataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: extra_dataWhereInput
    orderBy?: extra_dataOrderByWithAggregationInput | extra_dataOrderByWithAggregationInput[]
    by: Extra_dataScalarFieldEnum[] | Extra_dataScalarFieldEnum
    having?: extra_dataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Extra_dataCountAggregateInputType | true
    _avg?: Extra_dataAvgAggregateInputType
    _sum?: Extra_dataSumAggregateInputType
    _min?: Extra_dataMinAggregateInputType
    _max?: Extra_dataMaxAggregateInputType
  }

  export type Extra_dataGroupByOutputType = {
    name: string | null
    value: JsonValue | null
    user_id: bigint | null
    lynxtag: string
    _count: Extra_dataCountAggregateOutputType | null
    _avg: Extra_dataAvgAggregateOutputType | null
    _sum: Extra_dataSumAggregateOutputType | null
    _min: Extra_dataMinAggregateOutputType | null
    _max: Extra_dataMaxAggregateOutputType | null
  }

  type GetExtra_dataGroupByPayload<T extends extra_dataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Extra_dataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Extra_dataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Extra_dataGroupByOutputType[P]>
            : GetScalarType<T[P], Extra_dataGroupByOutputType[P]>
        }
      >
    >


  export type extra_dataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    name?: boolean
    value?: boolean
    user_id?: boolean
    lynxtag?: boolean
    users?: boolean | extra_data$usersArgs<ExtArgs>
  }, ExtArgs["result"]["extra_data"]>

  export type extra_dataSelectScalar = {
    name?: boolean
    value?: boolean
    user_id?: boolean
    lynxtag?: boolean
  }

  export type extra_dataInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | extra_data$usersArgs<ExtArgs>
  }


  export type $extra_dataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "extra_data"
    objects: {
      users: Prisma.$usersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      name: string | null
      value: Prisma.JsonValue | null
      user_id: bigint | null
      lynxtag: string
    }, ExtArgs["result"]["extra_data"]>
    composites: {}
  }


  type extra_dataGetPayload<S extends boolean | null | undefined | extra_dataDefaultArgs> = $Result.GetResult<Prisma.$extra_dataPayload, S>

  type extra_dataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<extra_dataFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Extra_dataCountAggregateInputType | true
    }

  export interface extra_dataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['extra_data'], meta: { name: 'extra_data' } }
    /**
     * Find zero or one Extra_data that matches the filter.
     * @param {extra_dataFindUniqueArgs} args - Arguments to find a Extra_data
     * @example
     * // Get one Extra_data
     * const extra_data = await prisma.extra_data.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends extra_dataFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, extra_dataFindUniqueArgs<ExtArgs>>
    ): Prisma__extra_dataClient<$Result.GetResult<Prisma.$extra_dataPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Extra_data that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {extra_dataFindUniqueOrThrowArgs} args - Arguments to find a Extra_data
     * @example
     * // Get one Extra_data
     * const extra_data = await prisma.extra_data.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends extra_dataFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, extra_dataFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__extra_dataClient<$Result.GetResult<Prisma.$extra_dataPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Extra_data that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {extra_dataFindFirstArgs} args - Arguments to find a Extra_data
     * @example
     * // Get one Extra_data
     * const extra_data = await prisma.extra_data.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends extra_dataFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, extra_dataFindFirstArgs<ExtArgs>>
    ): Prisma__extra_dataClient<$Result.GetResult<Prisma.$extra_dataPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Extra_data that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {extra_dataFindFirstOrThrowArgs} args - Arguments to find a Extra_data
     * @example
     * // Get one Extra_data
     * const extra_data = await prisma.extra_data.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends extra_dataFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, extra_dataFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__extra_dataClient<$Result.GetResult<Prisma.$extra_dataPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Extra_data that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {extra_dataFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Extra_data
     * const extra_data = await prisma.extra_data.findMany()
     * 
     * // Get first 10 Extra_data
     * const extra_data = await prisma.extra_data.findMany({ take: 10 })
     * 
     * // Only select the `name`
     * const extra_dataWithNameOnly = await prisma.extra_data.findMany({ select: { name: true } })
     * 
    **/
    findMany<T extends extra_dataFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, extra_dataFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$extra_dataPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Extra_data.
     * @param {extra_dataCreateArgs} args - Arguments to create a Extra_data.
     * @example
     * // Create one Extra_data
     * const Extra_data = await prisma.extra_data.create({
     *   data: {
     *     // ... data to create a Extra_data
     *   }
     * })
     * 
    **/
    create<T extends extra_dataCreateArgs<ExtArgs>>(
      args: SelectSubset<T, extra_dataCreateArgs<ExtArgs>>
    ): Prisma__extra_dataClient<$Result.GetResult<Prisma.$extra_dataPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Extra_data.
     *     @param {extra_dataCreateManyArgs} args - Arguments to create many Extra_data.
     *     @example
     *     // Create many Extra_data
     *     const extra_data = await prisma.extra_data.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends extra_dataCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, extra_dataCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Extra_data.
     * @param {extra_dataDeleteArgs} args - Arguments to delete one Extra_data.
     * @example
     * // Delete one Extra_data
     * const Extra_data = await prisma.extra_data.delete({
     *   where: {
     *     // ... filter to delete one Extra_data
     *   }
     * })
     * 
    **/
    delete<T extends extra_dataDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, extra_dataDeleteArgs<ExtArgs>>
    ): Prisma__extra_dataClient<$Result.GetResult<Prisma.$extra_dataPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Extra_data.
     * @param {extra_dataUpdateArgs} args - Arguments to update one Extra_data.
     * @example
     * // Update one Extra_data
     * const extra_data = await prisma.extra_data.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends extra_dataUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, extra_dataUpdateArgs<ExtArgs>>
    ): Prisma__extra_dataClient<$Result.GetResult<Prisma.$extra_dataPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Extra_data.
     * @param {extra_dataDeleteManyArgs} args - Arguments to filter Extra_data to delete.
     * @example
     * // Delete a few Extra_data
     * const { count } = await prisma.extra_data.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends extra_dataDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, extra_dataDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Extra_data.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {extra_dataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Extra_data
     * const extra_data = await prisma.extra_data.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends extra_dataUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, extra_dataUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Extra_data.
     * @param {extra_dataUpsertArgs} args - Arguments to update or create a Extra_data.
     * @example
     * // Update or create a Extra_data
     * const extra_data = await prisma.extra_data.upsert({
     *   create: {
     *     // ... data to create a Extra_data
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Extra_data we want to update
     *   }
     * })
    **/
    upsert<T extends extra_dataUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, extra_dataUpsertArgs<ExtArgs>>
    ): Prisma__extra_dataClient<$Result.GetResult<Prisma.$extra_dataPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Extra_data.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {extra_dataCountArgs} args - Arguments to filter Extra_data to count.
     * @example
     * // Count the number of Extra_data
     * const count = await prisma.extra_data.count({
     *   where: {
     *     // ... the filter for the Extra_data we want to count
     *   }
     * })
    **/
    count<T extends extra_dataCountArgs>(
      args?: Subset<T, extra_dataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Extra_dataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Extra_data.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Extra_dataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Extra_dataAggregateArgs>(args: Subset<T, Extra_dataAggregateArgs>): Prisma.PrismaPromise<GetExtra_dataAggregateType<T>>

    /**
     * Group by Extra_data.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {extra_dataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends extra_dataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: extra_dataGroupByArgs['orderBy'] }
        : { orderBy?: extra_dataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, extra_dataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExtra_dataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the extra_data model
   */
  readonly fields: extra_dataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for extra_data.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__extra_dataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    users<T extends extra_data$usersArgs<ExtArgs> = {}>(args?: Subset<T, extra_data$usersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the extra_data model
   */ 
  interface extra_dataFieldRefs {
    readonly name: FieldRef<"extra_data", 'String'>
    readonly value: FieldRef<"extra_data", 'Json'>
    readonly user_id: FieldRef<"extra_data", 'BigInt'>
    readonly lynxtag: FieldRef<"extra_data", 'String'>
  }
    

  // Custom InputTypes

  /**
   * extra_data findUnique
   */
  export type extra_dataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the extra_data
     */
    select?: extra_dataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: extra_dataInclude<ExtArgs> | null
    /**
     * Filter, which extra_data to fetch.
     */
    where: extra_dataWhereUniqueInput
  }


  /**
   * extra_data findUniqueOrThrow
   */
  export type extra_dataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the extra_data
     */
    select?: extra_dataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: extra_dataInclude<ExtArgs> | null
    /**
     * Filter, which extra_data to fetch.
     */
    where: extra_dataWhereUniqueInput
  }


  /**
   * extra_data findFirst
   */
  export type extra_dataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the extra_data
     */
    select?: extra_dataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: extra_dataInclude<ExtArgs> | null
    /**
     * Filter, which extra_data to fetch.
     */
    where?: extra_dataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of extra_data to fetch.
     */
    orderBy?: extra_dataOrderByWithRelationInput | extra_dataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for extra_data.
     */
    cursor?: extra_dataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` extra_data from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` extra_data.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of extra_data.
     */
    distinct?: Extra_dataScalarFieldEnum | Extra_dataScalarFieldEnum[]
  }


  /**
   * extra_data findFirstOrThrow
   */
  export type extra_dataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the extra_data
     */
    select?: extra_dataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: extra_dataInclude<ExtArgs> | null
    /**
     * Filter, which extra_data to fetch.
     */
    where?: extra_dataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of extra_data to fetch.
     */
    orderBy?: extra_dataOrderByWithRelationInput | extra_dataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for extra_data.
     */
    cursor?: extra_dataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` extra_data from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` extra_data.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of extra_data.
     */
    distinct?: Extra_dataScalarFieldEnum | Extra_dataScalarFieldEnum[]
  }


  /**
   * extra_data findMany
   */
  export type extra_dataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the extra_data
     */
    select?: extra_dataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: extra_dataInclude<ExtArgs> | null
    /**
     * Filter, which extra_data to fetch.
     */
    where?: extra_dataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of extra_data to fetch.
     */
    orderBy?: extra_dataOrderByWithRelationInput | extra_dataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing extra_data.
     */
    cursor?: extra_dataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` extra_data from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` extra_data.
     */
    skip?: number
    distinct?: Extra_dataScalarFieldEnum | Extra_dataScalarFieldEnum[]
  }


  /**
   * extra_data create
   */
  export type extra_dataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the extra_data
     */
    select?: extra_dataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: extra_dataInclude<ExtArgs> | null
    /**
     * The data needed to create a extra_data.
     */
    data?: XOR<extra_dataCreateInput, extra_dataUncheckedCreateInput>
  }


  /**
   * extra_data createMany
   */
  export type extra_dataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many extra_data.
     */
    data: extra_dataCreateManyInput | extra_dataCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * extra_data update
   */
  export type extra_dataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the extra_data
     */
    select?: extra_dataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: extra_dataInclude<ExtArgs> | null
    /**
     * The data needed to update a extra_data.
     */
    data: XOR<extra_dataUpdateInput, extra_dataUncheckedUpdateInput>
    /**
     * Choose, which extra_data to update.
     */
    where: extra_dataWhereUniqueInput
  }


  /**
   * extra_data updateMany
   */
  export type extra_dataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update extra_data.
     */
    data: XOR<extra_dataUpdateManyMutationInput, extra_dataUncheckedUpdateManyInput>
    /**
     * Filter which extra_data to update
     */
    where?: extra_dataWhereInput
  }


  /**
   * extra_data upsert
   */
  export type extra_dataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the extra_data
     */
    select?: extra_dataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: extra_dataInclude<ExtArgs> | null
    /**
     * The filter to search for the extra_data to update in case it exists.
     */
    where: extra_dataWhereUniqueInput
    /**
     * In case the extra_data found by the `where` argument doesn't exist, create a new extra_data with this data.
     */
    create: XOR<extra_dataCreateInput, extra_dataUncheckedCreateInput>
    /**
     * In case the extra_data was found with the provided `where` argument, update it with this data.
     */
    update: XOR<extra_dataUpdateInput, extra_dataUncheckedUpdateInput>
  }


  /**
   * extra_data delete
   */
  export type extra_dataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the extra_data
     */
    select?: extra_dataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: extra_dataInclude<ExtArgs> | null
    /**
     * Filter which extra_data to delete.
     */
    where: extra_dataWhereUniqueInput
  }


  /**
   * extra_data deleteMany
   */
  export type extra_dataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which extra_data to delete
     */
    where?: extra_dataWhereInput
  }


  /**
   * extra_data.users
   */
  export type extra_data$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }


  /**
   * extra_data without action
   */
  export type extra_dataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the extra_data
     */
    select?: extra_dataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: extra_dataInclude<ExtArgs> | null
  }



  /**
   * Model features
   */

  export type AggregateFeatures = {
    _count: FeaturesCountAggregateOutputType | null
    _min: FeaturesMinAggregateOutputType | null
    _max: FeaturesMaxAggregateOutputType | null
  }

  export type FeaturesMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    viewed_as: string | null
    lynxtag: string | null
  }

  export type FeaturesMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    viewed_as: string | null
    lynxtag: string | null
  }

  export type FeaturesCountAggregateOutputType = {
    id: number
    name: number
    description: number
    viewed_as: number
    lynxtag: number
    _all: number
  }


  export type FeaturesMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    viewed_as?: true
    lynxtag?: true
  }

  export type FeaturesMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    viewed_as?: true
    lynxtag?: true
  }

  export type FeaturesCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    viewed_as?: true
    lynxtag?: true
    _all?: true
  }

  export type FeaturesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which features to aggregate.
     */
    where?: featuresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of features to fetch.
     */
    orderBy?: featuresOrderByWithRelationInput | featuresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: featuresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` features from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` features.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned features
    **/
    _count?: true | FeaturesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeaturesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeaturesMaxAggregateInputType
  }

  export type GetFeaturesAggregateType<T extends FeaturesAggregateArgs> = {
        [P in keyof T & keyof AggregateFeatures]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeatures[P]>
      : GetScalarType<T[P], AggregateFeatures[P]>
  }




  export type featuresGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: featuresWhereInput
    orderBy?: featuresOrderByWithAggregationInput | featuresOrderByWithAggregationInput[]
    by: FeaturesScalarFieldEnum[] | FeaturesScalarFieldEnum
    having?: featuresScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeaturesCountAggregateInputType | true
    _min?: FeaturesMinAggregateInputType
    _max?: FeaturesMaxAggregateInputType
  }

  export type FeaturesGroupByOutputType = {
    id: string
    name: string
    description: string
    viewed_as: string
    lynxtag: string
    _count: FeaturesCountAggregateOutputType | null
    _min: FeaturesMinAggregateOutputType | null
    _max: FeaturesMaxAggregateOutputType | null
  }

  type GetFeaturesGroupByPayload<T extends featuresGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeaturesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeaturesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeaturesGroupByOutputType[P]>
            : GetScalarType<T[P], FeaturesGroupByOutputType[P]>
        }
      >
    >


  export type featuresSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    viewed_as?: boolean
    lynxtag?: boolean
  }, ExtArgs["result"]["features"]>

  export type featuresSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    viewed_as?: boolean
    lynxtag?: boolean
  }


  export type $featuresPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "features"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      viewed_as: string
      lynxtag: string
    }, ExtArgs["result"]["features"]>
    composites: {}
  }


  type featuresGetPayload<S extends boolean | null | undefined | featuresDefaultArgs> = $Result.GetResult<Prisma.$featuresPayload, S>

  type featuresCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<featuresFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FeaturesCountAggregateInputType | true
    }

  export interface featuresDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['features'], meta: { name: 'features' } }
    /**
     * Find zero or one Features that matches the filter.
     * @param {featuresFindUniqueArgs} args - Arguments to find a Features
     * @example
     * // Get one Features
     * const features = await prisma.features.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends featuresFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, featuresFindUniqueArgs<ExtArgs>>
    ): Prisma__featuresClient<$Result.GetResult<Prisma.$featuresPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Features that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {featuresFindUniqueOrThrowArgs} args - Arguments to find a Features
     * @example
     * // Get one Features
     * const features = await prisma.features.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends featuresFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, featuresFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__featuresClient<$Result.GetResult<Prisma.$featuresPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Features that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {featuresFindFirstArgs} args - Arguments to find a Features
     * @example
     * // Get one Features
     * const features = await prisma.features.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends featuresFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, featuresFindFirstArgs<ExtArgs>>
    ): Prisma__featuresClient<$Result.GetResult<Prisma.$featuresPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Features that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {featuresFindFirstOrThrowArgs} args - Arguments to find a Features
     * @example
     * // Get one Features
     * const features = await prisma.features.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends featuresFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, featuresFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__featuresClient<$Result.GetResult<Prisma.$featuresPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Features that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {featuresFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Features
     * const features = await prisma.features.findMany()
     * 
     * // Get first 10 Features
     * const features = await prisma.features.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const featuresWithIdOnly = await prisma.features.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends featuresFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, featuresFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$featuresPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Features.
     * @param {featuresCreateArgs} args - Arguments to create a Features.
     * @example
     * // Create one Features
     * const Features = await prisma.features.create({
     *   data: {
     *     // ... data to create a Features
     *   }
     * })
     * 
    **/
    create<T extends featuresCreateArgs<ExtArgs>>(
      args: SelectSubset<T, featuresCreateArgs<ExtArgs>>
    ): Prisma__featuresClient<$Result.GetResult<Prisma.$featuresPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Features.
     *     @param {featuresCreateManyArgs} args - Arguments to create many Features.
     *     @example
     *     // Create many Features
     *     const features = await prisma.features.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends featuresCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, featuresCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Features.
     * @param {featuresDeleteArgs} args - Arguments to delete one Features.
     * @example
     * // Delete one Features
     * const Features = await prisma.features.delete({
     *   where: {
     *     // ... filter to delete one Features
     *   }
     * })
     * 
    **/
    delete<T extends featuresDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, featuresDeleteArgs<ExtArgs>>
    ): Prisma__featuresClient<$Result.GetResult<Prisma.$featuresPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Features.
     * @param {featuresUpdateArgs} args - Arguments to update one Features.
     * @example
     * // Update one Features
     * const features = await prisma.features.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends featuresUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, featuresUpdateArgs<ExtArgs>>
    ): Prisma__featuresClient<$Result.GetResult<Prisma.$featuresPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Features.
     * @param {featuresDeleteManyArgs} args - Arguments to filter Features to delete.
     * @example
     * // Delete a few Features
     * const { count } = await prisma.features.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends featuresDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, featuresDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Features.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {featuresUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Features
     * const features = await prisma.features.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends featuresUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, featuresUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Features.
     * @param {featuresUpsertArgs} args - Arguments to update or create a Features.
     * @example
     * // Update or create a Features
     * const features = await prisma.features.upsert({
     *   create: {
     *     // ... data to create a Features
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Features we want to update
     *   }
     * })
    **/
    upsert<T extends featuresUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, featuresUpsertArgs<ExtArgs>>
    ): Prisma__featuresClient<$Result.GetResult<Prisma.$featuresPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Features.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {featuresCountArgs} args - Arguments to filter Features to count.
     * @example
     * // Count the number of Features
     * const count = await prisma.features.count({
     *   where: {
     *     // ... the filter for the Features we want to count
     *   }
     * })
    **/
    count<T extends featuresCountArgs>(
      args?: Subset<T, featuresCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeaturesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Features.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeaturesAggregateArgs>(args: Subset<T, FeaturesAggregateArgs>): Prisma.PrismaPromise<GetFeaturesAggregateType<T>>

    /**
     * Group by Features.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {featuresGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends featuresGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: featuresGroupByArgs['orderBy'] }
        : { orderBy?: featuresGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, featuresGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeaturesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the features model
   */
  readonly fields: featuresFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for features.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__featuresClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the features model
   */ 
  interface featuresFieldRefs {
    readonly id: FieldRef<"features", 'String'>
    readonly name: FieldRef<"features", 'String'>
    readonly description: FieldRef<"features", 'String'>
    readonly viewed_as: FieldRef<"features", 'String'>
    readonly lynxtag: FieldRef<"features", 'String'>
  }
    

  // Custom InputTypes

  /**
   * features findUnique
   */
  export type featuresFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the features
     */
    select?: featuresSelect<ExtArgs> | null
    /**
     * Filter, which features to fetch.
     */
    where: featuresWhereUniqueInput
  }


  /**
   * features findUniqueOrThrow
   */
  export type featuresFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the features
     */
    select?: featuresSelect<ExtArgs> | null
    /**
     * Filter, which features to fetch.
     */
    where: featuresWhereUniqueInput
  }


  /**
   * features findFirst
   */
  export type featuresFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the features
     */
    select?: featuresSelect<ExtArgs> | null
    /**
     * Filter, which features to fetch.
     */
    where?: featuresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of features to fetch.
     */
    orderBy?: featuresOrderByWithRelationInput | featuresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for features.
     */
    cursor?: featuresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` features from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` features.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of features.
     */
    distinct?: FeaturesScalarFieldEnum | FeaturesScalarFieldEnum[]
  }


  /**
   * features findFirstOrThrow
   */
  export type featuresFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the features
     */
    select?: featuresSelect<ExtArgs> | null
    /**
     * Filter, which features to fetch.
     */
    where?: featuresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of features to fetch.
     */
    orderBy?: featuresOrderByWithRelationInput | featuresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for features.
     */
    cursor?: featuresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` features from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` features.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of features.
     */
    distinct?: FeaturesScalarFieldEnum | FeaturesScalarFieldEnum[]
  }


  /**
   * features findMany
   */
  export type featuresFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the features
     */
    select?: featuresSelect<ExtArgs> | null
    /**
     * Filter, which features to fetch.
     */
    where?: featuresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of features to fetch.
     */
    orderBy?: featuresOrderByWithRelationInput | featuresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing features.
     */
    cursor?: featuresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` features from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` features.
     */
    skip?: number
    distinct?: FeaturesScalarFieldEnum | FeaturesScalarFieldEnum[]
  }


  /**
   * features create
   */
  export type featuresCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the features
     */
    select?: featuresSelect<ExtArgs> | null
    /**
     * The data needed to create a features.
     */
    data: XOR<featuresCreateInput, featuresUncheckedCreateInput>
  }


  /**
   * features createMany
   */
  export type featuresCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many features.
     */
    data: featuresCreateManyInput | featuresCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * features update
   */
  export type featuresUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the features
     */
    select?: featuresSelect<ExtArgs> | null
    /**
     * The data needed to update a features.
     */
    data: XOR<featuresUpdateInput, featuresUncheckedUpdateInput>
    /**
     * Choose, which features to update.
     */
    where: featuresWhereUniqueInput
  }


  /**
   * features updateMany
   */
  export type featuresUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update features.
     */
    data: XOR<featuresUpdateManyMutationInput, featuresUncheckedUpdateManyInput>
    /**
     * Filter which features to update
     */
    where?: featuresWhereInput
  }


  /**
   * features upsert
   */
  export type featuresUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the features
     */
    select?: featuresSelect<ExtArgs> | null
    /**
     * The filter to search for the features to update in case it exists.
     */
    where: featuresWhereUniqueInput
    /**
     * In case the features found by the `where` argument doesn't exist, create a new features with this data.
     */
    create: XOR<featuresCreateInput, featuresUncheckedCreateInput>
    /**
     * In case the features was found with the provided `where` argument, update it with this data.
     */
    update: XOR<featuresUpdateInput, featuresUncheckedUpdateInput>
  }


  /**
   * features delete
   */
  export type featuresDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the features
     */
    select?: featuresSelect<ExtArgs> | null
    /**
     * Filter which features to delete.
     */
    where: featuresWhereUniqueInput
  }


  /**
   * features deleteMany
   */
  export type featuresDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which features to delete
     */
    where?: featuresWhereInput
  }


  /**
   * features without action
   */
  export type featuresDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the features
     */
    select?: featuresSelect<ExtArgs> | null
  }



  /**
   * Model frostpaw_clients
   */

  export type AggregateFrostpaw_clients = {
    _count: Frostpaw_clientsCountAggregateOutputType | null
    _avg: Frostpaw_clientsAvgAggregateOutputType | null
    _sum: Frostpaw_clientsSumAggregateOutputType | null
    _min: Frostpaw_clientsMinAggregateOutputType | null
    _max: Frostpaw_clientsMaxAggregateOutputType | null
  }

  export type Frostpaw_clientsAvgAggregateOutputType = {
    owner_id: number | null
  }

  export type Frostpaw_clientsSumAggregateOutputType = {
    owner_id: bigint | null
  }

  export type Frostpaw_clientsMinAggregateOutputType = {
    id: string | null
    name: string | null
    domain: string | null
    privacy_policy: string | null
    secret: string | null
    owner_id: bigint | null
    lynxtag: string | null
    verified: boolean | null
  }

  export type Frostpaw_clientsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    domain: string | null
    privacy_policy: string | null
    secret: string | null
    owner_id: bigint | null
    lynxtag: string | null
    verified: boolean | null
  }

  export type Frostpaw_clientsCountAggregateOutputType = {
    id: number
    name: number
    domain: number
    privacy_policy: number
    secret: number
    owner_id: number
    lynxtag: number
    verified: number
    _all: number
  }


  export type Frostpaw_clientsAvgAggregateInputType = {
    owner_id?: true
  }

  export type Frostpaw_clientsSumAggregateInputType = {
    owner_id?: true
  }

  export type Frostpaw_clientsMinAggregateInputType = {
    id?: true
    name?: true
    domain?: true
    privacy_policy?: true
    secret?: true
    owner_id?: true
    lynxtag?: true
    verified?: true
  }

  export type Frostpaw_clientsMaxAggregateInputType = {
    id?: true
    name?: true
    domain?: true
    privacy_policy?: true
    secret?: true
    owner_id?: true
    lynxtag?: true
    verified?: true
  }

  export type Frostpaw_clientsCountAggregateInputType = {
    id?: true
    name?: true
    domain?: true
    privacy_policy?: true
    secret?: true
    owner_id?: true
    lynxtag?: true
    verified?: true
    _all?: true
  }

  export type Frostpaw_clientsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which frostpaw_clients to aggregate.
     */
    where?: frostpaw_clientsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of frostpaw_clients to fetch.
     */
    orderBy?: frostpaw_clientsOrderByWithRelationInput | frostpaw_clientsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: frostpaw_clientsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` frostpaw_clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` frostpaw_clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned frostpaw_clients
    **/
    _count?: true | Frostpaw_clientsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Frostpaw_clientsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Frostpaw_clientsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Frostpaw_clientsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Frostpaw_clientsMaxAggregateInputType
  }

  export type GetFrostpaw_clientsAggregateType<T extends Frostpaw_clientsAggregateArgs> = {
        [P in keyof T & keyof AggregateFrostpaw_clients]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFrostpaw_clients[P]>
      : GetScalarType<T[P], AggregateFrostpaw_clients[P]>
  }




  export type frostpaw_clientsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: frostpaw_clientsWhereInput
    orderBy?: frostpaw_clientsOrderByWithAggregationInput | frostpaw_clientsOrderByWithAggregationInput[]
    by: Frostpaw_clientsScalarFieldEnum[] | Frostpaw_clientsScalarFieldEnum
    having?: frostpaw_clientsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Frostpaw_clientsCountAggregateInputType | true
    _avg?: Frostpaw_clientsAvgAggregateInputType
    _sum?: Frostpaw_clientsSumAggregateInputType
    _min?: Frostpaw_clientsMinAggregateInputType
    _max?: Frostpaw_clientsMaxAggregateInputType
  }

  export type Frostpaw_clientsGroupByOutputType = {
    id: string
    name: string
    domain: string
    privacy_policy: string
    secret: string
    owner_id: bigint
    lynxtag: string
    verified: boolean
    _count: Frostpaw_clientsCountAggregateOutputType | null
    _avg: Frostpaw_clientsAvgAggregateOutputType | null
    _sum: Frostpaw_clientsSumAggregateOutputType | null
    _min: Frostpaw_clientsMinAggregateOutputType | null
    _max: Frostpaw_clientsMaxAggregateOutputType | null
  }

  type GetFrostpaw_clientsGroupByPayload<T extends frostpaw_clientsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Frostpaw_clientsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Frostpaw_clientsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Frostpaw_clientsGroupByOutputType[P]>
            : GetScalarType<T[P], Frostpaw_clientsGroupByOutputType[P]>
        }
      >
    >


  export type frostpaw_clientsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    domain?: boolean
    privacy_policy?: boolean
    secret?: boolean
    owner_id?: boolean
    lynxtag?: boolean
    verified?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["frostpaw_clients"]>

  export type frostpaw_clientsSelectScalar = {
    id?: boolean
    name?: boolean
    domain?: boolean
    privacy_policy?: boolean
    secret?: boolean
    owner_id?: boolean
    lynxtag?: boolean
    verified?: boolean
  }

  export type frostpaw_clientsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }


  export type $frostpaw_clientsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "frostpaw_clients"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      domain: string
      privacy_policy: string
      secret: string
      owner_id: bigint
      lynxtag: string
      verified: boolean
    }, ExtArgs["result"]["frostpaw_clients"]>
    composites: {}
  }


  type frostpaw_clientsGetPayload<S extends boolean | null | undefined | frostpaw_clientsDefaultArgs> = $Result.GetResult<Prisma.$frostpaw_clientsPayload, S>

  type frostpaw_clientsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<frostpaw_clientsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Frostpaw_clientsCountAggregateInputType | true
    }

  export interface frostpaw_clientsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['frostpaw_clients'], meta: { name: 'frostpaw_clients' } }
    /**
     * Find zero or one Frostpaw_clients that matches the filter.
     * @param {frostpaw_clientsFindUniqueArgs} args - Arguments to find a Frostpaw_clients
     * @example
     * // Get one Frostpaw_clients
     * const frostpaw_clients = await prisma.frostpaw_clients.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends frostpaw_clientsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, frostpaw_clientsFindUniqueArgs<ExtArgs>>
    ): Prisma__frostpaw_clientsClient<$Result.GetResult<Prisma.$frostpaw_clientsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Frostpaw_clients that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {frostpaw_clientsFindUniqueOrThrowArgs} args - Arguments to find a Frostpaw_clients
     * @example
     * // Get one Frostpaw_clients
     * const frostpaw_clients = await prisma.frostpaw_clients.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends frostpaw_clientsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, frostpaw_clientsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__frostpaw_clientsClient<$Result.GetResult<Prisma.$frostpaw_clientsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Frostpaw_clients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {frostpaw_clientsFindFirstArgs} args - Arguments to find a Frostpaw_clients
     * @example
     * // Get one Frostpaw_clients
     * const frostpaw_clients = await prisma.frostpaw_clients.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends frostpaw_clientsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, frostpaw_clientsFindFirstArgs<ExtArgs>>
    ): Prisma__frostpaw_clientsClient<$Result.GetResult<Prisma.$frostpaw_clientsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Frostpaw_clients that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {frostpaw_clientsFindFirstOrThrowArgs} args - Arguments to find a Frostpaw_clients
     * @example
     * // Get one Frostpaw_clients
     * const frostpaw_clients = await prisma.frostpaw_clients.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends frostpaw_clientsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, frostpaw_clientsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__frostpaw_clientsClient<$Result.GetResult<Prisma.$frostpaw_clientsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Frostpaw_clients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {frostpaw_clientsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Frostpaw_clients
     * const frostpaw_clients = await prisma.frostpaw_clients.findMany()
     * 
     * // Get first 10 Frostpaw_clients
     * const frostpaw_clients = await prisma.frostpaw_clients.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const frostpaw_clientsWithIdOnly = await prisma.frostpaw_clients.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends frostpaw_clientsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, frostpaw_clientsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$frostpaw_clientsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Frostpaw_clients.
     * @param {frostpaw_clientsCreateArgs} args - Arguments to create a Frostpaw_clients.
     * @example
     * // Create one Frostpaw_clients
     * const Frostpaw_clients = await prisma.frostpaw_clients.create({
     *   data: {
     *     // ... data to create a Frostpaw_clients
     *   }
     * })
     * 
    **/
    create<T extends frostpaw_clientsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, frostpaw_clientsCreateArgs<ExtArgs>>
    ): Prisma__frostpaw_clientsClient<$Result.GetResult<Prisma.$frostpaw_clientsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Frostpaw_clients.
     *     @param {frostpaw_clientsCreateManyArgs} args - Arguments to create many Frostpaw_clients.
     *     @example
     *     // Create many Frostpaw_clients
     *     const frostpaw_clients = await prisma.frostpaw_clients.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends frostpaw_clientsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, frostpaw_clientsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Frostpaw_clients.
     * @param {frostpaw_clientsDeleteArgs} args - Arguments to delete one Frostpaw_clients.
     * @example
     * // Delete one Frostpaw_clients
     * const Frostpaw_clients = await prisma.frostpaw_clients.delete({
     *   where: {
     *     // ... filter to delete one Frostpaw_clients
     *   }
     * })
     * 
    **/
    delete<T extends frostpaw_clientsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, frostpaw_clientsDeleteArgs<ExtArgs>>
    ): Prisma__frostpaw_clientsClient<$Result.GetResult<Prisma.$frostpaw_clientsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Frostpaw_clients.
     * @param {frostpaw_clientsUpdateArgs} args - Arguments to update one Frostpaw_clients.
     * @example
     * // Update one Frostpaw_clients
     * const frostpaw_clients = await prisma.frostpaw_clients.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends frostpaw_clientsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, frostpaw_clientsUpdateArgs<ExtArgs>>
    ): Prisma__frostpaw_clientsClient<$Result.GetResult<Prisma.$frostpaw_clientsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Frostpaw_clients.
     * @param {frostpaw_clientsDeleteManyArgs} args - Arguments to filter Frostpaw_clients to delete.
     * @example
     * // Delete a few Frostpaw_clients
     * const { count } = await prisma.frostpaw_clients.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends frostpaw_clientsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, frostpaw_clientsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Frostpaw_clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {frostpaw_clientsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Frostpaw_clients
     * const frostpaw_clients = await prisma.frostpaw_clients.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends frostpaw_clientsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, frostpaw_clientsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Frostpaw_clients.
     * @param {frostpaw_clientsUpsertArgs} args - Arguments to update or create a Frostpaw_clients.
     * @example
     * // Update or create a Frostpaw_clients
     * const frostpaw_clients = await prisma.frostpaw_clients.upsert({
     *   create: {
     *     // ... data to create a Frostpaw_clients
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Frostpaw_clients we want to update
     *   }
     * })
    **/
    upsert<T extends frostpaw_clientsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, frostpaw_clientsUpsertArgs<ExtArgs>>
    ): Prisma__frostpaw_clientsClient<$Result.GetResult<Prisma.$frostpaw_clientsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Frostpaw_clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {frostpaw_clientsCountArgs} args - Arguments to filter Frostpaw_clients to count.
     * @example
     * // Count the number of Frostpaw_clients
     * const count = await prisma.frostpaw_clients.count({
     *   where: {
     *     // ... the filter for the Frostpaw_clients we want to count
     *   }
     * })
    **/
    count<T extends frostpaw_clientsCountArgs>(
      args?: Subset<T, frostpaw_clientsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Frostpaw_clientsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Frostpaw_clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Frostpaw_clientsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Frostpaw_clientsAggregateArgs>(args: Subset<T, Frostpaw_clientsAggregateArgs>): Prisma.PrismaPromise<GetFrostpaw_clientsAggregateType<T>>

    /**
     * Group by Frostpaw_clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {frostpaw_clientsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends frostpaw_clientsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: frostpaw_clientsGroupByArgs['orderBy'] }
        : { orderBy?: frostpaw_clientsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, frostpaw_clientsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFrostpaw_clientsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the frostpaw_clients model
   */
  readonly fields: frostpaw_clientsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for frostpaw_clients.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__frostpaw_clientsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the frostpaw_clients model
   */ 
  interface frostpaw_clientsFieldRefs {
    readonly id: FieldRef<"frostpaw_clients", 'String'>
    readonly name: FieldRef<"frostpaw_clients", 'String'>
    readonly domain: FieldRef<"frostpaw_clients", 'String'>
    readonly privacy_policy: FieldRef<"frostpaw_clients", 'String'>
    readonly secret: FieldRef<"frostpaw_clients", 'String'>
    readonly owner_id: FieldRef<"frostpaw_clients", 'BigInt'>
    readonly lynxtag: FieldRef<"frostpaw_clients", 'String'>
    readonly verified: FieldRef<"frostpaw_clients", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * frostpaw_clients findUnique
   */
  export type frostpaw_clientsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the frostpaw_clients
     */
    select?: frostpaw_clientsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: frostpaw_clientsInclude<ExtArgs> | null
    /**
     * Filter, which frostpaw_clients to fetch.
     */
    where: frostpaw_clientsWhereUniqueInput
  }


  /**
   * frostpaw_clients findUniqueOrThrow
   */
  export type frostpaw_clientsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the frostpaw_clients
     */
    select?: frostpaw_clientsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: frostpaw_clientsInclude<ExtArgs> | null
    /**
     * Filter, which frostpaw_clients to fetch.
     */
    where: frostpaw_clientsWhereUniqueInput
  }


  /**
   * frostpaw_clients findFirst
   */
  export type frostpaw_clientsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the frostpaw_clients
     */
    select?: frostpaw_clientsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: frostpaw_clientsInclude<ExtArgs> | null
    /**
     * Filter, which frostpaw_clients to fetch.
     */
    where?: frostpaw_clientsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of frostpaw_clients to fetch.
     */
    orderBy?: frostpaw_clientsOrderByWithRelationInput | frostpaw_clientsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for frostpaw_clients.
     */
    cursor?: frostpaw_clientsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` frostpaw_clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` frostpaw_clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of frostpaw_clients.
     */
    distinct?: Frostpaw_clientsScalarFieldEnum | Frostpaw_clientsScalarFieldEnum[]
  }


  /**
   * frostpaw_clients findFirstOrThrow
   */
  export type frostpaw_clientsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the frostpaw_clients
     */
    select?: frostpaw_clientsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: frostpaw_clientsInclude<ExtArgs> | null
    /**
     * Filter, which frostpaw_clients to fetch.
     */
    where?: frostpaw_clientsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of frostpaw_clients to fetch.
     */
    orderBy?: frostpaw_clientsOrderByWithRelationInput | frostpaw_clientsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for frostpaw_clients.
     */
    cursor?: frostpaw_clientsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` frostpaw_clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` frostpaw_clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of frostpaw_clients.
     */
    distinct?: Frostpaw_clientsScalarFieldEnum | Frostpaw_clientsScalarFieldEnum[]
  }


  /**
   * frostpaw_clients findMany
   */
  export type frostpaw_clientsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the frostpaw_clients
     */
    select?: frostpaw_clientsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: frostpaw_clientsInclude<ExtArgs> | null
    /**
     * Filter, which frostpaw_clients to fetch.
     */
    where?: frostpaw_clientsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of frostpaw_clients to fetch.
     */
    orderBy?: frostpaw_clientsOrderByWithRelationInput | frostpaw_clientsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing frostpaw_clients.
     */
    cursor?: frostpaw_clientsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` frostpaw_clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` frostpaw_clients.
     */
    skip?: number
    distinct?: Frostpaw_clientsScalarFieldEnum | Frostpaw_clientsScalarFieldEnum[]
  }


  /**
   * frostpaw_clients create
   */
  export type frostpaw_clientsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the frostpaw_clients
     */
    select?: frostpaw_clientsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: frostpaw_clientsInclude<ExtArgs> | null
    /**
     * The data needed to create a frostpaw_clients.
     */
    data: XOR<frostpaw_clientsCreateInput, frostpaw_clientsUncheckedCreateInput>
  }


  /**
   * frostpaw_clients createMany
   */
  export type frostpaw_clientsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many frostpaw_clients.
     */
    data: frostpaw_clientsCreateManyInput | frostpaw_clientsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * frostpaw_clients update
   */
  export type frostpaw_clientsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the frostpaw_clients
     */
    select?: frostpaw_clientsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: frostpaw_clientsInclude<ExtArgs> | null
    /**
     * The data needed to update a frostpaw_clients.
     */
    data: XOR<frostpaw_clientsUpdateInput, frostpaw_clientsUncheckedUpdateInput>
    /**
     * Choose, which frostpaw_clients to update.
     */
    where: frostpaw_clientsWhereUniqueInput
  }


  /**
   * frostpaw_clients updateMany
   */
  export type frostpaw_clientsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update frostpaw_clients.
     */
    data: XOR<frostpaw_clientsUpdateManyMutationInput, frostpaw_clientsUncheckedUpdateManyInput>
    /**
     * Filter which frostpaw_clients to update
     */
    where?: frostpaw_clientsWhereInput
  }


  /**
   * frostpaw_clients upsert
   */
  export type frostpaw_clientsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the frostpaw_clients
     */
    select?: frostpaw_clientsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: frostpaw_clientsInclude<ExtArgs> | null
    /**
     * The filter to search for the frostpaw_clients to update in case it exists.
     */
    where: frostpaw_clientsWhereUniqueInput
    /**
     * In case the frostpaw_clients found by the `where` argument doesn't exist, create a new frostpaw_clients with this data.
     */
    create: XOR<frostpaw_clientsCreateInput, frostpaw_clientsUncheckedCreateInput>
    /**
     * In case the frostpaw_clients was found with the provided `where` argument, update it with this data.
     */
    update: XOR<frostpaw_clientsUpdateInput, frostpaw_clientsUncheckedUpdateInput>
  }


  /**
   * frostpaw_clients delete
   */
  export type frostpaw_clientsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the frostpaw_clients
     */
    select?: frostpaw_clientsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: frostpaw_clientsInclude<ExtArgs> | null
    /**
     * Filter which frostpaw_clients to delete.
     */
    where: frostpaw_clientsWhereUniqueInput
  }


  /**
   * frostpaw_clients deleteMany
   */
  export type frostpaw_clientsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which frostpaw_clients to delete
     */
    where?: frostpaw_clientsWhereInput
  }


  /**
   * frostpaw_clients without action
   */
  export type frostpaw_clientsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the frostpaw_clients
     */
    select?: frostpaw_clientsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: frostpaw_clientsInclude<ExtArgs> | null
  }



  /**
   * Model leave_of_absence
   */

  export type AggregateLeave_of_absence = {
    _count: Leave_of_absenceCountAggregateOutputType | null
    _avg: Leave_of_absenceAvgAggregateOutputType | null
    _sum: Leave_of_absenceSumAggregateOutputType | null
    _min: Leave_of_absenceMinAggregateOutputType | null
    _max: Leave_of_absenceMaxAggregateOutputType | null
  }

  export type Leave_of_absenceAvgAggregateOutputType = {
    user_id: number | null
    id: number | null
  }

  export type Leave_of_absenceSumAggregateOutputType = {
    user_id: bigint | null
    id: number | null
  }

  export type Leave_of_absenceMinAggregateOutputType = {
    reason: string | null
    start_date: Date | null
    user_id: bigint | null
    id: number | null
    lynxtag: string | null
  }

  export type Leave_of_absenceMaxAggregateOutputType = {
    reason: string | null
    start_date: Date | null
    user_id: bigint | null
    id: number | null
    lynxtag: string | null
  }

  export type Leave_of_absenceCountAggregateOutputType = {
    reason: number
    start_date: number
    user_id: number
    id: number
    lynxtag: number
    _all: number
  }


  export type Leave_of_absenceAvgAggregateInputType = {
    user_id?: true
    id?: true
  }

  export type Leave_of_absenceSumAggregateInputType = {
    user_id?: true
    id?: true
  }

  export type Leave_of_absenceMinAggregateInputType = {
    reason?: true
    start_date?: true
    user_id?: true
    id?: true
    lynxtag?: true
  }

  export type Leave_of_absenceMaxAggregateInputType = {
    reason?: true
    start_date?: true
    user_id?: true
    id?: true
    lynxtag?: true
  }

  export type Leave_of_absenceCountAggregateInputType = {
    reason?: true
    start_date?: true
    user_id?: true
    id?: true
    lynxtag?: true
    _all?: true
  }

  export type Leave_of_absenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which leave_of_absence to aggregate.
     */
    where?: leave_of_absenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of leave_of_absences to fetch.
     */
    orderBy?: leave_of_absenceOrderByWithRelationInput | leave_of_absenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: leave_of_absenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` leave_of_absences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` leave_of_absences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned leave_of_absences
    **/
    _count?: true | Leave_of_absenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Leave_of_absenceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Leave_of_absenceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Leave_of_absenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Leave_of_absenceMaxAggregateInputType
  }

  export type GetLeave_of_absenceAggregateType<T extends Leave_of_absenceAggregateArgs> = {
        [P in keyof T & keyof AggregateLeave_of_absence]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeave_of_absence[P]>
      : GetScalarType<T[P], AggregateLeave_of_absence[P]>
  }




  export type leave_of_absenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: leave_of_absenceWhereInput
    orderBy?: leave_of_absenceOrderByWithAggregationInput | leave_of_absenceOrderByWithAggregationInput[]
    by: Leave_of_absenceScalarFieldEnum[] | Leave_of_absenceScalarFieldEnum
    having?: leave_of_absenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Leave_of_absenceCountAggregateInputType | true
    _avg?: Leave_of_absenceAvgAggregateInputType
    _sum?: Leave_of_absenceSumAggregateInputType
    _min?: Leave_of_absenceMinAggregateInputType
    _max?: Leave_of_absenceMaxAggregateInputType
  }

  export type Leave_of_absenceGroupByOutputType = {
    reason: string | null
    start_date: Date | null
    user_id: bigint | null
    id: number
    lynxtag: string
    _count: Leave_of_absenceCountAggregateOutputType | null
    _avg: Leave_of_absenceAvgAggregateOutputType | null
    _sum: Leave_of_absenceSumAggregateOutputType | null
    _min: Leave_of_absenceMinAggregateOutputType | null
    _max: Leave_of_absenceMaxAggregateOutputType | null
  }

  type GetLeave_of_absenceGroupByPayload<T extends leave_of_absenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Leave_of_absenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Leave_of_absenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Leave_of_absenceGroupByOutputType[P]>
            : GetScalarType<T[P], Leave_of_absenceGroupByOutputType[P]>
        }
      >
    >


  export type leave_of_absenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    reason?: boolean
    start_date?: boolean
    user_id?: boolean
    id?: boolean
    lynxtag?: boolean
    users?: boolean | leave_of_absence$usersArgs<ExtArgs>
  }, ExtArgs["result"]["leave_of_absence"]>

  export type leave_of_absenceSelectScalar = {
    reason?: boolean
    start_date?: boolean
    user_id?: boolean
    id?: boolean
    lynxtag?: boolean
  }

  export type leave_of_absenceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | leave_of_absence$usersArgs<ExtArgs>
  }


  export type $leave_of_absencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "leave_of_absence"
    objects: {
      users: Prisma.$usersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      reason: string | null
      start_date: Date | null
      user_id: bigint | null
      id: number
      lynxtag: string
    }, ExtArgs["result"]["leave_of_absence"]>
    composites: {}
  }


  type leave_of_absenceGetPayload<S extends boolean | null | undefined | leave_of_absenceDefaultArgs> = $Result.GetResult<Prisma.$leave_of_absencePayload, S>

  type leave_of_absenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<leave_of_absenceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Leave_of_absenceCountAggregateInputType | true
    }

  export interface leave_of_absenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['leave_of_absence'], meta: { name: 'leave_of_absence' } }
    /**
     * Find zero or one Leave_of_absence that matches the filter.
     * @param {leave_of_absenceFindUniqueArgs} args - Arguments to find a Leave_of_absence
     * @example
     * // Get one Leave_of_absence
     * const leave_of_absence = await prisma.leave_of_absence.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends leave_of_absenceFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, leave_of_absenceFindUniqueArgs<ExtArgs>>
    ): Prisma__leave_of_absenceClient<$Result.GetResult<Prisma.$leave_of_absencePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Leave_of_absence that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {leave_of_absenceFindUniqueOrThrowArgs} args - Arguments to find a Leave_of_absence
     * @example
     * // Get one Leave_of_absence
     * const leave_of_absence = await prisma.leave_of_absence.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends leave_of_absenceFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, leave_of_absenceFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__leave_of_absenceClient<$Result.GetResult<Prisma.$leave_of_absencePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Leave_of_absence that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {leave_of_absenceFindFirstArgs} args - Arguments to find a Leave_of_absence
     * @example
     * // Get one Leave_of_absence
     * const leave_of_absence = await prisma.leave_of_absence.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends leave_of_absenceFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, leave_of_absenceFindFirstArgs<ExtArgs>>
    ): Prisma__leave_of_absenceClient<$Result.GetResult<Prisma.$leave_of_absencePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Leave_of_absence that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {leave_of_absenceFindFirstOrThrowArgs} args - Arguments to find a Leave_of_absence
     * @example
     * // Get one Leave_of_absence
     * const leave_of_absence = await prisma.leave_of_absence.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends leave_of_absenceFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, leave_of_absenceFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__leave_of_absenceClient<$Result.GetResult<Prisma.$leave_of_absencePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Leave_of_absences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {leave_of_absenceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Leave_of_absences
     * const leave_of_absences = await prisma.leave_of_absence.findMany()
     * 
     * // Get first 10 Leave_of_absences
     * const leave_of_absences = await prisma.leave_of_absence.findMany({ take: 10 })
     * 
     * // Only select the `reason`
     * const leave_of_absenceWithReasonOnly = await prisma.leave_of_absence.findMany({ select: { reason: true } })
     * 
    **/
    findMany<T extends leave_of_absenceFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, leave_of_absenceFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$leave_of_absencePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Leave_of_absence.
     * @param {leave_of_absenceCreateArgs} args - Arguments to create a Leave_of_absence.
     * @example
     * // Create one Leave_of_absence
     * const Leave_of_absence = await prisma.leave_of_absence.create({
     *   data: {
     *     // ... data to create a Leave_of_absence
     *   }
     * })
     * 
    **/
    create<T extends leave_of_absenceCreateArgs<ExtArgs>>(
      args: SelectSubset<T, leave_of_absenceCreateArgs<ExtArgs>>
    ): Prisma__leave_of_absenceClient<$Result.GetResult<Prisma.$leave_of_absencePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Leave_of_absences.
     *     @param {leave_of_absenceCreateManyArgs} args - Arguments to create many Leave_of_absences.
     *     @example
     *     // Create many Leave_of_absences
     *     const leave_of_absence = await prisma.leave_of_absence.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends leave_of_absenceCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, leave_of_absenceCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Leave_of_absence.
     * @param {leave_of_absenceDeleteArgs} args - Arguments to delete one Leave_of_absence.
     * @example
     * // Delete one Leave_of_absence
     * const Leave_of_absence = await prisma.leave_of_absence.delete({
     *   where: {
     *     // ... filter to delete one Leave_of_absence
     *   }
     * })
     * 
    **/
    delete<T extends leave_of_absenceDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, leave_of_absenceDeleteArgs<ExtArgs>>
    ): Prisma__leave_of_absenceClient<$Result.GetResult<Prisma.$leave_of_absencePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Leave_of_absence.
     * @param {leave_of_absenceUpdateArgs} args - Arguments to update one Leave_of_absence.
     * @example
     * // Update one Leave_of_absence
     * const leave_of_absence = await prisma.leave_of_absence.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends leave_of_absenceUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, leave_of_absenceUpdateArgs<ExtArgs>>
    ): Prisma__leave_of_absenceClient<$Result.GetResult<Prisma.$leave_of_absencePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Leave_of_absences.
     * @param {leave_of_absenceDeleteManyArgs} args - Arguments to filter Leave_of_absences to delete.
     * @example
     * // Delete a few Leave_of_absences
     * const { count } = await prisma.leave_of_absence.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends leave_of_absenceDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, leave_of_absenceDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leave_of_absences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {leave_of_absenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Leave_of_absences
     * const leave_of_absence = await prisma.leave_of_absence.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends leave_of_absenceUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, leave_of_absenceUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Leave_of_absence.
     * @param {leave_of_absenceUpsertArgs} args - Arguments to update or create a Leave_of_absence.
     * @example
     * // Update or create a Leave_of_absence
     * const leave_of_absence = await prisma.leave_of_absence.upsert({
     *   create: {
     *     // ... data to create a Leave_of_absence
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Leave_of_absence we want to update
     *   }
     * })
    **/
    upsert<T extends leave_of_absenceUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, leave_of_absenceUpsertArgs<ExtArgs>>
    ): Prisma__leave_of_absenceClient<$Result.GetResult<Prisma.$leave_of_absencePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Leave_of_absences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {leave_of_absenceCountArgs} args - Arguments to filter Leave_of_absences to count.
     * @example
     * // Count the number of Leave_of_absences
     * const count = await prisma.leave_of_absence.count({
     *   where: {
     *     // ... the filter for the Leave_of_absences we want to count
     *   }
     * })
    **/
    count<T extends leave_of_absenceCountArgs>(
      args?: Subset<T, leave_of_absenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Leave_of_absenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Leave_of_absence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Leave_of_absenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Leave_of_absenceAggregateArgs>(args: Subset<T, Leave_of_absenceAggregateArgs>): Prisma.PrismaPromise<GetLeave_of_absenceAggregateType<T>>

    /**
     * Group by Leave_of_absence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {leave_of_absenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends leave_of_absenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: leave_of_absenceGroupByArgs['orderBy'] }
        : { orderBy?: leave_of_absenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, leave_of_absenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeave_of_absenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the leave_of_absence model
   */
  readonly fields: leave_of_absenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for leave_of_absence.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__leave_of_absenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    users<T extends leave_of_absence$usersArgs<ExtArgs> = {}>(args?: Subset<T, leave_of_absence$usersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the leave_of_absence model
   */ 
  interface leave_of_absenceFieldRefs {
    readonly reason: FieldRef<"leave_of_absence", 'String'>
    readonly start_date: FieldRef<"leave_of_absence", 'DateTime'>
    readonly user_id: FieldRef<"leave_of_absence", 'BigInt'>
    readonly id: FieldRef<"leave_of_absence", 'Int'>
    readonly lynxtag: FieldRef<"leave_of_absence", 'String'>
  }
    

  // Custom InputTypes

  /**
   * leave_of_absence findUnique
   */
  export type leave_of_absenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the leave_of_absence
     */
    select?: leave_of_absenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: leave_of_absenceInclude<ExtArgs> | null
    /**
     * Filter, which leave_of_absence to fetch.
     */
    where: leave_of_absenceWhereUniqueInput
  }


  /**
   * leave_of_absence findUniqueOrThrow
   */
  export type leave_of_absenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the leave_of_absence
     */
    select?: leave_of_absenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: leave_of_absenceInclude<ExtArgs> | null
    /**
     * Filter, which leave_of_absence to fetch.
     */
    where: leave_of_absenceWhereUniqueInput
  }


  /**
   * leave_of_absence findFirst
   */
  export type leave_of_absenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the leave_of_absence
     */
    select?: leave_of_absenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: leave_of_absenceInclude<ExtArgs> | null
    /**
     * Filter, which leave_of_absence to fetch.
     */
    where?: leave_of_absenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of leave_of_absences to fetch.
     */
    orderBy?: leave_of_absenceOrderByWithRelationInput | leave_of_absenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for leave_of_absences.
     */
    cursor?: leave_of_absenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` leave_of_absences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` leave_of_absences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of leave_of_absences.
     */
    distinct?: Leave_of_absenceScalarFieldEnum | Leave_of_absenceScalarFieldEnum[]
  }


  /**
   * leave_of_absence findFirstOrThrow
   */
  export type leave_of_absenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the leave_of_absence
     */
    select?: leave_of_absenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: leave_of_absenceInclude<ExtArgs> | null
    /**
     * Filter, which leave_of_absence to fetch.
     */
    where?: leave_of_absenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of leave_of_absences to fetch.
     */
    orderBy?: leave_of_absenceOrderByWithRelationInput | leave_of_absenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for leave_of_absences.
     */
    cursor?: leave_of_absenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` leave_of_absences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` leave_of_absences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of leave_of_absences.
     */
    distinct?: Leave_of_absenceScalarFieldEnum | Leave_of_absenceScalarFieldEnum[]
  }


  /**
   * leave_of_absence findMany
   */
  export type leave_of_absenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the leave_of_absence
     */
    select?: leave_of_absenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: leave_of_absenceInclude<ExtArgs> | null
    /**
     * Filter, which leave_of_absences to fetch.
     */
    where?: leave_of_absenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of leave_of_absences to fetch.
     */
    orderBy?: leave_of_absenceOrderByWithRelationInput | leave_of_absenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing leave_of_absences.
     */
    cursor?: leave_of_absenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` leave_of_absences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` leave_of_absences.
     */
    skip?: number
    distinct?: Leave_of_absenceScalarFieldEnum | Leave_of_absenceScalarFieldEnum[]
  }


  /**
   * leave_of_absence create
   */
  export type leave_of_absenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the leave_of_absence
     */
    select?: leave_of_absenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: leave_of_absenceInclude<ExtArgs> | null
    /**
     * The data needed to create a leave_of_absence.
     */
    data?: XOR<leave_of_absenceCreateInput, leave_of_absenceUncheckedCreateInput>
  }


  /**
   * leave_of_absence createMany
   */
  export type leave_of_absenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many leave_of_absences.
     */
    data: leave_of_absenceCreateManyInput | leave_of_absenceCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * leave_of_absence update
   */
  export type leave_of_absenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the leave_of_absence
     */
    select?: leave_of_absenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: leave_of_absenceInclude<ExtArgs> | null
    /**
     * The data needed to update a leave_of_absence.
     */
    data: XOR<leave_of_absenceUpdateInput, leave_of_absenceUncheckedUpdateInput>
    /**
     * Choose, which leave_of_absence to update.
     */
    where: leave_of_absenceWhereUniqueInput
  }


  /**
   * leave_of_absence updateMany
   */
  export type leave_of_absenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update leave_of_absences.
     */
    data: XOR<leave_of_absenceUpdateManyMutationInput, leave_of_absenceUncheckedUpdateManyInput>
    /**
     * Filter which leave_of_absences to update
     */
    where?: leave_of_absenceWhereInput
  }


  /**
   * leave_of_absence upsert
   */
  export type leave_of_absenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the leave_of_absence
     */
    select?: leave_of_absenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: leave_of_absenceInclude<ExtArgs> | null
    /**
     * The filter to search for the leave_of_absence to update in case it exists.
     */
    where: leave_of_absenceWhereUniqueInput
    /**
     * In case the leave_of_absence found by the `where` argument doesn't exist, create a new leave_of_absence with this data.
     */
    create: XOR<leave_of_absenceCreateInput, leave_of_absenceUncheckedCreateInput>
    /**
     * In case the leave_of_absence was found with the provided `where` argument, update it with this data.
     */
    update: XOR<leave_of_absenceUpdateInput, leave_of_absenceUncheckedUpdateInput>
  }


  /**
   * leave_of_absence delete
   */
  export type leave_of_absenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the leave_of_absence
     */
    select?: leave_of_absenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: leave_of_absenceInclude<ExtArgs> | null
    /**
     * Filter which leave_of_absence to delete.
     */
    where: leave_of_absenceWhereUniqueInput
  }


  /**
   * leave_of_absence deleteMany
   */
  export type leave_of_absenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which leave_of_absences to delete
     */
    where?: leave_of_absenceWhereInput
  }


  /**
   * leave_of_absence.users
   */
  export type leave_of_absence$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }


  /**
   * leave_of_absence without action
   */
  export type leave_of_absenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the leave_of_absence
     */
    select?: leave_of_absenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: leave_of_absenceInclude<ExtArgs> | null
  }



  /**
   * Model lynx_apps
   */

  export type AggregateLynx_apps = {
    _count: Lynx_appsCountAggregateOutputType | null
    _avg: Lynx_appsAvgAggregateOutputType | null
    _sum: Lynx_appsSumAggregateOutputType | null
    _min: Lynx_appsMinAggregateOutputType | null
    _max: Lynx_appsMaxAggregateOutputType | null
  }

  export type Lynx_appsAvgAggregateOutputType = {
    user_id: number | null
    app_version: number | null
  }

  export type Lynx_appsSumAggregateOutputType = {
    user_id: bigint | null
    app_version: number | null
  }

  export type Lynx_appsMinAggregateOutputType = {
    user_id: bigint | null
    app_id: string | null
    app_version: number | null
    created_at: Date | null
    lynxtag: string | null
  }

  export type Lynx_appsMaxAggregateOutputType = {
    user_id: bigint | null
    app_id: string | null
    app_version: number | null
    created_at: Date | null
    lynxtag: string | null
  }

  export type Lynx_appsCountAggregateOutputType = {
    user_id: number
    app_id: number
    questions: number
    answers: number
    app_version: number
    created_at: number
    lynxtag: number
    _all: number
  }


  export type Lynx_appsAvgAggregateInputType = {
    user_id?: true
    app_version?: true
  }

  export type Lynx_appsSumAggregateInputType = {
    user_id?: true
    app_version?: true
  }

  export type Lynx_appsMinAggregateInputType = {
    user_id?: true
    app_id?: true
    app_version?: true
    created_at?: true
    lynxtag?: true
  }

  export type Lynx_appsMaxAggregateInputType = {
    user_id?: true
    app_id?: true
    app_version?: true
    created_at?: true
    lynxtag?: true
  }

  export type Lynx_appsCountAggregateInputType = {
    user_id?: true
    app_id?: true
    questions?: true
    answers?: true
    app_version?: true
    created_at?: true
    lynxtag?: true
    _all?: true
  }

  export type Lynx_appsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which lynx_apps to aggregate.
     */
    where?: lynx_appsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lynx_apps to fetch.
     */
    orderBy?: lynx_appsOrderByWithRelationInput | lynx_appsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: lynx_appsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lynx_apps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lynx_apps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned lynx_apps
    **/
    _count?: true | Lynx_appsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Lynx_appsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Lynx_appsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Lynx_appsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Lynx_appsMaxAggregateInputType
  }

  export type GetLynx_appsAggregateType<T extends Lynx_appsAggregateArgs> = {
        [P in keyof T & keyof AggregateLynx_apps]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLynx_apps[P]>
      : GetScalarType<T[P], AggregateLynx_apps[P]>
  }




  export type lynx_appsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: lynx_appsWhereInput
    orderBy?: lynx_appsOrderByWithAggregationInput | lynx_appsOrderByWithAggregationInput[]
    by: Lynx_appsScalarFieldEnum[] | Lynx_appsScalarFieldEnum
    having?: lynx_appsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Lynx_appsCountAggregateInputType | true
    _avg?: Lynx_appsAvgAggregateInputType
    _sum?: Lynx_appsSumAggregateInputType
    _min?: Lynx_appsMinAggregateInputType
    _max?: Lynx_appsMaxAggregateInputType
  }

  export type Lynx_appsGroupByOutputType = {
    user_id: bigint | null
    app_id: string
    questions: JsonValue | null
    answers: JsonValue | null
    app_version: number | null
    created_at: Date | null
    lynxtag: string
    _count: Lynx_appsCountAggregateOutputType | null
    _avg: Lynx_appsAvgAggregateOutputType | null
    _sum: Lynx_appsSumAggregateOutputType | null
    _min: Lynx_appsMinAggregateOutputType | null
    _max: Lynx_appsMaxAggregateOutputType | null
  }

  type GetLynx_appsGroupByPayload<T extends lynx_appsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Lynx_appsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Lynx_appsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Lynx_appsGroupByOutputType[P]>
            : GetScalarType<T[P], Lynx_appsGroupByOutputType[P]>
        }
      >
    >


  export type lynx_appsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    app_id?: boolean
    questions?: boolean
    answers?: boolean
    app_version?: boolean
    created_at?: boolean
    lynxtag?: boolean
    users?: boolean | lynx_apps$usersArgs<ExtArgs>
  }, ExtArgs["result"]["lynx_apps"]>

  export type lynx_appsSelectScalar = {
    user_id?: boolean
    app_id?: boolean
    questions?: boolean
    answers?: boolean
    app_version?: boolean
    created_at?: boolean
    lynxtag?: boolean
  }

  export type lynx_appsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | lynx_apps$usersArgs<ExtArgs>
  }


  export type $lynx_appsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "lynx_apps"
    objects: {
      users: Prisma.$usersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      user_id: bigint | null
      app_id: string
      questions: Prisma.JsonValue | null
      answers: Prisma.JsonValue | null
      app_version: number | null
      created_at: Date | null
      lynxtag: string
    }, ExtArgs["result"]["lynx_apps"]>
    composites: {}
  }


  type lynx_appsGetPayload<S extends boolean | null | undefined | lynx_appsDefaultArgs> = $Result.GetResult<Prisma.$lynx_appsPayload, S>

  type lynx_appsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<lynx_appsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Lynx_appsCountAggregateInputType | true
    }

  export interface lynx_appsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['lynx_apps'], meta: { name: 'lynx_apps' } }
    /**
     * Find zero or one Lynx_apps that matches the filter.
     * @param {lynx_appsFindUniqueArgs} args - Arguments to find a Lynx_apps
     * @example
     * // Get one Lynx_apps
     * const lynx_apps = await prisma.lynx_apps.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends lynx_appsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, lynx_appsFindUniqueArgs<ExtArgs>>
    ): Prisma__lynx_appsClient<$Result.GetResult<Prisma.$lynx_appsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Lynx_apps that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {lynx_appsFindUniqueOrThrowArgs} args - Arguments to find a Lynx_apps
     * @example
     * // Get one Lynx_apps
     * const lynx_apps = await prisma.lynx_apps.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends lynx_appsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, lynx_appsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__lynx_appsClient<$Result.GetResult<Prisma.$lynx_appsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Lynx_apps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lynx_appsFindFirstArgs} args - Arguments to find a Lynx_apps
     * @example
     * // Get one Lynx_apps
     * const lynx_apps = await prisma.lynx_apps.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends lynx_appsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, lynx_appsFindFirstArgs<ExtArgs>>
    ): Prisma__lynx_appsClient<$Result.GetResult<Prisma.$lynx_appsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Lynx_apps that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lynx_appsFindFirstOrThrowArgs} args - Arguments to find a Lynx_apps
     * @example
     * // Get one Lynx_apps
     * const lynx_apps = await prisma.lynx_apps.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends lynx_appsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, lynx_appsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__lynx_appsClient<$Result.GetResult<Prisma.$lynx_appsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Lynx_apps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lynx_appsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lynx_apps
     * const lynx_apps = await prisma.lynx_apps.findMany()
     * 
     * // Get first 10 Lynx_apps
     * const lynx_apps = await prisma.lynx_apps.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const lynx_appsWithUser_idOnly = await prisma.lynx_apps.findMany({ select: { user_id: true } })
     * 
    **/
    findMany<T extends lynx_appsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, lynx_appsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$lynx_appsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Lynx_apps.
     * @param {lynx_appsCreateArgs} args - Arguments to create a Lynx_apps.
     * @example
     * // Create one Lynx_apps
     * const Lynx_apps = await prisma.lynx_apps.create({
     *   data: {
     *     // ... data to create a Lynx_apps
     *   }
     * })
     * 
    **/
    create<T extends lynx_appsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, lynx_appsCreateArgs<ExtArgs>>
    ): Prisma__lynx_appsClient<$Result.GetResult<Prisma.$lynx_appsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Lynx_apps.
     *     @param {lynx_appsCreateManyArgs} args - Arguments to create many Lynx_apps.
     *     @example
     *     // Create many Lynx_apps
     *     const lynx_apps = await prisma.lynx_apps.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends lynx_appsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, lynx_appsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Lynx_apps.
     * @param {lynx_appsDeleteArgs} args - Arguments to delete one Lynx_apps.
     * @example
     * // Delete one Lynx_apps
     * const Lynx_apps = await prisma.lynx_apps.delete({
     *   where: {
     *     // ... filter to delete one Lynx_apps
     *   }
     * })
     * 
    **/
    delete<T extends lynx_appsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, lynx_appsDeleteArgs<ExtArgs>>
    ): Prisma__lynx_appsClient<$Result.GetResult<Prisma.$lynx_appsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Lynx_apps.
     * @param {lynx_appsUpdateArgs} args - Arguments to update one Lynx_apps.
     * @example
     * // Update one Lynx_apps
     * const lynx_apps = await prisma.lynx_apps.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends lynx_appsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, lynx_appsUpdateArgs<ExtArgs>>
    ): Prisma__lynx_appsClient<$Result.GetResult<Prisma.$lynx_appsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Lynx_apps.
     * @param {lynx_appsDeleteManyArgs} args - Arguments to filter Lynx_apps to delete.
     * @example
     * // Delete a few Lynx_apps
     * const { count } = await prisma.lynx_apps.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends lynx_appsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, lynx_appsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lynx_apps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lynx_appsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lynx_apps
     * const lynx_apps = await prisma.lynx_apps.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends lynx_appsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, lynx_appsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Lynx_apps.
     * @param {lynx_appsUpsertArgs} args - Arguments to update or create a Lynx_apps.
     * @example
     * // Update or create a Lynx_apps
     * const lynx_apps = await prisma.lynx_apps.upsert({
     *   create: {
     *     // ... data to create a Lynx_apps
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lynx_apps we want to update
     *   }
     * })
    **/
    upsert<T extends lynx_appsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, lynx_appsUpsertArgs<ExtArgs>>
    ): Prisma__lynx_appsClient<$Result.GetResult<Prisma.$lynx_appsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Lynx_apps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lynx_appsCountArgs} args - Arguments to filter Lynx_apps to count.
     * @example
     * // Count the number of Lynx_apps
     * const count = await prisma.lynx_apps.count({
     *   where: {
     *     // ... the filter for the Lynx_apps we want to count
     *   }
     * })
    **/
    count<T extends lynx_appsCountArgs>(
      args?: Subset<T, lynx_appsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Lynx_appsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lynx_apps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lynx_appsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Lynx_appsAggregateArgs>(args: Subset<T, Lynx_appsAggregateArgs>): Prisma.PrismaPromise<GetLynx_appsAggregateType<T>>

    /**
     * Group by Lynx_apps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lynx_appsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends lynx_appsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: lynx_appsGroupByArgs['orderBy'] }
        : { orderBy?: lynx_appsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, lynx_appsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLynx_appsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the lynx_apps model
   */
  readonly fields: lynx_appsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for lynx_apps.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__lynx_appsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    users<T extends lynx_apps$usersArgs<ExtArgs> = {}>(args?: Subset<T, lynx_apps$usersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the lynx_apps model
   */ 
  interface lynx_appsFieldRefs {
    readonly user_id: FieldRef<"lynx_apps", 'BigInt'>
    readonly app_id: FieldRef<"lynx_apps", 'String'>
    readonly questions: FieldRef<"lynx_apps", 'Json'>
    readonly answers: FieldRef<"lynx_apps", 'Json'>
    readonly app_version: FieldRef<"lynx_apps", 'Int'>
    readonly created_at: FieldRef<"lynx_apps", 'DateTime'>
    readonly lynxtag: FieldRef<"lynx_apps", 'String'>
  }
    

  // Custom InputTypes

  /**
   * lynx_apps findUnique
   */
  export type lynx_appsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lynx_apps
     */
    select?: lynx_appsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: lynx_appsInclude<ExtArgs> | null
    /**
     * Filter, which lynx_apps to fetch.
     */
    where: lynx_appsWhereUniqueInput
  }


  /**
   * lynx_apps findUniqueOrThrow
   */
  export type lynx_appsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lynx_apps
     */
    select?: lynx_appsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: lynx_appsInclude<ExtArgs> | null
    /**
     * Filter, which lynx_apps to fetch.
     */
    where: lynx_appsWhereUniqueInput
  }


  /**
   * lynx_apps findFirst
   */
  export type lynx_appsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lynx_apps
     */
    select?: lynx_appsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: lynx_appsInclude<ExtArgs> | null
    /**
     * Filter, which lynx_apps to fetch.
     */
    where?: lynx_appsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lynx_apps to fetch.
     */
    orderBy?: lynx_appsOrderByWithRelationInput | lynx_appsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for lynx_apps.
     */
    cursor?: lynx_appsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lynx_apps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lynx_apps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of lynx_apps.
     */
    distinct?: Lynx_appsScalarFieldEnum | Lynx_appsScalarFieldEnum[]
  }


  /**
   * lynx_apps findFirstOrThrow
   */
  export type lynx_appsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lynx_apps
     */
    select?: lynx_appsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: lynx_appsInclude<ExtArgs> | null
    /**
     * Filter, which lynx_apps to fetch.
     */
    where?: lynx_appsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lynx_apps to fetch.
     */
    orderBy?: lynx_appsOrderByWithRelationInput | lynx_appsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for lynx_apps.
     */
    cursor?: lynx_appsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lynx_apps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lynx_apps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of lynx_apps.
     */
    distinct?: Lynx_appsScalarFieldEnum | Lynx_appsScalarFieldEnum[]
  }


  /**
   * lynx_apps findMany
   */
  export type lynx_appsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lynx_apps
     */
    select?: lynx_appsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: lynx_appsInclude<ExtArgs> | null
    /**
     * Filter, which lynx_apps to fetch.
     */
    where?: lynx_appsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lynx_apps to fetch.
     */
    orderBy?: lynx_appsOrderByWithRelationInput | lynx_appsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing lynx_apps.
     */
    cursor?: lynx_appsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lynx_apps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lynx_apps.
     */
    skip?: number
    distinct?: Lynx_appsScalarFieldEnum | Lynx_appsScalarFieldEnum[]
  }


  /**
   * lynx_apps create
   */
  export type lynx_appsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lynx_apps
     */
    select?: lynx_appsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: lynx_appsInclude<ExtArgs> | null
    /**
     * The data needed to create a lynx_apps.
     */
    data?: XOR<lynx_appsCreateInput, lynx_appsUncheckedCreateInput>
  }


  /**
   * lynx_apps createMany
   */
  export type lynx_appsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many lynx_apps.
     */
    data: lynx_appsCreateManyInput | lynx_appsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * lynx_apps update
   */
  export type lynx_appsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lynx_apps
     */
    select?: lynx_appsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: lynx_appsInclude<ExtArgs> | null
    /**
     * The data needed to update a lynx_apps.
     */
    data: XOR<lynx_appsUpdateInput, lynx_appsUncheckedUpdateInput>
    /**
     * Choose, which lynx_apps to update.
     */
    where: lynx_appsWhereUniqueInput
  }


  /**
   * lynx_apps updateMany
   */
  export type lynx_appsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update lynx_apps.
     */
    data: XOR<lynx_appsUpdateManyMutationInput, lynx_appsUncheckedUpdateManyInput>
    /**
     * Filter which lynx_apps to update
     */
    where?: lynx_appsWhereInput
  }


  /**
   * lynx_apps upsert
   */
  export type lynx_appsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lynx_apps
     */
    select?: lynx_appsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: lynx_appsInclude<ExtArgs> | null
    /**
     * The filter to search for the lynx_apps to update in case it exists.
     */
    where: lynx_appsWhereUniqueInput
    /**
     * In case the lynx_apps found by the `where` argument doesn't exist, create a new lynx_apps with this data.
     */
    create: XOR<lynx_appsCreateInput, lynx_appsUncheckedCreateInput>
    /**
     * In case the lynx_apps was found with the provided `where` argument, update it with this data.
     */
    update: XOR<lynx_appsUpdateInput, lynx_appsUncheckedUpdateInput>
  }


  /**
   * lynx_apps delete
   */
  export type lynx_appsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lynx_apps
     */
    select?: lynx_appsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: lynx_appsInclude<ExtArgs> | null
    /**
     * Filter which lynx_apps to delete.
     */
    where: lynx_appsWhereUniqueInput
  }


  /**
   * lynx_apps deleteMany
   */
  export type lynx_appsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which lynx_apps to delete
     */
    where?: lynx_appsWhereInput
  }


  /**
   * lynx_apps.users
   */
  export type lynx_apps$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }


  /**
   * lynx_apps without action
   */
  export type lynx_appsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lynx_apps
     */
    select?: lynx_appsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: lynx_appsInclude<ExtArgs> | null
  }



  /**
   * Model lynx_data
   */

  export type AggregateLynx_data = {
    _count: Lynx_dataCountAggregateOutputType | null
    _avg: Lynx_dataAvgAggregateOutputType | null
    _sum: Lynx_dataSumAggregateOutputType | null
    _min: Lynx_dataMinAggregateOutputType | null
    _max: Lynx_dataMaxAggregateOutputType | null
  }

  export type Lynx_dataAvgAggregateOutputType = {
    default_user_experiments: number | null
    id: number | null
  }

  export type Lynx_dataSumAggregateOutputType = {
    default_user_experiments: number[]
    id: number | null
  }

  export type Lynx_dataMinAggregateOutputType = {
    id: number | null
    lynxtag: string | null
  }

  export type Lynx_dataMaxAggregateOutputType = {
    id: number | null
    lynxtag: string | null
  }

  export type Lynx_dataCountAggregateOutputType = {
    default_user_experiments: number
    id: number
    lynxtag: number
    _all: number
  }


  export type Lynx_dataAvgAggregateInputType = {
    default_user_experiments?: true
    id?: true
  }

  export type Lynx_dataSumAggregateInputType = {
    default_user_experiments?: true
    id?: true
  }

  export type Lynx_dataMinAggregateInputType = {
    id?: true
    lynxtag?: true
  }

  export type Lynx_dataMaxAggregateInputType = {
    id?: true
    lynxtag?: true
  }

  export type Lynx_dataCountAggregateInputType = {
    default_user_experiments?: true
    id?: true
    lynxtag?: true
    _all?: true
  }

  export type Lynx_dataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which lynx_data to aggregate.
     */
    where?: lynx_dataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lynx_data to fetch.
     */
    orderBy?: lynx_dataOrderByWithRelationInput | lynx_dataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: lynx_dataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lynx_data from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lynx_data.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned lynx_data
    **/
    _count?: true | Lynx_dataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Lynx_dataAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Lynx_dataSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Lynx_dataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Lynx_dataMaxAggregateInputType
  }

  export type GetLynx_dataAggregateType<T extends Lynx_dataAggregateArgs> = {
        [P in keyof T & keyof AggregateLynx_data]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLynx_data[P]>
      : GetScalarType<T[P], AggregateLynx_data[P]>
  }




  export type lynx_dataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: lynx_dataWhereInput
    orderBy?: lynx_dataOrderByWithAggregationInput | lynx_dataOrderByWithAggregationInput[]
    by: Lynx_dataScalarFieldEnum[] | Lynx_dataScalarFieldEnum
    having?: lynx_dataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Lynx_dataCountAggregateInputType | true
    _avg?: Lynx_dataAvgAggregateInputType
    _sum?: Lynx_dataSumAggregateInputType
    _min?: Lynx_dataMinAggregateInputType
    _max?: Lynx_dataMaxAggregateInputType
  }

  export type Lynx_dataGroupByOutputType = {
    default_user_experiments: number[]
    id: number
    lynxtag: string
    _count: Lynx_dataCountAggregateOutputType | null
    _avg: Lynx_dataAvgAggregateOutputType | null
    _sum: Lynx_dataSumAggregateOutputType | null
    _min: Lynx_dataMinAggregateOutputType | null
    _max: Lynx_dataMaxAggregateOutputType | null
  }

  type GetLynx_dataGroupByPayload<T extends lynx_dataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Lynx_dataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Lynx_dataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Lynx_dataGroupByOutputType[P]>
            : GetScalarType<T[P], Lynx_dataGroupByOutputType[P]>
        }
      >
    >


  export type lynx_dataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    default_user_experiments?: boolean
    id?: boolean
    lynxtag?: boolean
  }, ExtArgs["result"]["lynx_data"]>

  export type lynx_dataSelectScalar = {
    default_user_experiments?: boolean
    id?: boolean
    lynxtag?: boolean
  }


  export type $lynx_dataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "lynx_data"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      default_user_experiments: number[]
      id: number
      lynxtag: string
    }, ExtArgs["result"]["lynx_data"]>
    composites: {}
  }


  type lynx_dataGetPayload<S extends boolean | null | undefined | lynx_dataDefaultArgs> = $Result.GetResult<Prisma.$lynx_dataPayload, S>

  type lynx_dataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<lynx_dataFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Lynx_dataCountAggregateInputType | true
    }

  export interface lynx_dataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['lynx_data'], meta: { name: 'lynx_data' } }
    /**
     * Find zero or one Lynx_data that matches the filter.
     * @param {lynx_dataFindUniqueArgs} args - Arguments to find a Lynx_data
     * @example
     * // Get one Lynx_data
     * const lynx_data = await prisma.lynx_data.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends lynx_dataFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, lynx_dataFindUniqueArgs<ExtArgs>>
    ): Prisma__lynx_dataClient<$Result.GetResult<Prisma.$lynx_dataPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Lynx_data that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {lynx_dataFindUniqueOrThrowArgs} args - Arguments to find a Lynx_data
     * @example
     * // Get one Lynx_data
     * const lynx_data = await prisma.lynx_data.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends lynx_dataFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, lynx_dataFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__lynx_dataClient<$Result.GetResult<Prisma.$lynx_dataPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Lynx_data that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lynx_dataFindFirstArgs} args - Arguments to find a Lynx_data
     * @example
     * // Get one Lynx_data
     * const lynx_data = await prisma.lynx_data.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends lynx_dataFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, lynx_dataFindFirstArgs<ExtArgs>>
    ): Prisma__lynx_dataClient<$Result.GetResult<Prisma.$lynx_dataPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Lynx_data that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lynx_dataFindFirstOrThrowArgs} args - Arguments to find a Lynx_data
     * @example
     * // Get one Lynx_data
     * const lynx_data = await prisma.lynx_data.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends lynx_dataFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, lynx_dataFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__lynx_dataClient<$Result.GetResult<Prisma.$lynx_dataPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Lynx_data that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lynx_dataFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lynx_data
     * const lynx_data = await prisma.lynx_data.findMany()
     * 
     * // Get first 10 Lynx_data
     * const lynx_data = await prisma.lynx_data.findMany({ take: 10 })
     * 
     * // Only select the `default_user_experiments`
     * const lynx_dataWithDefault_user_experimentsOnly = await prisma.lynx_data.findMany({ select: { default_user_experiments: true } })
     * 
    **/
    findMany<T extends lynx_dataFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, lynx_dataFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$lynx_dataPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Lynx_data.
     * @param {lynx_dataCreateArgs} args - Arguments to create a Lynx_data.
     * @example
     * // Create one Lynx_data
     * const Lynx_data = await prisma.lynx_data.create({
     *   data: {
     *     // ... data to create a Lynx_data
     *   }
     * })
     * 
    **/
    create<T extends lynx_dataCreateArgs<ExtArgs>>(
      args: SelectSubset<T, lynx_dataCreateArgs<ExtArgs>>
    ): Prisma__lynx_dataClient<$Result.GetResult<Prisma.$lynx_dataPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Lynx_data.
     *     @param {lynx_dataCreateManyArgs} args - Arguments to create many Lynx_data.
     *     @example
     *     // Create many Lynx_data
     *     const lynx_data = await prisma.lynx_data.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends lynx_dataCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, lynx_dataCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Lynx_data.
     * @param {lynx_dataDeleteArgs} args - Arguments to delete one Lynx_data.
     * @example
     * // Delete one Lynx_data
     * const Lynx_data = await prisma.lynx_data.delete({
     *   where: {
     *     // ... filter to delete one Lynx_data
     *   }
     * })
     * 
    **/
    delete<T extends lynx_dataDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, lynx_dataDeleteArgs<ExtArgs>>
    ): Prisma__lynx_dataClient<$Result.GetResult<Prisma.$lynx_dataPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Lynx_data.
     * @param {lynx_dataUpdateArgs} args - Arguments to update one Lynx_data.
     * @example
     * // Update one Lynx_data
     * const lynx_data = await prisma.lynx_data.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends lynx_dataUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, lynx_dataUpdateArgs<ExtArgs>>
    ): Prisma__lynx_dataClient<$Result.GetResult<Prisma.$lynx_dataPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Lynx_data.
     * @param {lynx_dataDeleteManyArgs} args - Arguments to filter Lynx_data to delete.
     * @example
     * // Delete a few Lynx_data
     * const { count } = await prisma.lynx_data.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends lynx_dataDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, lynx_dataDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lynx_data.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lynx_dataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lynx_data
     * const lynx_data = await prisma.lynx_data.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends lynx_dataUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, lynx_dataUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Lynx_data.
     * @param {lynx_dataUpsertArgs} args - Arguments to update or create a Lynx_data.
     * @example
     * // Update or create a Lynx_data
     * const lynx_data = await prisma.lynx_data.upsert({
     *   create: {
     *     // ... data to create a Lynx_data
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lynx_data we want to update
     *   }
     * })
    **/
    upsert<T extends lynx_dataUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, lynx_dataUpsertArgs<ExtArgs>>
    ): Prisma__lynx_dataClient<$Result.GetResult<Prisma.$lynx_dataPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Lynx_data.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lynx_dataCountArgs} args - Arguments to filter Lynx_data to count.
     * @example
     * // Count the number of Lynx_data
     * const count = await prisma.lynx_data.count({
     *   where: {
     *     // ... the filter for the Lynx_data we want to count
     *   }
     * })
    **/
    count<T extends lynx_dataCountArgs>(
      args?: Subset<T, lynx_dataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Lynx_dataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lynx_data.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lynx_dataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Lynx_dataAggregateArgs>(args: Subset<T, Lynx_dataAggregateArgs>): Prisma.PrismaPromise<GetLynx_dataAggregateType<T>>

    /**
     * Group by Lynx_data.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lynx_dataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends lynx_dataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: lynx_dataGroupByArgs['orderBy'] }
        : { orderBy?: lynx_dataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, lynx_dataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLynx_dataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the lynx_data model
   */
  readonly fields: lynx_dataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for lynx_data.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__lynx_dataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the lynx_data model
   */ 
  interface lynx_dataFieldRefs {
    readonly default_user_experiments: FieldRef<"lynx_data", 'Int[]'>
    readonly id: FieldRef<"lynx_data", 'Int'>
    readonly lynxtag: FieldRef<"lynx_data", 'String'>
  }
    

  // Custom InputTypes

  /**
   * lynx_data findUnique
   */
  export type lynx_dataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lynx_data
     */
    select?: lynx_dataSelect<ExtArgs> | null
    /**
     * Filter, which lynx_data to fetch.
     */
    where: lynx_dataWhereUniqueInput
  }


  /**
   * lynx_data findUniqueOrThrow
   */
  export type lynx_dataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lynx_data
     */
    select?: lynx_dataSelect<ExtArgs> | null
    /**
     * Filter, which lynx_data to fetch.
     */
    where: lynx_dataWhereUniqueInput
  }


  /**
   * lynx_data findFirst
   */
  export type lynx_dataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lynx_data
     */
    select?: lynx_dataSelect<ExtArgs> | null
    /**
     * Filter, which lynx_data to fetch.
     */
    where?: lynx_dataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lynx_data to fetch.
     */
    orderBy?: lynx_dataOrderByWithRelationInput | lynx_dataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for lynx_data.
     */
    cursor?: lynx_dataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lynx_data from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lynx_data.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of lynx_data.
     */
    distinct?: Lynx_dataScalarFieldEnum | Lynx_dataScalarFieldEnum[]
  }


  /**
   * lynx_data findFirstOrThrow
   */
  export type lynx_dataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lynx_data
     */
    select?: lynx_dataSelect<ExtArgs> | null
    /**
     * Filter, which lynx_data to fetch.
     */
    where?: lynx_dataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lynx_data to fetch.
     */
    orderBy?: lynx_dataOrderByWithRelationInput | lynx_dataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for lynx_data.
     */
    cursor?: lynx_dataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lynx_data from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lynx_data.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of lynx_data.
     */
    distinct?: Lynx_dataScalarFieldEnum | Lynx_dataScalarFieldEnum[]
  }


  /**
   * lynx_data findMany
   */
  export type lynx_dataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lynx_data
     */
    select?: lynx_dataSelect<ExtArgs> | null
    /**
     * Filter, which lynx_data to fetch.
     */
    where?: lynx_dataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lynx_data to fetch.
     */
    orderBy?: lynx_dataOrderByWithRelationInput | lynx_dataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing lynx_data.
     */
    cursor?: lynx_dataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lynx_data from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lynx_data.
     */
    skip?: number
    distinct?: Lynx_dataScalarFieldEnum | Lynx_dataScalarFieldEnum[]
  }


  /**
   * lynx_data create
   */
  export type lynx_dataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lynx_data
     */
    select?: lynx_dataSelect<ExtArgs> | null
    /**
     * The data needed to create a lynx_data.
     */
    data?: XOR<lynx_dataCreateInput, lynx_dataUncheckedCreateInput>
  }


  /**
   * lynx_data createMany
   */
  export type lynx_dataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many lynx_data.
     */
    data: lynx_dataCreateManyInput | lynx_dataCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * lynx_data update
   */
  export type lynx_dataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lynx_data
     */
    select?: lynx_dataSelect<ExtArgs> | null
    /**
     * The data needed to update a lynx_data.
     */
    data: XOR<lynx_dataUpdateInput, lynx_dataUncheckedUpdateInput>
    /**
     * Choose, which lynx_data to update.
     */
    where: lynx_dataWhereUniqueInput
  }


  /**
   * lynx_data updateMany
   */
  export type lynx_dataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update lynx_data.
     */
    data: XOR<lynx_dataUpdateManyMutationInput, lynx_dataUncheckedUpdateManyInput>
    /**
     * Filter which lynx_data to update
     */
    where?: lynx_dataWhereInput
  }


  /**
   * lynx_data upsert
   */
  export type lynx_dataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lynx_data
     */
    select?: lynx_dataSelect<ExtArgs> | null
    /**
     * The filter to search for the lynx_data to update in case it exists.
     */
    where: lynx_dataWhereUniqueInput
    /**
     * In case the lynx_data found by the `where` argument doesn't exist, create a new lynx_data with this data.
     */
    create: XOR<lynx_dataCreateInput, lynx_dataUncheckedCreateInput>
    /**
     * In case the lynx_data was found with the provided `where` argument, update it with this data.
     */
    update: XOR<lynx_dataUpdateInput, lynx_dataUncheckedUpdateInput>
  }


  /**
   * lynx_data delete
   */
  export type lynx_dataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lynx_data
     */
    select?: lynx_dataSelect<ExtArgs> | null
    /**
     * Filter which lynx_data to delete.
     */
    where: lynx_dataWhereUniqueInput
  }


  /**
   * lynx_data deleteMany
   */
  export type lynx_dataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which lynx_data to delete
     */
    where?: lynx_dataWhereInput
  }


  /**
   * lynx_data without action
   */
  export type lynx_dataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lynx_data
     */
    select?: lynx_dataSelect<ExtArgs> | null
  }



  /**
   * Model lynx_logs
   */

  export type AggregateLynx_logs = {
    _count: Lynx_logsCountAggregateOutputType | null
    _avg: Lynx_logsAvgAggregateOutputType | null
    _sum: Lynx_logsSumAggregateOutputType | null
    _min: Lynx_logsMinAggregateOutputType | null
    _max: Lynx_logsMaxAggregateOutputType | null
  }

  export type Lynx_logsAvgAggregateOutputType = {
    user_id: number | null
    status_code: number | null
  }

  export type Lynx_logsSumAggregateOutputType = {
    user_id: bigint | null
    status_code: number | null
  }

  export type Lynx_logsMinAggregateOutputType = {
    user_id: bigint | null
    method: string | null
    url: string | null
    status_code: number | null
    request_time: Date | null
    lynxtag: string | null
  }

  export type Lynx_logsMaxAggregateOutputType = {
    user_id: bigint | null
    method: string | null
    url: string | null
    status_code: number | null
    request_time: Date | null
    lynxtag: string | null
  }

  export type Lynx_logsCountAggregateOutputType = {
    user_id: number
    method: number
    url: number
    status_code: number
    request_time: number
    lynxtag: number
    _all: number
  }


  export type Lynx_logsAvgAggregateInputType = {
    user_id?: true
    status_code?: true
  }

  export type Lynx_logsSumAggregateInputType = {
    user_id?: true
    status_code?: true
  }

  export type Lynx_logsMinAggregateInputType = {
    user_id?: true
    method?: true
    url?: true
    status_code?: true
    request_time?: true
    lynxtag?: true
  }

  export type Lynx_logsMaxAggregateInputType = {
    user_id?: true
    method?: true
    url?: true
    status_code?: true
    request_time?: true
    lynxtag?: true
  }

  export type Lynx_logsCountAggregateInputType = {
    user_id?: true
    method?: true
    url?: true
    status_code?: true
    request_time?: true
    lynxtag?: true
    _all?: true
  }

  export type Lynx_logsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which lynx_logs to aggregate.
     */
    where?: lynx_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lynx_logs to fetch.
     */
    orderBy?: lynx_logsOrderByWithRelationInput | lynx_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: lynx_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lynx_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lynx_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned lynx_logs
    **/
    _count?: true | Lynx_logsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Lynx_logsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Lynx_logsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Lynx_logsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Lynx_logsMaxAggregateInputType
  }

  export type GetLynx_logsAggregateType<T extends Lynx_logsAggregateArgs> = {
        [P in keyof T & keyof AggregateLynx_logs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLynx_logs[P]>
      : GetScalarType<T[P], AggregateLynx_logs[P]>
  }




  export type lynx_logsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: lynx_logsWhereInput
    orderBy?: lynx_logsOrderByWithAggregationInput | lynx_logsOrderByWithAggregationInput[]
    by: Lynx_logsScalarFieldEnum[] | Lynx_logsScalarFieldEnum
    having?: lynx_logsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Lynx_logsCountAggregateInputType | true
    _avg?: Lynx_logsAvgAggregateInputType
    _sum?: Lynx_logsSumAggregateInputType
    _min?: Lynx_logsMinAggregateInputType
    _max?: Lynx_logsMaxAggregateInputType
  }

  export type Lynx_logsGroupByOutputType = {
    user_id: bigint
    method: string
    url: string
    status_code: number
    request_time: Date | null
    lynxtag: string
    _count: Lynx_logsCountAggregateOutputType | null
    _avg: Lynx_logsAvgAggregateOutputType | null
    _sum: Lynx_logsSumAggregateOutputType | null
    _min: Lynx_logsMinAggregateOutputType | null
    _max: Lynx_logsMaxAggregateOutputType | null
  }

  type GetLynx_logsGroupByPayload<T extends lynx_logsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Lynx_logsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Lynx_logsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Lynx_logsGroupByOutputType[P]>
            : GetScalarType<T[P], Lynx_logsGroupByOutputType[P]>
        }
      >
    >


  export type lynx_logsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    method?: boolean
    url?: boolean
    status_code?: boolean
    request_time?: boolean
    lynxtag?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lynx_logs"]>

  export type lynx_logsSelectScalar = {
    user_id?: boolean
    method?: boolean
    url?: boolean
    status_code?: boolean
    request_time?: boolean
    lynxtag?: boolean
  }

  export type lynx_logsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }


  export type $lynx_logsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "lynx_logs"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      user_id: bigint
      method: string
      url: string
      status_code: number
      request_time: Date | null
      lynxtag: string
    }, ExtArgs["result"]["lynx_logs"]>
    composites: {}
  }


  type lynx_logsGetPayload<S extends boolean | null | undefined | lynx_logsDefaultArgs> = $Result.GetResult<Prisma.$lynx_logsPayload, S>

  type lynx_logsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<lynx_logsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Lynx_logsCountAggregateInputType | true
    }

  export interface lynx_logsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['lynx_logs'], meta: { name: 'lynx_logs' } }
    /**
     * Find zero or one Lynx_logs that matches the filter.
     * @param {lynx_logsFindUniqueArgs} args - Arguments to find a Lynx_logs
     * @example
     * // Get one Lynx_logs
     * const lynx_logs = await prisma.lynx_logs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends lynx_logsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, lynx_logsFindUniqueArgs<ExtArgs>>
    ): Prisma__lynx_logsClient<$Result.GetResult<Prisma.$lynx_logsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Lynx_logs that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {lynx_logsFindUniqueOrThrowArgs} args - Arguments to find a Lynx_logs
     * @example
     * // Get one Lynx_logs
     * const lynx_logs = await prisma.lynx_logs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends lynx_logsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, lynx_logsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__lynx_logsClient<$Result.GetResult<Prisma.$lynx_logsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Lynx_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lynx_logsFindFirstArgs} args - Arguments to find a Lynx_logs
     * @example
     * // Get one Lynx_logs
     * const lynx_logs = await prisma.lynx_logs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends lynx_logsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, lynx_logsFindFirstArgs<ExtArgs>>
    ): Prisma__lynx_logsClient<$Result.GetResult<Prisma.$lynx_logsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Lynx_logs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lynx_logsFindFirstOrThrowArgs} args - Arguments to find a Lynx_logs
     * @example
     * // Get one Lynx_logs
     * const lynx_logs = await prisma.lynx_logs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends lynx_logsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, lynx_logsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__lynx_logsClient<$Result.GetResult<Prisma.$lynx_logsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Lynx_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lynx_logsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lynx_logs
     * const lynx_logs = await prisma.lynx_logs.findMany()
     * 
     * // Get first 10 Lynx_logs
     * const lynx_logs = await prisma.lynx_logs.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const lynx_logsWithUser_idOnly = await prisma.lynx_logs.findMany({ select: { user_id: true } })
     * 
    **/
    findMany<T extends lynx_logsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, lynx_logsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$lynx_logsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Lynx_logs.
     * @param {lynx_logsCreateArgs} args - Arguments to create a Lynx_logs.
     * @example
     * // Create one Lynx_logs
     * const Lynx_logs = await prisma.lynx_logs.create({
     *   data: {
     *     // ... data to create a Lynx_logs
     *   }
     * })
     * 
    **/
    create<T extends lynx_logsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, lynx_logsCreateArgs<ExtArgs>>
    ): Prisma__lynx_logsClient<$Result.GetResult<Prisma.$lynx_logsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Lynx_logs.
     *     @param {lynx_logsCreateManyArgs} args - Arguments to create many Lynx_logs.
     *     @example
     *     // Create many Lynx_logs
     *     const lynx_logs = await prisma.lynx_logs.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends lynx_logsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, lynx_logsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Lynx_logs.
     * @param {lynx_logsDeleteArgs} args - Arguments to delete one Lynx_logs.
     * @example
     * // Delete one Lynx_logs
     * const Lynx_logs = await prisma.lynx_logs.delete({
     *   where: {
     *     // ... filter to delete one Lynx_logs
     *   }
     * })
     * 
    **/
    delete<T extends lynx_logsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, lynx_logsDeleteArgs<ExtArgs>>
    ): Prisma__lynx_logsClient<$Result.GetResult<Prisma.$lynx_logsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Lynx_logs.
     * @param {lynx_logsUpdateArgs} args - Arguments to update one Lynx_logs.
     * @example
     * // Update one Lynx_logs
     * const lynx_logs = await prisma.lynx_logs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends lynx_logsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, lynx_logsUpdateArgs<ExtArgs>>
    ): Prisma__lynx_logsClient<$Result.GetResult<Prisma.$lynx_logsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Lynx_logs.
     * @param {lynx_logsDeleteManyArgs} args - Arguments to filter Lynx_logs to delete.
     * @example
     * // Delete a few Lynx_logs
     * const { count } = await prisma.lynx_logs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends lynx_logsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, lynx_logsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lynx_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lynx_logsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lynx_logs
     * const lynx_logs = await prisma.lynx_logs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends lynx_logsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, lynx_logsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Lynx_logs.
     * @param {lynx_logsUpsertArgs} args - Arguments to update or create a Lynx_logs.
     * @example
     * // Update or create a Lynx_logs
     * const lynx_logs = await prisma.lynx_logs.upsert({
     *   create: {
     *     // ... data to create a Lynx_logs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lynx_logs we want to update
     *   }
     * })
    **/
    upsert<T extends lynx_logsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, lynx_logsUpsertArgs<ExtArgs>>
    ): Prisma__lynx_logsClient<$Result.GetResult<Prisma.$lynx_logsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Lynx_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lynx_logsCountArgs} args - Arguments to filter Lynx_logs to count.
     * @example
     * // Count the number of Lynx_logs
     * const count = await prisma.lynx_logs.count({
     *   where: {
     *     // ... the filter for the Lynx_logs we want to count
     *   }
     * })
    **/
    count<T extends lynx_logsCountArgs>(
      args?: Subset<T, lynx_logsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Lynx_logsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lynx_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lynx_logsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Lynx_logsAggregateArgs>(args: Subset<T, Lynx_logsAggregateArgs>): Prisma.PrismaPromise<GetLynx_logsAggregateType<T>>

    /**
     * Group by Lynx_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lynx_logsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends lynx_logsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: lynx_logsGroupByArgs['orderBy'] }
        : { orderBy?: lynx_logsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, lynx_logsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLynx_logsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the lynx_logs model
   */
  readonly fields: lynx_logsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for lynx_logs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__lynx_logsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the lynx_logs model
   */ 
  interface lynx_logsFieldRefs {
    readonly user_id: FieldRef<"lynx_logs", 'BigInt'>
    readonly method: FieldRef<"lynx_logs", 'String'>
    readonly url: FieldRef<"lynx_logs", 'String'>
    readonly status_code: FieldRef<"lynx_logs", 'Int'>
    readonly request_time: FieldRef<"lynx_logs", 'DateTime'>
    readonly lynxtag: FieldRef<"lynx_logs", 'String'>
  }
    

  // Custom InputTypes

  /**
   * lynx_logs findUnique
   */
  export type lynx_logsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lynx_logs
     */
    select?: lynx_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: lynx_logsInclude<ExtArgs> | null
    /**
     * Filter, which lynx_logs to fetch.
     */
    where: lynx_logsWhereUniqueInput
  }


  /**
   * lynx_logs findUniqueOrThrow
   */
  export type lynx_logsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lynx_logs
     */
    select?: lynx_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: lynx_logsInclude<ExtArgs> | null
    /**
     * Filter, which lynx_logs to fetch.
     */
    where: lynx_logsWhereUniqueInput
  }


  /**
   * lynx_logs findFirst
   */
  export type lynx_logsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lynx_logs
     */
    select?: lynx_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: lynx_logsInclude<ExtArgs> | null
    /**
     * Filter, which lynx_logs to fetch.
     */
    where?: lynx_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lynx_logs to fetch.
     */
    orderBy?: lynx_logsOrderByWithRelationInput | lynx_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for lynx_logs.
     */
    cursor?: lynx_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lynx_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lynx_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of lynx_logs.
     */
    distinct?: Lynx_logsScalarFieldEnum | Lynx_logsScalarFieldEnum[]
  }


  /**
   * lynx_logs findFirstOrThrow
   */
  export type lynx_logsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lynx_logs
     */
    select?: lynx_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: lynx_logsInclude<ExtArgs> | null
    /**
     * Filter, which lynx_logs to fetch.
     */
    where?: lynx_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lynx_logs to fetch.
     */
    orderBy?: lynx_logsOrderByWithRelationInput | lynx_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for lynx_logs.
     */
    cursor?: lynx_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lynx_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lynx_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of lynx_logs.
     */
    distinct?: Lynx_logsScalarFieldEnum | Lynx_logsScalarFieldEnum[]
  }


  /**
   * lynx_logs findMany
   */
  export type lynx_logsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lynx_logs
     */
    select?: lynx_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: lynx_logsInclude<ExtArgs> | null
    /**
     * Filter, which lynx_logs to fetch.
     */
    where?: lynx_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lynx_logs to fetch.
     */
    orderBy?: lynx_logsOrderByWithRelationInput | lynx_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing lynx_logs.
     */
    cursor?: lynx_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lynx_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lynx_logs.
     */
    skip?: number
    distinct?: Lynx_logsScalarFieldEnum | Lynx_logsScalarFieldEnum[]
  }


  /**
   * lynx_logs create
   */
  export type lynx_logsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lynx_logs
     */
    select?: lynx_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: lynx_logsInclude<ExtArgs> | null
    /**
     * The data needed to create a lynx_logs.
     */
    data: XOR<lynx_logsCreateInput, lynx_logsUncheckedCreateInput>
  }


  /**
   * lynx_logs createMany
   */
  export type lynx_logsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many lynx_logs.
     */
    data: lynx_logsCreateManyInput | lynx_logsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * lynx_logs update
   */
  export type lynx_logsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lynx_logs
     */
    select?: lynx_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: lynx_logsInclude<ExtArgs> | null
    /**
     * The data needed to update a lynx_logs.
     */
    data: XOR<lynx_logsUpdateInput, lynx_logsUncheckedUpdateInput>
    /**
     * Choose, which lynx_logs to update.
     */
    where: lynx_logsWhereUniqueInput
  }


  /**
   * lynx_logs updateMany
   */
  export type lynx_logsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update lynx_logs.
     */
    data: XOR<lynx_logsUpdateManyMutationInput, lynx_logsUncheckedUpdateManyInput>
    /**
     * Filter which lynx_logs to update
     */
    where?: lynx_logsWhereInput
  }


  /**
   * lynx_logs upsert
   */
  export type lynx_logsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lynx_logs
     */
    select?: lynx_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: lynx_logsInclude<ExtArgs> | null
    /**
     * The filter to search for the lynx_logs to update in case it exists.
     */
    where: lynx_logsWhereUniqueInput
    /**
     * In case the lynx_logs found by the `where` argument doesn't exist, create a new lynx_logs with this data.
     */
    create: XOR<lynx_logsCreateInput, lynx_logsUncheckedCreateInput>
    /**
     * In case the lynx_logs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<lynx_logsUpdateInput, lynx_logsUncheckedUpdateInput>
  }


  /**
   * lynx_logs delete
   */
  export type lynx_logsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lynx_logs
     */
    select?: lynx_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: lynx_logsInclude<ExtArgs> | null
    /**
     * Filter which lynx_logs to delete.
     */
    where: lynx_logsWhereUniqueInput
  }


  /**
   * lynx_logs deleteMany
   */
  export type lynx_logsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which lynx_logs to delete
     */
    where?: lynx_logsWhereInput
  }


  /**
   * lynx_logs without action
   */
  export type lynx_logsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lynx_logs
     */
    select?: lynx_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: lynx_logsInclude<ExtArgs> | null
  }



  /**
   * Model lynx_notifications
   */

  export type AggregateLynx_notifications = {
    _count: Lynx_notificationsCountAggregateOutputType | null
    _avg: Lynx_notificationsAvgAggregateOutputType | null
    _sum: Lynx_notificationsSumAggregateOutputType | null
    _min: Lynx_notificationsMinAggregateOutputType | null
    _max: Lynx_notificationsMaxAggregateOutputType | null
  }

  export type Lynx_notificationsAvgAggregateOutputType = {
    acked_users: number | null
  }

  export type Lynx_notificationsSumAggregateOutputType = {
    acked_users: bigint[]
  }

  export type Lynx_notificationsMinAggregateOutputType = {
    message: string | null
    type: string | null
    id: string | null
    staff_only: boolean | null
    lynxtag: string | null
  }

  export type Lynx_notificationsMaxAggregateOutputType = {
    message: string | null
    type: string | null
    id: string | null
    staff_only: boolean | null
    lynxtag: string | null
  }

  export type Lynx_notificationsCountAggregateOutputType = {
    acked_users: number
    message: number
    type: number
    id: number
    staff_only: number
    lynxtag: number
    _all: number
  }


  export type Lynx_notificationsAvgAggregateInputType = {
    acked_users?: true
  }

  export type Lynx_notificationsSumAggregateInputType = {
    acked_users?: true
  }

  export type Lynx_notificationsMinAggregateInputType = {
    message?: true
    type?: true
    id?: true
    staff_only?: true
    lynxtag?: true
  }

  export type Lynx_notificationsMaxAggregateInputType = {
    message?: true
    type?: true
    id?: true
    staff_only?: true
    lynxtag?: true
  }

  export type Lynx_notificationsCountAggregateInputType = {
    acked_users?: true
    message?: true
    type?: true
    id?: true
    staff_only?: true
    lynxtag?: true
    _all?: true
  }

  export type Lynx_notificationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which lynx_notifications to aggregate.
     */
    where?: lynx_notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lynx_notifications to fetch.
     */
    orderBy?: lynx_notificationsOrderByWithRelationInput | lynx_notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: lynx_notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lynx_notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lynx_notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned lynx_notifications
    **/
    _count?: true | Lynx_notificationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Lynx_notificationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Lynx_notificationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Lynx_notificationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Lynx_notificationsMaxAggregateInputType
  }

  export type GetLynx_notificationsAggregateType<T extends Lynx_notificationsAggregateArgs> = {
        [P in keyof T & keyof AggregateLynx_notifications]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLynx_notifications[P]>
      : GetScalarType<T[P], AggregateLynx_notifications[P]>
  }




  export type lynx_notificationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: lynx_notificationsWhereInput
    orderBy?: lynx_notificationsOrderByWithAggregationInput | lynx_notificationsOrderByWithAggregationInput[]
    by: Lynx_notificationsScalarFieldEnum[] | Lynx_notificationsScalarFieldEnum
    having?: lynx_notificationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Lynx_notificationsCountAggregateInputType | true
    _avg?: Lynx_notificationsAvgAggregateInputType
    _sum?: Lynx_notificationsSumAggregateInputType
    _min?: Lynx_notificationsMinAggregateInputType
    _max?: Lynx_notificationsMaxAggregateInputType
  }

  export type Lynx_notificationsGroupByOutputType = {
    acked_users: bigint[]
    message: string
    type: string
    id: string
    staff_only: boolean | null
    lynxtag: string
    _count: Lynx_notificationsCountAggregateOutputType | null
    _avg: Lynx_notificationsAvgAggregateOutputType | null
    _sum: Lynx_notificationsSumAggregateOutputType | null
    _min: Lynx_notificationsMinAggregateOutputType | null
    _max: Lynx_notificationsMaxAggregateOutputType | null
  }

  type GetLynx_notificationsGroupByPayload<T extends lynx_notificationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Lynx_notificationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Lynx_notificationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Lynx_notificationsGroupByOutputType[P]>
            : GetScalarType<T[P], Lynx_notificationsGroupByOutputType[P]>
        }
      >
    >


  export type lynx_notificationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    acked_users?: boolean
    message?: boolean
    type?: boolean
    id?: boolean
    staff_only?: boolean
    lynxtag?: boolean
  }, ExtArgs["result"]["lynx_notifications"]>

  export type lynx_notificationsSelectScalar = {
    acked_users?: boolean
    message?: boolean
    type?: boolean
    id?: boolean
    staff_only?: boolean
    lynxtag?: boolean
  }


  export type $lynx_notificationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "lynx_notifications"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      acked_users: bigint[]
      message: string
      type: string
      id: string
      staff_only: boolean | null
      lynxtag: string
    }, ExtArgs["result"]["lynx_notifications"]>
    composites: {}
  }


  type lynx_notificationsGetPayload<S extends boolean | null | undefined | lynx_notificationsDefaultArgs> = $Result.GetResult<Prisma.$lynx_notificationsPayload, S>

  type lynx_notificationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<lynx_notificationsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Lynx_notificationsCountAggregateInputType | true
    }

  export interface lynx_notificationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['lynx_notifications'], meta: { name: 'lynx_notifications' } }
    /**
     * Find zero or one Lynx_notifications that matches the filter.
     * @param {lynx_notificationsFindUniqueArgs} args - Arguments to find a Lynx_notifications
     * @example
     * // Get one Lynx_notifications
     * const lynx_notifications = await prisma.lynx_notifications.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends lynx_notificationsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, lynx_notificationsFindUniqueArgs<ExtArgs>>
    ): Prisma__lynx_notificationsClient<$Result.GetResult<Prisma.$lynx_notificationsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Lynx_notifications that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {lynx_notificationsFindUniqueOrThrowArgs} args - Arguments to find a Lynx_notifications
     * @example
     * // Get one Lynx_notifications
     * const lynx_notifications = await prisma.lynx_notifications.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends lynx_notificationsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, lynx_notificationsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__lynx_notificationsClient<$Result.GetResult<Prisma.$lynx_notificationsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Lynx_notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lynx_notificationsFindFirstArgs} args - Arguments to find a Lynx_notifications
     * @example
     * // Get one Lynx_notifications
     * const lynx_notifications = await prisma.lynx_notifications.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends lynx_notificationsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, lynx_notificationsFindFirstArgs<ExtArgs>>
    ): Prisma__lynx_notificationsClient<$Result.GetResult<Prisma.$lynx_notificationsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Lynx_notifications that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lynx_notificationsFindFirstOrThrowArgs} args - Arguments to find a Lynx_notifications
     * @example
     * // Get one Lynx_notifications
     * const lynx_notifications = await prisma.lynx_notifications.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends lynx_notificationsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, lynx_notificationsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__lynx_notificationsClient<$Result.GetResult<Prisma.$lynx_notificationsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Lynx_notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lynx_notificationsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lynx_notifications
     * const lynx_notifications = await prisma.lynx_notifications.findMany()
     * 
     * // Get first 10 Lynx_notifications
     * const lynx_notifications = await prisma.lynx_notifications.findMany({ take: 10 })
     * 
     * // Only select the `acked_users`
     * const lynx_notificationsWithAcked_usersOnly = await prisma.lynx_notifications.findMany({ select: { acked_users: true } })
     * 
    **/
    findMany<T extends lynx_notificationsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, lynx_notificationsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$lynx_notificationsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Lynx_notifications.
     * @param {lynx_notificationsCreateArgs} args - Arguments to create a Lynx_notifications.
     * @example
     * // Create one Lynx_notifications
     * const Lynx_notifications = await prisma.lynx_notifications.create({
     *   data: {
     *     // ... data to create a Lynx_notifications
     *   }
     * })
     * 
    **/
    create<T extends lynx_notificationsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, lynx_notificationsCreateArgs<ExtArgs>>
    ): Prisma__lynx_notificationsClient<$Result.GetResult<Prisma.$lynx_notificationsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Lynx_notifications.
     *     @param {lynx_notificationsCreateManyArgs} args - Arguments to create many Lynx_notifications.
     *     @example
     *     // Create many Lynx_notifications
     *     const lynx_notifications = await prisma.lynx_notifications.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends lynx_notificationsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, lynx_notificationsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Lynx_notifications.
     * @param {lynx_notificationsDeleteArgs} args - Arguments to delete one Lynx_notifications.
     * @example
     * // Delete one Lynx_notifications
     * const Lynx_notifications = await prisma.lynx_notifications.delete({
     *   where: {
     *     // ... filter to delete one Lynx_notifications
     *   }
     * })
     * 
    **/
    delete<T extends lynx_notificationsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, lynx_notificationsDeleteArgs<ExtArgs>>
    ): Prisma__lynx_notificationsClient<$Result.GetResult<Prisma.$lynx_notificationsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Lynx_notifications.
     * @param {lynx_notificationsUpdateArgs} args - Arguments to update one Lynx_notifications.
     * @example
     * // Update one Lynx_notifications
     * const lynx_notifications = await prisma.lynx_notifications.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends lynx_notificationsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, lynx_notificationsUpdateArgs<ExtArgs>>
    ): Prisma__lynx_notificationsClient<$Result.GetResult<Prisma.$lynx_notificationsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Lynx_notifications.
     * @param {lynx_notificationsDeleteManyArgs} args - Arguments to filter Lynx_notifications to delete.
     * @example
     * // Delete a few Lynx_notifications
     * const { count } = await prisma.lynx_notifications.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends lynx_notificationsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, lynx_notificationsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lynx_notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lynx_notificationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lynx_notifications
     * const lynx_notifications = await prisma.lynx_notifications.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends lynx_notificationsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, lynx_notificationsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Lynx_notifications.
     * @param {lynx_notificationsUpsertArgs} args - Arguments to update or create a Lynx_notifications.
     * @example
     * // Update or create a Lynx_notifications
     * const lynx_notifications = await prisma.lynx_notifications.upsert({
     *   create: {
     *     // ... data to create a Lynx_notifications
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lynx_notifications we want to update
     *   }
     * })
    **/
    upsert<T extends lynx_notificationsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, lynx_notificationsUpsertArgs<ExtArgs>>
    ): Prisma__lynx_notificationsClient<$Result.GetResult<Prisma.$lynx_notificationsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Lynx_notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lynx_notificationsCountArgs} args - Arguments to filter Lynx_notifications to count.
     * @example
     * // Count the number of Lynx_notifications
     * const count = await prisma.lynx_notifications.count({
     *   where: {
     *     // ... the filter for the Lynx_notifications we want to count
     *   }
     * })
    **/
    count<T extends lynx_notificationsCountArgs>(
      args?: Subset<T, lynx_notificationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Lynx_notificationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lynx_notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lynx_notificationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Lynx_notificationsAggregateArgs>(args: Subset<T, Lynx_notificationsAggregateArgs>): Prisma.PrismaPromise<GetLynx_notificationsAggregateType<T>>

    /**
     * Group by Lynx_notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lynx_notificationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends lynx_notificationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: lynx_notificationsGroupByArgs['orderBy'] }
        : { orderBy?: lynx_notificationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, lynx_notificationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLynx_notificationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the lynx_notifications model
   */
  readonly fields: lynx_notificationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for lynx_notifications.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__lynx_notificationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the lynx_notifications model
   */ 
  interface lynx_notificationsFieldRefs {
    readonly acked_users: FieldRef<"lynx_notifications", 'BigInt[]'>
    readonly message: FieldRef<"lynx_notifications", 'String'>
    readonly type: FieldRef<"lynx_notifications", 'String'>
    readonly id: FieldRef<"lynx_notifications", 'String'>
    readonly staff_only: FieldRef<"lynx_notifications", 'Boolean'>
    readonly lynxtag: FieldRef<"lynx_notifications", 'String'>
  }
    

  // Custom InputTypes

  /**
   * lynx_notifications findUnique
   */
  export type lynx_notificationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lynx_notifications
     */
    select?: lynx_notificationsSelect<ExtArgs> | null
    /**
     * Filter, which lynx_notifications to fetch.
     */
    where: lynx_notificationsWhereUniqueInput
  }


  /**
   * lynx_notifications findUniqueOrThrow
   */
  export type lynx_notificationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lynx_notifications
     */
    select?: lynx_notificationsSelect<ExtArgs> | null
    /**
     * Filter, which lynx_notifications to fetch.
     */
    where: lynx_notificationsWhereUniqueInput
  }


  /**
   * lynx_notifications findFirst
   */
  export type lynx_notificationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lynx_notifications
     */
    select?: lynx_notificationsSelect<ExtArgs> | null
    /**
     * Filter, which lynx_notifications to fetch.
     */
    where?: lynx_notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lynx_notifications to fetch.
     */
    orderBy?: lynx_notificationsOrderByWithRelationInput | lynx_notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for lynx_notifications.
     */
    cursor?: lynx_notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lynx_notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lynx_notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of lynx_notifications.
     */
    distinct?: Lynx_notificationsScalarFieldEnum | Lynx_notificationsScalarFieldEnum[]
  }


  /**
   * lynx_notifications findFirstOrThrow
   */
  export type lynx_notificationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lynx_notifications
     */
    select?: lynx_notificationsSelect<ExtArgs> | null
    /**
     * Filter, which lynx_notifications to fetch.
     */
    where?: lynx_notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lynx_notifications to fetch.
     */
    orderBy?: lynx_notificationsOrderByWithRelationInput | lynx_notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for lynx_notifications.
     */
    cursor?: lynx_notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lynx_notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lynx_notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of lynx_notifications.
     */
    distinct?: Lynx_notificationsScalarFieldEnum | Lynx_notificationsScalarFieldEnum[]
  }


  /**
   * lynx_notifications findMany
   */
  export type lynx_notificationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lynx_notifications
     */
    select?: lynx_notificationsSelect<ExtArgs> | null
    /**
     * Filter, which lynx_notifications to fetch.
     */
    where?: lynx_notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lynx_notifications to fetch.
     */
    orderBy?: lynx_notificationsOrderByWithRelationInput | lynx_notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing lynx_notifications.
     */
    cursor?: lynx_notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lynx_notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lynx_notifications.
     */
    skip?: number
    distinct?: Lynx_notificationsScalarFieldEnum | Lynx_notificationsScalarFieldEnum[]
  }


  /**
   * lynx_notifications create
   */
  export type lynx_notificationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lynx_notifications
     */
    select?: lynx_notificationsSelect<ExtArgs> | null
    /**
     * The data needed to create a lynx_notifications.
     */
    data: XOR<lynx_notificationsCreateInput, lynx_notificationsUncheckedCreateInput>
  }


  /**
   * lynx_notifications createMany
   */
  export type lynx_notificationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many lynx_notifications.
     */
    data: lynx_notificationsCreateManyInput | lynx_notificationsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * lynx_notifications update
   */
  export type lynx_notificationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lynx_notifications
     */
    select?: lynx_notificationsSelect<ExtArgs> | null
    /**
     * The data needed to update a lynx_notifications.
     */
    data: XOR<lynx_notificationsUpdateInput, lynx_notificationsUncheckedUpdateInput>
    /**
     * Choose, which lynx_notifications to update.
     */
    where: lynx_notificationsWhereUniqueInput
  }


  /**
   * lynx_notifications updateMany
   */
  export type lynx_notificationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update lynx_notifications.
     */
    data: XOR<lynx_notificationsUpdateManyMutationInput, lynx_notificationsUncheckedUpdateManyInput>
    /**
     * Filter which lynx_notifications to update
     */
    where?: lynx_notificationsWhereInput
  }


  /**
   * lynx_notifications upsert
   */
  export type lynx_notificationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lynx_notifications
     */
    select?: lynx_notificationsSelect<ExtArgs> | null
    /**
     * The filter to search for the lynx_notifications to update in case it exists.
     */
    where: lynx_notificationsWhereUniqueInput
    /**
     * In case the lynx_notifications found by the `where` argument doesn't exist, create a new lynx_notifications with this data.
     */
    create: XOR<lynx_notificationsCreateInput, lynx_notificationsUncheckedCreateInput>
    /**
     * In case the lynx_notifications was found with the provided `where` argument, update it with this data.
     */
    update: XOR<lynx_notificationsUpdateInput, lynx_notificationsUncheckedUpdateInput>
  }


  /**
   * lynx_notifications delete
   */
  export type lynx_notificationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lynx_notifications
     */
    select?: lynx_notificationsSelect<ExtArgs> | null
    /**
     * Filter which lynx_notifications to delete.
     */
    where: lynx_notificationsWhereUniqueInput
  }


  /**
   * lynx_notifications deleteMany
   */
  export type lynx_notificationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which lynx_notifications to delete
     */
    where?: lynx_notificationsWhereInput
  }


  /**
   * lynx_notifications without action
   */
  export type lynx_notificationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lynx_notifications
     */
    select?: lynx_notificationsSelect<ExtArgs> | null
  }



  /**
   * Model lynx_ratings
   */

  export type AggregateLynx_ratings = {
    _count: Lynx_ratingsCountAggregateOutputType | null
    _avg: Lynx_ratingsAvgAggregateOutputType | null
    _sum: Lynx_ratingsSumAggregateOutputType | null
    _min: Lynx_ratingsMinAggregateOutputType | null
    _max: Lynx_ratingsMaxAggregateOutputType | null
  }

  export type Lynx_ratingsAvgAggregateOutputType = {
    user_id: number | null
  }

  export type Lynx_ratingsSumAggregateOutputType = {
    user_id: bigint | null
  }

  export type Lynx_ratingsMinAggregateOutputType = {
    id: string | null
    feedback: string | null
    username_cached: string | null
    user_id: bigint | null
    page: string | null
    lynxtag: string | null
  }

  export type Lynx_ratingsMaxAggregateOutputType = {
    id: string | null
    feedback: string | null
    username_cached: string | null
    user_id: bigint | null
    page: string | null
    lynxtag: string | null
  }

  export type Lynx_ratingsCountAggregateOutputType = {
    id: number
    feedback: number
    username_cached: number
    user_id: number
    page: number
    lynxtag: number
    _all: number
  }


  export type Lynx_ratingsAvgAggregateInputType = {
    user_id?: true
  }

  export type Lynx_ratingsSumAggregateInputType = {
    user_id?: true
  }

  export type Lynx_ratingsMinAggregateInputType = {
    id?: true
    feedback?: true
    username_cached?: true
    user_id?: true
    page?: true
    lynxtag?: true
  }

  export type Lynx_ratingsMaxAggregateInputType = {
    id?: true
    feedback?: true
    username_cached?: true
    user_id?: true
    page?: true
    lynxtag?: true
  }

  export type Lynx_ratingsCountAggregateInputType = {
    id?: true
    feedback?: true
    username_cached?: true
    user_id?: true
    page?: true
    lynxtag?: true
    _all?: true
  }

  export type Lynx_ratingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which lynx_ratings to aggregate.
     */
    where?: lynx_ratingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lynx_ratings to fetch.
     */
    orderBy?: lynx_ratingsOrderByWithRelationInput | lynx_ratingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: lynx_ratingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lynx_ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lynx_ratings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned lynx_ratings
    **/
    _count?: true | Lynx_ratingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Lynx_ratingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Lynx_ratingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Lynx_ratingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Lynx_ratingsMaxAggregateInputType
  }

  export type GetLynx_ratingsAggregateType<T extends Lynx_ratingsAggregateArgs> = {
        [P in keyof T & keyof AggregateLynx_ratings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLynx_ratings[P]>
      : GetScalarType<T[P], AggregateLynx_ratings[P]>
  }




  export type lynx_ratingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: lynx_ratingsWhereInput
    orderBy?: lynx_ratingsOrderByWithAggregationInput | lynx_ratingsOrderByWithAggregationInput[]
    by: Lynx_ratingsScalarFieldEnum[] | Lynx_ratingsScalarFieldEnum
    having?: lynx_ratingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Lynx_ratingsCountAggregateInputType | true
    _avg?: Lynx_ratingsAvgAggregateInputType
    _sum?: Lynx_ratingsSumAggregateInputType
    _min?: Lynx_ratingsMinAggregateInputType
    _max?: Lynx_ratingsMaxAggregateInputType
  }

  export type Lynx_ratingsGroupByOutputType = {
    id: string
    feedback: string
    username_cached: string
    user_id: bigint | null
    page: string
    lynxtag: string
    _count: Lynx_ratingsCountAggregateOutputType | null
    _avg: Lynx_ratingsAvgAggregateOutputType | null
    _sum: Lynx_ratingsSumAggregateOutputType | null
    _min: Lynx_ratingsMinAggregateOutputType | null
    _max: Lynx_ratingsMaxAggregateOutputType | null
  }

  type GetLynx_ratingsGroupByPayload<T extends lynx_ratingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Lynx_ratingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Lynx_ratingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Lynx_ratingsGroupByOutputType[P]>
            : GetScalarType<T[P], Lynx_ratingsGroupByOutputType[P]>
        }
      >
    >


  export type lynx_ratingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    feedback?: boolean
    username_cached?: boolean
    user_id?: boolean
    page?: boolean
    lynxtag?: boolean
    users?: boolean | lynx_ratings$usersArgs<ExtArgs>
  }, ExtArgs["result"]["lynx_ratings"]>

  export type lynx_ratingsSelectScalar = {
    id?: boolean
    feedback?: boolean
    username_cached?: boolean
    user_id?: boolean
    page?: boolean
    lynxtag?: boolean
  }

  export type lynx_ratingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | lynx_ratings$usersArgs<ExtArgs>
  }


  export type $lynx_ratingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "lynx_ratings"
    objects: {
      users: Prisma.$usersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      feedback: string
      username_cached: string
      user_id: bigint | null
      page: string
      lynxtag: string
    }, ExtArgs["result"]["lynx_ratings"]>
    composites: {}
  }


  type lynx_ratingsGetPayload<S extends boolean | null | undefined | lynx_ratingsDefaultArgs> = $Result.GetResult<Prisma.$lynx_ratingsPayload, S>

  type lynx_ratingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<lynx_ratingsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Lynx_ratingsCountAggregateInputType | true
    }

  export interface lynx_ratingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['lynx_ratings'], meta: { name: 'lynx_ratings' } }
    /**
     * Find zero or one Lynx_ratings that matches the filter.
     * @param {lynx_ratingsFindUniqueArgs} args - Arguments to find a Lynx_ratings
     * @example
     * // Get one Lynx_ratings
     * const lynx_ratings = await prisma.lynx_ratings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends lynx_ratingsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, lynx_ratingsFindUniqueArgs<ExtArgs>>
    ): Prisma__lynx_ratingsClient<$Result.GetResult<Prisma.$lynx_ratingsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Lynx_ratings that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {lynx_ratingsFindUniqueOrThrowArgs} args - Arguments to find a Lynx_ratings
     * @example
     * // Get one Lynx_ratings
     * const lynx_ratings = await prisma.lynx_ratings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends lynx_ratingsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, lynx_ratingsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__lynx_ratingsClient<$Result.GetResult<Prisma.$lynx_ratingsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Lynx_ratings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lynx_ratingsFindFirstArgs} args - Arguments to find a Lynx_ratings
     * @example
     * // Get one Lynx_ratings
     * const lynx_ratings = await prisma.lynx_ratings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends lynx_ratingsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, lynx_ratingsFindFirstArgs<ExtArgs>>
    ): Prisma__lynx_ratingsClient<$Result.GetResult<Prisma.$lynx_ratingsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Lynx_ratings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lynx_ratingsFindFirstOrThrowArgs} args - Arguments to find a Lynx_ratings
     * @example
     * // Get one Lynx_ratings
     * const lynx_ratings = await prisma.lynx_ratings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends lynx_ratingsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, lynx_ratingsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__lynx_ratingsClient<$Result.GetResult<Prisma.$lynx_ratingsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Lynx_ratings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lynx_ratingsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lynx_ratings
     * const lynx_ratings = await prisma.lynx_ratings.findMany()
     * 
     * // Get first 10 Lynx_ratings
     * const lynx_ratings = await prisma.lynx_ratings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lynx_ratingsWithIdOnly = await prisma.lynx_ratings.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends lynx_ratingsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, lynx_ratingsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$lynx_ratingsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Lynx_ratings.
     * @param {lynx_ratingsCreateArgs} args - Arguments to create a Lynx_ratings.
     * @example
     * // Create one Lynx_ratings
     * const Lynx_ratings = await prisma.lynx_ratings.create({
     *   data: {
     *     // ... data to create a Lynx_ratings
     *   }
     * })
     * 
    **/
    create<T extends lynx_ratingsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, lynx_ratingsCreateArgs<ExtArgs>>
    ): Prisma__lynx_ratingsClient<$Result.GetResult<Prisma.$lynx_ratingsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Lynx_ratings.
     *     @param {lynx_ratingsCreateManyArgs} args - Arguments to create many Lynx_ratings.
     *     @example
     *     // Create many Lynx_ratings
     *     const lynx_ratings = await prisma.lynx_ratings.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends lynx_ratingsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, lynx_ratingsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Lynx_ratings.
     * @param {lynx_ratingsDeleteArgs} args - Arguments to delete one Lynx_ratings.
     * @example
     * // Delete one Lynx_ratings
     * const Lynx_ratings = await prisma.lynx_ratings.delete({
     *   where: {
     *     // ... filter to delete one Lynx_ratings
     *   }
     * })
     * 
    **/
    delete<T extends lynx_ratingsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, lynx_ratingsDeleteArgs<ExtArgs>>
    ): Prisma__lynx_ratingsClient<$Result.GetResult<Prisma.$lynx_ratingsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Lynx_ratings.
     * @param {lynx_ratingsUpdateArgs} args - Arguments to update one Lynx_ratings.
     * @example
     * // Update one Lynx_ratings
     * const lynx_ratings = await prisma.lynx_ratings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends lynx_ratingsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, lynx_ratingsUpdateArgs<ExtArgs>>
    ): Prisma__lynx_ratingsClient<$Result.GetResult<Prisma.$lynx_ratingsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Lynx_ratings.
     * @param {lynx_ratingsDeleteManyArgs} args - Arguments to filter Lynx_ratings to delete.
     * @example
     * // Delete a few Lynx_ratings
     * const { count } = await prisma.lynx_ratings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends lynx_ratingsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, lynx_ratingsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lynx_ratings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lynx_ratingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lynx_ratings
     * const lynx_ratings = await prisma.lynx_ratings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends lynx_ratingsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, lynx_ratingsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Lynx_ratings.
     * @param {lynx_ratingsUpsertArgs} args - Arguments to update or create a Lynx_ratings.
     * @example
     * // Update or create a Lynx_ratings
     * const lynx_ratings = await prisma.lynx_ratings.upsert({
     *   create: {
     *     // ... data to create a Lynx_ratings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lynx_ratings we want to update
     *   }
     * })
    **/
    upsert<T extends lynx_ratingsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, lynx_ratingsUpsertArgs<ExtArgs>>
    ): Prisma__lynx_ratingsClient<$Result.GetResult<Prisma.$lynx_ratingsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Lynx_ratings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lynx_ratingsCountArgs} args - Arguments to filter Lynx_ratings to count.
     * @example
     * // Count the number of Lynx_ratings
     * const count = await prisma.lynx_ratings.count({
     *   where: {
     *     // ... the filter for the Lynx_ratings we want to count
     *   }
     * })
    **/
    count<T extends lynx_ratingsCountArgs>(
      args?: Subset<T, lynx_ratingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Lynx_ratingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lynx_ratings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lynx_ratingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Lynx_ratingsAggregateArgs>(args: Subset<T, Lynx_ratingsAggregateArgs>): Prisma.PrismaPromise<GetLynx_ratingsAggregateType<T>>

    /**
     * Group by Lynx_ratings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lynx_ratingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends lynx_ratingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: lynx_ratingsGroupByArgs['orderBy'] }
        : { orderBy?: lynx_ratingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, lynx_ratingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLynx_ratingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the lynx_ratings model
   */
  readonly fields: lynx_ratingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for lynx_ratings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__lynx_ratingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    users<T extends lynx_ratings$usersArgs<ExtArgs> = {}>(args?: Subset<T, lynx_ratings$usersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the lynx_ratings model
   */ 
  interface lynx_ratingsFieldRefs {
    readonly id: FieldRef<"lynx_ratings", 'String'>
    readonly feedback: FieldRef<"lynx_ratings", 'String'>
    readonly username_cached: FieldRef<"lynx_ratings", 'String'>
    readonly user_id: FieldRef<"lynx_ratings", 'BigInt'>
    readonly page: FieldRef<"lynx_ratings", 'String'>
    readonly lynxtag: FieldRef<"lynx_ratings", 'String'>
  }
    

  // Custom InputTypes

  /**
   * lynx_ratings findUnique
   */
  export type lynx_ratingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lynx_ratings
     */
    select?: lynx_ratingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: lynx_ratingsInclude<ExtArgs> | null
    /**
     * Filter, which lynx_ratings to fetch.
     */
    where: lynx_ratingsWhereUniqueInput
  }


  /**
   * lynx_ratings findUniqueOrThrow
   */
  export type lynx_ratingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lynx_ratings
     */
    select?: lynx_ratingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: lynx_ratingsInclude<ExtArgs> | null
    /**
     * Filter, which lynx_ratings to fetch.
     */
    where: lynx_ratingsWhereUniqueInput
  }


  /**
   * lynx_ratings findFirst
   */
  export type lynx_ratingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lynx_ratings
     */
    select?: lynx_ratingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: lynx_ratingsInclude<ExtArgs> | null
    /**
     * Filter, which lynx_ratings to fetch.
     */
    where?: lynx_ratingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lynx_ratings to fetch.
     */
    orderBy?: lynx_ratingsOrderByWithRelationInput | lynx_ratingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for lynx_ratings.
     */
    cursor?: lynx_ratingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lynx_ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lynx_ratings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of lynx_ratings.
     */
    distinct?: Lynx_ratingsScalarFieldEnum | Lynx_ratingsScalarFieldEnum[]
  }


  /**
   * lynx_ratings findFirstOrThrow
   */
  export type lynx_ratingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lynx_ratings
     */
    select?: lynx_ratingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: lynx_ratingsInclude<ExtArgs> | null
    /**
     * Filter, which lynx_ratings to fetch.
     */
    where?: lynx_ratingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lynx_ratings to fetch.
     */
    orderBy?: lynx_ratingsOrderByWithRelationInput | lynx_ratingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for lynx_ratings.
     */
    cursor?: lynx_ratingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lynx_ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lynx_ratings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of lynx_ratings.
     */
    distinct?: Lynx_ratingsScalarFieldEnum | Lynx_ratingsScalarFieldEnum[]
  }


  /**
   * lynx_ratings findMany
   */
  export type lynx_ratingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lynx_ratings
     */
    select?: lynx_ratingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: lynx_ratingsInclude<ExtArgs> | null
    /**
     * Filter, which lynx_ratings to fetch.
     */
    where?: lynx_ratingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lynx_ratings to fetch.
     */
    orderBy?: lynx_ratingsOrderByWithRelationInput | lynx_ratingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing lynx_ratings.
     */
    cursor?: lynx_ratingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lynx_ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lynx_ratings.
     */
    skip?: number
    distinct?: Lynx_ratingsScalarFieldEnum | Lynx_ratingsScalarFieldEnum[]
  }


  /**
   * lynx_ratings create
   */
  export type lynx_ratingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lynx_ratings
     */
    select?: lynx_ratingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: lynx_ratingsInclude<ExtArgs> | null
    /**
     * The data needed to create a lynx_ratings.
     */
    data: XOR<lynx_ratingsCreateInput, lynx_ratingsUncheckedCreateInput>
  }


  /**
   * lynx_ratings createMany
   */
  export type lynx_ratingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many lynx_ratings.
     */
    data: lynx_ratingsCreateManyInput | lynx_ratingsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * lynx_ratings update
   */
  export type lynx_ratingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lynx_ratings
     */
    select?: lynx_ratingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: lynx_ratingsInclude<ExtArgs> | null
    /**
     * The data needed to update a lynx_ratings.
     */
    data: XOR<lynx_ratingsUpdateInput, lynx_ratingsUncheckedUpdateInput>
    /**
     * Choose, which lynx_ratings to update.
     */
    where: lynx_ratingsWhereUniqueInput
  }


  /**
   * lynx_ratings updateMany
   */
  export type lynx_ratingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update lynx_ratings.
     */
    data: XOR<lynx_ratingsUpdateManyMutationInput, lynx_ratingsUncheckedUpdateManyInput>
    /**
     * Filter which lynx_ratings to update
     */
    where?: lynx_ratingsWhereInput
  }


  /**
   * lynx_ratings upsert
   */
  export type lynx_ratingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lynx_ratings
     */
    select?: lynx_ratingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: lynx_ratingsInclude<ExtArgs> | null
    /**
     * The filter to search for the lynx_ratings to update in case it exists.
     */
    where: lynx_ratingsWhereUniqueInput
    /**
     * In case the lynx_ratings found by the `where` argument doesn't exist, create a new lynx_ratings with this data.
     */
    create: XOR<lynx_ratingsCreateInput, lynx_ratingsUncheckedCreateInput>
    /**
     * In case the lynx_ratings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<lynx_ratingsUpdateInput, lynx_ratingsUncheckedUpdateInput>
  }


  /**
   * lynx_ratings delete
   */
  export type lynx_ratingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lynx_ratings
     */
    select?: lynx_ratingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: lynx_ratingsInclude<ExtArgs> | null
    /**
     * Filter which lynx_ratings to delete.
     */
    where: lynx_ratingsWhereUniqueInput
  }


  /**
   * lynx_ratings deleteMany
   */
  export type lynx_ratingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which lynx_ratings to delete
     */
    where?: lynx_ratingsWhereInput
  }


  /**
   * lynx_ratings.users
   */
  export type lynx_ratings$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }


  /**
   * lynx_ratings without action
   */
  export type lynx_ratingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lynx_ratings
     */
    select?: lynx_ratingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: lynx_ratingsInclude<ExtArgs> | null
  }



  /**
   * Model lynx_survey_responses
   */

  export type AggregateLynx_survey_responses = {
    _count: Lynx_survey_responsesCountAggregateOutputType | null
    _avg: Lynx_survey_responsesAvgAggregateOutputType | null
    _sum: Lynx_survey_responsesSumAggregateOutputType | null
    _min: Lynx_survey_responsesMinAggregateOutputType | null
    _max: Lynx_survey_responsesMaxAggregateOutputType | null
  }

  export type Lynx_survey_responsesAvgAggregateOutputType = {
    user_id: number | null
  }

  export type Lynx_survey_responsesSumAggregateOutputType = {
    user_id: bigint | null
  }

  export type Lynx_survey_responsesMinAggregateOutputType = {
    id: string | null
    username_cached: string | null
    user_id: bigint | null
    survey_id: string | null
    lynxtag: string | null
  }

  export type Lynx_survey_responsesMaxAggregateOutputType = {
    id: string | null
    username_cached: string | null
    user_id: bigint | null
    survey_id: string | null
    lynxtag: string | null
  }

  export type Lynx_survey_responsesCountAggregateOutputType = {
    id: number
    questions: number
    answers: number
    username_cached: number
    user_id: number
    survey_id: number
    lynxtag: number
    _all: number
  }


  export type Lynx_survey_responsesAvgAggregateInputType = {
    user_id?: true
  }

  export type Lynx_survey_responsesSumAggregateInputType = {
    user_id?: true
  }

  export type Lynx_survey_responsesMinAggregateInputType = {
    id?: true
    username_cached?: true
    user_id?: true
    survey_id?: true
    lynxtag?: true
  }

  export type Lynx_survey_responsesMaxAggregateInputType = {
    id?: true
    username_cached?: true
    user_id?: true
    survey_id?: true
    lynxtag?: true
  }

  export type Lynx_survey_responsesCountAggregateInputType = {
    id?: true
    questions?: true
    answers?: true
    username_cached?: true
    user_id?: true
    survey_id?: true
    lynxtag?: true
    _all?: true
  }

  export type Lynx_survey_responsesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which lynx_survey_responses to aggregate.
     */
    where?: lynx_survey_responsesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lynx_survey_responses to fetch.
     */
    orderBy?: lynx_survey_responsesOrderByWithRelationInput | lynx_survey_responsesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: lynx_survey_responsesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lynx_survey_responses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lynx_survey_responses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned lynx_survey_responses
    **/
    _count?: true | Lynx_survey_responsesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Lynx_survey_responsesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Lynx_survey_responsesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Lynx_survey_responsesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Lynx_survey_responsesMaxAggregateInputType
  }

  export type GetLynx_survey_responsesAggregateType<T extends Lynx_survey_responsesAggregateArgs> = {
        [P in keyof T & keyof AggregateLynx_survey_responses]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLynx_survey_responses[P]>
      : GetScalarType<T[P], AggregateLynx_survey_responses[P]>
  }




  export type lynx_survey_responsesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: lynx_survey_responsesWhereInput
    orderBy?: lynx_survey_responsesOrderByWithAggregationInput | lynx_survey_responsesOrderByWithAggregationInput[]
    by: Lynx_survey_responsesScalarFieldEnum[] | Lynx_survey_responsesScalarFieldEnum
    having?: lynx_survey_responsesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Lynx_survey_responsesCountAggregateInputType | true
    _avg?: Lynx_survey_responsesAvgAggregateInputType
    _sum?: Lynx_survey_responsesSumAggregateInputType
    _min?: Lynx_survey_responsesMinAggregateInputType
    _max?: Lynx_survey_responsesMaxAggregateInputType
  }

  export type Lynx_survey_responsesGroupByOutputType = {
    id: string
    questions: JsonValue
    answers: JsonValue
    username_cached: string
    user_id: bigint | null
    survey_id: string
    lynxtag: string
    _count: Lynx_survey_responsesCountAggregateOutputType | null
    _avg: Lynx_survey_responsesAvgAggregateOutputType | null
    _sum: Lynx_survey_responsesSumAggregateOutputType | null
    _min: Lynx_survey_responsesMinAggregateOutputType | null
    _max: Lynx_survey_responsesMaxAggregateOutputType | null
  }

  type GetLynx_survey_responsesGroupByPayload<T extends lynx_survey_responsesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Lynx_survey_responsesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Lynx_survey_responsesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Lynx_survey_responsesGroupByOutputType[P]>
            : GetScalarType<T[P], Lynx_survey_responsesGroupByOutputType[P]>
        }
      >
    >


  export type lynx_survey_responsesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questions?: boolean
    answers?: boolean
    username_cached?: boolean
    user_id?: boolean
    survey_id?: boolean
    lynxtag?: boolean
    lynx_surveys?: boolean | lynx_surveysDefaultArgs<ExtArgs>
    users?: boolean | lynx_survey_responses$usersArgs<ExtArgs>
  }, ExtArgs["result"]["lynx_survey_responses"]>

  export type lynx_survey_responsesSelectScalar = {
    id?: boolean
    questions?: boolean
    answers?: boolean
    username_cached?: boolean
    user_id?: boolean
    survey_id?: boolean
    lynxtag?: boolean
  }

  export type lynx_survey_responsesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lynx_surveys?: boolean | lynx_surveysDefaultArgs<ExtArgs>
    users?: boolean | lynx_survey_responses$usersArgs<ExtArgs>
  }


  export type $lynx_survey_responsesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "lynx_survey_responses"
    objects: {
      lynx_surveys: Prisma.$lynx_surveysPayload<ExtArgs>
      users: Prisma.$usersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      questions: Prisma.JsonValue
      answers: Prisma.JsonValue
      username_cached: string
      user_id: bigint | null
      survey_id: string
      lynxtag: string
    }, ExtArgs["result"]["lynx_survey_responses"]>
    composites: {}
  }


  type lynx_survey_responsesGetPayload<S extends boolean | null | undefined | lynx_survey_responsesDefaultArgs> = $Result.GetResult<Prisma.$lynx_survey_responsesPayload, S>

  type lynx_survey_responsesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<lynx_survey_responsesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Lynx_survey_responsesCountAggregateInputType | true
    }

  export interface lynx_survey_responsesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['lynx_survey_responses'], meta: { name: 'lynx_survey_responses' } }
    /**
     * Find zero or one Lynx_survey_responses that matches the filter.
     * @param {lynx_survey_responsesFindUniqueArgs} args - Arguments to find a Lynx_survey_responses
     * @example
     * // Get one Lynx_survey_responses
     * const lynx_survey_responses = await prisma.lynx_survey_responses.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends lynx_survey_responsesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, lynx_survey_responsesFindUniqueArgs<ExtArgs>>
    ): Prisma__lynx_survey_responsesClient<$Result.GetResult<Prisma.$lynx_survey_responsesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Lynx_survey_responses that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {lynx_survey_responsesFindUniqueOrThrowArgs} args - Arguments to find a Lynx_survey_responses
     * @example
     * // Get one Lynx_survey_responses
     * const lynx_survey_responses = await prisma.lynx_survey_responses.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends lynx_survey_responsesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, lynx_survey_responsesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__lynx_survey_responsesClient<$Result.GetResult<Prisma.$lynx_survey_responsesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Lynx_survey_responses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lynx_survey_responsesFindFirstArgs} args - Arguments to find a Lynx_survey_responses
     * @example
     * // Get one Lynx_survey_responses
     * const lynx_survey_responses = await prisma.lynx_survey_responses.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends lynx_survey_responsesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, lynx_survey_responsesFindFirstArgs<ExtArgs>>
    ): Prisma__lynx_survey_responsesClient<$Result.GetResult<Prisma.$lynx_survey_responsesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Lynx_survey_responses that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lynx_survey_responsesFindFirstOrThrowArgs} args - Arguments to find a Lynx_survey_responses
     * @example
     * // Get one Lynx_survey_responses
     * const lynx_survey_responses = await prisma.lynx_survey_responses.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends lynx_survey_responsesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, lynx_survey_responsesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__lynx_survey_responsesClient<$Result.GetResult<Prisma.$lynx_survey_responsesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Lynx_survey_responses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lynx_survey_responsesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lynx_survey_responses
     * const lynx_survey_responses = await prisma.lynx_survey_responses.findMany()
     * 
     * // Get first 10 Lynx_survey_responses
     * const lynx_survey_responses = await prisma.lynx_survey_responses.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lynx_survey_responsesWithIdOnly = await prisma.lynx_survey_responses.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends lynx_survey_responsesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, lynx_survey_responsesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$lynx_survey_responsesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Lynx_survey_responses.
     * @param {lynx_survey_responsesCreateArgs} args - Arguments to create a Lynx_survey_responses.
     * @example
     * // Create one Lynx_survey_responses
     * const Lynx_survey_responses = await prisma.lynx_survey_responses.create({
     *   data: {
     *     // ... data to create a Lynx_survey_responses
     *   }
     * })
     * 
    **/
    create<T extends lynx_survey_responsesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, lynx_survey_responsesCreateArgs<ExtArgs>>
    ): Prisma__lynx_survey_responsesClient<$Result.GetResult<Prisma.$lynx_survey_responsesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Lynx_survey_responses.
     *     @param {lynx_survey_responsesCreateManyArgs} args - Arguments to create many Lynx_survey_responses.
     *     @example
     *     // Create many Lynx_survey_responses
     *     const lynx_survey_responses = await prisma.lynx_survey_responses.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends lynx_survey_responsesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, lynx_survey_responsesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Lynx_survey_responses.
     * @param {lynx_survey_responsesDeleteArgs} args - Arguments to delete one Lynx_survey_responses.
     * @example
     * // Delete one Lynx_survey_responses
     * const Lynx_survey_responses = await prisma.lynx_survey_responses.delete({
     *   where: {
     *     // ... filter to delete one Lynx_survey_responses
     *   }
     * })
     * 
    **/
    delete<T extends lynx_survey_responsesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, lynx_survey_responsesDeleteArgs<ExtArgs>>
    ): Prisma__lynx_survey_responsesClient<$Result.GetResult<Prisma.$lynx_survey_responsesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Lynx_survey_responses.
     * @param {lynx_survey_responsesUpdateArgs} args - Arguments to update one Lynx_survey_responses.
     * @example
     * // Update one Lynx_survey_responses
     * const lynx_survey_responses = await prisma.lynx_survey_responses.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends lynx_survey_responsesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, lynx_survey_responsesUpdateArgs<ExtArgs>>
    ): Prisma__lynx_survey_responsesClient<$Result.GetResult<Prisma.$lynx_survey_responsesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Lynx_survey_responses.
     * @param {lynx_survey_responsesDeleteManyArgs} args - Arguments to filter Lynx_survey_responses to delete.
     * @example
     * // Delete a few Lynx_survey_responses
     * const { count } = await prisma.lynx_survey_responses.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends lynx_survey_responsesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, lynx_survey_responsesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lynx_survey_responses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lynx_survey_responsesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lynx_survey_responses
     * const lynx_survey_responses = await prisma.lynx_survey_responses.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends lynx_survey_responsesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, lynx_survey_responsesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Lynx_survey_responses.
     * @param {lynx_survey_responsesUpsertArgs} args - Arguments to update or create a Lynx_survey_responses.
     * @example
     * // Update or create a Lynx_survey_responses
     * const lynx_survey_responses = await prisma.lynx_survey_responses.upsert({
     *   create: {
     *     // ... data to create a Lynx_survey_responses
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lynx_survey_responses we want to update
     *   }
     * })
    **/
    upsert<T extends lynx_survey_responsesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, lynx_survey_responsesUpsertArgs<ExtArgs>>
    ): Prisma__lynx_survey_responsesClient<$Result.GetResult<Prisma.$lynx_survey_responsesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Lynx_survey_responses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lynx_survey_responsesCountArgs} args - Arguments to filter Lynx_survey_responses to count.
     * @example
     * // Count the number of Lynx_survey_responses
     * const count = await prisma.lynx_survey_responses.count({
     *   where: {
     *     // ... the filter for the Lynx_survey_responses we want to count
     *   }
     * })
    **/
    count<T extends lynx_survey_responsesCountArgs>(
      args?: Subset<T, lynx_survey_responsesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Lynx_survey_responsesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lynx_survey_responses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lynx_survey_responsesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Lynx_survey_responsesAggregateArgs>(args: Subset<T, Lynx_survey_responsesAggregateArgs>): Prisma.PrismaPromise<GetLynx_survey_responsesAggregateType<T>>

    /**
     * Group by Lynx_survey_responses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lynx_survey_responsesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends lynx_survey_responsesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: lynx_survey_responsesGroupByArgs['orderBy'] }
        : { orderBy?: lynx_survey_responsesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, lynx_survey_responsesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLynx_survey_responsesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the lynx_survey_responses model
   */
  readonly fields: lynx_survey_responsesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for lynx_survey_responses.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__lynx_survey_responsesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    lynx_surveys<T extends lynx_surveysDefaultArgs<ExtArgs> = {}>(args?: Subset<T, lynx_surveysDefaultArgs<ExtArgs>>): Prisma__lynx_surveysClient<$Result.GetResult<Prisma.$lynx_surveysPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    users<T extends lynx_survey_responses$usersArgs<ExtArgs> = {}>(args?: Subset<T, lynx_survey_responses$usersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the lynx_survey_responses model
   */ 
  interface lynx_survey_responsesFieldRefs {
    readonly id: FieldRef<"lynx_survey_responses", 'String'>
    readonly questions: FieldRef<"lynx_survey_responses", 'Json'>
    readonly answers: FieldRef<"lynx_survey_responses", 'Json'>
    readonly username_cached: FieldRef<"lynx_survey_responses", 'String'>
    readonly user_id: FieldRef<"lynx_survey_responses", 'BigInt'>
    readonly survey_id: FieldRef<"lynx_survey_responses", 'String'>
    readonly lynxtag: FieldRef<"lynx_survey_responses", 'String'>
  }
    

  // Custom InputTypes

  /**
   * lynx_survey_responses findUnique
   */
  export type lynx_survey_responsesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lynx_survey_responses
     */
    select?: lynx_survey_responsesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: lynx_survey_responsesInclude<ExtArgs> | null
    /**
     * Filter, which lynx_survey_responses to fetch.
     */
    where: lynx_survey_responsesWhereUniqueInput
  }


  /**
   * lynx_survey_responses findUniqueOrThrow
   */
  export type lynx_survey_responsesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lynx_survey_responses
     */
    select?: lynx_survey_responsesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: lynx_survey_responsesInclude<ExtArgs> | null
    /**
     * Filter, which lynx_survey_responses to fetch.
     */
    where: lynx_survey_responsesWhereUniqueInput
  }


  /**
   * lynx_survey_responses findFirst
   */
  export type lynx_survey_responsesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lynx_survey_responses
     */
    select?: lynx_survey_responsesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: lynx_survey_responsesInclude<ExtArgs> | null
    /**
     * Filter, which lynx_survey_responses to fetch.
     */
    where?: lynx_survey_responsesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lynx_survey_responses to fetch.
     */
    orderBy?: lynx_survey_responsesOrderByWithRelationInput | lynx_survey_responsesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for lynx_survey_responses.
     */
    cursor?: lynx_survey_responsesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lynx_survey_responses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lynx_survey_responses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of lynx_survey_responses.
     */
    distinct?: Lynx_survey_responsesScalarFieldEnum | Lynx_survey_responsesScalarFieldEnum[]
  }


  /**
   * lynx_survey_responses findFirstOrThrow
   */
  export type lynx_survey_responsesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lynx_survey_responses
     */
    select?: lynx_survey_responsesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: lynx_survey_responsesInclude<ExtArgs> | null
    /**
     * Filter, which lynx_survey_responses to fetch.
     */
    where?: lynx_survey_responsesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lynx_survey_responses to fetch.
     */
    orderBy?: lynx_survey_responsesOrderByWithRelationInput | lynx_survey_responsesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for lynx_survey_responses.
     */
    cursor?: lynx_survey_responsesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lynx_survey_responses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lynx_survey_responses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of lynx_survey_responses.
     */
    distinct?: Lynx_survey_responsesScalarFieldEnum | Lynx_survey_responsesScalarFieldEnum[]
  }


  /**
   * lynx_survey_responses findMany
   */
  export type lynx_survey_responsesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lynx_survey_responses
     */
    select?: lynx_survey_responsesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: lynx_survey_responsesInclude<ExtArgs> | null
    /**
     * Filter, which lynx_survey_responses to fetch.
     */
    where?: lynx_survey_responsesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lynx_survey_responses to fetch.
     */
    orderBy?: lynx_survey_responsesOrderByWithRelationInput | lynx_survey_responsesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing lynx_survey_responses.
     */
    cursor?: lynx_survey_responsesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lynx_survey_responses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lynx_survey_responses.
     */
    skip?: number
    distinct?: Lynx_survey_responsesScalarFieldEnum | Lynx_survey_responsesScalarFieldEnum[]
  }


  /**
   * lynx_survey_responses create
   */
  export type lynx_survey_responsesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lynx_survey_responses
     */
    select?: lynx_survey_responsesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: lynx_survey_responsesInclude<ExtArgs> | null
    /**
     * The data needed to create a lynx_survey_responses.
     */
    data: XOR<lynx_survey_responsesCreateInput, lynx_survey_responsesUncheckedCreateInput>
  }


  /**
   * lynx_survey_responses createMany
   */
  export type lynx_survey_responsesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many lynx_survey_responses.
     */
    data: lynx_survey_responsesCreateManyInput | lynx_survey_responsesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * lynx_survey_responses update
   */
  export type lynx_survey_responsesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lynx_survey_responses
     */
    select?: lynx_survey_responsesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: lynx_survey_responsesInclude<ExtArgs> | null
    /**
     * The data needed to update a lynx_survey_responses.
     */
    data: XOR<lynx_survey_responsesUpdateInput, lynx_survey_responsesUncheckedUpdateInput>
    /**
     * Choose, which lynx_survey_responses to update.
     */
    where: lynx_survey_responsesWhereUniqueInput
  }


  /**
   * lynx_survey_responses updateMany
   */
  export type lynx_survey_responsesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update lynx_survey_responses.
     */
    data: XOR<lynx_survey_responsesUpdateManyMutationInput, lynx_survey_responsesUncheckedUpdateManyInput>
    /**
     * Filter which lynx_survey_responses to update
     */
    where?: lynx_survey_responsesWhereInput
  }


  /**
   * lynx_survey_responses upsert
   */
  export type lynx_survey_responsesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lynx_survey_responses
     */
    select?: lynx_survey_responsesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: lynx_survey_responsesInclude<ExtArgs> | null
    /**
     * The filter to search for the lynx_survey_responses to update in case it exists.
     */
    where: lynx_survey_responsesWhereUniqueInput
    /**
     * In case the lynx_survey_responses found by the `where` argument doesn't exist, create a new lynx_survey_responses with this data.
     */
    create: XOR<lynx_survey_responsesCreateInput, lynx_survey_responsesUncheckedCreateInput>
    /**
     * In case the lynx_survey_responses was found with the provided `where` argument, update it with this data.
     */
    update: XOR<lynx_survey_responsesUpdateInput, lynx_survey_responsesUncheckedUpdateInput>
  }


  /**
   * lynx_survey_responses delete
   */
  export type lynx_survey_responsesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lynx_survey_responses
     */
    select?: lynx_survey_responsesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: lynx_survey_responsesInclude<ExtArgs> | null
    /**
     * Filter which lynx_survey_responses to delete.
     */
    where: lynx_survey_responsesWhereUniqueInput
  }


  /**
   * lynx_survey_responses deleteMany
   */
  export type lynx_survey_responsesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which lynx_survey_responses to delete
     */
    where?: lynx_survey_responsesWhereInput
  }


  /**
   * lynx_survey_responses.users
   */
  export type lynx_survey_responses$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }


  /**
   * lynx_survey_responses without action
   */
  export type lynx_survey_responsesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lynx_survey_responses
     */
    select?: lynx_survey_responsesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: lynx_survey_responsesInclude<ExtArgs> | null
  }



  /**
   * Model lynx_surveys
   */

  export type AggregateLynx_surveys = {
    _count: Lynx_surveysCountAggregateOutputType | null
    _min: Lynx_surveysMinAggregateOutputType | null
    _max: Lynx_surveysMaxAggregateOutputType | null
  }

  export type Lynx_surveysMinAggregateOutputType = {
    id: string | null
    title: string | null
    created_at: Date | null
    lynxtag: string | null
  }

  export type Lynx_surveysMaxAggregateOutputType = {
    id: string | null
    title: string | null
    created_at: Date | null
    lynxtag: string | null
  }

  export type Lynx_surveysCountAggregateOutputType = {
    id: number
    title: number
    questions: number
    created_at: number
    lynxtag: number
    _all: number
  }


  export type Lynx_surveysMinAggregateInputType = {
    id?: true
    title?: true
    created_at?: true
    lynxtag?: true
  }

  export type Lynx_surveysMaxAggregateInputType = {
    id?: true
    title?: true
    created_at?: true
    lynxtag?: true
  }

  export type Lynx_surveysCountAggregateInputType = {
    id?: true
    title?: true
    questions?: true
    created_at?: true
    lynxtag?: true
    _all?: true
  }

  export type Lynx_surveysAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which lynx_surveys to aggregate.
     */
    where?: lynx_surveysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lynx_surveys to fetch.
     */
    orderBy?: lynx_surveysOrderByWithRelationInput | lynx_surveysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: lynx_surveysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lynx_surveys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lynx_surveys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned lynx_surveys
    **/
    _count?: true | Lynx_surveysCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Lynx_surveysMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Lynx_surveysMaxAggregateInputType
  }

  export type GetLynx_surveysAggregateType<T extends Lynx_surveysAggregateArgs> = {
        [P in keyof T & keyof AggregateLynx_surveys]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLynx_surveys[P]>
      : GetScalarType<T[P], AggregateLynx_surveys[P]>
  }




  export type lynx_surveysGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: lynx_surveysWhereInput
    orderBy?: lynx_surveysOrderByWithAggregationInput | lynx_surveysOrderByWithAggregationInput[]
    by: Lynx_surveysScalarFieldEnum[] | Lynx_surveysScalarFieldEnum
    having?: lynx_surveysScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Lynx_surveysCountAggregateInputType | true
    _min?: Lynx_surveysMinAggregateInputType
    _max?: Lynx_surveysMaxAggregateInputType
  }

  export type Lynx_surveysGroupByOutputType = {
    id: string
    title: string
    questions: JsonValue
    created_at: Date | null
    lynxtag: string
    _count: Lynx_surveysCountAggregateOutputType | null
    _min: Lynx_surveysMinAggregateOutputType | null
    _max: Lynx_surveysMaxAggregateOutputType | null
  }

  type GetLynx_surveysGroupByPayload<T extends lynx_surveysGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Lynx_surveysGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Lynx_surveysGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Lynx_surveysGroupByOutputType[P]>
            : GetScalarType<T[P], Lynx_surveysGroupByOutputType[P]>
        }
      >
    >


  export type lynx_surveysSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    questions?: boolean
    created_at?: boolean
    lynxtag?: boolean
    lynx_survey_responses?: boolean | lynx_surveys$lynx_survey_responsesArgs<ExtArgs>
    _count?: boolean | Lynx_surveysCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lynx_surveys"]>

  export type lynx_surveysSelectScalar = {
    id?: boolean
    title?: boolean
    questions?: boolean
    created_at?: boolean
    lynxtag?: boolean
  }

  export type lynx_surveysInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lynx_survey_responses?: boolean | lynx_surveys$lynx_survey_responsesArgs<ExtArgs>
    _count?: boolean | Lynx_surveysCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $lynx_surveysPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "lynx_surveys"
    objects: {
      lynx_survey_responses: Prisma.$lynx_survey_responsesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      questions: Prisma.JsonValue
      created_at: Date | null
      lynxtag: string
    }, ExtArgs["result"]["lynx_surveys"]>
    composites: {}
  }


  type lynx_surveysGetPayload<S extends boolean | null | undefined | lynx_surveysDefaultArgs> = $Result.GetResult<Prisma.$lynx_surveysPayload, S>

  type lynx_surveysCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<lynx_surveysFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Lynx_surveysCountAggregateInputType | true
    }

  export interface lynx_surveysDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['lynx_surveys'], meta: { name: 'lynx_surveys' } }
    /**
     * Find zero or one Lynx_surveys that matches the filter.
     * @param {lynx_surveysFindUniqueArgs} args - Arguments to find a Lynx_surveys
     * @example
     * // Get one Lynx_surveys
     * const lynx_surveys = await prisma.lynx_surveys.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends lynx_surveysFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, lynx_surveysFindUniqueArgs<ExtArgs>>
    ): Prisma__lynx_surveysClient<$Result.GetResult<Prisma.$lynx_surveysPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Lynx_surveys that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {lynx_surveysFindUniqueOrThrowArgs} args - Arguments to find a Lynx_surveys
     * @example
     * // Get one Lynx_surveys
     * const lynx_surveys = await prisma.lynx_surveys.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends lynx_surveysFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, lynx_surveysFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__lynx_surveysClient<$Result.GetResult<Prisma.$lynx_surveysPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Lynx_surveys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lynx_surveysFindFirstArgs} args - Arguments to find a Lynx_surveys
     * @example
     * // Get one Lynx_surveys
     * const lynx_surveys = await prisma.lynx_surveys.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends lynx_surveysFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, lynx_surveysFindFirstArgs<ExtArgs>>
    ): Prisma__lynx_surveysClient<$Result.GetResult<Prisma.$lynx_surveysPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Lynx_surveys that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lynx_surveysFindFirstOrThrowArgs} args - Arguments to find a Lynx_surveys
     * @example
     * // Get one Lynx_surveys
     * const lynx_surveys = await prisma.lynx_surveys.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends lynx_surveysFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, lynx_surveysFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__lynx_surveysClient<$Result.GetResult<Prisma.$lynx_surveysPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Lynx_surveys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lynx_surveysFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lynx_surveys
     * const lynx_surveys = await prisma.lynx_surveys.findMany()
     * 
     * // Get first 10 Lynx_surveys
     * const lynx_surveys = await prisma.lynx_surveys.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lynx_surveysWithIdOnly = await prisma.lynx_surveys.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends lynx_surveysFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, lynx_surveysFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$lynx_surveysPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Lynx_surveys.
     * @param {lynx_surveysCreateArgs} args - Arguments to create a Lynx_surveys.
     * @example
     * // Create one Lynx_surveys
     * const Lynx_surveys = await prisma.lynx_surveys.create({
     *   data: {
     *     // ... data to create a Lynx_surveys
     *   }
     * })
     * 
    **/
    create<T extends lynx_surveysCreateArgs<ExtArgs>>(
      args: SelectSubset<T, lynx_surveysCreateArgs<ExtArgs>>
    ): Prisma__lynx_surveysClient<$Result.GetResult<Prisma.$lynx_surveysPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Lynx_surveys.
     *     @param {lynx_surveysCreateManyArgs} args - Arguments to create many Lynx_surveys.
     *     @example
     *     // Create many Lynx_surveys
     *     const lynx_surveys = await prisma.lynx_surveys.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends lynx_surveysCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, lynx_surveysCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Lynx_surveys.
     * @param {lynx_surveysDeleteArgs} args - Arguments to delete one Lynx_surveys.
     * @example
     * // Delete one Lynx_surveys
     * const Lynx_surveys = await prisma.lynx_surveys.delete({
     *   where: {
     *     // ... filter to delete one Lynx_surveys
     *   }
     * })
     * 
    **/
    delete<T extends lynx_surveysDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, lynx_surveysDeleteArgs<ExtArgs>>
    ): Prisma__lynx_surveysClient<$Result.GetResult<Prisma.$lynx_surveysPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Lynx_surveys.
     * @param {lynx_surveysUpdateArgs} args - Arguments to update one Lynx_surveys.
     * @example
     * // Update one Lynx_surveys
     * const lynx_surveys = await prisma.lynx_surveys.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends lynx_surveysUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, lynx_surveysUpdateArgs<ExtArgs>>
    ): Prisma__lynx_surveysClient<$Result.GetResult<Prisma.$lynx_surveysPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Lynx_surveys.
     * @param {lynx_surveysDeleteManyArgs} args - Arguments to filter Lynx_surveys to delete.
     * @example
     * // Delete a few Lynx_surveys
     * const { count } = await prisma.lynx_surveys.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends lynx_surveysDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, lynx_surveysDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lynx_surveys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lynx_surveysUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lynx_surveys
     * const lynx_surveys = await prisma.lynx_surveys.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends lynx_surveysUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, lynx_surveysUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Lynx_surveys.
     * @param {lynx_surveysUpsertArgs} args - Arguments to update or create a Lynx_surveys.
     * @example
     * // Update or create a Lynx_surveys
     * const lynx_surveys = await prisma.lynx_surveys.upsert({
     *   create: {
     *     // ... data to create a Lynx_surveys
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lynx_surveys we want to update
     *   }
     * })
    **/
    upsert<T extends lynx_surveysUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, lynx_surveysUpsertArgs<ExtArgs>>
    ): Prisma__lynx_surveysClient<$Result.GetResult<Prisma.$lynx_surveysPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Lynx_surveys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lynx_surveysCountArgs} args - Arguments to filter Lynx_surveys to count.
     * @example
     * // Count the number of Lynx_surveys
     * const count = await prisma.lynx_surveys.count({
     *   where: {
     *     // ... the filter for the Lynx_surveys we want to count
     *   }
     * })
    **/
    count<T extends lynx_surveysCountArgs>(
      args?: Subset<T, lynx_surveysCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Lynx_surveysCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lynx_surveys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lynx_surveysAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Lynx_surveysAggregateArgs>(args: Subset<T, Lynx_surveysAggregateArgs>): Prisma.PrismaPromise<GetLynx_surveysAggregateType<T>>

    /**
     * Group by Lynx_surveys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lynx_surveysGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends lynx_surveysGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: lynx_surveysGroupByArgs['orderBy'] }
        : { orderBy?: lynx_surveysGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, lynx_surveysGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLynx_surveysGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the lynx_surveys model
   */
  readonly fields: lynx_surveysFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for lynx_surveys.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__lynx_surveysClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    lynx_survey_responses<T extends lynx_surveys$lynx_survey_responsesArgs<ExtArgs> = {}>(args?: Subset<T, lynx_surveys$lynx_survey_responsesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$lynx_survey_responsesPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the lynx_surveys model
   */ 
  interface lynx_surveysFieldRefs {
    readonly id: FieldRef<"lynx_surveys", 'String'>
    readonly title: FieldRef<"lynx_surveys", 'String'>
    readonly questions: FieldRef<"lynx_surveys", 'Json'>
    readonly created_at: FieldRef<"lynx_surveys", 'DateTime'>
    readonly lynxtag: FieldRef<"lynx_surveys", 'String'>
  }
    

  // Custom InputTypes

  /**
   * lynx_surveys findUnique
   */
  export type lynx_surveysFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lynx_surveys
     */
    select?: lynx_surveysSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: lynx_surveysInclude<ExtArgs> | null
    /**
     * Filter, which lynx_surveys to fetch.
     */
    where: lynx_surveysWhereUniqueInput
  }


  /**
   * lynx_surveys findUniqueOrThrow
   */
  export type lynx_surveysFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lynx_surveys
     */
    select?: lynx_surveysSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: lynx_surveysInclude<ExtArgs> | null
    /**
     * Filter, which lynx_surveys to fetch.
     */
    where: lynx_surveysWhereUniqueInput
  }


  /**
   * lynx_surveys findFirst
   */
  export type lynx_surveysFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lynx_surveys
     */
    select?: lynx_surveysSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: lynx_surveysInclude<ExtArgs> | null
    /**
     * Filter, which lynx_surveys to fetch.
     */
    where?: lynx_surveysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lynx_surveys to fetch.
     */
    orderBy?: lynx_surveysOrderByWithRelationInput | lynx_surveysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for lynx_surveys.
     */
    cursor?: lynx_surveysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lynx_surveys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lynx_surveys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of lynx_surveys.
     */
    distinct?: Lynx_surveysScalarFieldEnum | Lynx_surveysScalarFieldEnum[]
  }


  /**
   * lynx_surveys findFirstOrThrow
   */
  export type lynx_surveysFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lynx_surveys
     */
    select?: lynx_surveysSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: lynx_surveysInclude<ExtArgs> | null
    /**
     * Filter, which lynx_surveys to fetch.
     */
    where?: lynx_surveysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lynx_surveys to fetch.
     */
    orderBy?: lynx_surveysOrderByWithRelationInput | lynx_surveysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for lynx_surveys.
     */
    cursor?: lynx_surveysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lynx_surveys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lynx_surveys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of lynx_surveys.
     */
    distinct?: Lynx_surveysScalarFieldEnum | Lynx_surveysScalarFieldEnum[]
  }


  /**
   * lynx_surveys findMany
   */
  export type lynx_surveysFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lynx_surveys
     */
    select?: lynx_surveysSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: lynx_surveysInclude<ExtArgs> | null
    /**
     * Filter, which lynx_surveys to fetch.
     */
    where?: lynx_surveysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lynx_surveys to fetch.
     */
    orderBy?: lynx_surveysOrderByWithRelationInput | lynx_surveysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing lynx_surveys.
     */
    cursor?: lynx_surveysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lynx_surveys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lynx_surveys.
     */
    skip?: number
    distinct?: Lynx_surveysScalarFieldEnum | Lynx_surveysScalarFieldEnum[]
  }


  /**
   * lynx_surveys create
   */
  export type lynx_surveysCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lynx_surveys
     */
    select?: lynx_surveysSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: lynx_surveysInclude<ExtArgs> | null
    /**
     * The data needed to create a lynx_surveys.
     */
    data: XOR<lynx_surveysCreateInput, lynx_surveysUncheckedCreateInput>
  }


  /**
   * lynx_surveys createMany
   */
  export type lynx_surveysCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many lynx_surveys.
     */
    data: lynx_surveysCreateManyInput | lynx_surveysCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * lynx_surveys update
   */
  export type lynx_surveysUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lynx_surveys
     */
    select?: lynx_surveysSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: lynx_surveysInclude<ExtArgs> | null
    /**
     * The data needed to update a lynx_surveys.
     */
    data: XOR<lynx_surveysUpdateInput, lynx_surveysUncheckedUpdateInput>
    /**
     * Choose, which lynx_surveys to update.
     */
    where: lynx_surveysWhereUniqueInput
  }


  /**
   * lynx_surveys updateMany
   */
  export type lynx_surveysUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update lynx_surveys.
     */
    data: XOR<lynx_surveysUpdateManyMutationInput, lynx_surveysUncheckedUpdateManyInput>
    /**
     * Filter which lynx_surveys to update
     */
    where?: lynx_surveysWhereInput
  }


  /**
   * lynx_surveys upsert
   */
  export type lynx_surveysUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lynx_surveys
     */
    select?: lynx_surveysSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: lynx_surveysInclude<ExtArgs> | null
    /**
     * The filter to search for the lynx_surveys to update in case it exists.
     */
    where: lynx_surveysWhereUniqueInput
    /**
     * In case the lynx_surveys found by the `where` argument doesn't exist, create a new lynx_surveys with this data.
     */
    create: XOR<lynx_surveysCreateInput, lynx_surveysUncheckedCreateInput>
    /**
     * In case the lynx_surveys was found with the provided `where` argument, update it with this data.
     */
    update: XOR<lynx_surveysUpdateInput, lynx_surveysUncheckedUpdateInput>
  }


  /**
   * lynx_surveys delete
   */
  export type lynx_surveysDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lynx_surveys
     */
    select?: lynx_surveysSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: lynx_surveysInclude<ExtArgs> | null
    /**
     * Filter which lynx_surveys to delete.
     */
    where: lynx_surveysWhereUniqueInput
  }


  /**
   * lynx_surveys deleteMany
   */
  export type lynx_surveysDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which lynx_surveys to delete
     */
    where?: lynx_surveysWhereInput
  }


  /**
   * lynx_surveys.lynx_survey_responses
   */
  export type lynx_surveys$lynx_survey_responsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lynx_survey_responses
     */
    select?: lynx_survey_responsesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: lynx_survey_responsesInclude<ExtArgs> | null
    where?: lynx_survey_responsesWhereInput
    orderBy?: lynx_survey_responsesOrderByWithRelationInput | lynx_survey_responsesOrderByWithRelationInput[]
    cursor?: lynx_survey_responsesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Lynx_survey_responsesScalarFieldEnum | Lynx_survey_responsesScalarFieldEnum[]
  }


  /**
   * lynx_surveys without action
   */
  export type lynx_surveysDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lynx_surveys
     */
    select?: lynx_surveysSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: lynx_surveysInclude<ExtArgs> | null
  }



  /**
   * Model migration
   */

  export type AggregateMigration = {
    _count: MigrationCountAggregateOutputType | null
    _avg: MigrationAvgAggregateOutputType | null
    _sum: MigrationSumAggregateOutputType | null
    _min: MigrationMinAggregateOutputType | null
    _max: MigrationMaxAggregateOutputType | null
  }

  export type MigrationAvgAggregateOutputType = {
    id: number | null
  }

  export type MigrationSumAggregateOutputType = {
    id: number | null
  }

  export type MigrationMinAggregateOutputType = {
    id: number | null
    name: string | null
    app_name: string | null
    ran_on: Date | null
    lynxtag: string | null
  }

  export type MigrationMaxAggregateOutputType = {
    id: number | null
    name: string | null
    app_name: string | null
    ran_on: Date | null
    lynxtag: string | null
  }

  export type MigrationCountAggregateOutputType = {
    id: number
    name: number
    app_name: number
    ran_on: number
    lynxtag: number
    _all: number
  }


  export type MigrationAvgAggregateInputType = {
    id?: true
  }

  export type MigrationSumAggregateInputType = {
    id?: true
  }

  export type MigrationMinAggregateInputType = {
    id?: true
    name?: true
    app_name?: true
    ran_on?: true
    lynxtag?: true
  }

  export type MigrationMaxAggregateInputType = {
    id?: true
    name?: true
    app_name?: true
    ran_on?: true
    lynxtag?: true
  }

  export type MigrationCountAggregateInputType = {
    id?: true
    name?: true
    app_name?: true
    ran_on?: true
    lynxtag?: true
    _all?: true
  }

  export type MigrationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which migration to aggregate.
     */
    where?: migrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of migrations to fetch.
     */
    orderBy?: migrationOrderByWithRelationInput | migrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: migrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` migrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` migrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned migrations
    **/
    _count?: true | MigrationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MigrationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MigrationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MigrationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MigrationMaxAggregateInputType
  }

  export type GetMigrationAggregateType<T extends MigrationAggregateArgs> = {
        [P in keyof T & keyof AggregateMigration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMigration[P]>
      : GetScalarType<T[P], AggregateMigration[P]>
  }




  export type migrationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: migrationWhereInput
    orderBy?: migrationOrderByWithAggregationInput | migrationOrderByWithAggregationInput[]
    by: MigrationScalarFieldEnum[] | MigrationScalarFieldEnum
    having?: migrationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MigrationCountAggregateInputType | true
    _avg?: MigrationAvgAggregateInputType
    _sum?: MigrationSumAggregateInputType
    _min?: MigrationMinAggregateInputType
    _max?: MigrationMaxAggregateInputType
  }

  export type MigrationGroupByOutputType = {
    id: number
    name: string
    app_name: string
    ran_on: Date
    lynxtag: string
    _count: MigrationCountAggregateOutputType | null
    _avg: MigrationAvgAggregateOutputType | null
    _sum: MigrationSumAggregateOutputType | null
    _min: MigrationMinAggregateOutputType | null
    _max: MigrationMaxAggregateOutputType | null
  }

  type GetMigrationGroupByPayload<T extends migrationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MigrationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MigrationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MigrationGroupByOutputType[P]>
            : GetScalarType<T[P], MigrationGroupByOutputType[P]>
        }
      >
    >


  export type migrationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    app_name?: boolean
    ran_on?: boolean
    lynxtag?: boolean
  }, ExtArgs["result"]["migration"]>

  export type migrationSelectScalar = {
    id?: boolean
    name?: boolean
    app_name?: boolean
    ran_on?: boolean
    lynxtag?: boolean
  }


  export type $migrationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "migration"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      app_name: string
      ran_on: Date
      lynxtag: string
    }, ExtArgs["result"]["migration"]>
    composites: {}
  }


  type migrationGetPayload<S extends boolean | null | undefined | migrationDefaultArgs> = $Result.GetResult<Prisma.$migrationPayload, S>

  type migrationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<migrationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MigrationCountAggregateInputType | true
    }

  export interface migrationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['migration'], meta: { name: 'migration' } }
    /**
     * Find zero or one Migration that matches the filter.
     * @param {migrationFindUniqueArgs} args - Arguments to find a Migration
     * @example
     * // Get one Migration
     * const migration = await prisma.migration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends migrationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, migrationFindUniqueArgs<ExtArgs>>
    ): Prisma__migrationClient<$Result.GetResult<Prisma.$migrationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Migration that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {migrationFindUniqueOrThrowArgs} args - Arguments to find a Migration
     * @example
     * // Get one Migration
     * const migration = await prisma.migration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends migrationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, migrationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__migrationClient<$Result.GetResult<Prisma.$migrationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Migration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migrationFindFirstArgs} args - Arguments to find a Migration
     * @example
     * // Get one Migration
     * const migration = await prisma.migration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends migrationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, migrationFindFirstArgs<ExtArgs>>
    ): Prisma__migrationClient<$Result.GetResult<Prisma.$migrationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Migration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migrationFindFirstOrThrowArgs} args - Arguments to find a Migration
     * @example
     * // Get one Migration
     * const migration = await prisma.migration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends migrationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, migrationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__migrationClient<$Result.GetResult<Prisma.$migrationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Migrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migrationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Migrations
     * const migrations = await prisma.migration.findMany()
     * 
     * // Get first 10 Migrations
     * const migrations = await prisma.migration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const migrationWithIdOnly = await prisma.migration.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends migrationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, migrationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$migrationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Migration.
     * @param {migrationCreateArgs} args - Arguments to create a Migration.
     * @example
     * // Create one Migration
     * const Migration = await prisma.migration.create({
     *   data: {
     *     // ... data to create a Migration
     *   }
     * })
     * 
    **/
    create<T extends migrationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, migrationCreateArgs<ExtArgs>>
    ): Prisma__migrationClient<$Result.GetResult<Prisma.$migrationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Migrations.
     *     @param {migrationCreateManyArgs} args - Arguments to create many Migrations.
     *     @example
     *     // Create many Migrations
     *     const migration = await prisma.migration.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends migrationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, migrationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Migration.
     * @param {migrationDeleteArgs} args - Arguments to delete one Migration.
     * @example
     * // Delete one Migration
     * const Migration = await prisma.migration.delete({
     *   where: {
     *     // ... filter to delete one Migration
     *   }
     * })
     * 
    **/
    delete<T extends migrationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, migrationDeleteArgs<ExtArgs>>
    ): Prisma__migrationClient<$Result.GetResult<Prisma.$migrationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Migration.
     * @param {migrationUpdateArgs} args - Arguments to update one Migration.
     * @example
     * // Update one Migration
     * const migration = await prisma.migration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends migrationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, migrationUpdateArgs<ExtArgs>>
    ): Prisma__migrationClient<$Result.GetResult<Prisma.$migrationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Migrations.
     * @param {migrationDeleteManyArgs} args - Arguments to filter Migrations to delete.
     * @example
     * // Delete a few Migrations
     * const { count } = await prisma.migration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends migrationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, migrationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Migrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migrationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Migrations
     * const migration = await prisma.migration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends migrationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, migrationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Migration.
     * @param {migrationUpsertArgs} args - Arguments to update or create a Migration.
     * @example
     * // Update or create a Migration
     * const migration = await prisma.migration.upsert({
     *   create: {
     *     // ... data to create a Migration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Migration we want to update
     *   }
     * })
    **/
    upsert<T extends migrationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, migrationUpsertArgs<ExtArgs>>
    ): Prisma__migrationClient<$Result.GetResult<Prisma.$migrationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Migrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migrationCountArgs} args - Arguments to filter Migrations to count.
     * @example
     * // Count the number of Migrations
     * const count = await prisma.migration.count({
     *   where: {
     *     // ... the filter for the Migrations we want to count
     *   }
     * })
    **/
    count<T extends migrationCountArgs>(
      args?: Subset<T, migrationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MigrationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Migration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MigrationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MigrationAggregateArgs>(args: Subset<T, MigrationAggregateArgs>): Prisma.PrismaPromise<GetMigrationAggregateType<T>>

    /**
     * Group by Migration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migrationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends migrationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: migrationGroupByArgs['orderBy'] }
        : { orderBy?: migrationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, migrationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMigrationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the migration model
   */
  readonly fields: migrationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for migration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__migrationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the migration model
   */ 
  interface migrationFieldRefs {
    readonly id: FieldRef<"migration", 'Int'>
    readonly name: FieldRef<"migration", 'String'>
    readonly app_name: FieldRef<"migration", 'String'>
    readonly ran_on: FieldRef<"migration", 'DateTime'>
    readonly lynxtag: FieldRef<"migration", 'String'>
  }
    

  // Custom InputTypes

  /**
   * migration findUnique
   */
  export type migrationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migration
     */
    select?: migrationSelect<ExtArgs> | null
    /**
     * Filter, which migration to fetch.
     */
    where: migrationWhereUniqueInput
  }


  /**
   * migration findUniqueOrThrow
   */
  export type migrationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migration
     */
    select?: migrationSelect<ExtArgs> | null
    /**
     * Filter, which migration to fetch.
     */
    where: migrationWhereUniqueInput
  }


  /**
   * migration findFirst
   */
  export type migrationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migration
     */
    select?: migrationSelect<ExtArgs> | null
    /**
     * Filter, which migration to fetch.
     */
    where?: migrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of migrations to fetch.
     */
    orderBy?: migrationOrderByWithRelationInput | migrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for migrations.
     */
    cursor?: migrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` migrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` migrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of migrations.
     */
    distinct?: MigrationScalarFieldEnum | MigrationScalarFieldEnum[]
  }


  /**
   * migration findFirstOrThrow
   */
  export type migrationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migration
     */
    select?: migrationSelect<ExtArgs> | null
    /**
     * Filter, which migration to fetch.
     */
    where?: migrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of migrations to fetch.
     */
    orderBy?: migrationOrderByWithRelationInput | migrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for migrations.
     */
    cursor?: migrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` migrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` migrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of migrations.
     */
    distinct?: MigrationScalarFieldEnum | MigrationScalarFieldEnum[]
  }


  /**
   * migration findMany
   */
  export type migrationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migration
     */
    select?: migrationSelect<ExtArgs> | null
    /**
     * Filter, which migrations to fetch.
     */
    where?: migrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of migrations to fetch.
     */
    orderBy?: migrationOrderByWithRelationInput | migrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing migrations.
     */
    cursor?: migrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` migrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` migrations.
     */
    skip?: number
    distinct?: MigrationScalarFieldEnum | MigrationScalarFieldEnum[]
  }


  /**
   * migration create
   */
  export type migrationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migration
     */
    select?: migrationSelect<ExtArgs> | null
    /**
     * The data needed to create a migration.
     */
    data?: XOR<migrationCreateInput, migrationUncheckedCreateInput>
  }


  /**
   * migration createMany
   */
  export type migrationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many migrations.
     */
    data: migrationCreateManyInput | migrationCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * migration update
   */
  export type migrationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migration
     */
    select?: migrationSelect<ExtArgs> | null
    /**
     * The data needed to update a migration.
     */
    data: XOR<migrationUpdateInput, migrationUncheckedUpdateInput>
    /**
     * Choose, which migration to update.
     */
    where: migrationWhereUniqueInput
  }


  /**
   * migration updateMany
   */
  export type migrationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update migrations.
     */
    data: XOR<migrationUpdateManyMutationInput, migrationUncheckedUpdateManyInput>
    /**
     * Filter which migrations to update
     */
    where?: migrationWhereInput
  }


  /**
   * migration upsert
   */
  export type migrationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migration
     */
    select?: migrationSelect<ExtArgs> | null
    /**
     * The filter to search for the migration to update in case it exists.
     */
    where: migrationWhereUniqueInput
    /**
     * In case the migration found by the `where` argument doesn't exist, create a new migration with this data.
     */
    create: XOR<migrationCreateInput, migrationUncheckedCreateInput>
    /**
     * In case the migration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<migrationUpdateInput, migrationUncheckedUpdateInput>
  }


  /**
   * migration delete
   */
  export type migrationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migration
     */
    select?: migrationSelect<ExtArgs> | null
    /**
     * Filter which migration to delete.
     */
    where: migrationWhereUniqueInput
  }


  /**
   * migration deleteMany
   */
  export type migrationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which migrations to delete
     */
    where?: migrationWhereInput
  }


  /**
   * migration without action
   */
  export type migrationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migration
     */
    select?: migrationSelect<ExtArgs> | null
  }



  /**
   * Model piccolo_user
   */

  export type AggregatePiccolo_user = {
    _count: Piccolo_userCountAggregateOutputType | null
    _avg: Piccolo_userAvgAggregateOutputType | null
    _sum: Piccolo_userSumAggregateOutputType | null
    _min: Piccolo_userMinAggregateOutputType | null
    _max: Piccolo_userMaxAggregateOutputType | null
  }

  export type Piccolo_userAvgAggregateOutputType = {
    id: number | null
  }

  export type Piccolo_userSumAggregateOutputType = {
    id: number | null
  }

  export type Piccolo_userMinAggregateOutputType = {
    id: number | null
    username: string | null
    password: string | null
    email: string | null
    active: boolean | null
    admin: boolean | null
    first_name: string | null
    last_name: string | null
    superuser: boolean | null
    last_login: Date | null
    lynxtag: string | null
  }

  export type Piccolo_userMaxAggregateOutputType = {
    id: number | null
    username: string | null
    password: string | null
    email: string | null
    active: boolean | null
    admin: boolean | null
    first_name: string | null
    last_name: string | null
    superuser: boolean | null
    last_login: Date | null
    lynxtag: string | null
  }

  export type Piccolo_userCountAggregateOutputType = {
    id: number
    username: number
    password: number
    email: number
    active: number
    admin: number
    first_name: number
    last_name: number
    superuser: number
    last_login: number
    lynxtag: number
    _all: number
  }


  export type Piccolo_userAvgAggregateInputType = {
    id?: true
  }

  export type Piccolo_userSumAggregateInputType = {
    id?: true
  }

  export type Piccolo_userMinAggregateInputType = {
    id?: true
    username?: true
    password?: true
    email?: true
    active?: true
    admin?: true
    first_name?: true
    last_name?: true
    superuser?: true
    last_login?: true
    lynxtag?: true
  }

  export type Piccolo_userMaxAggregateInputType = {
    id?: true
    username?: true
    password?: true
    email?: true
    active?: true
    admin?: true
    first_name?: true
    last_name?: true
    superuser?: true
    last_login?: true
    lynxtag?: true
  }

  export type Piccolo_userCountAggregateInputType = {
    id?: true
    username?: true
    password?: true
    email?: true
    active?: true
    admin?: true
    first_name?: true
    last_name?: true
    superuser?: true
    last_login?: true
    lynxtag?: true
    _all?: true
  }

  export type Piccolo_userAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which piccolo_user to aggregate.
     */
    where?: piccolo_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of piccolo_users to fetch.
     */
    orderBy?: piccolo_userOrderByWithRelationInput | piccolo_userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: piccolo_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` piccolo_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` piccolo_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned piccolo_users
    **/
    _count?: true | Piccolo_userCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Piccolo_userAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Piccolo_userSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Piccolo_userMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Piccolo_userMaxAggregateInputType
  }

  export type GetPiccolo_userAggregateType<T extends Piccolo_userAggregateArgs> = {
        [P in keyof T & keyof AggregatePiccolo_user]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePiccolo_user[P]>
      : GetScalarType<T[P], AggregatePiccolo_user[P]>
  }




  export type piccolo_userGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: piccolo_userWhereInput
    orderBy?: piccolo_userOrderByWithAggregationInput | piccolo_userOrderByWithAggregationInput[]
    by: Piccolo_userScalarFieldEnum[] | Piccolo_userScalarFieldEnum
    having?: piccolo_userScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Piccolo_userCountAggregateInputType | true
    _avg?: Piccolo_userAvgAggregateInputType
    _sum?: Piccolo_userSumAggregateInputType
    _min?: Piccolo_userMinAggregateInputType
    _max?: Piccolo_userMaxAggregateInputType
  }

  export type Piccolo_userGroupByOutputType = {
    id: number
    username: string
    password: string
    email: string
    active: boolean
    admin: boolean
    first_name: string | null
    last_name: string | null
    superuser: boolean
    last_login: Date | null
    lynxtag: string
    _count: Piccolo_userCountAggregateOutputType | null
    _avg: Piccolo_userAvgAggregateOutputType | null
    _sum: Piccolo_userSumAggregateOutputType | null
    _min: Piccolo_userMinAggregateOutputType | null
    _max: Piccolo_userMaxAggregateOutputType | null
  }

  type GetPiccolo_userGroupByPayload<T extends piccolo_userGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Piccolo_userGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Piccolo_userGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Piccolo_userGroupByOutputType[P]>
            : GetScalarType<T[P], Piccolo_userGroupByOutputType[P]>
        }
      >
    >


  export type piccolo_userSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
    email?: boolean
    active?: boolean
    admin?: boolean
    first_name?: boolean
    last_name?: boolean
    superuser?: boolean
    last_login?: boolean
    lynxtag?: boolean
  }, ExtArgs["result"]["piccolo_user"]>

  export type piccolo_userSelectScalar = {
    id?: boolean
    username?: boolean
    password?: boolean
    email?: boolean
    active?: boolean
    admin?: boolean
    first_name?: boolean
    last_name?: boolean
    superuser?: boolean
    last_login?: boolean
    lynxtag?: boolean
  }


  export type $piccolo_userPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "piccolo_user"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      username: string
      password: string
      email: string
      active: boolean
      admin: boolean
      first_name: string | null
      last_name: string | null
      superuser: boolean
      last_login: Date | null
      lynxtag: string
    }, ExtArgs["result"]["piccolo_user"]>
    composites: {}
  }


  type piccolo_userGetPayload<S extends boolean | null | undefined | piccolo_userDefaultArgs> = $Result.GetResult<Prisma.$piccolo_userPayload, S>

  type piccolo_userCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<piccolo_userFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Piccolo_userCountAggregateInputType | true
    }

  export interface piccolo_userDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['piccolo_user'], meta: { name: 'piccolo_user' } }
    /**
     * Find zero or one Piccolo_user that matches the filter.
     * @param {piccolo_userFindUniqueArgs} args - Arguments to find a Piccolo_user
     * @example
     * // Get one Piccolo_user
     * const piccolo_user = await prisma.piccolo_user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends piccolo_userFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, piccolo_userFindUniqueArgs<ExtArgs>>
    ): Prisma__piccolo_userClient<$Result.GetResult<Prisma.$piccolo_userPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Piccolo_user that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {piccolo_userFindUniqueOrThrowArgs} args - Arguments to find a Piccolo_user
     * @example
     * // Get one Piccolo_user
     * const piccolo_user = await prisma.piccolo_user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends piccolo_userFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, piccolo_userFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__piccolo_userClient<$Result.GetResult<Prisma.$piccolo_userPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Piccolo_user that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {piccolo_userFindFirstArgs} args - Arguments to find a Piccolo_user
     * @example
     * // Get one Piccolo_user
     * const piccolo_user = await prisma.piccolo_user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends piccolo_userFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, piccolo_userFindFirstArgs<ExtArgs>>
    ): Prisma__piccolo_userClient<$Result.GetResult<Prisma.$piccolo_userPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Piccolo_user that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {piccolo_userFindFirstOrThrowArgs} args - Arguments to find a Piccolo_user
     * @example
     * // Get one Piccolo_user
     * const piccolo_user = await prisma.piccolo_user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends piccolo_userFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, piccolo_userFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__piccolo_userClient<$Result.GetResult<Prisma.$piccolo_userPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Piccolo_users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {piccolo_userFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Piccolo_users
     * const piccolo_users = await prisma.piccolo_user.findMany()
     * 
     * // Get first 10 Piccolo_users
     * const piccolo_users = await prisma.piccolo_user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const piccolo_userWithIdOnly = await prisma.piccolo_user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends piccolo_userFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, piccolo_userFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$piccolo_userPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Piccolo_user.
     * @param {piccolo_userCreateArgs} args - Arguments to create a Piccolo_user.
     * @example
     * // Create one Piccolo_user
     * const Piccolo_user = await prisma.piccolo_user.create({
     *   data: {
     *     // ... data to create a Piccolo_user
     *   }
     * })
     * 
    **/
    create<T extends piccolo_userCreateArgs<ExtArgs>>(
      args: SelectSubset<T, piccolo_userCreateArgs<ExtArgs>>
    ): Prisma__piccolo_userClient<$Result.GetResult<Prisma.$piccolo_userPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Piccolo_users.
     *     @param {piccolo_userCreateManyArgs} args - Arguments to create many Piccolo_users.
     *     @example
     *     // Create many Piccolo_users
     *     const piccolo_user = await prisma.piccolo_user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends piccolo_userCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, piccolo_userCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Piccolo_user.
     * @param {piccolo_userDeleteArgs} args - Arguments to delete one Piccolo_user.
     * @example
     * // Delete one Piccolo_user
     * const Piccolo_user = await prisma.piccolo_user.delete({
     *   where: {
     *     // ... filter to delete one Piccolo_user
     *   }
     * })
     * 
    **/
    delete<T extends piccolo_userDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, piccolo_userDeleteArgs<ExtArgs>>
    ): Prisma__piccolo_userClient<$Result.GetResult<Prisma.$piccolo_userPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Piccolo_user.
     * @param {piccolo_userUpdateArgs} args - Arguments to update one Piccolo_user.
     * @example
     * // Update one Piccolo_user
     * const piccolo_user = await prisma.piccolo_user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends piccolo_userUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, piccolo_userUpdateArgs<ExtArgs>>
    ): Prisma__piccolo_userClient<$Result.GetResult<Prisma.$piccolo_userPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Piccolo_users.
     * @param {piccolo_userDeleteManyArgs} args - Arguments to filter Piccolo_users to delete.
     * @example
     * // Delete a few Piccolo_users
     * const { count } = await prisma.piccolo_user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends piccolo_userDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, piccolo_userDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Piccolo_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {piccolo_userUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Piccolo_users
     * const piccolo_user = await prisma.piccolo_user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends piccolo_userUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, piccolo_userUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Piccolo_user.
     * @param {piccolo_userUpsertArgs} args - Arguments to update or create a Piccolo_user.
     * @example
     * // Update or create a Piccolo_user
     * const piccolo_user = await prisma.piccolo_user.upsert({
     *   create: {
     *     // ... data to create a Piccolo_user
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Piccolo_user we want to update
     *   }
     * })
    **/
    upsert<T extends piccolo_userUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, piccolo_userUpsertArgs<ExtArgs>>
    ): Prisma__piccolo_userClient<$Result.GetResult<Prisma.$piccolo_userPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Piccolo_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {piccolo_userCountArgs} args - Arguments to filter Piccolo_users to count.
     * @example
     * // Count the number of Piccolo_users
     * const count = await prisma.piccolo_user.count({
     *   where: {
     *     // ... the filter for the Piccolo_users we want to count
     *   }
     * })
    **/
    count<T extends piccolo_userCountArgs>(
      args?: Subset<T, piccolo_userCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Piccolo_userCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Piccolo_user.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Piccolo_userAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Piccolo_userAggregateArgs>(args: Subset<T, Piccolo_userAggregateArgs>): Prisma.PrismaPromise<GetPiccolo_userAggregateType<T>>

    /**
     * Group by Piccolo_user.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {piccolo_userGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends piccolo_userGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: piccolo_userGroupByArgs['orderBy'] }
        : { orderBy?: piccolo_userGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, piccolo_userGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPiccolo_userGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the piccolo_user model
   */
  readonly fields: piccolo_userFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for piccolo_user.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__piccolo_userClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the piccolo_user model
   */ 
  interface piccolo_userFieldRefs {
    readonly id: FieldRef<"piccolo_user", 'Int'>
    readonly username: FieldRef<"piccolo_user", 'String'>
    readonly password: FieldRef<"piccolo_user", 'String'>
    readonly email: FieldRef<"piccolo_user", 'String'>
    readonly active: FieldRef<"piccolo_user", 'Boolean'>
    readonly admin: FieldRef<"piccolo_user", 'Boolean'>
    readonly first_name: FieldRef<"piccolo_user", 'String'>
    readonly last_name: FieldRef<"piccolo_user", 'String'>
    readonly superuser: FieldRef<"piccolo_user", 'Boolean'>
    readonly last_login: FieldRef<"piccolo_user", 'DateTime'>
    readonly lynxtag: FieldRef<"piccolo_user", 'String'>
  }
    

  // Custom InputTypes

  /**
   * piccolo_user findUnique
   */
  export type piccolo_userFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the piccolo_user
     */
    select?: piccolo_userSelect<ExtArgs> | null
    /**
     * Filter, which piccolo_user to fetch.
     */
    where: piccolo_userWhereUniqueInput
  }


  /**
   * piccolo_user findUniqueOrThrow
   */
  export type piccolo_userFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the piccolo_user
     */
    select?: piccolo_userSelect<ExtArgs> | null
    /**
     * Filter, which piccolo_user to fetch.
     */
    where: piccolo_userWhereUniqueInput
  }


  /**
   * piccolo_user findFirst
   */
  export type piccolo_userFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the piccolo_user
     */
    select?: piccolo_userSelect<ExtArgs> | null
    /**
     * Filter, which piccolo_user to fetch.
     */
    where?: piccolo_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of piccolo_users to fetch.
     */
    orderBy?: piccolo_userOrderByWithRelationInput | piccolo_userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for piccolo_users.
     */
    cursor?: piccolo_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` piccolo_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` piccolo_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of piccolo_users.
     */
    distinct?: Piccolo_userScalarFieldEnum | Piccolo_userScalarFieldEnum[]
  }


  /**
   * piccolo_user findFirstOrThrow
   */
  export type piccolo_userFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the piccolo_user
     */
    select?: piccolo_userSelect<ExtArgs> | null
    /**
     * Filter, which piccolo_user to fetch.
     */
    where?: piccolo_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of piccolo_users to fetch.
     */
    orderBy?: piccolo_userOrderByWithRelationInput | piccolo_userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for piccolo_users.
     */
    cursor?: piccolo_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` piccolo_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` piccolo_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of piccolo_users.
     */
    distinct?: Piccolo_userScalarFieldEnum | Piccolo_userScalarFieldEnum[]
  }


  /**
   * piccolo_user findMany
   */
  export type piccolo_userFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the piccolo_user
     */
    select?: piccolo_userSelect<ExtArgs> | null
    /**
     * Filter, which piccolo_users to fetch.
     */
    where?: piccolo_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of piccolo_users to fetch.
     */
    orderBy?: piccolo_userOrderByWithRelationInput | piccolo_userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing piccolo_users.
     */
    cursor?: piccolo_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` piccolo_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` piccolo_users.
     */
    skip?: number
    distinct?: Piccolo_userScalarFieldEnum | Piccolo_userScalarFieldEnum[]
  }


  /**
   * piccolo_user create
   */
  export type piccolo_userCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the piccolo_user
     */
    select?: piccolo_userSelect<ExtArgs> | null
    /**
     * The data needed to create a piccolo_user.
     */
    data?: XOR<piccolo_userCreateInput, piccolo_userUncheckedCreateInput>
  }


  /**
   * piccolo_user createMany
   */
  export type piccolo_userCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many piccolo_users.
     */
    data: piccolo_userCreateManyInput | piccolo_userCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * piccolo_user update
   */
  export type piccolo_userUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the piccolo_user
     */
    select?: piccolo_userSelect<ExtArgs> | null
    /**
     * The data needed to update a piccolo_user.
     */
    data: XOR<piccolo_userUpdateInput, piccolo_userUncheckedUpdateInput>
    /**
     * Choose, which piccolo_user to update.
     */
    where: piccolo_userWhereUniqueInput
  }


  /**
   * piccolo_user updateMany
   */
  export type piccolo_userUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update piccolo_users.
     */
    data: XOR<piccolo_userUpdateManyMutationInput, piccolo_userUncheckedUpdateManyInput>
    /**
     * Filter which piccolo_users to update
     */
    where?: piccolo_userWhereInput
  }


  /**
   * piccolo_user upsert
   */
  export type piccolo_userUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the piccolo_user
     */
    select?: piccolo_userSelect<ExtArgs> | null
    /**
     * The filter to search for the piccolo_user to update in case it exists.
     */
    where: piccolo_userWhereUniqueInput
    /**
     * In case the piccolo_user found by the `where` argument doesn't exist, create a new piccolo_user with this data.
     */
    create: XOR<piccolo_userCreateInput, piccolo_userUncheckedCreateInput>
    /**
     * In case the piccolo_user was found with the provided `where` argument, update it with this data.
     */
    update: XOR<piccolo_userUpdateInput, piccolo_userUncheckedUpdateInput>
  }


  /**
   * piccolo_user delete
   */
  export type piccolo_userDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the piccolo_user
     */
    select?: piccolo_userSelect<ExtArgs> | null
    /**
     * Filter which piccolo_user to delete.
     */
    where: piccolo_userWhereUniqueInput
  }


  /**
   * piccolo_user deleteMany
   */
  export type piccolo_userDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which piccolo_users to delete
     */
    where?: piccolo_userWhereInput
  }


  /**
   * piccolo_user without action
   */
  export type piccolo_userDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the piccolo_user
     */
    select?: piccolo_userSelect<ExtArgs> | null
  }



  /**
   * Model platform_map
   */

  export type AggregatePlatform_map = {
    _count: Platform_mapCountAggregateOutputType | null
    _avg: Platform_mapAvgAggregateOutputType | null
    _sum: Platform_mapSumAggregateOutputType | null
    _min: Platform_mapMinAggregateOutputType | null
    _max: Platform_mapMaxAggregateOutputType | null
  }

  export type Platform_mapAvgAggregateOutputType = {
    fates_id: Decimal | null
  }

  export type Platform_mapSumAggregateOutputType = {
    fates_id: Decimal | null
  }

  export type Platform_mapMinAggregateOutputType = {
    fates_id: Decimal | null
    platform_id: string | null
    lynxtag: string | null
  }

  export type Platform_mapMaxAggregateOutputType = {
    fates_id: Decimal | null
    platform_id: string | null
    lynxtag: string | null
  }

  export type Platform_mapCountAggregateOutputType = {
    fates_id: number
    platform_id: number
    lynxtag: number
    _all: number
  }


  export type Platform_mapAvgAggregateInputType = {
    fates_id?: true
  }

  export type Platform_mapSumAggregateInputType = {
    fates_id?: true
  }

  export type Platform_mapMinAggregateInputType = {
    fates_id?: true
    platform_id?: true
    lynxtag?: true
  }

  export type Platform_mapMaxAggregateInputType = {
    fates_id?: true
    platform_id?: true
    lynxtag?: true
  }

  export type Platform_mapCountAggregateInputType = {
    fates_id?: true
    platform_id?: true
    lynxtag?: true
    _all?: true
  }

  export type Platform_mapAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which platform_map to aggregate.
     */
    where?: platform_mapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of platform_maps to fetch.
     */
    orderBy?: platform_mapOrderByWithRelationInput | platform_mapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: platform_mapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` platform_maps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` platform_maps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned platform_maps
    **/
    _count?: true | Platform_mapCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Platform_mapAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Platform_mapSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Platform_mapMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Platform_mapMaxAggregateInputType
  }

  export type GetPlatform_mapAggregateType<T extends Platform_mapAggregateArgs> = {
        [P in keyof T & keyof AggregatePlatform_map]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlatform_map[P]>
      : GetScalarType<T[P], AggregatePlatform_map[P]>
  }




  export type platform_mapGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: platform_mapWhereInput
    orderBy?: platform_mapOrderByWithAggregationInput | platform_mapOrderByWithAggregationInput[]
    by: Platform_mapScalarFieldEnum[] | Platform_mapScalarFieldEnum
    having?: platform_mapScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Platform_mapCountAggregateInputType | true
    _avg?: Platform_mapAvgAggregateInputType
    _sum?: Platform_mapSumAggregateInputType
    _min?: Platform_mapMinAggregateInputType
    _max?: Platform_mapMaxAggregateInputType
  }

  export type Platform_mapGroupByOutputType = {
    fates_id: Decimal
    platform_id: string
    lynxtag: string
    _count: Platform_mapCountAggregateOutputType | null
    _avg: Platform_mapAvgAggregateOutputType | null
    _sum: Platform_mapSumAggregateOutputType | null
    _min: Platform_mapMinAggregateOutputType | null
    _max: Platform_mapMaxAggregateOutputType | null
  }

  type GetPlatform_mapGroupByPayload<T extends platform_mapGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Platform_mapGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Platform_mapGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Platform_mapGroupByOutputType[P]>
            : GetScalarType<T[P], Platform_mapGroupByOutputType[P]>
        }
      >
    >


  export type platform_mapSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    fates_id?: boolean
    platform_id?: boolean
    lynxtag?: boolean
  }, ExtArgs["result"]["platform_map"]>

  export type platform_mapSelectScalar = {
    fates_id?: boolean
    platform_id?: boolean
    lynxtag?: boolean
  }


  export type $platform_mapPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "platform_map"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      fates_id: Prisma.Decimal
      platform_id: string
      lynxtag: string
    }, ExtArgs["result"]["platform_map"]>
    composites: {}
  }


  type platform_mapGetPayload<S extends boolean | null | undefined | platform_mapDefaultArgs> = $Result.GetResult<Prisma.$platform_mapPayload, S>

  type platform_mapCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<platform_mapFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Platform_mapCountAggregateInputType | true
    }

  export interface platform_mapDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['platform_map'], meta: { name: 'platform_map' } }
    /**
     * Find zero or one Platform_map that matches the filter.
     * @param {platform_mapFindUniqueArgs} args - Arguments to find a Platform_map
     * @example
     * // Get one Platform_map
     * const platform_map = await prisma.platform_map.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends platform_mapFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, platform_mapFindUniqueArgs<ExtArgs>>
    ): Prisma__platform_mapClient<$Result.GetResult<Prisma.$platform_mapPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Platform_map that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {platform_mapFindUniqueOrThrowArgs} args - Arguments to find a Platform_map
     * @example
     * // Get one Platform_map
     * const platform_map = await prisma.platform_map.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends platform_mapFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, platform_mapFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__platform_mapClient<$Result.GetResult<Prisma.$platform_mapPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Platform_map that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {platform_mapFindFirstArgs} args - Arguments to find a Platform_map
     * @example
     * // Get one Platform_map
     * const platform_map = await prisma.platform_map.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends platform_mapFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, platform_mapFindFirstArgs<ExtArgs>>
    ): Prisma__platform_mapClient<$Result.GetResult<Prisma.$platform_mapPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Platform_map that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {platform_mapFindFirstOrThrowArgs} args - Arguments to find a Platform_map
     * @example
     * // Get one Platform_map
     * const platform_map = await prisma.platform_map.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends platform_mapFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, platform_mapFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__platform_mapClient<$Result.GetResult<Prisma.$platform_mapPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Platform_maps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {platform_mapFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Platform_maps
     * const platform_maps = await prisma.platform_map.findMany()
     * 
     * // Get first 10 Platform_maps
     * const platform_maps = await prisma.platform_map.findMany({ take: 10 })
     * 
     * // Only select the `fates_id`
     * const platform_mapWithFates_idOnly = await prisma.platform_map.findMany({ select: { fates_id: true } })
     * 
    **/
    findMany<T extends platform_mapFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, platform_mapFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$platform_mapPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Platform_map.
     * @param {platform_mapCreateArgs} args - Arguments to create a Platform_map.
     * @example
     * // Create one Platform_map
     * const Platform_map = await prisma.platform_map.create({
     *   data: {
     *     // ... data to create a Platform_map
     *   }
     * })
     * 
    **/
    create<T extends platform_mapCreateArgs<ExtArgs>>(
      args: SelectSubset<T, platform_mapCreateArgs<ExtArgs>>
    ): Prisma__platform_mapClient<$Result.GetResult<Prisma.$platform_mapPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Platform_maps.
     *     @param {platform_mapCreateManyArgs} args - Arguments to create many Platform_maps.
     *     @example
     *     // Create many Platform_maps
     *     const platform_map = await prisma.platform_map.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends platform_mapCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, platform_mapCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Platform_map.
     * @param {platform_mapDeleteArgs} args - Arguments to delete one Platform_map.
     * @example
     * // Delete one Platform_map
     * const Platform_map = await prisma.platform_map.delete({
     *   where: {
     *     // ... filter to delete one Platform_map
     *   }
     * })
     * 
    **/
    delete<T extends platform_mapDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, platform_mapDeleteArgs<ExtArgs>>
    ): Prisma__platform_mapClient<$Result.GetResult<Prisma.$platform_mapPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Platform_map.
     * @param {platform_mapUpdateArgs} args - Arguments to update one Platform_map.
     * @example
     * // Update one Platform_map
     * const platform_map = await prisma.platform_map.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends platform_mapUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, platform_mapUpdateArgs<ExtArgs>>
    ): Prisma__platform_mapClient<$Result.GetResult<Prisma.$platform_mapPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Platform_maps.
     * @param {platform_mapDeleteManyArgs} args - Arguments to filter Platform_maps to delete.
     * @example
     * // Delete a few Platform_maps
     * const { count } = await prisma.platform_map.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends platform_mapDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, platform_mapDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Platform_maps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {platform_mapUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Platform_maps
     * const platform_map = await prisma.platform_map.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends platform_mapUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, platform_mapUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Platform_map.
     * @param {platform_mapUpsertArgs} args - Arguments to update or create a Platform_map.
     * @example
     * // Update or create a Platform_map
     * const platform_map = await prisma.platform_map.upsert({
     *   create: {
     *     // ... data to create a Platform_map
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Platform_map we want to update
     *   }
     * })
    **/
    upsert<T extends platform_mapUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, platform_mapUpsertArgs<ExtArgs>>
    ): Prisma__platform_mapClient<$Result.GetResult<Prisma.$platform_mapPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Platform_maps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {platform_mapCountArgs} args - Arguments to filter Platform_maps to count.
     * @example
     * // Count the number of Platform_maps
     * const count = await prisma.platform_map.count({
     *   where: {
     *     // ... the filter for the Platform_maps we want to count
     *   }
     * })
    **/
    count<T extends platform_mapCountArgs>(
      args?: Subset<T, platform_mapCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Platform_mapCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Platform_map.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Platform_mapAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Platform_mapAggregateArgs>(args: Subset<T, Platform_mapAggregateArgs>): Prisma.PrismaPromise<GetPlatform_mapAggregateType<T>>

    /**
     * Group by Platform_map.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {platform_mapGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends platform_mapGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: platform_mapGroupByArgs['orderBy'] }
        : { orderBy?: platform_mapGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, platform_mapGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlatform_mapGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the platform_map model
   */
  readonly fields: platform_mapFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for platform_map.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__platform_mapClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the platform_map model
   */ 
  interface platform_mapFieldRefs {
    readonly fates_id: FieldRef<"platform_map", 'Decimal'>
    readonly platform_id: FieldRef<"platform_map", 'String'>
    readonly lynxtag: FieldRef<"platform_map", 'String'>
  }
    

  // Custom InputTypes

  /**
   * platform_map findUnique
   */
  export type platform_mapFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the platform_map
     */
    select?: platform_mapSelect<ExtArgs> | null
    /**
     * Filter, which platform_map to fetch.
     */
    where: platform_mapWhereUniqueInput
  }


  /**
   * platform_map findUniqueOrThrow
   */
  export type platform_mapFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the platform_map
     */
    select?: platform_mapSelect<ExtArgs> | null
    /**
     * Filter, which platform_map to fetch.
     */
    where: platform_mapWhereUniqueInput
  }


  /**
   * platform_map findFirst
   */
  export type platform_mapFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the platform_map
     */
    select?: platform_mapSelect<ExtArgs> | null
    /**
     * Filter, which platform_map to fetch.
     */
    where?: platform_mapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of platform_maps to fetch.
     */
    orderBy?: platform_mapOrderByWithRelationInput | platform_mapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for platform_maps.
     */
    cursor?: platform_mapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` platform_maps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` platform_maps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of platform_maps.
     */
    distinct?: Platform_mapScalarFieldEnum | Platform_mapScalarFieldEnum[]
  }


  /**
   * platform_map findFirstOrThrow
   */
  export type platform_mapFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the platform_map
     */
    select?: platform_mapSelect<ExtArgs> | null
    /**
     * Filter, which platform_map to fetch.
     */
    where?: platform_mapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of platform_maps to fetch.
     */
    orderBy?: platform_mapOrderByWithRelationInput | platform_mapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for platform_maps.
     */
    cursor?: platform_mapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` platform_maps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` platform_maps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of platform_maps.
     */
    distinct?: Platform_mapScalarFieldEnum | Platform_mapScalarFieldEnum[]
  }


  /**
   * platform_map findMany
   */
  export type platform_mapFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the platform_map
     */
    select?: platform_mapSelect<ExtArgs> | null
    /**
     * Filter, which platform_maps to fetch.
     */
    where?: platform_mapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of platform_maps to fetch.
     */
    orderBy?: platform_mapOrderByWithRelationInput | platform_mapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing platform_maps.
     */
    cursor?: platform_mapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` platform_maps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` platform_maps.
     */
    skip?: number
    distinct?: Platform_mapScalarFieldEnum | Platform_mapScalarFieldEnum[]
  }


  /**
   * platform_map create
   */
  export type platform_mapCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the platform_map
     */
    select?: platform_mapSelect<ExtArgs> | null
    /**
     * The data needed to create a platform_map.
     */
    data: XOR<platform_mapCreateInput, platform_mapUncheckedCreateInput>
  }


  /**
   * platform_map createMany
   */
  export type platform_mapCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many platform_maps.
     */
    data: platform_mapCreateManyInput | platform_mapCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * platform_map update
   */
  export type platform_mapUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the platform_map
     */
    select?: platform_mapSelect<ExtArgs> | null
    /**
     * The data needed to update a platform_map.
     */
    data: XOR<platform_mapUpdateInput, platform_mapUncheckedUpdateInput>
    /**
     * Choose, which platform_map to update.
     */
    where: platform_mapWhereUniqueInput
  }


  /**
   * platform_map updateMany
   */
  export type platform_mapUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update platform_maps.
     */
    data: XOR<platform_mapUpdateManyMutationInput, platform_mapUncheckedUpdateManyInput>
    /**
     * Filter which platform_maps to update
     */
    where?: platform_mapWhereInput
  }


  /**
   * platform_map upsert
   */
  export type platform_mapUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the platform_map
     */
    select?: platform_mapSelect<ExtArgs> | null
    /**
     * The filter to search for the platform_map to update in case it exists.
     */
    where: platform_mapWhereUniqueInput
    /**
     * In case the platform_map found by the `where` argument doesn't exist, create a new platform_map with this data.
     */
    create: XOR<platform_mapCreateInput, platform_mapUncheckedCreateInput>
    /**
     * In case the platform_map was found with the provided `where` argument, update it with this data.
     */
    update: XOR<platform_mapUpdateInput, platform_mapUncheckedUpdateInput>
  }


  /**
   * platform_map delete
   */
  export type platform_mapDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the platform_map
     */
    select?: platform_mapSelect<ExtArgs> | null
    /**
     * Filter which platform_map to delete.
     */
    where: platform_mapWhereUniqueInput
  }


  /**
   * platform_map deleteMany
   */
  export type platform_mapDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which platform_maps to delete
     */
    where?: platform_mapWhereInput
  }


  /**
   * platform_map without action
   */
  export type platform_mapDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the platform_map
     */
    select?: platform_mapSelect<ExtArgs> | null
  }



  /**
   * Model push_notifications
   */

  export type AggregatePush_notifications = {
    _count: Push_notificationsCountAggregateOutputType | null
    _avg: Push_notificationsAvgAggregateOutputType | null
    _sum: Push_notificationsSumAggregateOutputType | null
    _min: Push_notificationsMinAggregateOutputType | null
    _max: Push_notificationsMaxAggregateOutputType | null
  }

  export type Push_notificationsAvgAggregateOutputType = {
    user_id: number | null
  }

  export type Push_notificationsSumAggregateOutputType = {
    user_id: bigint | null
  }

  export type Push_notificationsMinAggregateOutputType = {
    id: string | null
    user_id: bigint | null
    token: string | null
  }

  export type Push_notificationsMaxAggregateOutputType = {
    id: string | null
    user_id: bigint | null
    token: string | null
  }

  export type Push_notificationsCountAggregateOutputType = {
    id: number
    user_id: number
    token: number
    _all: number
  }


  export type Push_notificationsAvgAggregateInputType = {
    user_id?: true
  }

  export type Push_notificationsSumAggregateInputType = {
    user_id?: true
  }

  export type Push_notificationsMinAggregateInputType = {
    id?: true
    user_id?: true
    token?: true
  }

  export type Push_notificationsMaxAggregateInputType = {
    id?: true
    user_id?: true
    token?: true
  }

  export type Push_notificationsCountAggregateInputType = {
    id?: true
    user_id?: true
    token?: true
    _all?: true
  }

  export type Push_notificationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which push_notifications to aggregate.
     */
    where?: push_notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of push_notifications to fetch.
     */
    orderBy?: push_notificationsOrderByWithRelationInput | push_notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: push_notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` push_notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` push_notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned push_notifications
    **/
    _count?: true | Push_notificationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Push_notificationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Push_notificationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Push_notificationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Push_notificationsMaxAggregateInputType
  }

  export type GetPush_notificationsAggregateType<T extends Push_notificationsAggregateArgs> = {
        [P in keyof T & keyof AggregatePush_notifications]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePush_notifications[P]>
      : GetScalarType<T[P], AggregatePush_notifications[P]>
  }




  export type push_notificationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: push_notificationsWhereInput
    orderBy?: push_notificationsOrderByWithAggregationInput | push_notificationsOrderByWithAggregationInput[]
    by: Push_notificationsScalarFieldEnum[] | Push_notificationsScalarFieldEnum
    having?: push_notificationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Push_notificationsCountAggregateInputType | true
    _avg?: Push_notificationsAvgAggregateInputType
    _sum?: Push_notificationsSumAggregateInputType
    _min?: Push_notificationsMinAggregateInputType
    _max?: Push_notificationsMaxAggregateInputType
  }

  export type Push_notificationsGroupByOutputType = {
    id: string
    user_id: bigint
    token: string
    _count: Push_notificationsCountAggregateOutputType | null
    _avg: Push_notificationsAvgAggregateOutputType | null
    _sum: Push_notificationsSumAggregateOutputType | null
    _min: Push_notificationsMinAggregateOutputType | null
    _max: Push_notificationsMaxAggregateOutputType | null
  }

  type GetPush_notificationsGroupByPayload<T extends push_notificationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Push_notificationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Push_notificationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Push_notificationsGroupByOutputType[P]>
            : GetScalarType<T[P], Push_notificationsGroupByOutputType[P]>
        }
      >
    >


  export type push_notificationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    token?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["push_notifications"]>

  export type push_notificationsSelectScalar = {
    id?: boolean
    user_id?: boolean
    token?: boolean
  }

  export type push_notificationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }


  export type $push_notificationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "push_notifications"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: bigint
      token: string
    }, ExtArgs["result"]["push_notifications"]>
    composites: {}
  }


  type push_notificationsGetPayload<S extends boolean | null | undefined | push_notificationsDefaultArgs> = $Result.GetResult<Prisma.$push_notificationsPayload, S>

  type push_notificationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<push_notificationsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Push_notificationsCountAggregateInputType | true
    }

  export interface push_notificationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['push_notifications'], meta: { name: 'push_notifications' } }
    /**
     * Find zero or one Push_notifications that matches the filter.
     * @param {push_notificationsFindUniqueArgs} args - Arguments to find a Push_notifications
     * @example
     * // Get one Push_notifications
     * const push_notifications = await prisma.push_notifications.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends push_notificationsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, push_notificationsFindUniqueArgs<ExtArgs>>
    ): Prisma__push_notificationsClient<$Result.GetResult<Prisma.$push_notificationsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Push_notifications that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {push_notificationsFindUniqueOrThrowArgs} args - Arguments to find a Push_notifications
     * @example
     * // Get one Push_notifications
     * const push_notifications = await prisma.push_notifications.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends push_notificationsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, push_notificationsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__push_notificationsClient<$Result.GetResult<Prisma.$push_notificationsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Push_notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {push_notificationsFindFirstArgs} args - Arguments to find a Push_notifications
     * @example
     * // Get one Push_notifications
     * const push_notifications = await prisma.push_notifications.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends push_notificationsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, push_notificationsFindFirstArgs<ExtArgs>>
    ): Prisma__push_notificationsClient<$Result.GetResult<Prisma.$push_notificationsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Push_notifications that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {push_notificationsFindFirstOrThrowArgs} args - Arguments to find a Push_notifications
     * @example
     * // Get one Push_notifications
     * const push_notifications = await prisma.push_notifications.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends push_notificationsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, push_notificationsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__push_notificationsClient<$Result.GetResult<Prisma.$push_notificationsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Push_notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {push_notificationsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Push_notifications
     * const push_notifications = await prisma.push_notifications.findMany()
     * 
     * // Get first 10 Push_notifications
     * const push_notifications = await prisma.push_notifications.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const push_notificationsWithIdOnly = await prisma.push_notifications.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends push_notificationsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, push_notificationsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$push_notificationsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Push_notifications.
     * @param {push_notificationsCreateArgs} args - Arguments to create a Push_notifications.
     * @example
     * // Create one Push_notifications
     * const Push_notifications = await prisma.push_notifications.create({
     *   data: {
     *     // ... data to create a Push_notifications
     *   }
     * })
     * 
    **/
    create<T extends push_notificationsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, push_notificationsCreateArgs<ExtArgs>>
    ): Prisma__push_notificationsClient<$Result.GetResult<Prisma.$push_notificationsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Push_notifications.
     *     @param {push_notificationsCreateManyArgs} args - Arguments to create many Push_notifications.
     *     @example
     *     // Create many Push_notifications
     *     const push_notifications = await prisma.push_notifications.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends push_notificationsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, push_notificationsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Push_notifications.
     * @param {push_notificationsDeleteArgs} args - Arguments to delete one Push_notifications.
     * @example
     * // Delete one Push_notifications
     * const Push_notifications = await prisma.push_notifications.delete({
     *   where: {
     *     // ... filter to delete one Push_notifications
     *   }
     * })
     * 
    **/
    delete<T extends push_notificationsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, push_notificationsDeleteArgs<ExtArgs>>
    ): Prisma__push_notificationsClient<$Result.GetResult<Prisma.$push_notificationsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Push_notifications.
     * @param {push_notificationsUpdateArgs} args - Arguments to update one Push_notifications.
     * @example
     * // Update one Push_notifications
     * const push_notifications = await prisma.push_notifications.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends push_notificationsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, push_notificationsUpdateArgs<ExtArgs>>
    ): Prisma__push_notificationsClient<$Result.GetResult<Prisma.$push_notificationsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Push_notifications.
     * @param {push_notificationsDeleteManyArgs} args - Arguments to filter Push_notifications to delete.
     * @example
     * // Delete a few Push_notifications
     * const { count } = await prisma.push_notifications.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends push_notificationsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, push_notificationsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Push_notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {push_notificationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Push_notifications
     * const push_notifications = await prisma.push_notifications.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends push_notificationsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, push_notificationsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Push_notifications.
     * @param {push_notificationsUpsertArgs} args - Arguments to update or create a Push_notifications.
     * @example
     * // Update or create a Push_notifications
     * const push_notifications = await prisma.push_notifications.upsert({
     *   create: {
     *     // ... data to create a Push_notifications
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Push_notifications we want to update
     *   }
     * })
    **/
    upsert<T extends push_notificationsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, push_notificationsUpsertArgs<ExtArgs>>
    ): Prisma__push_notificationsClient<$Result.GetResult<Prisma.$push_notificationsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Push_notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {push_notificationsCountArgs} args - Arguments to filter Push_notifications to count.
     * @example
     * // Count the number of Push_notifications
     * const count = await prisma.push_notifications.count({
     *   where: {
     *     // ... the filter for the Push_notifications we want to count
     *   }
     * })
    **/
    count<T extends push_notificationsCountArgs>(
      args?: Subset<T, push_notificationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Push_notificationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Push_notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Push_notificationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Push_notificationsAggregateArgs>(args: Subset<T, Push_notificationsAggregateArgs>): Prisma.PrismaPromise<GetPush_notificationsAggregateType<T>>

    /**
     * Group by Push_notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {push_notificationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends push_notificationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: push_notificationsGroupByArgs['orderBy'] }
        : { orderBy?: push_notificationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, push_notificationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPush_notificationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the push_notifications model
   */
  readonly fields: push_notificationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for push_notifications.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__push_notificationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the push_notifications model
   */ 
  interface push_notificationsFieldRefs {
    readonly id: FieldRef<"push_notifications", 'String'>
    readonly user_id: FieldRef<"push_notifications", 'BigInt'>
    readonly token: FieldRef<"push_notifications", 'String'>
  }
    

  // Custom InputTypes

  /**
   * push_notifications findUnique
   */
  export type push_notificationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the push_notifications
     */
    select?: push_notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: push_notificationsInclude<ExtArgs> | null
    /**
     * Filter, which push_notifications to fetch.
     */
    where: push_notificationsWhereUniqueInput
  }


  /**
   * push_notifications findUniqueOrThrow
   */
  export type push_notificationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the push_notifications
     */
    select?: push_notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: push_notificationsInclude<ExtArgs> | null
    /**
     * Filter, which push_notifications to fetch.
     */
    where: push_notificationsWhereUniqueInput
  }


  /**
   * push_notifications findFirst
   */
  export type push_notificationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the push_notifications
     */
    select?: push_notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: push_notificationsInclude<ExtArgs> | null
    /**
     * Filter, which push_notifications to fetch.
     */
    where?: push_notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of push_notifications to fetch.
     */
    orderBy?: push_notificationsOrderByWithRelationInput | push_notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for push_notifications.
     */
    cursor?: push_notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` push_notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` push_notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of push_notifications.
     */
    distinct?: Push_notificationsScalarFieldEnum | Push_notificationsScalarFieldEnum[]
  }


  /**
   * push_notifications findFirstOrThrow
   */
  export type push_notificationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the push_notifications
     */
    select?: push_notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: push_notificationsInclude<ExtArgs> | null
    /**
     * Filter, which push_notifications to fetch.
     */
    where?: push_notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of push_notifications to fetch.
     */
    orderBy?: push_notificationsOrderByWithRelationInput | push_notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for push_notifications.
     */
    cursor?: push_notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` push_notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` push_notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of push_notifications.
     */
    distinct?: Push_notificationsScalarFieldEnum | Push_notificationsScalarFieldEnum[]
  }


  /**
   * push_notifications findMany
   */
  export type push_notificationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the push_notifications
     */
    select?: push_notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: push_notificationsInclude<ExtArgs> | null
    /**
     * Filter, which push_notifications to fetch.
     */
    where?: push_notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of push_notifications to fetch.
     */
    orderBy?: push_notificationsOrderByWithRelationInput | push_notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing push_notifications.
     */
    cursor?: push_notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` push_notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` push_notifications.
     */
    skip?: number
    distinct?: Push_notificationsScalarFieldEnum | Push_notificationsScalarFieldEnum[]
  }


  /**
   * push_notifications create
   */
  export type push_notificationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the push_notifications
     */
    select?: push_notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: push_notificationsInclude<ExtArgs> | null
    /**
     * The data needed to create a push_notifications.
     */
    data: XOR<push_notificationsCreateInput, push_notificationsUncheckedCreateInput>
  }


  /**
   * push_notifications createMany
   */
  export type push_notificationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many push_notifications.
     */
    data: push_notificationsCreateManyInput | push_notificationsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * push_notifications update
   */
  export type push_notificationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the push_notifications
     */
    select?: push_notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: push_notificationsInclude<ExtArgs> | null
    /**
     * The data needed to update a push_notifications.
     */
    data: XOR<push_notificationsUpdateInput, push_notificationsUncheckedUpdateInput>
    /**
     * Choose, which push_notifications to update.
     */
    where: push_notificationsWhereUniqueInput
  }


  /**
   * push_notifications updateMany
   */
  export type push_notificationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update push_notifications.
     */
    data: XOR<push_notificationsUpdateManyMutationInput, push_notificationsUncheckedUpdateManyInput>
    /**
     * Filter which push_notifications to update
     */
    where?: push_notificationsWhereInput
  }


  /**
   * push_notifications upsert
   */
  export type push_notificationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the push_notifications
     */
    select?: push_notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: push_notificationsInclude<ExtArgs> | null
    /**
     * The filter to search for the push_notifications to update in case it exists.
     */
    where: push_notificationsWhereUniqueInput
    /**
     * In case the push_notifications found by the `where` argument doesn't exist, create a new push_notifications with this data.
     */
    create: XOR<push_notificationsCreateInput, push_notificationsUncheckedCreateInput>
    /**
     * In case the push_notifications was found with the provided `where` argument, update it with this data.
     */
    update: XOR<push_notificationsUpdateInput, push_notificationsUncheckedUpdateInput>
  }


  /**
   * push_notifications delete
   */
  export type push_notificationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the push_notifications
     */
    select?: push_notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: push_notificationsInclude<ExtArgs> | null
    /**
     * Filter which push_notifications to delete.
     */
    where: push_notificationsWhereUniqueInput
  }


  /**
   * push_notifications deleteMany
   */
  export type push_notificationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which push_notifications to delete
     */
    where?: push_notificationsWhereInput
  }


  /**
   * push_notifications without action
   */
  export type push_notificationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the push_notifications
     */
    select?: push_notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: push_notificationsInclude<ExtArgs> | null
  }



  /**
   * Model review_votes
   */

  export type AggregateReview_votes = {
    _count: Review_votesCountAggregateOutputType | null
    _avg: Review_votesAvgAggregateOutputType | null
    _sum: Review_votesSumAggregateOutputType | null
    _min: Review_votesMinAggregateOutputType | null
    _max: Review_votesMaxAggregateOutputType | null
  }

  export type Review_votesAvgAggregateOutputType = {
    user_id: number | null
  }

  export type Review_votesSumAggregateOutputType = {
    user_id: bigint | null
  }

  export type Review_votesMinAggregateOutputType = {
    id: string | null
    user_id: bigint | null
    upvote: boolean | null
    lynxtag: string | null
  }

  export type Review_votesMaxAggregateOutputType = {
    id: string | null
    user_id: bigint | null
    upvote: boolean | null
    lynxtag: string | null
  }

  export type Review_votesCountAggregateOutputType = {
    id: number
    user_id: number
    upvote: number
    lynxtag: number
    _all: number
  }


  export type Review_votesAvgAggregateInputType = {
    user_id?: true
  }

  export type Review_votesSumAggregateInputType = {
    user_id?: true
  }

  export type Review_votesMinAggregateInputType = {
    id?: true
    user_id?: true
    upvote?: true
    lynxtag?: true
  }

  export type Review_votesMaxAggregateInputType = {
    id?: true
    user_id?: true
    upvote?: true
    lynxtag?: true
  }

  export type Review_votesCountAggregateInputType = {
    id?: true
    user_id?: true
    upvote?: true
    lynxtag?: true
    _all?: true
  }

  export type Review_votesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which review_votes to aggregate.
     */
    where?: review_votesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of review_votes to fetch.
     */
    orderBy?: review_votesOrderByWithRelationInput | review_votesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: review_votesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` review_votes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` review_votes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned review_votes
    **/
    _count?: true | Review_votesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Review_votesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Review_votesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Review_votesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Review_votesMaxAggregateInputType
  }

  export type GetReview_votesAggregateType<T extends Review_votesAggregateArgs> = {
        [P in keyof T & keyof AggregateReview_votes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReview_votes[P]>
      : GetScalarType<T[P], AggregateReview_votes[P]>
  }




  export type review_votesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: review_votesWhereInput
    orderBy?: review_votesOrderByWithAggregationInput | review_votesOrderByWithAggregationInput[]
    by: Review_votesScalarFieldEnum[] | Review_votesScalarFieldEnum
    having?: review_votesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Review_votesCountAggregateInputType | true
    _avg?: Review_votesAvgAggregateInputType
    _sum?: Review_votesSumAggregateInputType
    _min?: Review_votesMinAggregateInputType
    _max?: Review_votesMaxAggregateInputType
  }

  export type Review_votesGroupByOutputType = {
    id: string
    user_id: bigint
    upvote: boolean
    lynxtag: string
    _count: Review_votesCountAggregateOutputType | null
    _avg: Review_votesAvgAggregateOutputType | null
    _sum: Review_votesSumAggregateOutputType | null
    _min: Review_votesMinAggregateOutputType | null
    _max: Review_votesMaxAggregateOutputType | null
  }

  type GetReview_votesGroupByPayload<T extends review_votesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Review_votesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Review_votesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Review_votesGroupByOutputType[P]>
            : GetScalarType<T[P], Review_votesGroupByOutputType[P]>
        }
      >
    >


  export type review_votesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    upvote?: boolean
    lynxtag?: boolean
    reviews?: boolean | reviewsDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review_votes"]>

  export type review_votesSelectScalar = {
    id?: boolean
    user_id?: boolean
    upvote?: boolean
    lynxtag?: boolean
  }

  export type review_votesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reviews?: boolean | reviewsDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }


  export type $review_votesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "review_votes"
    objects: {
      reviews: Prisma.$reviewsPayload<ExtArgs>
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: bigint
      upvote: boolean
      lynxtag: string
    }, ExtArgs["result"]["review_votes"]>
    composites: {}
  }


  type review_votesGetPayload<S extends boolean | null | undefined | review_votesDefaultArgs> = $Result.GetResult<Prisma.$review_votesPayload, S>

  type review_votesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<review_votesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Review_votesCountAggregateInputType | true
    }

  export interface review_votesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['review_votes'], meta: { name: 'review_votes' } }
    /**
     * Find zero or one Review_votes that matches the filter.
     * @param {review_votesFindUniqueArgs} args - Arguments to find a Review_votes
     * @example
     * // Get one Review_votes
     * const review_votes = await prisma.review_votes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends review_votesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, review_votesFindUniqueArgs<ExtArgs>>
    ): Prisma__review_votesClient<$Result.GetResult<Prisma.$review_votesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Review_votes that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {review_votesFindUniqueOrThrowArgs} args - Arguments to find a Review_votes
     * @example
     * // Get one Review_votes
     * const review_votes = await prisma.review_votes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends review_votesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, review_votesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__review_votesClient<$Result.GetResult<Prisma.$review_votesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Review_votes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {review_votesFindFirstArgs} args - Arguments to find a Review_votes
     * @example
     * // Get one Review_votes
     * const review_votes = await prisma.review_votes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends review_votesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, review_votesFindFirstArgs<ExtArgs>>
    ): Prisma__review_votesClient<$Result.GetResult<Prisma.$review_votesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Review_votes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {review_votesFindFirstOrThrowArgs} args - Arguments to find a Review_votes
     * @example
     * // Get one Review_votes
     * const review_votes = await prisma.review_votes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends review_votesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, review_votesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__review_votesClient<$Result.GetResult<Prisma.$review_votesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Review_votes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {review_votesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Review_votes
     * const review_votes = await prisma.review_votes.findMany()
     * 
     * // Get first 10 Review_votes
     * const review_votes = await prisma.review_votes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const review_votesWithIdOnly = await prisma.review_votes.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends review_votesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, review_votesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$review_votesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Review_votes.
     * @param {review_votesCreateArgs} args - Arguments to create a Review_votes.
     * @example
     * // Create one Review_votes
     * const Review_votes = await prisma.review_votes.create({
     *   data: {
     *     // ... data to create a Review_votes
     *   }
     * })
     * 
    **/
    create<T extends review_votesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, review_votesCreateArgs<ExtArgs>>
    ): Prisma__review_votesClient<$Result.GetResult<Prisma.$review_votesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Review_votes.
     *     @param {review_votesCreateManyArgs} args - Arguments to create many Review_votes.
     *     @example
     *     // Create many Review_votes
     *     const review_votes = await prisma.review_votes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends review_votesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, review_votesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Review_votes.
     * @param {review_votesDeleteArgs} args - Arguments to delete one Review_votes.
     * @example
     * // Delete one Review_votes
     * const Review_votes = await prisma.review_votes.delete({
     *   where: {
     *     // ... filter to delete one Review_votes
     *   }
     * })
     * 
    **/
    delete<T extends review_votesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, review_votesDeleteArgs<ExtArgs>>
    ): Prisma__review_votesClient<$Result.GetResult<Prisma.$review_votesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Review_votes.
     * @param {review_votesUpdateArgs} args - Arguments to update one Review_votes.
     * @example
     * // Update one Review_votes
     * const review_votes = await prisma.review_votes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends review_votesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, review_votesUpdateArgs<ExtArgs>>
    ): Prisma__review_votesClient<$Result.GetResult<Prisma.$review_votesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Review_votes.
     * @param {review_votesDeleteManyArgs} args - Arguments to filter Review_votes to delete.
     * @example
     * // Delete a few Review_votes
     * const { count } = await prisma.review_votes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends review_votesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, review_votesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Review_votes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {review_votesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Review_votes
     * const review_votes = await prisma.review_votes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends review_votesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, review_votesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Review_votes.
     * @param {review_votesUpsertArgs} args - Arguments to update or create a Review_votes.
     * @example
     * // Update or create a Review_votes
     * const review_votes = await prisma.review_votes.upsert({
     *   create: {
     *     // ... data to create a Review_votes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Review_votes we want to update
     *   }
     * })
    **/
    upsert<T extends review_votesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, review_votesUpsertArgs<ExtArgs>>
    ): Prisma__review_votesClient<$Result.GetResult<Prisma.$review_votesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Review_votes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {review_votesCountArgs} args - Arguments to filter Review_votes to count.
     * @example
     * // Count the number of Review_votes
     * const count = await prisma.review_votes.count({
     *   where: {
     *     // ... the filter for the Review_votes we want to count
     *   }
     * })
    **/
    count<T extends review_votesCountArgs>(
      args?: Subset<T, review_votesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Review_votesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Review_votes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Review_votesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Review_votesAggregateArgs>(args: Subset<T, Review_votesAggregateArgs>): Prisma.PrismaPromise<GetReview_votesAggregateType<T>>

    /**
     * Group by Review_votes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {review_votesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends review_votesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: review_votesGroupByArgs['orderBy'] }
        : { orderBy?: review_votesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, review_votesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReview_votesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the review_votes model
   */
  readonly fields: review_votesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for review_votes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__review_votesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    reviews<T extends reviewsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, reviewsDefaultArgs<ExtArgs>>): Prisma__reviewsClient<$Result.GetResult<Prisma.$reviewsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the review_votes model
   */ 
  interface review_votesFieldRefs {
    readonly id: FieldRef<"review_votes", 'String'>
    readonly user_id: FieldRef<"review_votes", 'BigInt'>
    readonly upvote: FieldRef<"review_votes", 'Boolean'>
    readonly lynxtag: FieldRef<"review_votes", 'String'>
  }
    

  // Custom InputTypes

  /**
   * review_votes findUnique
   */
  export type review_votesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the review_votes
     */
    select?: review_votesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: review_votesInclude<ExtArgs> | null
    /**
     * Filter, which review_votes to fetch.
     */
    where: review_votesWhereUniqueInput
  }


  /**
   * review_votes findUniqueOrThrow
   */
  export type review_votesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the review_votes
     */
    select?: review_votesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: review_votesInclude<ExtArgs> | null
    /**
     * Filter, which review_votes to fetch.
     */
    where: review_votesWhereUniqueInput
  }


  /**
   * review_votes findFirst
   */
  export type review_votesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the review_votes
     */
    select?: review_votesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: review_votesInclude<ExtArgs> | null
    /**
     * Filter, which review_votes to fetch.
     */
    where?: review_votesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of review_votes to fetch.
     */
    orderBy?: review_votesOrderByWithRelationInput | review_votesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for review_votes.
     */
    cursor?: review_votesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` review_votes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` review_votes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of review_votes.
     */
    distinct?: Review_votesScalarFieldEnum | Review_votesScalarFieldEnum[]
  }


  /**
   * review_votes findFirstOrThrow
   */
  export type review_votesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the review_votes
     */
    select?: review_votesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: review_votesInclude<ExtArgs> | null
    /**
     * Filter, which review_votes to fetch.
     */
    where?: review_votesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of review_votes to fetch.
     */
    orderBy?: review_votesOrderByWithRelationInput | review_votesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for review_votes.
     */
    cursor?: review_votesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` review_votes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` review_votes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of review_votes.
     */
    distinct?: Review_votesScalarFieldEnum | Review_votesScalarFieldEnum[]
  }


  /**
   * review_votes findMany
   */
  export type review_votesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the review_votes
     */
    select?: review_votesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: review_votesInclude<ExtArgs> | null
    /**
     * Filter, which review_votes to fetch.
     */
    where?: review_votesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of review_votes to fetch.
     */
    orderBy?: review_votesOrderByWithRelationInput | review_votesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing review_votes.
     */
    cursor?: review_votesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` review_votes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` review_votes.
     */
    skip?: number
    distinct?: Review_votesScalarFieldEnum | Review_votesScalarFieldEnum[]
  }


  /**
   * review_votes create
   */
  export type review_votesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the review_votes
     */
    select?: review_votesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: review_votesInclude<ExtArgs> | null
    /**
     * The data needed to create a review_votes.
     */
    data: XOR<review_votesCreateInput, review_votesUncheckedCreateInput>
  }


  /**
   * review_votes createMany
   */
  export type review_votesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many review_votes.
     */
    data: review_votesCreateManyInput | review_votesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * review_votes update
   */
  export type review_votesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the review_votes
     */
    select?: review_votesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: review_votesInclude<ExtArgs> | null
    /**
     * The data needed to update a review_votes.
     */
    data: XOR<review_votesUpdateInput, review_votesUncheckedUpdateInput>
    /**
     * Choose, which review_votes to update.
     */
    where: review_votesWhereUniqueInput
  }


  /**
   * review_votes updateMany
   */
  export type review_votesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update review_votes.
     */
    data: XOR<review_votesUpdateManyMutationInput, review_votesUncheckedUpdateManyInput>
    /**
     * Filter which review_votes to update
     */
    where?: review_votesWhereInput
  }


  /**
   * review_votes upsert
   */
  export type review_votesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the review_votes
     */
    select?: review_votesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: review_votesInclude<ExtArgs> | null
    /**
     * The filter to search for the review_votes to update in case it exists.
     */
    where: review_votesWhereUniqueInput
    /**
     * In case the review_votes found by the `where` argument doesn't exist, create a new review_votes with this data.
     */
    create: XOR<review_votesCreateInput, review_votesUncheckedCreateInput>
    /**
     * In case the review_votes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<review_votesUpdateInput, review_votesUncheckedUpdateInput>
  }


  /**
   * review_votes delete
   */
  export type review_votesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the review_votes
     */
    select?: review_votesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: review_votesInclude<ExtArgs> | null
    /**
     * Filter which review_votes to delete.
     */
    where: review_votesWhereUniqueInput
  }


  /**
   * review_votes deleteMany
   */
  export type review_votesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which review_votes to delete
     */
    where?: review_votesWhereInput
  }


  /**
   * review_votes without action
   */
  export type review_votesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the review_votes
     */
    select?: review_votesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: review_votesInclude<ExtArgs> | null
  }



  /**
   * Model reviews
   */

  export type AggregateReviews = {
    _count: ReviewsCountAggregateOutputType | null
    _avg: ReviewsAvgAggregateOutputType | null
    _sum: ReviewsSumAggregateOutputType | null
    _min: ReviewsMinAggregateOutputType | null
    _max: ReviewsMaxAggregateOutputType | null
  }

  export type ReviewsAvgAggregateOutputType = {
    target_id: number | null
    user_id: number | null
    star_rating: Decimal | null
    epoch: number | null
    target_type: number | null
  }

  export type ReviewsSumAggregateOutputType = {
    target_id: bigint | null
    user_id: bigint | null
    star_rating: Decimal | null
    epoch: bigint[]
    target_type: number | null
  }

  export type ReviewsMinAggregateOutputType = {
    id: string | null
    target_id: bigint | null
    user_id: bigint | null
    star_rating: Decimal | null
    review_text: string | null
    flagged: boolean | null
    target_type: number | null
    parent_id: string | null
    lynxtag: string | null
  }

  export type ReviewsMaxAggregateOutputType = {
    id: string | null
    target_id: bigint | null
    user_id: bigint | null
    star_rating: Decimal | null
    review_text: string | null
    flagged: boolean | null
    target_type: number | null
    parent_id: string | null
    lynxtag: string | null
  }

  export type ReviewsCountAggregateOutputType = {
    id: number
    target_id: number
    user_id: number
    star_rating: number
    review_text: number
    flagged: number
    epoch: number
    target_type: number
    parent_id: number
    lynxtag: number
    _all: number
  }


  export type ReviewsAvgAggregateInputType = {
    target_id?: true
    user_id?: true
    star_rating?: true
    epoch?: true
    target_type?: true
  }

  export type ReviewsSumAggregateInputType = {
    target_id?: true
    user_id?: true
    star_rating?: true
    epoch?: true
    target_type?: true
  }

  export type ReviewsMinAggregateInputType = {
    id?: true
    target_id?: true
    user_id?: true
    star_rating?: true
    review_text?: true
    flagged?: true
    target_type?: true
    parent_id?: true
    lynxtag?: true
  }

  export type ReviewsMaxAggregateInputType = {
    id?: true
    target_id?: true
    user_id?: true
    star_rating?: true
    review_text?: true
    flagged?: true
    target_type?: true
    parent_id?: true
    lynxtag?: true
  }

  export type ReviewsCountAggregateInputType = {
    id?: true
    target_id?: true
    user_id?: true
    star_rating?: true
    review_text?: true
    flagged?: true
    epoch?: true
    target_type?: true
    parent_id?: true
    lynxtag?: true
    _all?: true
  }

  export type ReviewsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which reviews to aggregate.
     */
    where?: reviewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reviews to fetch.
     */
    orderBy?: reviewsOrderByWithRelationInput | reviewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: reviewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned reviews
    **/
    _count?: true | ReviewsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReviewsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReviewsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewsMaxAggregateInputType
  }

  export type GetReviewsAggregateType<T extends ReviewsAggregateArgs> = {
        [P in keyof T & keyof AggregateReviews]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReviews[P]>
      : GetScalarType<T[P], AggregateReviews[P]>
  }




  export type reviewsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reviewsWhereInput
    orderBy?: reviewsOrderByWithAggregationInput | reviewsOrderByWithAggregationInput[]
    by: ReviewsScalarFieldEnum[] | ReviewsScalarFieldEnum
    having?: reviewsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewsCountAggregateInputType | true
    _avg?: ReviewsAvgAggregateInputType
    _sum?: ReviewsSumAggregateInputType
    _min?: ReviewsMinAggregateInputType
    _max?: ReviewsMaxAggregateInputType
  }

  export type ReviewsGroupByOutputType = {
    id: string
    target_id: bigint
    user_id: bigint
    star_rating: Decimal
    review_text: string
    flagged: boolean
    epoch: bigint[]
    target_type: number | null
    parent_id: string | null
    lynxtag: string
    _count: ReviewsCountAggregateOutputType | null
    _avg: ReviewsAvgAggregateOutputType | null
    _sum: ReviewsSumAggregateOutputType | null
    _min: ReviewsMinAggregateOutputType | null
    _max: ReviewsMaxAggregateOutputType | null
  }

  type GetReviewsGroupByPayload<T extends reviewsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewsGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewsGroupByOutputType[P]>
        }
      >
    >


  export type reviewsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    target_id?: boolean
    user_id?: boolean
    star_rating?: boolean
    review_text?: boolean
    flagged?: boolean
    epoch?: boolean
    target_type?: boolean
    parent_id?: boolean
    lynxtag?: boolean
    review_votes?: boolean | reviews$review_votesArgs<ExtArgs>
    reviews?: boolean | reviews$reviewsArgs<ExtArgs>
    other_reviews?: boolean | reviews$other_reviewsArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    _count?: boolean | ReviewsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviews"]>

  export type reviewsSelectScalar = {
    id?: boolean
    target_id?: boolean
    user_id?: boolean
    star_rating?: boolean
    review_text?: boolean
    flagged?: boolean
    epoch?: boolean
    target_type?: boolean
    parent_id?: boolean
    lynxtag?: boolean
  }

  export type reviewsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    review_votes?: boolean | reviews$review_votesArgs<ExtArgs>
    reviews?: boolean | reviews$reviewsArgs<ExtArgs>
    other_reviews?: boolean | reviews$other_reviewsArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    _count?: boolean | ReviewsCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $reviewsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "reviews"
    objects: {
      review_votes: Prisma.$review_votesPayload<ExtArgs>[]
      reviews: Prisma.$reviewsPayload<ExtArgs> | null
      other_reviews: Prisma.$reviewsPayload<ExtArgs>[]
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      target_id: bigint
      user_id: bigint
      star_rating: Prisma.Decimal
      review_text: string
      flagged: boolean
      epoch: bigint[]
      target_type: number | null
      parent_id: string | null
      lynxtag: string
    }, ExtArgs["result"]["reviews"]>
    composites: {}
  }


  type reviewsGetPayload<S extends boolean | null | undefined | reviewsDefaultArgs> = $Result.GetResult<Prisma.$reviewsPayload, S>

  type reviewsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<reviewsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReviewsCountAggregateInputType | true
    }

  export interface reviewsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['reviews'], meta: { name: 'reviews' } }
    /**
     * Find zero or one Reviews that matches the filter.
     * @param {reviewsFindUniqueArgs} args - Arguments to find a Reviews
     * @example
     * // Get one Reviews
     * const reviews = await prisma.reviews.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends reviewsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, reviewsFindUniqueArgs<ExtArgs>>
    ): Prisma__reviewsClient<$Result.GetResult<Prisma.$reviewsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Reviews that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {reviewsFindUniqueOrThrowArgs} args - Arguments to find a Reviews
     * @example
     * // Get one Reviews
     * const reviews = await prisma.reviews.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends reviewsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, reviewsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__reviewsClient<$Result.GetResult<Prisma.$reviewsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewsFindFirstArgs} args - Arguments to find a Reviews
     * @example
     * // Get one Reviews
     * const reviews = await prisma.reviews.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends reviewsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, reviewsFindFirstArgs<ExtArgs>>
    ): Prisma__reviewsClient<$Result.GetResult<Prisma.$reviewsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Reviews that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewsFindFirstOrThrowArgs} args - Arguments to find a Reviews
     * @example
     * // Get one Reviews
     * const reviews = await prisma.reviews.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends reviewsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, reviewsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__reviewsClient<$Result.GetResult<Prisma.$reviewsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reviews
     * const reviews = await prisma.reviews.findMany()
     * 
     * // Get first 10 Reviews
     * const reviews = await prisma.reviews.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewsWithIdOnly = await prisma.reviews.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends reviewsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, reviewsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reviewsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Reviews.
     * @param {reviewsCreateArgs} args - Arguments to create a Reviews.
     * @example
     * // Create one Reviews
     * const Reviews = await prisma.reviews.create({
     *   data: {
     *     // ... data to create a Reviews
     *   }
     * })
     * 
    **/
    create<T extends reviewsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, reviewsCreateArgs<ExtArgs>>
    ): Prisma__reviewsClient<$Result.GetResult<Prisma.$reviewsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Reviews.
     *     @param {reviewsCreateManyArgs} args - Arguments to create many Reviews.
     *     @example
     *     // Create many Reviews
     *     const reviews = await prisma.reviews.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends reviewsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, reviewsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Reviews.
     * @param {reviewsDeleteArgs} args - Arguments to delete one Reviews.
     * @example
     * // Delete one Reviews
     * const Reviews = await prisma.reviews.delete({
     *   where: {
     *     // ... filter to delete one Reviews
     *   }
     * })
     * 
    **/
    delete<T extends reviewsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, reviewsDeleteArgs<ExtArgs>>
    ): Prisma__reviewsClient<$Result.GetResult<Prisma.$reviewsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Reviews.
     * @param {reviewsUpdateArgs} args - Arguments to update one Reviews.
     * @example
     * // Update one Reviews
     * const reviews = await prisma.reviews.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends reviewsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, reviewsUpdateArgs<ExtArgs>>
    ): Prisma__reviewsClient<$Result.GetResult<Prisma.$reviewsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Reviews.
     * @param {reviewsDeleteManyArgs} args - Arguments to filter Reviews to delete.
     * @example
     * // Delete a few Reviews
     * const { count } = await prisma.reviews.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends reviewsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, reviewsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reviews
     * const reviews = await prisma.reviews.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends reviewsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, reviewsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Reviews.
     * @param {reviewsUpsertArgs} args - Arguments to update or create a Reviews.
     * @example
     * // Update or create a Reviews
     * const reviews = await prisma.reviews.upsert({
     *   create: {
     *     // ... data to create a Reviews
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reviews we want to update
     *   }
     * })
    **/
    upsert<T extends reviewsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, reviewsUpsertArgs<ExtArgs>>
    ): Prisma__reviewsClient<$Result.GetResult<Prisma.$reviewsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewsCountArgs} args - Arguments to filter Reviews to count.
     * @example
     * // Count the number of Reviews
     * const count = await prisma.reviews.count({
     *   where: {
     *     // ... the filter for the Reviews we want to count
     *   }
     * })
    **/
    count<T extends reviewsCountArgs>(
      args?: Subset<T, reviewsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewsAggregateArgs>(args: Subset<T, ReviewsAggregateArgs>): Prisma.PrismaPromise<GetReviewsAggregateType<T>>

    /**
     * Group by Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends reviewsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: reviewsGroupByArgs['orderBy'] }
        : { orderBy?: reviewsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, reviewsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the reviews model
   */
  readonly fields: reviewsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for reviews.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__reviewsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    review_votes<T extends reviews$review_votesArgs<ExtArgs> = {}>(args?: Subset<T, reviews$review_votesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$review_votesPayload<ExtArgs>, T, 'findMany'> | Null>;

    reviews<T extends reviews$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, reviews$reviewsArgs<ExtArgs>>): Prisma__reviewsClient<$Result.GetResult<Prisma.$reviewsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    other_reviews<T extends reviews$other_reviewsArgs<ExtArgs> = {}>(args?: Subset<T, reviews$other_reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reviewsPayload<ExtArgs>, T, 'findMany'> | Null>;

    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the reviews model
   */ 
  interface reviewsFieldRefs {
    readonly id: FieldRef<"reviews", 'String'>
    readonly target_id: FieldRef<"reviews", 'BigInt'>
    readonly user_id: FieldRef<"reviews", 'BigInt'>
    readonly star_rating: FieldRef<"reviews", 'Decimal'>
    readonly review_text: FieldRef<"reviews", 'String'>
    readonly flagged: FieldRef<"reviews", 'Boolean'>
    readonly epoch: FieldRef<"reviews", 'BigInt[]'>
    readonly target_type: FieldRef<"reviews", 'Int'>
    readonly parent_id: FieldRef<"reviews", 'String'>
    readonly lynxtag: FieldRef<"reviews", 'String'>
  }
    

  // Custom InputTypes

  /**
   * reviews findUnique
   */
  export type reviewsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reviewsInclude<ExtArgs> | null
    /**
     * Filter, which reviews to fetch.
     */
    where: reviewsWhereUniqueInput
  }


  /**
   * reviews findUniqueOrThrow
   */
  export type reviewsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reviewsInclude<ExtArgs> | null
    /**
     * Filter, which reviews to fetch.
     */
    where: reviewsWhereUniqueInput
  }


  /**
   * reviews findFirst
   */
  export type reviewsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reviewsInclude<ExtArgs> | null
    /**
     * Filter, which reviews to fetch.
     */
    where?: reviewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reviews to fetch.
     */
    orderBy?: reviewsOrderByWithRelationInput | reviewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reviews.
     */
    cursor?: reviewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reviews.
     */
    distinct?: ReviewsScalarFieldEnum | ReviewsScalarFieldEnum[]
  }


  /**
   * reviews findFirstOrThrow
   */
  export type reviewsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reviewsInclude<ExtArgs> | null
    /**
     * Filter, which reviews to fetch.
     */
    where?: reviewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reviews to fetch.
     */
    orderBy?: reviewsOrderByWithRelationInput | reviewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reviews.
     */
    cursor?: reviewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reviews.
     */
    distinct?: ReviewsScalarFieldEnum | ReviewsScalarFieldEnum[]
  }


  /**
   * reviews findMany
   */
  export type reviewsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reviewsInclude<ExtArgs> | null
    /**
     * Filter, which reviews to fetch.
     */
    where?: reviewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reviews to fetch.
     */
    orderBy?: reviewsOrderByWithRelationInput | reviewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing reviews.
     */
    cursor?: reviewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reviews.
     */
    skip?: number
    distinct?: ReviewsScalarFieldEnum | ReviewsScalarFieldEnum[]
  }


  /**
   * reviews create
   */
  export type reviewsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reviewsInclude<ExtArgs> | null
    /**
     * The data needed to create a reviews.
     */
    data: XOR<reviewsCreateInput, reviewsUncheckedCreateInput>
  }


  /**
   * reviews createMany
   */
  export type reviewsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many reviews.
     */
    data: reviewsCreateManyInput | reviewsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * reviews update
   */
  export type reviewsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reviewsInclude<ExtArgs> | null
    /**
     * The data needed to update a reviews.
     */
    data: XOR<reviewsUpdateInput, reviewsUncheckedUpdateInput>
    /**
     * Choose, which reviews to update.
     */
    where: reviewsWhereUniqueInput
  }


  /**
   * reviews updateMany
   */
  export type reviewsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update reviews.
     */
    data: XOR<reviewsUpdateManyMutationInput, reviewsUncheckedUpdateManyInput>
    /**
     * Filter which reviews to update
     */
    where?: reviewsWhereInput
  }


  /**
   * reviews upsert
   */
  export type reviewsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reviewsInclude<ExtArgs> | null
    /**
     * The filter to search for the reviews to update in case it exists.
     */
    where: reviewsWhereUniqueInput
    /**
     * In case the reviews found by the `where` argument doesn't exist, create a new reviews with this data.
     */
    create: XOR<reviewsCreateInput, reviewsUncheckedCreateInput>
    /**
     * In case the reviews was found with the provided `where` argument, update it with this data.
     */
    update: XOR<reviewsUpdateInput, reviewsUncheckedUpdateInput>
  }


  /**
   * reviews delete
   */
  export type reviewsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reviewsInclude<ExtArgs> | null
    /**
     * Filter which reviews to delete.
     */
    where: reviewsWhereUniqueInput
  }


  /**
   * reviews deleteMany
   */
  export type reviewsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which reviews to delete
     */
    where?: reviewsWhereInput
  }


  /**
   * reviews.review_votes
   */
  export type reviews$review_votesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the review_votes
     */
    select?: review_votesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: review_votesInclude<ExtArgs> | null
    where?: review_votesWhereInput
    orderBy?: review_votesOrderByWithRelationInput | review_votesOrderByWithRelationInput[]
    cursor?: review_votesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Review_votesScalarFieldEnum | Review_votesScalarFieldEnum[]
  }


  /**
   * reviews.reviews
   */
  export type reviews$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reviewsInclude<ExtArgs> | null
    where?: reviewsWhereInput
  }


  /**
   * reviews.other_reviews
   */
  export type reviews$other_reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reviewsInclude<ExtArgs> | null
    where?: reviewsWhereInput
    orderBy?: reviewsOrderByWithRelationInput | reviewsOrderByWithRelationInput[]
    cursor?: reviewsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewsScalarFieldEnum | ReviewsScalarFieldEnum[]
  }


  /**
   * reviews without action
   */
  export type reviewsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reviewsInclude<ExtArgs> | null
  }



  /**
   * Model server_audit_logs
   */

  export type AggregateServer_audit_logs = {
    _count: Server_audit_logsCountAggregateOutputType | null
    _avg: Server_audit_logsAvgAggregateOutputType | null
    _sum: Server_audit_logsSumAggregateOutputType | null
    _min: Server_audit_logsMinAggregateOutputType | null
    _max: Server_audit_logsMaxAggregateOutputType | null
  }

  export type Server_audit_logsAvgAggregateOutputType = {
    guild_id: number | null
    user_id: number | null
  }

  export type Server_audit_logsSumAggregateOutputType = {
    guild_id: bigint | null
    user_id: bigint | null
  }

  export type Server_audit_logsMinAggregateOutputType = {
    guild_id: bigint | null
    user_id: bigint | null
    username: string | null
    user_guild_perms: string | null
    field: string | null
    value: string | null
    action_time: Date | null
    action_id: string | null
    lynxtag: string | null
  }

  export type Server_audit_logsMaxAggregateOutputType = {
    guild_id: bigint | null
    user_id: bigint | null
    username: string | null
    user_guild_perms: string | null
    field: string | null
    value: string | null
    action_time: Date | null
    action_id: string | null
    lynxtag: string | null
  }

  export type Server_audit_logsCountAggregateOutputType = {
    guild_id: number
    user_id: number
    username: number
    user_guild_perms: number
    field: number
    value: number
    action_time: number
    action_id: number
    lynxtag: number
    _all: number
  }


  export type Server_audit_logsAvgAggregateInputType = {
    guild_id?: true
    user_id?: true
  }

  export type Server_audit_logsSumAggregateInputType = {
    guild_id?: true
    user_id?: true
  }

  export type Server_audit_logsMinAggregateInputType = {
    guild_id?: true
    user_id?: true
    username?: true
    user_guild_perms?: true
    field?: true
    value?: true
    action_time?: true
    action_id?: true
    lynxtag?: true
  }

  export type Server_audit_logsMaxAggregateInputType = {
    guild_id?: true
    user_id?: true
    username?: true
    user_guild_perms?: true
    field?: true
    value?: true
    action_time?: true
    action_id?: true
    lynxtag?: true
  }

  export type Server_audit_logsCountAggregateInputType = {
    guild_id?: true
    user_id?: true
    username?: true
    user_guild_perms?: true
    field?: true
    value?: true
    action_time?: true
    action_id?: true
    lynxtag?: true
    _all?: true
  }

  export type Server_audit_logsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which server_audit_logs to aggregate.
     */
    where?: server_audit_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of server_audit_logs to fetch.
     */
    orderBy?: server_audit_logsOrderByWithRelationInput | server_audit_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: server_audit_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` server_audit_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` server_audit_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned server_audit_logs
    **/
    _count?: true | Server_audit_logsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Server_audit_logsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Server_audit_logsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Server_audit_logsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Server_audit_logsMaxAggregateInputType
  }

  export type GetServer_audit_logsAggregateType<T extends Server_audit_logsAggregateArgs> = {
        [P in keyof T & keyof AggregateServer_audit_logs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServer_audit_logs[P]>
      : GetScalarType<T[P], AggregateServer_audit_logs[P]>
  }




  export type server_audit_logsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: server_audit_logsWhereInput
    orderBy?: server_audit_logsOrderByWithAggregationInput | server_audit_logsOrderByWithAggregationInput[]
    by: Server_audit_logsScalarFieldEnum[] | Server_audit_logsScalarFieldEnum
    having?: server_audit_logsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Server_audit_logsCountAggregateInputType | true
    _avg?: Server_audit_logsAvgAggregateInputType
    _sum?: Server_audit_logsSumAggregateInputType
    _min?: Server_audit_logsMinAggregateInputType
    _max?: Server_audit_logsMaxAggregateInputType
  }

  export type Server_audit_logsGroupByOutputType = {
    guild_id: bigint
    user_id: bigint
    username: string
    user_guild_perms: string
    field: string
    value: string
    action_time: Date
    action_id: string
    lynxtag: string
    _count: Server_audit_logsCountAggregateOutputType | null
    _avg: Server_audit_logsAvgAggregateOutputType | null
    _sum: Server_audit_logsSumAggregateOutputType | null
    _min: Server_audit_logsMinAggregateOutputType | null
    _max: Server_audit_logsMaxAggregateOutputType | null
  }

  type GetServer_audit_logsGroupByPayload<T extends server_audit_logsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Server_audit_logsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Server_audit_logsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Server_audit_logsGroupByOutputType[P]>
            : GetScalarType<T[P], Server_audit_logsGroupByOutputType[P]>
        }
      >
    >


  export type server_audit_logsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    guild_id?: boolean
    user_id?: boolean
    username?: boolean
    user_guild_perms?: boolean
    field?: boolean
    value?: boolean
    action_time?: boolean
    action_id?: boolean
    lynxtag?: boolean
    servers?: boolean | serversDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["server_audit_logs"]>

  export type server_audit_logsSelectScalar = {
    guild_id?: boolean
    user_id?: boolean
    username?: boolean
    user_guild_perms?: boolean
    field?: boolean
    value?: boolean
    action_time?: boolean
    action_id?: boolean
    lynxtag?: boolean
  }

  export type server_audit_logsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    servers?: boolean | serversDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }


  export type $server_audit_logsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "server_audit_logs"
    objects: {
      servers: Prisma.$serversPayload<ExtArgs>
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      guild_id: bigint
      user_id: bigint
      username: string
      user_guild_perms: string
      field: string
      value: string
      action_time: Date
      action_id: string
      lynxtag: string
    }, ExtArgs["result"]["server_audit_logs"]>
    composites: {}
  }


  type server_audit_logsGetPayload<S extends boolean | null | undefined | server_audit_logsDefaultArgs> = $Result.GetResult<Prisma.$server_audit_logsPayload, S>

  type server_audit_logsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<server_audit_logsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Server_audit_logsCountAggregateInputType | true
    }

  export interface server_audit_logsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['server_audit_logs'], meta: { name: 'server_audit_logs' } }
    /**
     * Find zero or one Server_audit_logs that matches the filter.
     * @param {server_audit_logsFindUniqueArgs} args - Arguments to find a Server_audit_logs
     * @example
     * // Get one Server_audit_logs
     * const server_audit_logs = await prisma.server_audit_logs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends server_audit_logsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, server_audit_logsFindUniqueArgs<ExtArgs>>
    ): Prisma__server_audit_logsClient<$Result.GetResult<Prisma.$server_audit_logsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Server_audit_logs that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {server_audit_logsFindUniqueOrThrowArgs} args - Arguments to find a Server_audit_logs
     * @example
     * // Get one Server_audit_logs
     * const server_audit_logs = await prisma.server_audit_logs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends server_audit_logsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, server_audit_logsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__server_audit_logsClient<$Result.GetResult<Prisma.$server_audit_logsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Server_audit_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {server_audit_logsFindFirstArgs} args - Arguments to find a Server_audit_logs
     * @example
     * // Get one Server_audit_logs
     * const server_audit_logs = await prisma.server_audit_logs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends server_audit_logsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, server_audit_logsFindFirstArgs<ExtArgs>>
    ): Prisma__server_audit_logsClient<$Result.GetResult<Prisma.$server_audit_logsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Server_audit_logs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {server_audit_logsFindFirstOrThrowArgs} args - Arguments to find a Server_audit_logs
     * @example
     * // Get one Server_audit_logs
     * const server_audit_logs = await prisma.server_audit_logs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends server_audit_logsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, server_audit_logsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__server_audit_logsClient<$Result.GetResult<Prisma.$server_audit_logsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Server_audit_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {server_audit_logsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Server_audit_logs
     * const server_audit_logs = await prisma.server_audit_logs.findMany()
     * 
     * // Get first 10 Server_audit_logs
     * const server_audit_logs = await prisma.server_audit_logs.findMany({ take: 10 })
     * 
     * // Only select the `guild_id`
     * const server_audit_logsWithGuild_idOnly = await prisma.server_audit_logs.findMany({ select: { guild_id: true } })
     * 
    **/
    findMany<T extends server_audit_logsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, server_audit_logsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$server_audit_logsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Server_audit_logs.
     * @param {server_audit_logsCreateArgs} args - Arguments to create a Server_audit_logs.
     * @example
     * // Create one Server_audit_logs
     * const Server_audit_logs = await prisma.server_audit_logs.create({
     *   data: {
     *     // ... data to create a Server_audit_logs
     *   }
     * })
     * 
    **/
    create<T extends server_audit_logsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, server_audit_logsCreateArgs<ExtArgs>>
    ): Prisma__server_audit_logsClient<$Result.GetResult<Prisma.$server_audit_logsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Server_audit_logs.
     *     @param {server_audit_logsCreateManyArgs} args - Arguments to create many Server_audit_logs.
     *     @example
     *     // Create many Server_audit_logs
     *     const server_audit_logs = await prisma.server_audit_logs.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends server_audit_logsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, server_audit_logsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Server_audit_logs.
     * @param {server_audit_logsDeleteArgs} args - Arguments to delete one Server_audit_logs.
     * @example
     * // Delete one Server_audit_logs
     * const Server_audit_logs = await prisma.server_audit_logs.delete({
     *   where: {
     *     // ... filter to delete one Server_audit_logs
     *   }
     * })
     * 
    **/
    delete<T extends server_audit_logsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, server_audit_logsDeleteArgs<ExtArgs>>
    ): Prisma__server_audit_logsClient<$Result.GetResult<Prisma.$server_audit_logsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Server_audit_logs.
     * @param {server_audit_logsUpdateArgs} args - Arguments to update one Server_audit_logs.
     * @example
     * // Update one Server_audit_logs
     * const server_audit_logs = await prisma.server_audit_logs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends server_audit_logsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, server_audit_logsUpdateArgs<ExtArgs>>
    ): Prisma__server_audit_logsClient<$Result.GetResult<Prisma.$server_audit_logsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Server_audit_logs.
     * @param {server_audit_logsDeleteManyArgs} args - Arguments to filter Server_audit_logs to delete.
     * @example
     * // Delete a few Server_audit_logs
     * const { count } = await prisma.server_audit_logs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends server_audit_logsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, server_audit_logsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Server_audit_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {server_audit_logsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Server_audit_logs
     * const server_audit_logs = await prisma.server_audit_logs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends server_audit_logsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, server_audit_logsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Server_audit_logs.
     * @param {server_audit_logsUpsertArgs} args - Arguments to update or create a Server_audit_logs.
     * @example
     * // Update or create a Server_audit_logs
     * const server_audit_logs = await prisma.server_audit_logs.upsert({
     *   create: {
     *     // ... data to create a Server_audit_logs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Server_audit_logs we want to update
     *   }
     * })
    **/
    upsert<T extends server_audit_logsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, server_audit_logsUpsertArgs<ExtArgs>>
    ): Prisma__server_audit_logsClient<$Result.GetResult<Prisma.$server_audit_logsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Server_audit_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {server_audit_logsCountArgs} args - Arguments to filter Server_audit_logs to count.
     * @example
     * // Count the number of Server_audit_logs
     * const count = await prisma.server_audit_logs.count({
     *   where: {
     *     // ... the filter for the Server_audit_logs we want to count
     *   }
     * })
    **/
    count<T extends server_audit_logsCountArgs>(
      args?: Subset<T, server_audit_logsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Server_audit_logsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Server_audit_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Server_audit_logsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Server_audit_logsAggregateArgs>(args: Subset<T, Server_audit_logsAggregateArgs>): Prisma.PrismaPromise<GetServer_audit_logsAggregateType<T>>

    /**
     * Group by Server_audit_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {server_audit_logsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends server_audit_logsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: server_audit_logsGroupByArgs['orderBy'] }
        : { orderBy?: server_audit_logsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, server_audit_logsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServer_audit_logsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the server_audit_logs model
   */
  readonly fields: server_audit_logsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for server_audit_logs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__server_audit_logsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    servers<T extends serversDefaultArgs<ExtArgs> = {}>(args?: Subset<T, serversDefaultArgs<ExtArgs>>): Prisma__serversClient<$Result.GetResult<Prisma.$serversPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the server_audit_logs model
   */ 
  interface server_audit_logsFieldRefs {
    readonly guild_id: FieldRef<"server_audit_logs", 'BigInt'>
    readonly user_id: FieldRef<"server_audit_logs", 'BigInt'>
    readonly username: FieldRef<"server_audit_logs", 'String'>
    readonly user_guild_perms: FieldRef<"server_audit_logs", 'String'>
    readonly field: FieldRef<"server_audit_logs", 'String'>
    readonly value: FieldRef<"server_audit_logs", 'String'>
    readonly action_time: FieldRef<"server_audit_logs", 'DateTime'>
    readonly action_id: FieldRef<"server_audit_logs", 'String'>
    readonly lynxtag: FieldRef<"server_audit_logs", 'String'>
  }
    

  // Custom InputTypes

  /**
   * server_audit_logs findUnique
   */
  export type server_audit_logsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the server_audit_logs
     */
    select?: server_audit_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: server_audit_logsInclude<ExtArgs> | null
    /**
     * Filter, which server_audit_logs to fetch.
     */
    where: server_audit_logsWhereUniqueInput
  }


  /**
   * server_audit_logs findUniqueOrThrow
   */
  export type server_audit_logsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the server_audit_logs
     */
    select?: server_audit_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: server_audit_logsInclude<ExtArgs> | null
    /**
     * Filter, which server_audit_logs to fetch.
     */
    where: server_audit_logsWhereUniqueInput
  }


  /**
   * server_audit_logs findFirst
   */
  export type server_audit_logsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the server_audit_logs
     */
    select?: server_audit_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: server_audit_logsInclude<ExtArgs> | null
    /**
     * Filter, which server_audit_logs to fetch.
     */
    where?: server_audit_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of server_audit_logs to fetch.
     */
    orderBy?: server_audit_logsOrderByWithRelationInput | server_audit_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for server_audit_logs.
     */
    cursor?: server_audit_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` server_audit_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` server_audit_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of server_audit_logs.
     */
    distinct?: Server_audit_logsScalarFieldEnum | Server_audit_logsScalarFieldEnum[]
  }


  /**
   * server_audit_logs findFirstOrThrow
   */
  export type server_audit_logsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the server_audit_logs
     */
    select?: server_audit_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: server_audit_logsInclude<ExtArgs> | null
    /**
     * Filter, which server_audit_logs to fetch.
     */
    where?: server_audit_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of server_audit_logs to fetch.
     */
    orderBy?: server_audit_logsOrderByWithRelationInput | server_audit_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for server_audit_logs.
     */
    cursor?: server_audit_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` server_audit_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` server_audit_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of server_audit_logs.
     */
    distinct?: Server_audit_logsScalarFieldEnum | Server_audit_logsScalarFieldEnum[]
  }


  /**
   * server_audit_logs findMany
   */
  export type server_audit_logsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the server_audit_logs
     */
    select?: server_audit_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: server_audit_logsInclude<ExtArgs> | null
    /**
     * Filter, which server_audit_logs to fetch.
     */
    where?: server_audit_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of server_audit_logs to fetch.
     */
    orderBy?: server_audit_logsOrderByWithRelationInput | server_audit_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing server_audit_logs.
     */
    cursor?: server_audit_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` server_audit_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` server_audit_logs.
     */
    skip?: number
    distinct?: Server_audit_logsScalarFieldEnum | Server_audit_logsScalarFieldEnum[]
  }


  /**
   * server_audit_logs create
   */
  export type server_audit_logsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the server_audit_logs
     */
    select?: server_audit_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: server_audit_logsInclude<ExtArgs> | null
    /**
     * The data needed to create a server_audit_logs.
     */
    data: XOR<server_audit_logsCreateInput, server_audit_logsUncheckedCreateInput>
  }


  /**
   * server_audit_logs createMany
   */
  export type server_audit_logsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many server_audit_logs.
     */
    data: server_audit_logsCreateManyInput | server_audit_logsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * server_audit_logs update
   */
  export type server_audit_logsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the server_audit_logs
     */
    select?: server_audit_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: server_audit_logsInclude<ExtArgs> | null
    /**
     * The data needed to update a server_audit_logs.
     */
    data: XOR<server_audit_logsUpdateInput, server_audit_logsUncheckedUpdateInput>
    /**
     * Choose, which server_audit_logs to update.
     */
    where: server_audit_logsWhereUniqueInput
  }


  /**
   * server_audit_logs updateMany
   */
  export type server_audit_logsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update server_audit_logs.
     */
    data: XOR<server_audit_logsUpdateManyMutationInput, server_audit_logsUncheckedUpdateManyInput>
    /**
     * Filter which server_audit_logs to update
     */
    where?: server_audit_logsWhereInput
  }


  /**
   * server_audit_logs upsert
   */
  export type server_audit_logsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the server_audit_logs
     */
    select?: server_audit_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: server_audit_logsInclude<ExtArgs> | null
    /**
     * The filter to search for the server_audit_logs to update in case it exists.
     */
    where: server_audit_logsWhereUniqueInput
    /**
     * In case the server_audit_logs found by the `where` argument doesn't exist, create a new server_audit_logs with this data.
     */
    create: XOR<server_audit_logsCreateInput, server_audit_logsUncheckedCreateInput>
    /**
     * In case the server_audit_logs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<server_audit_logsUpdateInput, server_audit_logsUncheckedUpdateInput>
  }


  /**
   * server_audit_logs delete
   */
  export type server_audit_logsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the server_audit_logs
     */
    select?: server_audit_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: server_audit_logsInclude<ExtArgs> | null
    /**
     * Filter which server_audit_logs to delete.
     */
    where: server_audit_logsWhereUniqueInput
  }


  /**
   * server_audit_logs deleteMany
   */
  export type server_audit_logsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which server_audit_logs to delete
     */
    where?: server_audit_logsWhereInput
  }


  /**
   * server_audit_logs without action
   */
  export type server_audit_logsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the server_audit_logs
     */
    select?: server_audit_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: server_audit_logsInclude<ExtArgs> | null
  }



  /**
   * Model server_tags
   */

  export type AggregateServer_tags = {
    _count: Server_tagsCountAggregateOutputType | null
    _avg: Server_tagsAvgAggregateOutputType | null
    _sum: Server_tagsSumAggregateOutputType | null
    _min: Server_tagsMinAggregateOutputType | null
    _max: Server_tagsMaxAggregateOutputType | null
  }

  export type Server_tagsAvgAggregateOutputType = {
    owner_guild: number | null
  }

  export type Server_tagsSumAggregateOutputType = {
    owner_guild: bigint | null
  }

  export type Server_tagsMinAggregateOutputType = {
    id: string | null
    name: string | null
    owner_guild: bigint | null
    iconify_data: string | null
    lynxtag: string | null
  }

  export type Server_tagsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    owner_guild: bigint | null
    iconify_data: string | null
    lynxtag: string | null
  }

  export type Server_tagsCountAggregateOutputType = {
    id: number
    name: number
    owner_guild: number
    iconify_data: number
    lynxtag: number
    _all: number
  }


  export type Server_tagsAvgAggregateInputType = {
    owner_guild?: true
  }

  export type Server_tagsSumAggregateInputType = {
    owner_guild?: true
  }

  export type Server_tagsMinAggregateInputType = {
    id?: true
    name?: true
    owner_guild?: true
    iconify_data?: true
    lynxtag?: true
  }

  export type Server_tagsMaxAggregateInputType = {
    id?: true
    name?: true
    owner_guild?: true
    iconify_data?: true
    lynxtag?: true
  }

  export type Server_tagsCountAggregateInputType = {
    id?: true
    name?: true
    owner_guild?: true
    iconify_data?: true
    lynxtag?: true
    _all?: true
  }

  export type Server_tagsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which server_tags to aggregate.
     */
    where?: server_tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of server_tags to fetch.
     */
    orderBy?: server_tagsOrderByWithRelationInput | server_tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: server_tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` server_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` server_tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned server_tags
    **/
    _count?: true | Server_tagsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Server_tagsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Server_tagsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Server_tagsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Server_tagsMaxAggregateInputType
  }

  export type GetServer_tagsAggregateType<T extends Server_tagsAggregateArgs> = {
        [P in keyof T & keyof AggregateServer_tags]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServer_tags[P]>
      : GetScalarType<T[P], AggregateServer_tags[P]>
  }




  export type server_tagsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: server_tagsWhereInput
    orderBy?: server_tagsOrderByWithAggregationInput | server_tagsOrderByWithAggregationInput[]
    by: Server_tagsScalarFieldEnum[] | Server_tagsScalarFieldEnum
    having?: server_tagsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Server_tagsCountAggregateInputType | true
    _avg?: Server_tagsAvgAggregateInputType
    _sum?: Server_tagsSumAggregateInputType
    _min?: Server_tagsMinAggregateInputType
    _max?: Server_tagsMaxAggregateInputType
  }

  export type Server_tagsGroupByOutputType = {
    id: string
    name: string
    owner_guild: bigint
    iconify_data: string
    lynxtag: string
    _count: Server_tagsCountAggregateOutputType | null
    _avg: Server_tagsAvgAggregateOutputType | null
    _sum: Server_tagsSumAggregateOutputType | null
    _min: Server_tagsMinAggregateOutputType | null
    _max: Server_tagsMaxAggregateOutputType | null
  }

  type GetServer_tagsGroupByPayload<T extends server_tagsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Server_tagsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Server_tagsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Server_tagsGroupByOutputType[P]>
            : GetScalarType<T[P], Server_tagsGroupByOutputType[P]>
        }
      >
    >


  export type server_tagsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    owner_guild?: boolean
    iconify_data?: boolean
    lynxtag?: boolean
  }, ExtArgs["result"]["server_tags"]>

  export type server_tagsSelectScalar = {
    id?: boolean
    name?: boolean
    owner_guild?: boolean
    iconify_data?: boolean
    lynxtag?: boolean
  }


  export type $server_tagsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "server_tags"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      owner_guild: bigint
      iconify_data: string
      lynxtag: string
    }, ExtArgs["result"]["server_tags"]>
    composites: {}
  }


  type server_tagsGetPayload<S extends boolean | null | undefined | server_tagsDefaultArgs> = $Result.GetResult<Prisma.$server_tagsPayload, S>

  type server_tagsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<server_tagsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Server_tagsCountAggregateInputType | true
    }

  export interface server_tagsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['server_tags'], meta: { name: 'server_tags' } }
    /**
     * Find zero or one Server_tags that matches the filter.
     * @param {server_tagsFindUniqueArgs} args - Arguments to find a Server_tags
     * @example
     * // Get one Server_tags
     * const server_tags = await prisma.server_tags.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends server_tagsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, server_tagsFindUniqueArgs<ExtArgs>>
    ): Prisma__server_tagsClient<$Result.GetResult<Prisma.$server_tagsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Server_tags that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {server_tagsFindUniqueOrThrowArgs} args - Arguments to find a Server_tags
     * @example
     * // Get one Server_tags
     * const server_tags = await prisma.server_tags.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends server_tagsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, server_tagsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__server_tagsClient<$Result.GetResult<Prisma.$server_tagsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Server_tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {server_tagsFindFirstArgs} args - Arguments to find a Server_tags
     * @example
     * // Get one Server_tags
     * const server_tags = await prisma.server_tags.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends server_tagsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, server_tagsFindFirstArgs<ExtArgs>>
    ): Prisma__server_tagsClient<$Result.GetResult<Prisma.$server_tagsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Server_tags that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {server_tagsFindFirstOrThrowArgs} args - Arguments to find a Server_tags
     * @example
     * // Get one Server_tags
     * const server_tags = await prisma.server_tags.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends server_tagsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, server_tagsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__server_tagsClient<$Result.GetResult<Prisma.$server_tagsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Server_tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {server_tagsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Server_tags
     * const server_tags = await prisma.server_tags.findMany()
     * 
     * // Get first 10 Server_tags
     * const server_tags = await prisma.server_tags.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const server_tagsWithIdOnly = await prisma.server_tags.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends server_tagsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, server_tagsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$server_tagsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Server_tags.
     * @param {server_tagsCreateArgs} args - Arguments to create a Server_tags.
     * @example
     * // Create one Server_tags
     * const Server_tags = await prisma.server_tags.create({
     *   data: {
     *     // ... data to create a Server_tags
     *   }
     * })
     * 
    **/
    create<T extends server_tagsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, server_tagsCreateArgs<ExtArgs>>
    ): Prisma__server_tagsClient<$Result.GetResult<Prisma.$server_tagsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Server_tags.
     *     @param {server_tagsCreateManyArgs} args - Arguments to create many Server_tags.
     *     @example
     *     // Create many Server_tags
     *     const server_tags = await prisma.server_tags.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends server_tagsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, server_tagsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Server_tags.
     * @param {server_tagsDeleteArgs} args - Arguments to delete one Server_tags.
     * @example
     * // Delete one Server_tags
     * const Server_tags = await prisma.server_tags.delete({
     *   where: {
     *     // ... filter to delete one Server_tags
     *   }
     * })
     * 
    **/
    delete<T extends server_tagsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, server_tagsDeleteArgs<ExtArgs>>
    ): Prisma__server_tagsClient<$Result.GetResult<Prisma.$server_tagsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Server_tags.
     * @param {server_tagsUpdateArgs} args - Arguments to update one Server_tags.
     * @example
     * // Update one Server_tags
     * const server_tags = await prisma.server_tags.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends server_tagsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, server_tagsUpdateArgs<ExtArgs>>
    ): Prisma__server_tagsClient<$Result.GetResult<Prisma.$server_tagsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Server_tags.
     * @param {server_tagsDeleteManyArgs} args - Arguments to filter Server_tags to delete.
     * @example
     * // Delete a few Server_tags
     * const { count } = await prisma.server_tags.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends server_tagsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, server_tagsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Server_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {server_tagsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Server_tags
     * const server_tags = await prisma.server_tags.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends server_tagsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, server_tagsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Server_tags.
     * @param {server_tagsUpsertArgs} args - Arguments to update or create a Server_tags.
     * @example
     * // Update or create a Server_tags
     * const server_tags = await prisma.server_tags.upsert({
     *   create: {
     *     // ... data to create a Server_tags
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Server_tags we want to update
     *   }
     * })
    **/
    upsert<T extends server_tagsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, server_tagsUpsertArgs<ExtArgs>>
    ): Prisma__server_tagsClient<$Result.GetResult<Prisma.$server_tagsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Server_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {server_tagsCountArgs} args - Arguments to filter Server_tags to count.
     * @example
     * // Count the number of Server_tags
     * const count = await prisma.server_tags.count({
     *   where: {
     *     // ... the filter for the Server_tags we want to count
     *   }
     * })
    **/
    count<T extends server_tagsCountArgs>(
      args?: Subset<T, server_tagsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Server_tagsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Server_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Server_tagsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Server_tagsAggregateArgs>(args: Subset<T, Server_tagsAggregateArgs>): Prisma.PrismaPromise<GetServer_tagsAggregateType<T>>

    /**
     * Group by Server_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {server_tagsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends server_tagsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: server_tagsGroupByArgs['orderBy'] }
        : { orderBy?: server_tagsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, server_tagsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServer_tagsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the server_tags model
   */
  readonly fields: server_tagsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for server_tags.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__server_tagsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the server_tags model
   */ 
  interface server_tagsFieldRefs {
    readonly id: FieldRef<"server_tags", 'String'>
    readonly name: FieldRef<"server_tags", 'String'>
    readonly owner_guild: FieldRef<"server_tags", 'BigInt'>
    readonly iconify_data: FieldRef<"server_tags", 'String'>
    readonly lynxtag: FieldRef<"server_tags", 'String'>
  }
    

  // Custom InputTypes

  /**
   * server_tags findUnique
   */
  export type server_tagsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the server_tags
     */
    select?: server_tagsSelect<ExtArgs> | null
    /**
     * Filter, which server_tags to fetch.
     */
    where: server_tagsWhereUniqueInput
  }


  /**
   * server_tags findUniqueOrThrow
   */
  export type server_tagsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the server_tags
     */
    select?: server_tagsSelect<ExtArgs> | null
    /**
     * Filter, which server_tags to fetch.
     */
    where: server_tagsWhereUniqueInput
  }


  /**
   * server_tags findFirst
   */
  export type server_tagsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the server_tags
     */
    select?: server_tagsSelect<ExtArgs> | null
    /**
     * Filter, which server_tags to fetch.
     */
    where?: server_tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of server_tags to fetch.
     */
    orderBy?: server_tagsOrderByWithRelationInput | server_tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for server_tags.
     */
    cursor?: server_tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` server_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` server_tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of server_tags.
     */
    distinct?: Server_tagsScalarFieldEnum | Server_tagsScalarFieldEnum[]
  }


  /**
   * server_tags findFirstOrThrow
   */
  export type server_tagsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the server_tags
     */
    select?: server_tagsSelect<ExtArgs> | null
    /**
     * Filter, which server_tags to fetch.
     */
    where?: server_tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of server_tags to fetch.
     */
    orderBy?: server_tagsOrderByWithRelationInput | server_tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for server_tags.
     */
    cursor?: server_tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` server_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` server_tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of server_tags.
     */
    distinct?: Server_tagsScalarFieldEnum | Server_tagsScalarFieldEnum[]
  }


  /**
   * server_tags findMany
   */
  export type server_tagsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the server_tags
     */
    select?: server_tagsSelect<ExtArgs> | null
    /**
     * Filter, which server_tags to fetch.
     */
    where?: server_tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of server_tags to fetch.
     */
    orderBy?: server_tagsOrderByWithRelationInput | server_tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing server_tags.
     */
    cursor?: server_tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` server_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` server_tags.
     */
    skip?: number
    distinct?: Server_tagsScalarFieldEnum | Server_tagsScalarFieldEnum[]
  }


  /**
   * server_tags create
   */
  export type server_tagsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the server_tags
     */
    select?: server_tagsSelect<ExtArgs> | null
    /**
     * The data needed to create a server_tags.
     */
    data: XOR<server_tagsCreateInput, server_tagsUncheckedCreateInput>
  }


  /**
   * server_tags createMany
   */
  export type server_tagsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many server_tags.
     */
    data: server_tagsCreateManyInput | server_tagsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * server_tags update
   */
  export type server_tagsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the server_tags
     */
    select?: server_tagsSelect<ExtArgs> | null
    /**
     * The data needed to update a server_tags.
     */
    data: XOR<server_tagsUpdateInput, server_tagsUncheckedUpdateInput>
    /**
     * Choose, which server_tags to update.
     */
    where: server_tagsWhereUniqueInput
  }


  /**
   * server_tags updateMany
   */
  export type server_tagsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update server_tags.
     */
    data: XOR<server_tagsUpdateManyMutationInput, server_tagsUncheckedUpdateManyInput>
    /**
     * Filter which server_tags to update
     */
    where?: server_tagsWhereInput
  }


  /**
   * server_tags upsert
   */
  export type server_tagsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the server_tags
     */
    select?: server_tagsSelect<ExtArgs> | null
    /**
     * The filter to search for the server_tags to update in case it exists.
     */
    where: server_tagsWhereUniqueInput
    /**
     * In case the server_tags found by the `where` argument doesn't exist, create a new server_tags with this data.
     */
    create: XOR<server_tagsCreateInput, server_tagsUncheckedCreateInput>
    /**
     * In case the server_tags was found with the provided `where` argument, update it with this data.
     */
    update: XOR<server_tagsUpdateInput, server_tagsUncheckedUpdateInput>
  }


  /**
   * server_tags delete
   */
  export type server_tagsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the server_tags
     */
    select?: server_tagsSelect<ExtArgs> | null
    /**
     * Filter which server_tags to delete.
     */
    where: server_tagsWhereUniqueInput
  }


  /**
   * server_tags deleteMany
   */
  export type server_tagsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which server_tags to delete
     */
    where?: server_tagsWhereInput
  }


  /**
   * server_tags without action
   */
  export type server_tagsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the server_tags
     */
    select?: server_tagsSelect<ExtArgs> | null
  }



  /**
   * Model server_voters
   */

  export type AggregateServer_voters = {
    _count: Server_votersCountAggregateOutputType | null
    _avg: Server_votersAvgAggregateOutputType | null
    _sum: Server_votersSumAggregateOutputType | null
    _min: Server_votersMinAggregateOutputType | null
    _max: Server_votersMaxAggregateOutputType | null
  }

  export type Server_votersAvgAggregateOutputType = {
    guild_id: number | null
    user_id: number | null
  }

  export type Server_votersSumAggregateOutputType = {
    guild_id: bigint | null
    user_id: bigint | null
  }

  export type Server_votersMinAggregateOutputType = {
    guild_id: bigint | null
    user_id: bigint | null
    lynxtag: string | null
  }

  export type Server_votersMaxAggregateOutputType = {
    guild_id: bigint | null
    user_id: bigint | null
    lynxtag: string | null
  }

  export type Server_votersCountAggregateOutputType = {
    guild_id: number
    user_id: number
    timestamps: number
    lynxtag: number
    _all: number
  }


  export type Server_votersAvgAggregateInputType = {
    guild_id?: true
    user_id?: true
  }

  export type Server_votersSumAggregateInputType = {
    guild_id?: true
    user_id?: true
  }

  export type Server_votersMinAggregateInputType = {
    guild_id?: true
    user_id?: true
    lynxtag?: true
  }

  export type Server_votersMaxAggregateInputType = {
    guild_id?: true
    user_id?: true
    lynxtag?: true
  }

  export type Server_votersCountAggregateInputType = {
    guild_id?: true
    user_id?: true
    timestamps?: true
    lynxtag?: true
    _all?: true
  }

  export type Server_votersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which server_voters to aggregate.
     */
    where?: server_votersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of server_voters to fetch.
     */
    orderBy?: server_votersOrderByWithRelationInput | server_votersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: server_votersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` server_voters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` server_voters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned server_voters
    **/
    _count?: true | Server_votersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Server_votersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Server_votersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Server_votersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Server_votersMaxAggregateInputType
  }

  export type GetServer_votersAggregateType<T extends Server_votersAggregateArgs> = {
        [P in keyof T & keyof AggregateServer_voters]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServer_voters[P]>
      : GetScalarType<T[P], AggregateServer_voters[P]>
  }




  export type server_votersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: server_votersWhereInput
    orderBy?: server_votersOrderByWithAggregationInput | server_votersOrderByWithAggregationInput[]
    by: Server_votersScalarFieldEnum[] | Server_votersScalarFieldEnum
    having?: server_votersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Server_votersCountAggregateInputType | true
    _avg?: Server_votersAvgAggregateInputType
    _sum?: Server_votersSumAggregateInputType
    _min?: Server_votersMinAggregateInputType
    _max?: Server_votersMaxAggregateInputType
  }

  export type Server_votersGroupByOutputType = {
    guild_id: bigint
    user_id: bigint
    timestamps: Date[]
    lynxtag: string
    _count: Server_votersCountAggregateOutputType | null
    _avg: Server_votersAvgAggregateOutputType | null
    _sum: Server_votersSumAggregateOutputType | null
    _min: Server_votersMinAggregateOutputType | null
    _max: Server_votersMaxAggregateOutputType | null
  }

  type GetServer_votersGroupByPayload<T extends server_votersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Server_votersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Server_votersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Server_votersGroupByOutputType[P]>
            : GetScalarType<T[P], Server_votersGroupByOutputType[P]>
        }
      >
    >


  export type server_votersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    guild_id?: boolean
    user_id?: boolean
    timestamps?: boolean
    lynxtag?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["server_voters"]>

  export type server_votersSelectScalar = {
    guild_id?: boolean
    user_id?: boolean
    timestamps?: boolean
    lynxtag?: boolean
  }

  export type server_votersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }


  export type $server_votersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "server_voters"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      guild_id: bigint
      user_id: bigint
      timestamps: Date[]
      lynxtag: string
    }, ExtArgs["result"]["server_voters"]>
    composites: {}
  }


  type server_votersGetPayload<S extends boolean | null | undefined | server_votersDefaultArgs> = $Result.GetResult<Prisma.$server_votersPayload, S>

  type server_votersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<server_votersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Server_votersCountAggregateInputType | true
    }

  export interface server_votersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['server_voters'], meta: { name: 'server_voters' } }
    /**
     * Find zero or one Server_voters that matches the filter.
     * @param {server_votersFindUniqueArgs} args - Arguments to find a Server_voters
     * @example
     * // Get one Server_voters
     * const server_voters = await prisma.server_voters.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends server_votersFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, server_votersFindUniqueArgs<ExtArgs>>
    ): Prisma__server_votersClient<$Result.GetResult<Prisma.$server_votersPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Server_voters that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {server_votersFindUniqueOrThrowArgs} args - Arguments to find a Server_voters
     * @example
     * // Get one Server_voters
     * const server_voters = await prisma.server_voters.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends server_votersFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, server_votersFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__server_votersClient<$Result.GetResult<Prisma.$server_votersPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Server_voters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {server_votersFindFirstArgs} args - Arguments to find a Server_voters
     * @example
     * // Get one Server_voters
     * const server_voters = await prisma.server_voters.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends server_votersFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, server_votersFindFirstArgs<ExtArgs>>
    ): Prisma__server_votersClient<$Result.GetResult<Prisma.$server_votersPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Server_voters that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {server_votersFindFirstOrThrowArgs} args - Arguments to find a Server_voters
     * @example
     * // Get one Server_voters
     * const server_voters = await prisma.server_voters.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends server_votersFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, server_votersFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__server_votersClient<$Result.GetResult<Prisma.$server_votersPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Server_voters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {server_votersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Server_voters
     * const server_voters = await prisma.server_voters.findMany()
     * 
     * // Get first 10 Server_voters
     * const server_voters = await prisma.server_voters.findMany({ take: 10 })
     * 
     * // Only select the `guild_id`
     * const server_votersWithGuild_idOnly = await prisma.server_voters.findMany({ select: { guild_id: true } })
     * 
    **/
    findMany<T extends server_votersFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, server_votersFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$server_votersPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Server_voters.
     * @param {server_votersCreateArgs} args - Arguments to create a Server_voters.
     * @example
     * // Create one Server_voters
     * const Server_voters = await prisma.server_voters.create({
     *   data: {
     *     // ... data to create a Server_voters
     *   }
     * })
     * 
    **/
    create<T extends server_votersCreateArgs<ExtArgs>>(
      args: SelectSubset<T, server_votersCreateArgs<ExtArgs>>
    ): Prisma__server_votersClient<$Result.GetResult<Prisma.$server_votersPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Server_voters.
     *     @param {server_votersCreateManyArgs} args - Arguments to create many Server_voters.
     *     @example
     *     // Create many Server_voters
     *     const server_voters = await prisma.server_voters.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends server_votersCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, server_votersCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Server_voters.
     * @param {server_votersDeleteArgs} args - Arguments to delete one Server_voters.
     * @example
     * // Delete one Server_voters
     * const Server_voters = await prisma.server_voters.delete({
     *   where: {
     *     // ... filter to delete one Server_voters
     *   }
     * })
     * 
    **/
    delete<T extends server_votersDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, server_votersDeleteArgs<ExtArgs>>
    ): Prisma__server_votersClient<$Result.GetResult<Prisma.$server_votersPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Server_voters.
     * @param {server_votersUpdateArgs} args - Arguments to update one Server_voters.
     * @example
     * // Update one Server_voters
     * const server_voters = await prisma.server_voters.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends server_votersUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, server_votersUpdateArgs<ExtArgs>>
    ): Prisma__server_votersClient<$Result.GetResult<Prisma.$server_votersPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Server_voters.
     * @param {server_votersDeleteManyArgs} args - Arguments to filter Server_voters to delete.
     * @example
     * // Delete a few Server_voters
     * const { count } = await prisma.server_voters.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends server_votersDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, server_votersDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Server_voters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {server_votersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Server_voters
     * const server_voters = await prisma.server_voters.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends server_votersUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, server_votersUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Server_voters.
     * @param {server_votersUpsertArgs} args - Arguments to update or create a Server_voters.
     * @example
     * // Update or create a Server_voters
     * const server_voters = await prisma.server_voters.upsert({
     *   create: {
     *     // ... data to create a Server_voters
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Server_voters we want to update
     *   }
     * })
    **/
    upsert<T extends server_votersUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, server_votersUpsertArgs<ExtArgs>>
    ): Prisma__server_votersClient<$Result.GetResult<Prisma.$server_votersPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Server_voters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {server_votersCountArgs} args - Arguments to filter Server_voters to count.
     * @example
     * // Count the number of Server_voters
     * const count = await prisma.server_voters.count({
     *   where: {
     *     // ... the filter for the Server_voters we want to count
     *   }
     * })
    **/
    count<T extends server_votersCountArgs>(
      args?: Subset<T, server_votersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Server_votersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Server_voters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Server_votersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Server_votersAggregateArgs>(args: Subset<T, Server_votersAggregateArgs>): Prisma.PrismaPromise<GetServer_votersAggregateType<T>>

    /**
     * Group by Server_voters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {server_votersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends server_votersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: server_votersGroupByArgs['orderBy'] }
        : { orderBy?: server_votersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, server_votersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServer_votersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the server_voters model
   */
  readonly fields: server_votersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for server_voters.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__server_votersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the server_voters model
   */ 
  interface server_votersFieldRefs {
    readonly guild_id: FieldRef<"server_voters", 'BigInt'>
    readonly user_id: FieldRef<"server_voters", 'BigInt'>
    readonly timestamps: FieldRef<"server_voters", 'DateTime[]'>
    readonly lynxtag: FieldRef<"server_voters", 'String'>
  }
    

  // Custom InputTypes

  /**
   * server_voters findUnique
   */
  export type server_votersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the server_voters
     */
    select?: server_votersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: server_votersInclude<ExtArgs> | null
    /**
     * Filter, which server_voters to fetch.
     */
    where: server_votersWhereUniqueInput
  }


  /**
   * server_voters findUniqueOrThrow
   */
  export type server_votersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the server_voters
     */
    select?: server_votersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: server_votersInclude<ExtArgs> | null
    /**
     * Filter, which server_voters to fetch.
     */
    where: server_votersWhereUniqueInput
  }


  /**
   * server_voters findFirst
   */
  export type server_votersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the server_voters
     */
    select?: server_votersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: server_votersInclude<ExtArgs> | null
    /**
     * Filter, which server_voters to fetch.
     */
    where?: server_votersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of server_voters to fetch.
     */
    orderBy?: server_votersOrderByWithRelationInput | server_votersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for server_voters.
     */
    cursor?: server_votersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` server_voters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` server_voters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of server_voters.
     */
    distinct?: Server_votersScalarFieldEnum | Server_votersScalarFieldEnum[]
  }


  /**
   * server_voters findFirstOrThrow
   */
  export type server_votersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the server_voters
     */
    select?: server_votersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: server_votersInclude<ExtArgs> | null
    /**
     * Filter, which server_voters to fetch.
     */
    where?: server_votersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of server_voters to fetch.
     */
    orderBy?: server_votersOrderByWithRelationInput | server_votersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for server_voters.
     */
    cursor?: server_votersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` server_voters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` server_voters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of server_voters.
     */
    distinct?: Server_votersScalarFieldEnum | Server_votersScalarFieldEnum[]
  }


  /**
   * server_voters findMany
   */
  export type server_votersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the server_voters
     */
    select?: server_votersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: server_votersInclude<ExtArgs> | null
    /**
     * Filter, which server_voters to fetch.
     */
    where?: server_votersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of server_voters to fetch.
     */
    orderBy?: server_votersOrderByWithRelationInput | server_votersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing server_voters.
     */
    cursor?: server_votersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` server_voters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` server_voters.
     */
    skip?: number
    distinct?: Server_votersScalarFieldEnum | Server_votersScalarFieldEnum[]
  }


  /**
   * server_voters create
   */
  export type server_votersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the server_voters
     */
    select?: server_votersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: server_votersInclude<ExtArgs> | null
    /**
     * The data needed to create a server_voters.
     */
    data: XOR<server_votersCreateInput, server_votersUncheckedCreateInput>
  }


  /**
   * server_voters createMany
   */
  export type server_votersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many server_voters.
     */
    data: server_votersCreateManyInput | server_votersCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * server_voters update
   */
  export type server_votersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the server_voters
     */
    select?: server_votersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: server_votersInclude<ExtArgs> | null
    /**
     * The data needed to update a server_voters.
     */
    data: XOR<server_votersUpdateInput, server_votersUncheckedUpdateInput>
    /**
     * Choose, which server_voters to update.
     */
    where: server_votersWhereUniqueInput
  }


  /**
   * server_voters updateMany
   */
  export type server_votersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update server_voters.
     */
    data: XOR<server_votersUpdateManyMutationInput, server_votersUncheckedUpdateManyInput>
    /**
     * Filter which server_voters to update
     */
    where?: server_votersWhereInput
  }


  /**
   * server_voters upsert
   */
  export type server_votersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the server_voters
     */
    select?: server_votersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: server_votersInclude<ExtArgs> | null
    /**
     * The filter to search for the server_voters to update in case it exists.
     */
    where: server_votersWhereUniqueInput
    /**
     * In case the server_voters found by the `where` argument doesn't exist, create a new server_voters with this data.
     */
    create: XOR<server_votersCreateInput, server_votersUncheckedCreateInput>
    /**
     * In case the server_voters was found with the provided `where` argument, update it with this data.
     */
    update: XOR<server_votersUpdateInput, server_votersUncheckedUpdateInput>
  }


  /**
   * server_voters delete
   */
  export type server_votersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the server_voters
     */
    select?: server_votersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: server_votersInclude<ExtArgs> | null
    /**
     * Filter which server_voters to delete.
     */
    where: server_votersWhereUniqueInput
  }


  /**
   * server_voters deleteMany
   */
  export type server_votersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which server_voters to delete
     */
    where?: server_votersWhereInput
  }


  /**
   * server_voters without action
   */
  export type server_votersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the server_voters
     */
    select?: server_votersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: server_votersInclude<ExtArgs> | null
  }



  /**
   * Model servers
   */

  export type AggregateServers = {
    _count: ServersCountAggregateOutputType | null
    _avg: ServersAvgAggregateOutputType | null
    _sum: ServersSumAggregateOutputType | null
    _min: ServersMinAggregateOutputType | null
    _max: ServersMaxAggregateOutputType | null
  }

  export type ServersAvgAggregateOutputType = {
    guild_id: number | null
    votes: number | null
    invite_amount: number | null
    long_description_type: number | null
    state: number | null
    invite_channel: number | null
    guild_count: number | null
    webhook_type: number | null
    total_votes: number | null
    owner_id: number | null
    flags: number | null
    autorole_votes: number | null
    old_state: number | null
    user_whitelist: number | null
    user_blacklist: number | null
  }

  export type ServersSumAggregateOutputType = {
    guild_id: bigint | null
    votes: bigint | null
    invite_amount: number | null
    long_description_type: number | null
    state: number | null
    invite_channel: bigint | null
    guild_count: bigint | null
    webhook_type: number | null
    total_votes: bigint | null
    owner_id: bigint | null
    flags: number[]
    autorole_votes: bigint[]
    old_state: number | null
    user_whitelist: bigint[]
    user_blacklist: bigint[]
  }

  export type ServersMinAggregateOutputType = {
    guild_id: bigint | null
    votes: bigint | null
    webhook: string | null
    description: string | null
    long_description: string | null
    css: string | null
    api_token: string | null
    invite_amount: number | null
    invite_url: string | null
    name_cached: string | null
    long_description_type: number | null
    state: number | null
    created_at: Date | null
    avatar_cached: string | null
    invite_channel: bigint | null
    guild_count: bigint | null
    banner_card: string | null
    banner_page: string | null
    webhook_secret: string | null
    webhook_type: number | null
    total_votes: bigint | null
    owner_id: bigint | null
    whitelist_form: string | null
    webhook_hmac_only: boolean | null
    old_state: number | null
    lynxtag: string | null
  }

  export type ServersMaxAggregateOutputType = {
    guild_id: bigint | null
    votes: bigint | null
    webhook: string | null
    description: string | null
    long_description: string | null
    css: string | null
    api_token: string | null
    invite_amount: number | null
    invite_url: string | null
    name_cached: string | null
    long_description_type: number | null
    state: number | null
    created_at: Date | null
    avatar_cached: string | null
    invite_channel: bigint | null
    guild_count: bigint | null
    banner_card: string | null
    banner_page: string | null
    webhook_secret: string | null
    webhook_type: number | null
    total_votes: bigint | null
    owner_id: bigint | null
    whitelist_form: string | null
    webhook_hmac_only: boolean | null
    old_state: number | null
    lynxtag: string | null
  }

  export type ServersCountAggregateOutputType = {
    guild_id: number
    votes: number
    webhook: number
    description: number
    long_description: number
    css: number
    api_token: number
    invite_amount: number
    invite_url: number
    name_cached: number
    long_description_type: number
    state: number
    created_at: number
    avatar_cached: number
    invite_channel: number
    guild_count: number
    banner_card: number
    banner_page: number
    webhook_secret: number
    webhook_type: number
    total_votes: number
    tags: number
    owner_id: number
    flags: number
    autorole_votes: number
    whitelist_form: number
    webhook_hmac_only: number
    old_state: number
    user_whitelist: number
    user_blacklist: number
    extra_links: number
    lynxtag: number
    _all: number
  }


  export type ServersAvgAggregateInputType = {
    guild_id?: true
    votes?: true
    invite_amount?: true
    long_description_type?: true
    state?: true
    invite_channel?: true
    guild_count?: true
    webhook_type?: true
    total_votes?: true
    owner_id?: true
    flags?: true
    autorole_votes?: true
    old_state?: true
    user_whitelist?: true
    user_blacklist?: true
  }

  export type ServersSumAggregateInputType = {
    guild_id?: true
    votes?: true
    invite_amount?: true
    long_description_type?: true
    state?: true
    invite_channel?: true
    guild_count?: true
    webhook_type?: true
    total_votes?: true
    owner_id?: true
    flags?: true
    autorole_votes?: true
    old_state?: true
    user_whitelist?: true
    user_blacklist?: true
  }

  export type ServersMinAggregateInputType = {
    guild_id?: true
    votes?: true
    webhook?: true
    description?: true
    long_description?: true
    css?: true
    api_token?: true
    invite_amount?: true
    invite_url?: true
    name_cached?: true
    long_description_type?: true
    state?: true
    created_at?: true
    avatar_cached?: true
    invite_channel?: true
    guild_count?: true
    banner_card?: true
    banner_page?: true
    webhook_secret?: true
    webhook_type?: true
    total_votes?: true
    owner_id?: true
    whitelist_form?: true
    webhook_hmac_only?: true
    old_state?: true
    lynxtag?: true
  }

  export type ServersMaxAggregateInputType = {
    guild_id?: true
    votes?: true
    webhook?: true
    description?: true
    long_description?: true
    css?: true
    api_token?: true
    invite_amount?: true
    invite_url?: true
    name_cached?: true
    long_description_type?: true
    state?: true
    created_at?: true
    avatar_cached?: true
    invite_channel?: true
    guild_count?: true
    banner_card?: true
    banner_page?: true
    webhook_secret?: true
    webhook_type?: true
    total_votes?: true
    owner_id?: true
    whitelist_form?: true
    webhook_hmac_only?: true
    old_state?: true
    lynxtag?: true
  }

  export type ServersCountAggregateInputType = {
    guild_id?: true
    votes?: true
    webhook?: true
    description?: true
    long_description?: true
    css?: true
    api_token?: true
    invite_amount?: true
    invite_url?: true
    name_cached?: true
    long_description_type?: true
    state?: true
    created_at?: true
    avatar_cached?: true
    invite_channel?: true
    guild_count?: true
    banner_card?: true
    banner_page?: true
    webhook_secret?: true
    webhook_type?: true
    total_votes?: true
    tags?: true
    owner_id?: true
    flags?: true
    autorole_votes?: true
    whitelist_form?: true
    webhook_hmac_only?: true
    old_state?: true
    user_whitelist?: true
    user_blacklist?: true
    extra_links?: true
    lynxtag?: true
    _all?: true
  }

  export type ServersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which servers to aggregate.
     */
    where?: serversWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servers to fetch.
     */
    orderBy?: serversOrderByWithRelationInput | serversOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: serversWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned servers
    **/
    _count?: true | ServersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServersMaxAggregateInputType
  }

  export type GetServersAggregateType<T extends ServersAggregateArgs> = {
        [P in keyof T & keyof AggregateServers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServers[P]>
      : GetScalarType<T[P], AggregateServers[P]>
  }




  export type serversGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: serversWhereInput
    orderBy?: serversOrderByWithAggregationInput | serversOrderByWithAggregationInput[]
    by: ServersScalarFieldEnum[] | ServersScalarFieldEnum
    having?: serversScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServersCountAggregateInputType | true
    _avg?: ServersAvgAggregateInputType
    _sum?: ServersSumAggregateInputType
    _min?: ServersMinAggregateInputType
    _max?: ServersMaxAggregateInputType
  }

  export type ServersGroupByOutputType = {
    guild_id: bigint
    votes: bigint | null
    webhook: string | null
    description: string
    long_description: string
    css: string | null
    api_token: string
    invite_amount: number | null
    invite_url: string | null
    name_cached: string
    long_description_type: number | null
    state: number
    created_at: Date
    avatar_cached: string | null
    invite_channel: bigint | null
    guild_count: bigint | null
    banner_card: string | null
    banner_page: string | null
    webhook_secret: string | null
    webhook_type: number | null
    total_votes: bigint | null
    tags: string[]
    owner_id: bigint
    flags: number[]
    autorole_votes: bigint[]
    whitelist_form: string | null
    webhook_hmac_only: boolean | null
    old_state: number
    user_whitelist: bigint[]
    user_blacklist: bigint[]
    extra_links: JsonValue
    lynxtag: string
    _count: ServersCountAggregateOutputType | null
    _avg: ServersAvgAggregateOutputType | null
    _sum: ServersSumAggregateOutputType | null
    _min: ServersMinAggregateOutputType | null
    _max: ServersMaxAggregateOutputType | null
  }

  type GetServersGroupByPayload<T extends serversGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServersGroupByOutputType[P]>
            : GetScalarType<T[P], ServersGroupByOutputType[P]>
        }
      >
    >


  export type serversSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    guild_id?: boolean
    votes?: boolean
    webhook?: boolean
    description?: boolean
    long_description?: boolean
    css?: boolean
    api_token?: boolean
    invite_amount?: boolean
    invite_url?: boolean
    name_cached?: boolean
    long_description_type?: boolean
    state?: boolean
    created_at?: boolean
    avatar_cached?: boolean
    invite_channel?: boolean
    guild_count?: boolean
    banner_card?: boolean
    banner_page?: boolean
    webhook_secret?: boolean
    webhook_type?: boolean
    total_votes?: boolean
    tags?: boolean
    owner_id?: boolean
    flags?: boolean
    autorole_votes?: boolean
    whitelist_form?: boolean
    webhook_hmac_only?: boolean
    old_state?: boolean
    user_whitelist?: boolean
    user_blacklist?: boolean
    extra_links?: boolean
    lynxtag?: boolean
    server_audit_logs?: boolean | servers$server_audit_logsArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    _count?: boolean | ServersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["servers"]>

  export type serversSelectScalar = {
    guild_id?: boolean
    votes?: boolean
    webhook?: boolean
    description?: boolean
    long_description?: boolean
    css?: boolean
    api_token?: boolean
    invite_amount?: boolean
    invite_url?: boolean
    name_cached?: boolean
    long_description_type?: boolean
    state?: boolean
    created_at?: boolean
    avatar_cached?: boolean
    invite_channel?: boolean
    guild_count?: boolean
    banner_card?: boolean
    banner_page?: boolean
    webhook_secret?: boolean
    webhook_type?: boolean
    total_votes?: boolean
    tags?: boolean
    owner_id?: boolean
    flags?: boolean
    autorole_votes?: boolean
    whitelist_form?: boolean
    webhook_hmac_only?: boolean
    old_state?: boolean
    user_whitelist?: boolean
    user_blacklist?: boolean
    extra_links?: boolean
    lynxtag?: boolean
  }

  export type serversInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    server_audit_logs?: boolean | servers$server_audit_logsArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    _count?: boolean | ServersCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $serversPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "servers"
    objects: {
      server_audit_logs: Prisma.$server_audit_logsPayload<ExtArgs>[]
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      guild_id: bigint
      votes: bigint | null
      webhook: string | null
      description: string
      long_description: string
      css: string | null
      api_token: string
      invite_amount: number | null
      invite_url: string | null
      name_cached: string
      long_description_type: number | null
      state: number
      created_at: Date
      avatar_cached: string | null
      invite_channel: bigint | null
      guild_count: bigint | null
      banner_card: string | null
      banner_page: string | null
      webhook_secret: string | null
      webhook_type: number | null
      total_votes: bigint | null
      tags: string[]
      owner_id: bigint
      flags: number[]
      autorole_votes: bigint[]
      whitelist_form: string | null
      webhook_hmac_only: boolean | null
      old_state: number
      user_whitelist: bigint[]
      user_blacklist: bigint[]
      extra_links: Prisma.JsonValue
      lynxtag: string
    }, ExtArgs["result"]["servers"]>
    composites: {}
  }


  type serversGetPayload<S extends boolean | null | undefined | serversDefaultArgs> = $Result.GetResult<Prisma.$serversPayload, S>

  type serversCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<serversFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ServersCountAggregateInputType | true
    }

  export interface serversDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['servers'], meta: { name: 'servers' } }
    /**
     * Find zero or one Servers that matches the filter.
     * @param {serversFindUniqueArgs} args - Arguments to find a Servers
     * @example
     * // Get one Servers
     * const servers = await prisma.servers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends serversFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, serversFindUniqueArgs<ExtArgs>>
    ): Prisma__serversClient<$Result.GetResult<Prisma.$serversPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Servers that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {serversFindUniqueOrThrowArgs} args - Arguments to find a Servers
     * @example
     * // Get one Servers
     * const servers = await prisma.servers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends serversFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, serversFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__serversClient<$Result.GetResult<Prisma.$serversPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Servers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serversFindFirstArgs} args - Arguments to find a Servers
     * @example
     * // Get one Servers
     * const servers = await prisma.servers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends serversFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, serversFindFirstArgs<ExtArgs>>
    ): Prisma__serversClient<$Result.GetResult<Prisma.$serversPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Servers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serversFindFirstOrThrowArgs} args - Arguments to find a Servers
     * @example
     * // Get one Servers
     * const servers = await prisma.servers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends serversFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, serversFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__serversClient<$Result.GetResult<Prisma.$serversPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Servers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serversFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Servers
     * const servers = await prisma.servers.findMany()
     * 
     * // Get first 10 Servers
     * const servers = await prisma.servers.findMany({ take: 10 })
     * 
     * // Only select the `guild_id`
     * const serversWithGuild_idOnly = await prisma.servers.findMany({ select: { guild_id: true } })
     * 
    **/
    findMany<T extends serversFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, serversFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$serversPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Servers.
     * @param {serversCreateArgs} args - Arguments to create a Servers.
     * @example
     * // Create one Servers
     * const Servers = await prisma.servers.create({
     *   data: {
     *     // ... data to create a Servers
     *   }
     * })
     * 
    **/
    create<T extends serversCreateArgs<ExtArgs>>(
      args: SelectSubset<T, serversCreateArgs<ExtArgs>>
    ): Prisma__serversClient<$Result.GetResult<Prisma.$serversPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Servers.
     *     @param {serversCreateManyArgs} args - Arguments to create many Servers.
     *     @example
     *     // Create many Servers
     *     const servers = await prisma.servers.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends serversCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, serversCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Servers.
     * @param {serversDeleteArgs} args - Arguments to delete one Servers.
     * @example
     * // Delete one Servers
     * const Servers = await prisma.servers.delete({
     *   where: {
     *     // ... filter to delete one Servers
     *   }
     * })
     * 
    **/
    delete<T extends serversDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, serversDeleteArgs<ExtArgs>>
    ): Prisma__serversClient<$Result.GetResult<Prisma.$serversPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Servers.
     * @param {serversUpdateArgs} args - Arguments to update one Servers.
     * @example
     * // Update one Servers
     * const servers = await prisma.servers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends serversUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, serversUpdateArgs<ExtArgs>>
    ): Prisma__serversClient<$Result.GetResult<Prisma.$serversPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Servers.
     * @param {serversDeleteManyArgs} args - Arguments to filter Servers to delete.
     * @example
     * // Delete a few Servers
     * const { count } = await prisma.servers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends serversDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, serversDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Servers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serversUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Servers
     * const servers = await prisma.servers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends serversUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, serversUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Servers.
     * @param {serversUpsertArgs} args - Arguments to update or create a Servers.
     * @example
     * // Update or create a Servers
     * const servers = await prisma.servers.upsert({
     *   create: {
     *     // ... data to create a Servers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Servers we want to update
     *   }
     * })
    **/
    upsert<T extends serversUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, serversUpsertArgs<ExtArgs>>
    ): Prisma__serversClient<$Result.GetResult<Prisma.$serversPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Servers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serversCountArgs} args - Arguments to filter Servers to count.
     * @example
     * // Count the number of Servers
     * const count = await prisma.servers.count({
     *   where: {
     *     // ... the filter for the Servers we want to count
     *   }
     * })
    **/
    count<T extends serversCountArgs>(
      args?: Subset<T, serversCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Servers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServersAggregateArgs>(args: Subset<T, ServersAggregateArgs>): Prisma.PrismaPromise<GetServersAggregateType<T>>

    /**
     * Group by Servers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serversGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends serversGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: serversGroupByArgs['orderBy'] }
        : { orderBy?: serversGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, serversGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the servers model
   */
  readonly fields: serversFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for servers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__serversClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    server_audit_logs<T extends servers$server_audit_logsArgs<ExtArgs> = {}>(args?: Subset<T, servers$server_audit_logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$server_audit_logsPayload<ExtArgs>, T, 'findMany'> | Null>;

    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the servers model
   */ 
  interface serversFieldRefs {
    readonly guild_id: FieldRef<"servers", 'BigInt'>
    readonly votes: FieldRef<"servers", 'BigInt'>
    readonly webhook: FieldRef<"servers", 'String'>
    readonly description: FieldRef<"servers", 'String'>
    readonly long_description: FieldRef<"servers", 'String'>
    readonly css: FieldRef<"servers", 'String'>
    readonly api_token: FieldRef<"servers", 'String'>
    readonly invite_amount: FieldRef<"servers", 'Int'>
    readonly invite_url: FieldRef<"servers", 'String'>
    readonly name_cached: FieldRef<"servers", 'String'>
    readonly long_description_type: FieldRef<"servers", 'Int'>
    readonly state: FieldRef<"servers", 'Int'>
    readonly created_at: FieldRef<"servers", 'DateTime'>
    readonly avatar_cached: FieldRef<"servers", 'String'>
    readonly invite_channel: FieldRef<"servers", 'BigInt'>
    readonly guild_count: FieldRef<"servers", 'BigInt'>
    readonly banner_card: FieldRef<"servers", 'String'>
    readonly banner_page: FieldRef<"servers", 'String'>
    readonly webhook_secret: FieldRef<"servers", 'String'>
    readonly webhook_type: FieldRef<"servers", 'Int'>
    readonly total_votes: FieldRef<"servers", 'BigInt'>
    readonly tags: FieldRef<"servers", 'String[]'>
    readonly owner_id: FieldRef<"servers", 'BigInt'>
    readonly flags: FieldRef<"servers", 'Int[]'>
    readonly autorole_votes: FieldRef<"servers", 'BigInt[]'>
    readonly whitelist_form: FieldRef<"servers", 'String'>
    readonly webhook_hmac_only: FieldRef<"servers", 'Boolean'>
    readonly old_state: FieldRef<"servers", 'Int'>
    readonly user_whitelist: FieldRef<"servers", 'BigInt[]'>
    readonly user_blacklist: FieldRef<"servers", 'BigInt[]'>
    readonly extra_links: FieldRef<"servers", 'Json'>
    readonly lynxtag: FieldRef<"servers", 'String'>
  }
    

  // Custom InputTypes

  /**
   * servers findUnique
   */
  export type serversFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servers
     */
    select?: serversSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: serversInclude<ExtArgs> | null
    /**
     * Filter, which servers to fetch.
     */
    where: serversWhereUniqueInput
  }


  /**
   * servers findUniqueOrThrow
   */
  export type serversFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servers
     */
    select?: serversSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: serversInclude<ExtArgs> | null
    /**
     * Filter, which servers to fetch.
     */
    where: serversWhereUniqueInput
  }


  /**
   * servers findFirst
   */
  export type serversFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servers
     */
    select?: serversSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: serversInclude<ExtArgs> | null
    /**
     * Filter, which servers to fetch.
     */
    where?: serversWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servers to fetch.
     */
    orderBy?: serversOrderByWithRelationInput | serversOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for servers.
     */
    cursor?: serversWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of servers.
     */
    distinct?: ServersScalarFieldEnum | ServersScalarFieldEnum[]
  }


  /**
   * servers findFirstOrThrow
   */
  export type serversFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servers
     */
    select?: serversSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: serversInclude<ExtArgs> | null
    /**
     * Filter, which servers to fetch.
     */
    where?: serversWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servers to fetch.
     */
    orderBy?: serversOrderByWithRelationInput | serversOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for servers.
     */
    cursor?: serversWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of servers.
     */
    distinct?: ServersScalarFieldEnum | ServersScalarFieldEnum[]
  }


  /**
   * servers findMany
   */
  export type serversFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servers
     */
    select?: serversSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: serversInclude<ExtArgs> | null
    /**
     * Filter, which servers to fetch.
     */
    where?: serversWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servers to fetch.
     */
    orderBy?: serversOrderByWithRelationInput | serversOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing servers.
     */
    cursor?: serversWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servers.
     */
    skip?: number
    distinct?: ServersScalarFieldEnum | ServersScalarFieldEnum[]
  }


  /**
   * servers create
   */
  export type serversCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servers
     */
    select?: serversSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: serversInclude<ExtArgs> | null
    /**
     * The data needed to create a servers.
     */
    data: XOR<serversCreateInput, serversUncheckedCreateInput>
  }


  /**
   * servers createMany
   */
  export type serversCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many servers.
     */
    data: serversCreateManyInput | serversCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * servers update
   */
  export type serversUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servers
     */
    select?: serversSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: serversInclude<ExtArgs> | null
    /**
     * The data needed to update a servers.
     */
    data: XOR<serversUpdateInput, serversUncheckedUpdateInput>
    /**
     * Choose, which servers to update.
     */
    where: serversWhereUniqueInput
  }


  /**
   * servers updateMany
   */
  export type serversUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update servers.
     */
    data: XOR<serversUpdateManyMutationInput, serversUncheckedUpdateManyInput>
    /**
     * Filter which servers to update
     */
    where?: serversWhereInput
  }


  /**
   * servers upsert
   */
  export type serversUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servers
     */
    select?: serversSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: serversInclude<ExtArgs> | null
    /**
     * The filter to search for the servers to update in case it exists.
     */
    where: serversWhereUniqueInput
    /**
     * In case the servers found by the `where` argument doesn't exist, create a new servers with this data.
     */
    create: XOR<serversCreateInput, serversUncheckedCreateInput>
    /**
     * In case the servers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<serversUpdateInput, serversUncheckedUpdateInput>
  }


  /**
   * servers delete
   */
  export type serversDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servers
     */
    select?: serversSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: serversInclude<ExtArgs> | null
    /**
     * Filter which servers to delete.
     */
    where: serversWhereUniqueInput
  }


  /**
   * servers deleteMany
   */
  export type serversDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which servers to delete
     */
    where?: serversWhereInput
  }


  /**
   * servers.server_audit_logs
   */
  export type servers$server_audit_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the server_audit_logs
     */
    select?: server_audit_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: server_audit_logsInclude<ExtArgs> | null
    where?: server_audit_logsWhereInput
    orderBy?: server_audit_logsOrderByWithRelationInput | server_audit_logsOrderByWithRelationInput[]
    cursor?: server_audit_logsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Server_audit_logsScalarFieldEnum | Server_audit_logsScalarFieldEnum[]
  }


  /**
   * servers without action
   */
  export type serversDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servers
     */
    select?: serversSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: serversInclude<ExtArgs> | null
  }



  /**
   * Model sessions
   */

  export type AggregateSessions = {
    _count: SessionsCountAggregateOutputType | null
    _avg: SessionsAvgAggregateOutputType | null
    _sum: SessionsSumAggregateOutputType | null
    _min: SessionsMinAggregateOutputType | null
    _max: SessionsMaxAggregateOutputType | null
  }

  export type SessionsAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type SessionsSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type SessionsMinAggregateOutputType = {
    id: number | null
    token: string | null
    user_id: number | null
    expiry_date: Date | null
    max_expiry_date: Date | null
    lynxtag: string | null
  }

  export type SessionsMaxAggregateOutputType = {
    id: number | null
    token: string | null
    user_id: number | null
    expiry_date: Date | null
    max_expiry_date: Date | null
    lynxtag: string | null
  }

  export type SessionsCountAggregateOutputType = {
    id: number
    token: number
    user_id: number
    expiry_date: number
    max_expiry_date: number
    lynxtag: number
    _all: number
  }


  export type SessionsAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type SessionsSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type SessionsMinAggregateInputType = {
    id?: true
    token?: true
    user_id?: true
    expiry_date?: true
    max_expiry_date?: true
    lynxtag?: true
  }

  export type SessionsMaxAggregateInputType = {
    id?: true
    token?: true
    user_id?: true
    expiry_date?: true
    max_expiry_date?: true
    lynxtag?: true
  }

  export type SessionsCountAggregateInputType = {
    id?: true
    token?: true
    user_id?: true
    expiry_date?: true
    max_expiry_date?: true
    lynxtag?: true
    _all?: true
  }

  export type SessionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sessions to aggregate.
     */
    where?: sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionsOrderByWithRelationInput | sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sessions
    **/
    _count?: true | SessionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SessionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SessionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionsMaxAggregateInputType
  }

  export type GetSessionsAggregateType<T extends SessionsAggregateArgs> = {
        [P in keyof T & keyof AggregateSessions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSessions[P]>
      : GetScalarType<T[P], AggregateSessions[P]>
  }




  export type sessionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sessionsWhereInput
    orderBy?: sessionsOrderByWithAggregationInput | sessionsOrderByWithAggregationInput[]
    by: SessionsScalarFieldEnum[] | SessionsScalarFieldEnum
    having?: sessionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionsCountAggregateInputType | true
    _avg?: SessionsAvgAggregateInputType
    _sum?: SessionsSumAggregateInputType
    _min?: SessionsMinAggregateInputType
    _max?: SessionsMaxAggregateInputType
  }

  export type SessionsGroupByOutputType = {
    id: number
    token: string
    user_id: number
    expiry_date: Date
    max_expiry_date: Date
    lynxtag: string
    _count: SessionsCountAggregateOutputType | null
    _avg: SessionsAvgAggregateOutputType | null
    _sum: SessionsSumAggregateOutputType | null
    _min: SessionsMinAggregateOutputType | null
    _max: SessionsMaxAggregateOutputType | null
  }

  type GetSessionsGroupByPayload<T extends sessionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionsGroupByOutputType[P]>
            : GetScalarType<T[P], SessionsGroupByOutputType[P]>
        }
      >
    >


  export type sessionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    user_id?: boolean
    expiry_date?: boolean
    max_expiry_date?: boolean
    lynxtag?: boolean
  }, ExtArgs["result"]["sessions"]>

  export type sessionsSelectScalar = {
    id?: boolean
    token?: boolean
    user_id?: boolean
    expiry_date?: boolean
    max_expiry_date?: boolean
    lynxtag?: boolean
  }


  export type $sessionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "sessions"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      token: string
      user_id: number
      expiry_date: Date
      max_expiry_date: Date
      lynxtag: string
    }, ExtArgs["result"]["sessions"]>
    composites: {}
  }


  type sessionsGetPayload<S extends boolean | null | undefined | sessionsDefaultArgs> = $Result.GetResult<Prisma.$sessionsPayload, S>

  type sessionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<sessionsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SessionsCountAggregateInputType | true
    }

  export interface sessionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['sessions'], meta: { name: 'sessions' } }
    /**
     * Find zero or one Sessions that matches the filter.
     * @param {sessionsFindUniqueArgs} args - Arguments to find a Sessions
     * @example
     * // Get one Sessions
     * const sessions = await prisma.sessions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends sessionsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, sessionsFindUniqueArgs<ExtArgs>>
    ): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Sessions that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {sessionsFindUniqueOrThrowArgs} args - Arguments to find a Sessions
     * @example
     * // Get one Sessions
     * const sessions = await prisma.sessions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends sessionsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, sessionsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsFindFirstArgs} args - Arguments to find a Sessions
     * @example
     * // Get one Sessions
     * const sessions = await prisma.sessions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends sessionsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, sessionsFindFirstArgs<ExtArgs>>
    ): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Sessions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsFindFirstOrThrowArgs} args - Arguments to find a Sessions
     * @example
     * // Get one Sessions
     * const sessions = await prisma.sessions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends sessionsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, sessionsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.sessions.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.sessions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionsWithIdOnly = await prisma.sessions.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends sessionsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, sessionsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Sessions.
     * @param {sessionsCreateArgs} args - Arguments to create a Sessions.
     * @example
     * // Create one Sessions
     * const Sessions = await prisma.sessions.create({
     *   data: {
     *     // ... data to create a Sessions
     *   }
     * })
     * 
    **/
    create<T extends sessionsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, sessionsCreateArgs<ExtArgs>>
    ): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Sessions.
     *     @param {sessionsCreateManyArgs} args - Arguments to create many Sessions.
     *     @example
     *     // Create many Sessions
     *     const sessions = await prisma.sessions.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends sessionsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, sessionsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Sessions.
     * @param {sessionsDeleteArgs} args - Arguments to delete one Sessions.
     * @example
     * // Delete one Sessions
     * const Sessions = await prisma.sessions.delete({
     *   where: {
     *     // ... filter to delete one Sessions
     *   }
     * })
     * 
    **/
    delete<T extends sessionsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, sessionsDeleteArgs<ExtArgs>>
    ): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Sessions.
     * @param {sessionsUpdateArgs} args - Arguments to update one Sessions.
     * @example
     * // Update one Sessions
     * const sessions = await prisma.sessions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends sessionsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, sessionsUpdateArgs<ExtArgs>>
    ): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Sessions.
     * @param {sessionsDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.sessions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends sessionsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, sessionsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const sessions = await prisma.sessions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends sessionsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, sessionsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sessions.
     * @param {sessionsUpsertArgs} args - Arguments to update or create a Sessions.
     * @example
     * // Update or create a Sessions
     * const sessions = await prisma.sessions.upsert({
     *   create: {
     *     // ... data to create a Sessions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sessions we want to update
     *   }
     * })
    **/
    upsert<T extends sessionsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, sessionsUpsertArgs<ExtArgs>>
    ): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.sessions.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends sessionsCountArgs>(
      args?: Subset<T, sessionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionsAggregateArgs>(args: Subset<T, SessionsAggregateArgs>): Prisma.PrismaPromise<GetSessionsAggregateType<T>>

    /**
     * Group by Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends sessionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: sessionsGroupByArgs['orderBy'] }
        : { orderBy?: sessionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, sessionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the sessions model
   */
  readonly fields: sessionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for sessions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__sessionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the sessions model
   */ 
  interface sessionsFieldRefs {
    readonly id: FieldRef<"sessions", 'Int'>
    readonly token: FieldRef<"sessions", 'String'>
    readonly user_id: FieldRef<"sessions", 'Int'>
    readonly expiry_date: FieldRef<"sessions", 'DateTime'>
    readonly max_expiry_date: FieldRef<"sessions", 'DateTime'>
    readonly lynxtag: FieldRef<"sessions", 'String'>
  }
    

  // Custom InputTypes

  /**
   * sessions findUnique
   */
  export type sessionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Filter, which sessions to fetch.
     */
    where: sessionsWhereUniqueInput
  }


  /**
   * sessions findUniqueOrThrow
   */
  export type sessionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Filter, which sessions to fetch.
     */
    where: sessionsWhereUniqueInput
  }


  /**
   * sessions findFirst
   */
  export type sessionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Filter, which sessions to fetch.
     */
    where?: sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionsOrderByWithRelationInput | sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sessions.
     */
    cursor?: sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sessions.
     */
    distinct?: SessionsScalarFieldEnum | SessionsScalarFieldEnum[]
  }


  /**
   * sessions findFirstOrThrow
   */
  export type sessionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Filter, which sessions to fetch.
     */
    where?: sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionsOrderByWithRelationInput | sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sessions.
     */
    cursor?: sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sessions.
     */
    distinct?: SessionsScalarFieldEnum | SessionsScalarFieldEnum[]
  }


  /**
   * sessions findMany
   */
  export type sessionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Filter, which sessions to fetch.
     */
    where?: sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionsOrderByWithRelationInput | sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sessions.
     */
    cursor?: sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    distinct?: SessionsScalarFieldEnum | SessionsScalarFieldEnum[]
  }


  /**
   * sessions create
   */
  export type sessionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * The data needed to create a sessions.
     */
    data?: XOR<sessionsCreateInput, sessionsUncheckedCreateInput>
  }


  /**
   * sessions createMany
   */
  export type sessionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many sessions.
     */
    data: sessionsCreateManyInput | sessionsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * sessions update
   */
  export type sessionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * The data needed to update a sessions.
     */
    data: XOR<sessionsUpdateInput, sessionsUncheckedUpdateInput>
    /**
     * Choose, which sessions to update.
     */
    where: sessionsWhereUniqueInput
  }


  /**
   * sessions updateMany
   */
  export type sessionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update sessions.
     */
    data: XOR<sessionsUpdateManyMutationInput, sessionsUncheckedUpdateManyInput>
    /**
     * Filter which sessions to update
     */
    where?: sessionsWhereInput
  }


  /**
   * sessions upsert
   */
  export type sessionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * The filter to search for the sessions to update in case it exists.
     */
    where: sessionsWhereUniqueInput
    /**
     * In case the sessions found by the `where` argument doesn't exist, create a new sessions with this data.
     */
    create: XOR<sessionsCreateInput, sessionsUncheckedCreateInput>
    /**
     * In case the sessions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sessionsUpdateInput, sessionsUncheckedUpdateInput>
  }


  /**
   * sessions delete
   */
  export type sessionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Filter which sessions to delete.
     */
    where: sessionsWhereUniqueInput
  }


  /**
   * sessions deleteMany
   */
  export type sessionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sessions to delete
     */
    where?: sessionsWhereInput
  }


  /**
   * sessions without action
   */
  export type sessionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
  }



  /**
   * Model user_bot_logs
   */

  export type AggregateUser_bot_logs = {
    _count: User_bot_logsCountAggregateOutputType | null
    _avg: User_bot_logsAvgAggregateOutputType | null
    _sum: User_bot_logsSumAggregateOutputType | null
    _min: User_bot_logsMinAggregateOutputType | null
    _max: User_bot_logsMaxAggregateOutputType | null
  }

  export type User_bot_logsAvgAggregateOutputType = {
    user_id: number | null
    bot_id: number | null
    action: number | null
  }

  export type User_bot_logsSumAggregateOutputType = {
    user_id: bigint | null
    bot_id: bigint | null
    action: number | null
  }

  export type User_bot_logsMinAggregateOutputType = {
    user_id: bigint | null
    bot_id: bigint | null
    action_time: Date | null
    action: number | null
    context: string | null
    lynxtag: string | null
  }

  export type User_bot_logsMaxAggregateOutputType = {
    user_id: bigint | null
    bot_id: bigint | null
    action_time: Date | null
    action: number | null
    context: string | null
    lynxtag: string | null
  }

  export type User_bot_logsCountAggregateOutputType = {
    user_id: number
    bot_id: number
    action_time: number
    action: number
    context: number
    lynxtag: number
    _all: number
  }


  export type User_bot_logsAvgAggregateInputType = {
    user_id?: true
    bot_id?: true
    action?: true
  }

  export type User_bot_logsSumAggregateInputType = {
    user_id?: true
    bot_id?: true
    action?: true
  }

  export type User_bot_logsMinAggregateInputType = {
    user_id?: true
    bot_id?: true
    action_time?: true
    action?: true
    context?: true
    lynxtag?: true
  }

  export type User_bot_logsMaxAggregateInputType = {
    user_id?: true
    bot_id?: true
    action_time?: true
    action?: true
    context?: true
    lynxtag?: true
  }

  export type User_bot_logsCountAggregateInputType = {
    user_id?: true
    bot_id?: true
    action_time?: true
    action?: true
    context?: true
    lynxtag?: true
    _all?: true
  }

  export type User_bot_logsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_bot_logs to aggregate.
     */
    where?: user_bot_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_bot_logs to fetch.
     */
    orderBy?: user_bot_logsOrderByWithRelationInput | user_bot_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: user_bot_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_bot_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_bot_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_bot_logs
    **/
    _count?: true | User_bot_logsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: User_bot_logsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: User_bot_logsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_bot_logsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_bot_logsMaxAggregateInputType
  }

  export type GetUser_bot_logsAggregateType<T extends User_bot_logsAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_bot_logs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_bot_logs[P]>
      : GetScalarType<T[P], AggregateUser_bot_logs[P]>
  }




  export type user_bot_logsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_bot_logsWhereInput
    orderBy?: user_bot_logsOrderByWithAggregationInput | user_bot_logsOrderByWithAggregationInput[]
    by: User_bot_logsScalarFieldEnum[] | User_bot_logsScalarFieldEnum
    having?: user_bot_logsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_bot_logsCountAggregateInputType | true
    _avg?: User_bot_logsAvgAggregateInputType
    _sum?: User_bot_logsSumAggregateInputType
    _min?: User_bot_logsMinAggregateInputType
    _max?: User_bot_logsMaxAggregateInputType
  }

  export type User_bot_logsGroupByOutputType = {
    user_id: bigint
    bot_id: bigint
    action_time: Date
    action: number
    context: string | null
    lynxtag: string
    _count: User_bot_logsCountAggregateOutputType | null
    _avg: User_bot_logsAvgAggregateOutputType | null
    _sum: User_bot_logsSumAggregateOutputType | null
    _min: User_bot_logsMinAggregateOutputType | null
    _max: User_bot_logsMaxAggregateOutputType | null
  }

  type GetUser_bot_logsGroupByPayload<T extends user_bot_logsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<User_bot_logsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_bot_logsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_bot_logsGroupByOutputType[P]>
            : GetScalarType<T[P], User_bot_logsGroupByOutputType[P]>
        }
      >
    >


  export type user_bot_logsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    bot_id?: boolean
    action_time?: boolean
    action?: boolean
    context?: boolean
    lynxtag?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_bot_logs"]>

  export type user_bot_logsSelectScalar = {
    user_id?: boolean
    bot_id?: boolean
    action_time?: boolean
    action?: boolean
    context?: boolean
    lynxtag?: boolean
  }

  export type user_bot_logsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }


  export type $user_bot_logsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user_bot_logs"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      user_id: bigint
      bot_id: bigint
      action_time: Date
      action: number
      context: string | null
      lynxtag: string
    }, ExtArgs["result"]["user_bot_logs"]>
    composites: {}
  }


  type user_bot_logsGetPayload<S extends boolean | null | undefined | user_bot_logsDefaultArgs> = $Result.GetResult<Prisma.$user_bot_logsPayload, S>

  type user_bot_logsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<user_bot_logsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: User_bot_logsCountAggregateInputType | true
    }

  export interface user_bot_logsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user_bot_logs'], meta: { name: 'user_bot_logs' } }
    /**
     * Find zero or one User_bot_logs that matches the filter.
     * @param {user_bot_logsFindUniqueArgs} args - Arguments to find a User_bot_logs
     * @example
     * // Get one User_bot_logs
     * const user_bot_logs = await prisma.user_bot_logs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends user_bot_logsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, user_bot_logsFindUniqueArgs<ExtArgs>>
    ): Prisma__user_bot_logsClient<$Result.GetResult<Prisma.$user_bot_logsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one User_bot_logs that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {user_bot_logsFindUniqueOrThrowArgs} args - Arguments to find a User_bot_logs
     * @example
     * // Get one User_bot_logs
     * const user_bot_logs = await prisma.user_bot_logs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends user_bot_logsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, user_bot_logsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__user_bot_logsClient<$Result.GetResult<Prisma.$user_bot_logsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first User_bot_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_bot_logsFindFirstArgs} args - Arguments to find a User_bot_logs
     * @example
     * // Get one User_bot_logs
     * const user_bot_logs = await prisma.user_bot_logs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends user_bot_logsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, user_bot_logsFindFirstArgs<ExtArgs>>
    ): Prisma__user_bot_logsClient<$Result.GetResult<Prisma.$user_bot_logsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first User_bot_logs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_bot_logsFindFirstOrThrowArgs} args - Arguments to find a User_bot_logs
     * @example
     * // Get one User_bot_logs
     * const user_bot_logs = await prisma.user_bot_logs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends user_bot_logsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, user_bot_logsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__user_bot_logsClient<$Result.GetResult<Prisma.$user_bot_logsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more User_bot_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_bot_logsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_bot_logs
     * const user_bot_logs = await prisma.user_bot_logs.findMany()
     * 
     * // Get first 10 User_bot_logs
     * const user_bot_logs = await prisma.user_bot_logs.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const user_bot_logsWithUser_idOnly = await prisma.user_bot_logs.findMany({ select: { user_id: true } })
     * 
    **/
    findMany<T extends user_bot_logsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, user_bot_logsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_bot_logsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a User_bot_logs.
     * @param {user_bot_logsCreateArgs} args - Arguments to create a User_bot_logs.
     * @example
     * // Create one User_bot_logs
     * const User_bot_logs = await prisma.user_bot_logs.create({
     *   data: {
     *     // ... data to create a User_bot_logs
     *   }
     * })
     * 
    **/
    create<T extends user_bot_logsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, user_bot_logsCreateArgs<ExtArgs>>
    ): Prisma__user_bot_logsClient<$Result.GetResult<Prisma.$user_bot_logsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many User_bot_logs.
     *     @param {user_bot_logsCreateManyArgs} args - Arguments to create many User_bot_logs.
     *     @example
     *     // Create many User_bot_logs
     *     const user_bot_logs = await prisma.user_bot_logs.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends user_bot_logsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, user_bot_logsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User_bot_logs.
     * @param {user_bot_logsDeleteArgs} args - Arguments to delete one User_bot_logs.
     * @example
     * // Delete one User_bot_logs
     * const User_bot_logs = await prisma.user_bot_logs.delete({
     *   where: {
     *     // ... filter to delete one User_bot_logs
     *   }
     * })
     * 
    **/
    delete<T extends user_bot_logsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, user_bot_logsDeleteArgs<ExtArgs>>
    ): Prisma__user_bot_logsClient<$Result.GetResult<Prisma.$user_bot_logsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one User_bot_logs.
     * @param {user_bot_logsUpdateArgs} args - Arguments to update one User_bot_logs.
     * @example
     * // Update one User_bot_logs
     * const user_bot_logs = await prisma.user_bot_logs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends user_bot_logsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, user_bot_logsUpdateArgs<ExtArgs>>
    ): Prisma__user_bot_logsClient<$Result.GetResult<Prisma.$user_bot_logsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more User_bot_logs.
     * @param {user_bot_logsDeleteManyArgs} args - Arguments to filter User_bot_logs to delete.
     * @example
     * // Delete a few User_bot_logs
     * const { count } = await prisma.user_bot_logs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends user_bot_logsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, user_bot_logsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_bot_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_bot_logsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_bot_logs
     * const user_bot_logs = await prisma.user_bot_logs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends user_bot_logsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, user_bot_logsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User_bot_logs.
     * @param {user_bot_logsUpsertArgs} args - Arguments to update or create a User_bot_logs.
     * @example
     * // Update or create a User_bot_logs
     * const user_bot_logs = await prisma.user_bot_logs.upsert({
     *   create: {
     *     // ... data to create a User_bot_logs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_bot_logs we want to update
     *   }
     * })
    **/
    upsert<T extends user_bot_logsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, user_bot_logsUpsertArgs<ExtArgs>>
    ): Prisma__user_bot_logsClient<$Result.GetResult<Prisma.$user_bot_logsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of User_bot_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_bot_logsCountArgs} args - Arguments to filter User_bot_logs to count.
     * @example
     * // Count the number of User_bot_logs
     * const count = await prisma.user_bot_logs.count({
     *   where: {
     *     // ... the filter for the User_bot_logs we want to count
     *   }
     * })
    **/
    count<T extends user_bot_logsCountArgs>(
      args?: Subset<T, user_bot_logsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_bot_logsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_bot_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_bot_logsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_bot_logsAggregateArgs>(args: Subset<T, User_bot_logsAggregateArgs>): Prisma.PrismaPromise<GetUser_bot_logsAggregateType<T>>

    /**
     * Group by User_bot_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_bot_logsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends user_bot_logsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: user_bot_logsGroupByArgs['orderBy'] }
        : { orderBy?: user_bot_logsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, user_bot_logsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_bot_logsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user_bot_logs model
   */
  readonly fields: user_bot_logsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user_bot_logs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__user_bot_logsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the user_bot_logs model
   */ 
  interface user_bot_logsFieldRefs {
    readonly user_id: FieldRef<"user_bot_logs", 'BigInt'>
    readonly bot_id: FieldRef<"user_bot_logs", 'BigInt'>
    readonly action_time: FieldRef<"user_bot_logs", 'DateTime'>
    readonly action: FieldRef<"user_bot_logs", 'Int'>
    readonly context: FieldRef<"user_bot_logs", 'String'>
    readonly lynxtag: FieldRef<"user_bot_logs", 'String'>
  }
    

  // Custom InputTypes

  /**
   * user_bot_logs findUnique
   */
  export type user_bot_logsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_bot_logs
     */
    select?: user_bot_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_bot_logsInclude<ExtArgs> | null
    /**
     * Filter, which user_bot_logs to fetch.
     */
    where: user_bot_logsWhereUniqueInput
  }


  /**
   * user_bot_logs findUniqueOrThrow
   */
  export type user_bot_logsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_bot_logs
     */
    select?: user_bot_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_bot_logsInclude<ExtArgs> | null
    /**
     * Filter, which user_bot_logs to fetch.
     */
    where: user_bot_logsWhereUniqueInput
  }


  /**
   * user_bot_logs findFirst
   */
  export type user_bot_logsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_bot_logs
     */
    select?: user_bot_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_bot_logsInclude<ExtArgs> | null
    /**
     * Filter, which user_bot_logs to fetch.
     */
    where?: user_bot_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_bot_logs to fetch.
     */
    orderBy?: user_bot_logsOrderByWithRelationInput | user_bot_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_bot_logs.
     */
    cursor?: user_bot_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_bot_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_bot_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_bot_logs.
     */
    distinct?: User_bot_logsScalarFieldEnum | User_bot_logsScalarFieldEnum[]
  }


  /**
   * user_bot_logs findFirstOrThrow
   */
  export type user_bot_logsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_bot_logs
     */
    select?: user_bot_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_bot_logsInclude<ExtArgs> | null
    /**
     * Filter, which user_bot_logs to fetch.
     */
    where?: user_bot_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_bot_logs to fetch.
     */
    orderBy?: user_bot_logsOrderByWithRelationInput | user_bot_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_bot_logs.
     */
    cursor?: user_bot_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_bot_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_bot_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_bot_logs.
     */
    distinct?: User_bot_logsScalarFieldEnum | User_bot_logsScalarFieldEnum[]
  }


  /**
   * user_bot_logs findMany
   */
  export type user_bot_logsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_bot_logs
     */
    select?: user_bot_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_bot_logsInclude<ExtArgs> | null
    /**
     * Filter, which user_bot_logs to fetch.
     */
    where?: user_bot_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_bot_logs to fetch.
     */
    orderBy?: user_bot_logsOrderByWithRelationInput | user_bot_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_bot_logs.
     */
    cursor?: user_bot_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_bot_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_bot_logs.
     */
    skip?: number
    distinct?: User_bot_logsScalarFieldEnum | User_bot_logsScalarFieldEnum[]
  }


  /**
   * user_bot_logs create
   */
  export type user_bot_logsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_bot_logs
     */
    select?: user_bot_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_bot_logsInclude<ExtArgs> | null
    /**
     * The data needed to create a user_bot_logs.
     */
    data: XOR<user_bot_logsCreateInput, user_bot_logsUncheckedCreateInput>
  }


  /**
   * user_bot_logs createMany
   */
  export type user_bot_logsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many user_bot_logs.
     */
    data: user_bot_logsCreateManyInput | user_bot_logsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * user_bot_logs update
   */
  export type user_bot_logsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_bot_logs
     */
    select?: user_bot_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_bot_logsInclude<ExtArgs> | null
    /**
     * The data needed to update a user_bot_logs.
     */
    data: XOR<user_bot_logsUpdateInput, user_bot_logsUncheckedUpdateInput>
    /**
     * Choose, which user_bot_logs to update.
     */
    where: user_bot_logsWhereUniqueInput
  }


  /**
   * user_bot_logs updateMany
   */
  export type user_bot_logsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update user_bot_logs.
     */
    data: XOR<user_bot_logsUpdateManyMutationInput, user_bot_logsUncheckedUpdateManyInput>
    /**
     * Filter which user_bot_logs to update
     */
    where?: user_bot_logsWhereInput
  }


  /**
   * user_bot_logs upsert
   */
  export type user_bot_logsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_bot_logs
     */
    select?: user_bot_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_bot_logsInclude<ExtArgs> | null
    /**
     * The filter to search for the user_bot_logs to update in case it exists.
     */
    where: user_bot_logsWhereUniqueInput
    /**
     * In case the user_bot_logs found by the `where` argument doesn't exist, create a new user_bot_logs with this data.
     */
    create: XOR<user_bot_logsCreateInput, user_bot_logsUncheckedCreateInput>
    /**
     * In case the user_bot_logs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<user_bot_logsUpdateInput, user_bot_logsUncheckedUpdateInput>
  }


  /**
   * user_bot_logs delete
   */
  export type user_bot_logsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_bot_logs
     */
    select?: user_bot_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_bot_logsInclude<ExtArgs> | null
    /**
     * Filter which user_bot_logs to delete.
     */
    where: user_bot_logsWhereUniqueInput
  }


  /**
   * user_bot_logs deleteMany
   */
  export type user_bot_logsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_bot_logs to delete
     */
    where?: user_bot_logsWhereInput
  }


  /**
   * user_bot_logs without action
   */
  export type user_bot_logsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_bot_logs
     */
    select?: user_bot_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_bot_logsInclude<ExtArgs> | null
  }



  /**
   * Model user_connections
   */

  export type AggregateUser_connections = {
    _count: User_connectionsCountAggregateOutputType | null
    _avg: User_connectionsAvgAggregateOutputType | null
    _sum: User_connectionsSumAggregateOutputType | null
    _min: User_connectionsMinAggregateOutputType | null
    _max: User_connectionsMaxAggregateOutputType | null
  }

  export type User_connectionsAvgAggregateOutputType = {
    user_id: number | null
  }

  export type User_connectionsSumAggregateOutputType = {
    user_id: bigint | null
  }

  export type User_connectionsMinAggregateOutputType = {
    user_id: bigint | null
    client_id: string | null
    refresh_token: string | null
    expires_on: Date | null
    lynxtag: string | null
  }

  export type User_connectionsMaxAggregateOutputType = {
    user_id: bigint | null
    client_id: string | null
    refresh_token: string | null
    expires_on: Date | null
    lynxtag: string | null
  }

  export type User_connectionsCountAggregateOutputType = {
    user_id: number
    client_id: number
    refresh_token: number
    expires_on: number
    lynxtag: number
    _all: number
  }


  export type User_connectionsAvgAggregateInputType = {
    user_id?: true
  }

  export type User_connectionsSumAggregateInputType = {
    user_id?: true
  }

  export type User_connectionsMinAggregateInputType = {
    user_id?: true
    client_id?: true
    refresh_token?: true
    expires_on?: true
    lynxtag?: true
  }

  export type User_connectionsMaxAggregateInputType = {
    user_id?: true
    client_id?: true
    refresh_token?: true
    expires_on?: true
    lynxtag?: true
  }

  export type User_connectionsCountAggregateInputType = {
    user_id?: true
    client_id?: true
    refresh_token?: true
    expires_on?: true
    lynxtag?: true
    _all?: true
  }

  export type User_connectionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_connections to aggregate.
     */
    where?: user_connectionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_connections to fetch.
     */
    orderBy?: user_connectionsOrderByWithRelationInput | user_connectionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: user_connectionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_connections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_connections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_connections
    **/
    _count?: true | User_connectionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: User_connectionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: User_connectionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_connectionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_connectionsMaxAggregateInputType
  }

  export type GetUser_connectionsAggregateType<T extends User_connectionsAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_connections]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_connections[P]>
      : GetScalarType<T[P], AggregateUser_connections[P]>
  }




  export type user_connectionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_connectionsWhereInput
    orderBy?: user_connectionsOrderByWithAggregationInput | user_connectionsOrderByWithAggregationInput[]
    by: User_connectionsScalarFieldEnum[] | User_connectionsScalarFieldEnum
    having?: user_connectionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_connectionsCountAggregateInputType | true
    _avg?: User_connectionsAvgAggregateInputType
    _sum?: User_connectionsSumAggregateInputType
    _min?: User_connectionsMinAggregateInputType
    _max?: User_connectionsMaxAggregateInputType
  }

  export type User_connectionsGroupByOutputType = {
    user_id: bigint
    client_id: string
    refresh_token: string
    expires_on: Date
    lynxtag: string
    _count: User_connectionsCountAggregateOutputType | null
    _avg: User_connectionsAvgAggregateOutputType | null
    _sum: User_connectionsSumAggregateOutputType | null
    _min: User_connectionsMinAggregateOutputType | null
    _max: User_connectionsMaxAggregateOutputType | null
  }

  type GetUser_connectionsGroupByPayload<T extends user_connectionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<User_connectionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_connectionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_connectionsGroupByOutputType[P]>
            : GetScalarType<T[P], User_connectionsGroupByOutputType[P]>
        }
      >
    >


  export type user_connectionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    client_id?: boolean
    refresh_token?: boolean
    expires_on?: boolean
    lynxtag?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_connections"]>

  export type user_connectionsSelectScalar = {
    user_id?: boolean
    client_id?: boolean
    refresh_token?: boolean
    expires_on?: boolean
    lynxtag?: boolean
  }

  export type user_connectionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }


  export type $user_connectionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user_connections"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      user_id: bigint
      client_id: string
      refresh_token: string
      expires_on: Date
      lynxtag: string
    }, ExtArgs["result"]["user_connections"]>
    composites: {}
  }


  type user_connectionsGetPayload<S extends boolean | null | undefined | user_connectionsDefaultArgs> = $Result.GetResult<Prisma.$user_connectionsPayload, S>

  type user_connectionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<user_connectionsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: User_connectionsCountAggregateInputType | true
    }

  export interface user_connectionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user_connections'], meta: { name: 'user_connections' } }
    /**
     * Find zero or one User_connections that matches the filter.
     * @param {user_connectionsFindUniqueArgs} args - Arguments to find a User_connections
     * @example
     * // Get one User_connections
     * const user_connections = await prisma.user_connections.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends user_connectionsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, user_connectionsFindUniqueArgs<ExtArgs>>
    ): Prisma__user_connectionsClient<$Result.GetResult<Prisma.$user_connectionsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one User_connections that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {user_connectionsFindUniqueOrThrowArgs} args - Arguments to find a User_connections
     * @example
     * // Get one User_connections
     * const user_connections = await prisma.user_connections.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends user_connectionsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, user_connectionsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__user_connectionsClient<$Result.GetResult<Prisma.$user_connectionsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first User_connections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_connectionsFindFirstArgs} args - Arguments to find a User_connections
     * @example
     * // Get one User_connections
     * const user_connections = await prisma.user_connections.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends user_connectionsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, user_connectionsFindFirstArgs<ExtArgs>>
    ): Prisma__user_connectionsClient<$Result.GetResult<Prisma.$user_connectionsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first User_connections that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_connectionsFindFirstOrThrowArgs} args - Arguments to find a User_connections
     * @example
     * // Get one User_connections
     * const user_connections = await prisma.user_connections.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends user_connectionsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, user_connectionsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__user_connectionsClient<$Result.GetResult<Prisma.$user_connectionsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more User_connections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_connectionsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_connections
     * const user_connections = await prisma.user_connections.findMany()
     * 
     * // Get first 10 User_connections
     * const user_connections = await prisma.user_connections.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const user_connectionsWithUser_idOnly = await prisma.user_connections.findMany({ select: { user_id: true } })
     * 
    **/
    findMany<T extends user_connectionsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, user_connectionsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_connectionsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a User_connections.
     * @param {user_connectionsCreateArgs} args - Arguments to create a User_connections.
     * @example
     * // Create one User_connections
     * const User_connections = await prisma.user_connections.create({
     *   data: {
     *     // ... data to create a User_connections
     *   }
     * })
     * 
    **/
    create<T extends user_connectionsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, user_connectionsCreateArgs<ExtArgs>>
    ): Prisma__user_connectionsClient<$Result.GetResult<Prisma.$user_connectionsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many User_connections.
     *     @param {user_connectionsCreateManyArgs} args - Arguments to create many User_connections.
     *     @example
     *     // Create many User_connections
     *     const user_connections = await prisma.user_connections.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends user_connectionsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, user_connectionsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User_connections.
     * @param {user_connectionsDeleteArgs} args - Arguments to delete one User_connections.
     * @example
     * // Delete one User_connections
     * const User_connections = await prisma.user_connections.delete({
     *   where: {
     *     // ... filter to delete one User_connections
     *   }
     * })
     * 
    **/
    delete<T extends user_connectionsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, user_connectionsDeleteArgs<ExtArgs>>
    ): Prisma__user_connectionsClient<$Result.GetResult<Prisma.$user_connectionsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one User_connections.
     * @param {user_connectionsUpdateArgs} args - Arguments to update one User_connections.
     * @example
     * // Update one User_connections
     * const user_connections = await prisma.user_connections.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends user_connectionsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, user_connectionsUpdateArgs<ExtArgs>>
    ): Prisma__user_connectionsClient<$Result.GetResult<Prisma.$user_connectionsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more User_connections.
     * @param {user_connectionsDeleteManyArgs} args - Arguments to filter User_connections to delete.
     * @example
     * // Delete a few User_connections
     * const { count } = await prisma.user_connections.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends user_connectionsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, user_connectionsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_connections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_connectionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_connections
     * const user_connections = await prisma.user_connections.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends user_connectionsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, user_connectionsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User_connections.
     * @param {user_connectionsUpsertArgs} args - Arguments to update or create a User_connections.
     * @example
     * // Update or create a User_connections
     * const user_connections = await prisma.user_connections.upsert({
     *   create: {
     *     // ... data to create a User_connections
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_connections we want to update
     *   }
     * })
    **/
    upsert<T extends user_connectionsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, user_connectionsUpsertArgs<ExtArgs>>
    ): Prisma__user_connectionsClient<$Result.GetResult<Prisma.$user_connectionsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of User_connections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_connectionsCountArgs} args - Arguments to filter User_connections to count.
     * @example
     * // Count the number of User_connections
     * const count = await prisma.user_connections.count({
     *   where: {
     *     // ... the filter for the User_connections we want to count
     *   }
     * })
    **/
    count<T extends user_connectionsCountArgs>(
      args?: Subset<T, user_connectionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_connectionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_connections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_connectionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_connectionsAggregateArgs>(args: Subset<T, User_connectionsAggregateArgs>): Prisma.PrismaPromise<GetUser_connectionsAggregateType<T>>

    /**
     * Group by User_connections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_connectionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends user_connectionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: user_connectionsGroupByArgs['orderBy'] }
        : { orderBy?: user_connectionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, user_connectionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_connectionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user_connections model
   */
  readonly fields: user_connectionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user_connections.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__user_connectionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the user_connections model
   */ 
  interface user_connectionsFieldRefs {
    readonly user_id: FieldRef<"user_connections", 'BigInt'>
    readonly client_id: FieldRef<"user_connections", 'String'>
    readonly refresh_token: FieldRef<"user_connections", 'String'>
    readonly expires_on: FieldRef<"user_connections", 'DateTime'>
    readonly lynxtag: FieldRef<"user_connections", 'String'>
  }
    

  // Custom InputTypes

  /**
   * user_connections findUnique
   */
  export type user_connectionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_connections
     */
    select?: user_connectionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_connectionsInclude<ExtArgs> | null
    /**
     * Filter, which user_connections to fetch.
     */
    where: user_connectionsWhereUniqueInput
  }


  /**
   * user_connections findUniqueOrThrow
   */
  export type user_connectionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_connections
     */
    select?: user_connectionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_connectionsInclude<ExtArgs> | null
    /**
     * Filter, which user_connections to fetch.
     */
    where: user_connectionsWhereUniqueInput
  }


  /**
   * user_connections findFirst
   */
  export type user_connectionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_connections
     */
    select?: user_connectionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_connectionsInclude<ExtArgs> | null
    /**
     * Filter, which user_connections to fetch.
     */
    where?: user_connectionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_connections to fetch.
     */
    orderBy?: user_connectionsOrderByWithRelationInput | user_connectionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_connections.
     */
    cursor?: user_connectionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_connections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_connections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_connections.
     */
    distinct?: User_connectionsScalarFieldEnum | User_connectionsScalarFieldEnum[]
  }


  /**
   * user_connections findFirstOrThrow
   */
  export type user_connectionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_connections
     */
    select?: user_connectionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_connectionsInclude<ExtArgs> | null
    /**
     * Filter, which user_connections to fetch.
     */
    where?: user_connectionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_connections to fetch.
     */
    orderBy?: user_connectionsOrderByWithRelationInput | user_connectionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_connections.
     */
    cursor?: user_connectionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_connections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_connections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_connections.
     */
    distinct?: User_connectionsScalarFieldEnum | User_connectionsScalarFieldEnum[]
  }


  /**
   * user_connections findMany
   */
  export type user_connectionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_connections
     */
    select?: user_connectionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_connectionsInclude<ExtArgs> | null
    /**
     * Filter, which user_connections to fetch.
     */
    where?: user_connectionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_connections to fetch.
     */
    orderBy?: user_connectionsOrderByWithRelationInput | user_connectionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_connections.
     */
    cursor?: user_connectionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_connections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_connections.
     */
    skip?: number
    distinct?: User_connectionsScalarFieldEnum | User_connectionsScalarFieldEnum[]
  }


  /**
   * user_connections create
   */
  export type user_connectionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_connections
     */
    select?: user_connectionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_connectionsInclude<ExtArgs> | null
    /**
     * The data needed to create a user_connections.
     */
    data: XOR<user_connectionsCreateInput, user_connectionsUncheckedCreateInput>
  }


  /**
   * user_connections createMany
   */
  export type user_connectionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many user_connections.
     */
    data: user_connectionsCreateManyInput | user_connectionsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * user_connections update
   */
  export type user_connectionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_connections
     */
    select?: user_connectionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_connectionsInclude<ExtArgs> | null
    /**
     * The data needed to update a user_connections.
     */
    data: XOR<user_connectionsUpdateInput, user_connectionsUncheckedUpdateInput>
    /**
     * Choose, which user_connections to update.
     */
    where: user_connectionsWhereUniqueInput
  }


  /**
   * user_connections updateMany
   */
  export type user_connectionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update user_connections.
     */
    data: XOR<user_connectionsUpdateManyMutationInput, user_connectionsUncheckedUpdateManyInput>
    /**
     * Filter which user_connections to update
     */
    where?: user_connectionsWhereInput
  }


  /**
   * user_connections upsert
   */
  export type user_connectionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_connections
     */
    select?: user_connectionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_connectionsInclude<ExtArgs> | null
    /**
     * The filter to search for the user_connections to update in case it exists.
     */
    where: user_connectionsWhereUniqueInput
    /**
     * In case the user_connections found by the `where` argument doesn't exist, create a new user_connections with this data.
     */
    create: XOR<user_connectionsCreateInput, user_connectionsUncheckedCreateInput>
    /**
     * In case the user_connections was found with the provided `where` argument, update it with this data.
     */
    update: XOR<user_connectionsUpdateInput, user_connectionsUncheckedUpdateInput>
  }


  /**
   * user_connections delete
   */
  export type user_connectionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_connections
     */
    select?: user_connectionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_connectionsInclude<ExtArgs> | null
    /**
     * Filter which user_connections to delete.
     */
    where: user_connectionsWhereUniqueInput
  }


  /**
   * user_connections deleteMany
   */
  export type user_connectionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_connections to delete
     */
    where?: user_connectionsWhereInput
  }


  /**
   * user_connections without action
   */
  export type user_connectionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_connections
     */
    select?: user_connectionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_connectionsInclude<ExtArgs> | null
  }



  /**
   * Model user_server_vote_table
   */

  export type AggregateUser_server_vote_table = {
    _count: User_server_vote_tableCountAggregateOutputType | null
    _avg: User_server_vote_tableAvgAggregateOutputType | null
    _sum: User_server_vote_tableSumAggregateOutputType | null
    _min: User_server_vote_tableMinAggregateOutputType | null
    _max: User_server_vote_tableMaxAggregateOutputType | null
  }

  export type User_server_vote_tableAvgAggregateOutputType = {
    user_id: number | null
    guild_id: number | null
  }

  export type User_server_vote_tableSumAggregateOutputType = {
    user_id: bigint | null
    guild_id: bigint | null
  }

  export type User_server_vote_tableMinAggregateOutputType = {
    user_id: bigint | null
    guild_id: bigint | null
    expires_on: Date | null
    lynxtag: string | null
  }

  export type User_server_vote_tableMaxAggregateOutputType = {
    user_id: bigint | null
    guild_id: bigint | null
    expires_on: Date | null
    lynxtag: string | null
  }

  export type User_server_vote_tableCountAggregateOutputType = {
    user_id: number
    guild_id: number
    expires_on: number
    lynxtag: number
    _all: number
  }


  export type User_server_vote_tableAvgAggregateInputType = {
    user_id?: true
    guild_id?: true
  }

  export type User_server_vote_tableSumAggregateInputType = {
    user_id?: true
    guild_id?: true
  }

  export type User_server_vote_tableMinAggregateInputType = {
    user_id?: true
    guild_id?: true
    expires_on?: true
    lynxtag?: true
  }

  export type User_server_vote_tableMaxAggregateInputType = {
    user_id?: true
    guild_id?: true
    expires_on?: true
    lynxtag?: true
  }

  export type User_server_vote_tableCountAggregateInputType = {
    user_id?: true
    guild_id?: true
    expires_on?: true
    lynxtag?: true
    _all?: true
  }

  export type User_server_vote_tableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_server_vote_table to aggregate.
     */
    where?: user_server_vote_tableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_server_vote_tables to fetch.
     */
    orderBy?: user_server_vote_tableOrderByWithRelationInput | user_server_vote_tableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: user_server_vote_tableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_server_vote_tables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_server_vote_tables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_server_vote_tables
    **/
    _count?: true | User_server_vote_tableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: User_server_vote_tableAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: User_server_vote_tableSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_server_vote_tableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_server_vote_tableMaxAggregateInputType
  }

  export type GetUser_server_vote_tableAggregateType<T extends User_server_vote_tableAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_server_vote_table]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_server_vote_table[P]>
      : GetScalarType<T[P], AggregateUser_server_vote_table[P]>
  }




  export type user_server_vote_tableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_server_vote_tableWhereInput
    orderBy?: user_server_vote_tableOrderByWithAggregationInput | user_server_vote_tableOrderByWithAggregationInput[]
    by: User_server_vote_tableScalarFieldEnum[] | User_server_vote_tableScalarFieldEnum
    having?: user_server_vote_tableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_server_vote_tableCountAggregateInputType | true
    _avg?: User_server_vote_tableAvgAggregateInputType
    _sum?: User_server_vote_tableSumAggregateInputType
    _min?: User_server_vote_tableMinAggregateInputType
    _max?: User_server_vote_tableMaxAggregateInputType
  }

  export type User_server_vote_tableGroupByOutputType = {
    user_id: bigint
    guild_id: bigint
    expires_on: Date | null
    lynxtag: string
    _count: User_server_vote_tableCountAggregateOutputType | null
    _avg: User_server_vote_tableAvgAggregateOutputType | null
    _sum: User_server_vote_tableSumAggregateOutputType | null
    _min: User_server_vote_tableMinAggregateOutputType | null
    _max: User_server_vote_tableMaxAggregateOutputType | null
  }

  type GetUser_server_vote_tableGroupByPayload<T extends user_server_vote_tableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<User_server_vote_tableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_server_vote_tableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_server_vote_tableGroupByOutputType[P]>
            : GetScalarType<T[P], User_server_vote_tableGroupByOutputType[P]>
        }
      >
    >


  export type user_server_vote_tableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    guild_id?: boolean
    expires_on?: boolean
    lynxtag?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_server_vote_table"]>

  export type user_server_vote_tableSelectScalar = {
    user_id?: boolean
    guild_id?: boolean
    expires_on?: boolean
    lynxtag?: boolean
  }

  export type user_server_vote_tableInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }


  export type $user_server_vote_tablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user_server_vote_table"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      user_id: bigint
      guild_id: bigint
      expires_on: Date | null
      lynxtag: string
    }, ExtArgs["result"]["user_server_vote_table"]>
    composites: {}
  }


  type user_server_vote_tableGetPayload<S extends boolean | null | undefined | user_server_vote_tableDefaultArgs> = $Result.GetResult<Prisma.$user_server_vote_tablePayload, S>

  type user_server_vote_tableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<user_server_vote_tableFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: User_server_vote_tableCountAggregateInputType | true
    }

  export interface user_server_vote_tableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user_server_vote_table'], meta: { name: 'user_server_vote_table' } }
    /**
     * Find zero or one User_server_vote_table that matches the filter.
     * @param {user_server_vote_tableFindUniqueArgs} args - Arguments to find a User_server_vote_table
     * @example
     * // Get one User_server_vote_table
     * const user_server_vote_table = await prisma.user_server_vote_table.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends user_server_vote_tableFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, user_server_vote_tableFindUniqueArgs<ExtArgs>>
    ): Prisma__user_server_vote_tableClient<$Result.GetResult<Prisma.$user_server_vote_tablePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one User_server_vote_table that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {user_server_vote_tableFindUniqueOrThrowArgs} args - Arguments to find a User_server_vote_table
     * @example
     * // Get one User_server_vote_table
     * const user_server_vote_table = await prisma.user_server_vote_table.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends user_server_vote_tableFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, user_server_vote_tableFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__user_server_vote_tableClient<$Result.GetResult<Prisma.$user_server_vote_tablePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first User_server_vote_table that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_server_vote_tableFindFirstArgs} args - Arguments to find a User_server_vote_table
     * @example
     * // Get one User_server_vote_table
     * const user_server_vote_table = await prisma.user_server_vote_table.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends user_server_vote_tableFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, user_server_vote_tableFindFirstArgs<ExtArgs>>
    ): Prisma__user_server_vote_tableClient<$Result.GetResult<Prisma.$user_server_vote_tablePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first User_server_vote_table that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_server_vote_tableFindFirstOrThrowArgs} args - Arguments to find a User_server_vote_table
     * @example
     * // Get one User_server_vote_table
     * const user_server_vote_table = await prisma.user_server_vote_table.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends user_server_vote_tableFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, user_server_vote_tableFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__user_server_vote_tableClient<$Result.GetResult<Prisma.$user_server_vote_tablePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more User_server_vote_tables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_server_vote_tableFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_server_vote_tables
     * const user_server_vote_tables = await prisma.user_server_vote_table.findMany()
     * 
     * // Get first 10 User_server_vote_tables
     * const user_server_vote_tables = await prisma.user_server_vote_table.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const user_server_vote_tableWithUser_idOnly = await prisma.user_server_vote_table.findMany({ select: { user_id: true } })
     * 
    **/
    findMany<T extends user_server_vote_tableFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, user_server_vote_tableFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_server_vote_tablePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a User_server_vote_table.
     * @param {user_server_vote_tableCreateArgs} args - Arguments to create a User_server_vote_table.
     * @example
     * // Create one User_server_vote_table
     * const User_server_vote_table = await prisma.user_server_vote_table.create({
     *   data: {
     *     // ... data to create a User_server_vote_table
     *   }
     * })
     * 
    **/
    create<T extends user_server_vote_tableCreateArgs<ExtArgs>>(
      args: SelectSubset<T, user_server_vote_tableCreateArgs<ExtArgs>>
    ): Prisma__user_server_vote_tableClient<$Result.GetResult<Prisma.$user_server_vote_tablePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many User_server_vote_tables.
     *     @param {user_server_vote_tableCreateManyArgs} args - Arguments to create many User_server_vote_tables.
     *     @example
     *     // Create many User_server_vote_tables
     *     const user_server_vote_table = await prisma.user_server_vote_table.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends user_server_vote_tableCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, user_server_vote_tableCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User_server_vote_table.
     * @param {user_server_vote_tableDeleteArgs} args - Arguments to delete one User_server_vote_table.
     * @example
     * // Delete one User_server_vote_table
     * const User_server_vote_table = await prisma.user_server_vote_table.delete({
     *   where: {
     *     // ... filter to delete one User_server_vote_table
     *   }
     * })
     * 
    **/
    delete<T extends user_server_vote_tableDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, user_server_vote_tableDeleteArgs<ExtArgs>>
    ): Prisma__user_server_vote_tableClient<$Result.GetResult<Prisma.$user_server_vote_tablePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one User_server_vote_table.
     * @param {user_server_vote_tableUpdateArgs} args - Arguments to update one User_server_vote_table.
     * @example
     * // Update one User_server_vote_table
     * const user_server_vote_table = await prisma.user_server_vote_table.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends user_server_vote_tableUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, user_server_vote_tableUpdateArgs<ExtArgs>>
    ): Prisma__user_server_vote_tableClient<$Result.GetResult<Prisma.$user_server_vote_tablePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more User_server_vote_tables.
     * @param {user_server_vote_tableDeleteManyArgs} args - Arguments to filter User_server_vote_tables to delete.
     * @example
     * // Delete a few User_server_vote_tables
     * const { count } = await prisma.user_server_vote_table.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends user_server_vote_tableDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, user_server_vote_tableDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_server_vote_tables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_server_vote_tableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_server_vote_tables
     * const user_server_vote_table = await prisma.user_server_vote_table.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends user_server_vote_tableUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, user_server_vote_tableUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User_server_vote_table.
     * @param {user_server_vote_tableUpsertArgs} args - Arguments to update or create a User_server_vote_table.
     * @example
     * // Update or create a User_server_vote_table
     * const user_server_vote_table = await prisma.user_server_vote_table.upsert({
     *   create: {
     *     // ... data to create a User_server_vote_table
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_server_vote_table we want to update
     *   }
     * })
    **/
    upsert<T extends user_server_vote_tableUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, user_server_vote_tableUpsertArgs<ExtArgs>>
    ): Prisma__user_server_vote_tableClient<$Result.GetResult<Prisma.$user_server_vote_tablePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of User_server_vote_tables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_server_vote_tableCountArgs} args - Arguments to filter User_server_vote_tables to count.
     * @example
     * // Count the number of User_server_vote_tables
     * const count = await prisma.user_server_vote_table.count({
     *   where: {
     *     // ... the filter for the User_server_vote_tables we want to count
     *   }
     * })
    **/
    count<T extends user_server_vote_tableCountArgs>(
      args?: Subset<T, user_server_vote_tableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_server_vote_tableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_server_vote_table.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_server_vote_tableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_server_vote_tableAggregateArgs>(args: Subset<T, User_server_vote_tableAggregateArgs>): Prisma.PrismaPromise<GetUser_server_vote_tableAggregateType<T>>

    /**
     * Group by User_server_vote_table.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_server_vote_tableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends user_server_vote_tableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: user_server_vote_tableGroupByArgs['orderBy'] }
        : { orderBy?: user_server_vote_tableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, user_server_vote_tableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_server_vote_tableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user_server_vote_table model
   */
  readonly fields: user_server_vote_tableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user_server_vote_table.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__user_server_vote_tableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the user_server_vote_table model
   */ 
  interface user_server_vote_tableFieldRefs {
    readonly user_id: FieldRef<"user_server_vote_table", 'BigInt'>
    readonly guild_id: FieldRef<"user_server_vote_table", 'BigInt'>
    readonly expires_on: FieldRef<"user_server_vote_table", 'DateTime'>
    readonly lynxtag: FieldRef<"user_server_vote_table", 'String'>
  }
    

  // Custom InputTypes

  /**
   * user_server_vote_table findUnique
   */
  export type user_server_vote_tableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_server_vote_table
     */
    select?: user_server_vote_tableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_server_vote_tableInclude<ExtArgs> | null
    /**
     * Filter, which user_server_vote_table to fetch.
     */
    where: user_server_vote_tableWhereUniqueInput
  }


  /**
   * user_server_vote_table findUniqueOrThrow
   */
  export type user_server_vote_tableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_server_vote_table
     */
    select?: user_server_vote_tableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_server_vote_tableInclude<ExtArgs> | null
    /**
     * Filter, which user_server_vote_table to fetch.
     */
    where: user_server_vote_tableWhereUniqueInput
  }


  /**
   * user_server_vote_table findFirst
   */
  export type user_server_vote_tableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_server_vote_table
     */
    select?: user_server_vote_tableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_server_vote_tableInclude<ExtArgs> | null
    /**
     * Filter, which user_server_vote_table to fetch.
     */
    where?: user_server_vote_tableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_server_vote_tables to fetch.
     */
    orderBy?: user_server_vote_tableOrderByWithRelationInput | user_server_vote_tableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_server_vote_tables.
     */
    cursor?: user_server_vote_tableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_server_vote_tables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_server_vote_tables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_server_vote_tables.
     */
    distinct?: User_server_vote_tableScalarFieldEnum | User_server_vote_tableScalarFieldEnum[]
  }


  /**
   * user_server_vote_table findFirstOrThrow
   */
  export type user_server_vote_tableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_server_vote_table
     */
    select?: user_server_vote_tableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_server_vote_tableInclude<ExtArgs> | null
    /**
     * Filter, which user_server_vote_table to fetch.
     */
    where?: user_server_vote_tableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_server_vote_tables to fetch.
     */
    orderBy?: user_server_vote_tableOrderByWithRelationInput | user_server_vote_tableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_server_vote_tables.
     */
    cursor?: user_server_vote_tableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_server_vote_tables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_server_vote_tables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_server_vote_tables.
     */
    distinct?: User_server_vote_tableScalarFieldEnum | User_server_vote_tableScalarFieldEnum[]
  }


  /**
   * user_server_vote_table findMany
   */
  export type user_server_vote_tableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_server_vote_table
     */
    select?: user_server_vote_tableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_server_vote_tableInclude<ExtArgs> | null
    /**
     * Filter, which user_server_vote_tables to fetch.
     */
    where?: user_server_vote_tableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_server_vote_tables to fetch.
     */
    orderBy?: user_server_vote_tableOrderByWithRelationInput | user_server_vote_tableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_server_vote_tables.
     */
    cursor?: user_server_vote_tableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_server_vote_tables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_server_vote_tables.
     */
    skip?: number
    distinct?: User_server_vote_tableScalarFieldEnum | User_server_vote_tableScalarFieldEnum[]
  }


  /**
   * user_server_vote_table create
   */
  export type user_server_vote_tableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_server_vote_table
     */
    select?: user_server_vote_tableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_server_vote_tableInclude<ExtArgs> | null
    /**
     * The data needed to create a user_server_vote_table.
     */
    data: XOR<user_server_vote_tableCreateInput, user_server_vote_tableUncheckedCreateInput>
  }


  /**
   * user_server_vote_table createMany
   */
  export type user_server_vote_tableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many user_server_vote_tables.
     */
    data: user_server_vote_tableCreateManyInput | user_server_vote_tableCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * user_server_vote_table update
   */
  export type user_server_vote_tableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_server_vote_table
     */
    select?: user_server_vote_tableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_server_vote_tableInclude<ExtArgs> | null
    /**
     * The data needed to update a user_server_vote_table.
     */
    data: XOR<user_server_vote_tableUpdateInput, user_server_vote_tableUncheckedUpdateInput>
    /**
     * Choose, which user_server_vote_table to update.
     */
    where: user_server_vote_tableWhereUniqueInput
  }


  /**
   * user_server_vote_table updateMany
   */
  export type user_server_vote_tableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update user_server_vote_tables.
     */
    data: XOR<user_server_vote_tableUpdateManyMutationInput, user_server_vote_tableUncheckedUpdateManyInput>
    /**
     * Filter which user_server_vote_tables to update
     */
    where?: user_server_vote_tableWhereInput
  }


  /**
   * user_server_vote_table upsert
   */
  export type user_server_vote_tableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_server_vote_table
     */
    select?: user_server_vote_tableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_server_vote_tableInclude<ExtArgs> | null
    /**
     * The filter to search for the user_server_vote_table to update in case it exists.
     */
    where: user_server_vote_tableWhereUniqueInput
    /**
     * In case the user_server_vote_table found by the `where` argument doesn't exist, create a new user_server_vote_table with this data.
     */
    create: XOR<user_server_vote_tableCreateInput, user_server_vote_tableUncheckedCreateInput>
    /**
     * In case the user_server_vote_table was found with the provided `where` argument, update it with this data.
     */
    update: XOR<user_server_vote_tableUpdateInput, user_server_vote_tableUncheckedUpdateInput>
  }


  /**
   * user_server_vote_table delete
   */
  export type user_server_vote_tableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_server_vote_table
     */
    select?: user_server_vote_tableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_server_vote_tableInclude<ExtArgs> | null
    /**
     * Filter which user_server_vote_table to delete.
     */
    where: user_server_vote_tableWhereUniqueInput
  }


  /**
   * user_server_vote_table deleteMany
   */
  export type user_server_vote_tableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_server_vote_tables to delete
     */
    where?: user_server_vote_tableWhereInput
  }


  /**
   * user_server_vote_table without action
   */
  export type user_server_vote_tableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_server_vote_table
     */
    select?: user_server_vote_tableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_server_vote_tableInclude<ExtArgs> | null
  }



  /**
   * Model user_vote_table
   */

  export type AggregateUser_vote_table = {
    _count: User_vote_tableCountAggregateOutputType | null
    _avg: User_vote_tableAvgAggregateOutputType | null
    _sum: User_vote_tableSumAggregateOutputType | null
    _min: User_vote_tableMinAggregateOutputType | null
    _max: User_vote_tableMaxAggregateOutputType | null
  }

  export type User_vote_tableAvgAggregateOutputType = {
    user_id: number | null
    bot_id: number | null
  }

  export type User_vote_tableSumAggregateOutputType = {
    user_id: bigint | null
    bot_id: bigint | null
  }

  export type User_vote_tableMinAggregateOutputType = {
    user_id: bigint | null
    bot_id: bigint | null
    expires_on: Date | null
    lynxtag: string | null
  }

  export type User_vote_tableMaxAggregateOutputType = {
    user_id: bigint | null
    bot_id: bigint | null
    expires_on: Date | null
    lynxtag: string | null
  }

  export type User_vote_tableCountAggregateOutputType = {
    user_id: number
    bot_id: number
    expires_on: number
    lynxtag: number
    _all: number
  }


  export type User_vote_tableAvgAggregateInputType = {
    user_id?: true
    bot_id?: true
  }

  export type User_vote_tableSumAggregateInputType = {
    user_id?: true
    bot_id?: true
  }

  export type User_vote_tableMinAggregateInputType = {
    user_id?: true
    bot_id?: true
    expires_on?: true
    lynxtag?: true
  }

  export type User_vote_tableMaxAggregateInputType = {
    user_id?: true
    bot_id?: true
    expires_on?: true
    lynxtag?: true
  }

  export type User_vote_tableCountAggregateInputType = {
    user_id?: true
    bot_id?: true
    expires_on?: true
    lynxtag?: true
    _all?: true
  }

  export type User_vote_tableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_vote_table to aggregate.
     */
    where?: user_vote_tableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_vote_tables to fetch.
     */
    orderBy?: user_vote_tableOrderByWithRelationInput | user_vote_tableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: user_vote_tableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_vote_tables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_vote_tables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_vote_tables
    **/
    _count?: true | User_vote_tableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: User_vote_tableAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: User_vote_tableSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_vote_tableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_vote_tableMaxAggregateInputType
  }

  export type GetUser_vote_tableAggregateType<T extends User_vote_tableAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_vote_table]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_vote_table[P]>
      : GetScalarType<T[P], AggregateUser_vote_table[P]>
  }




  export type user_vote_tableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_vote_tableWhereInput
    orderBy?: user_vote_tableOrderByWithAggregationInput | user_vote_tableOrderByWithAggregationInput[]
    by: User_vote_tableScalarFieldEnum[] | User_vote_tableScalarFieldEnum
    having?: user_vote_tableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_vote_tableCountAggregateInputType | true
    _avg?: User_vote_tableAvgAggregateInputType
    _sum?: User_vote_tableSumAggregateInputType
    _min?: User_vote_tableMinAggregateInputType
    _max?: User_vote_tableMaxAggregateInputType
  }

  export type User_vote_tableGroupByOutputType = {
    user_id: bigint
    bot_id: bigint
    expires_on: Date | null
    lynxtag: string
    _count: User_vote_tableCountAggregateOutputType | null
    _avg: User_vote_tableAvgAggregateOutputType | null
    _sum: User_vote_tableSumAggregateOutputType | null
    _min: User_vote_tableMinAggregateOutputType | null
    _max: User_vote_tableMaxAggregateOutputType | null
  }

  type GetUser_vote_tableGroupByPayload<T extends user_vote_tableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<User_vote_tableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_vote_tableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_vote_tableGroupByOutputType[P]>
            : GetScalarType<T[P], User_vote_tableGroupByOutputType[P]>
        }
      >
    >


  export type user_vote_tableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    bot_id?: boolean
    expires_on?: boolean
    lynxtag?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_vote_table"]>

  export type user_vote_tableSelectScalar = {
    user_id?: boolean
    bot_id?: boolean
    expires_on?: boolean
    lynxtag?: boolean
  }

  export type user_vote_tableInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }


  export type $user_vote_tablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user_vote_table"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      user_id: bigint
      bot_id: bigint
      expires_on: Date | null
      lynxtag: string
    }, ExtArgs["result"]["user_vote_table"]>
    composites: {}
  }


  type user_vote_tableGetPayload<S extends boolean | null | undefined | user_vote_tableDefaultArgs> = $Result.GetResult<Prisma.$user_vote_tablePayload, S>

  type user_vote_tableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<user_vote_tableFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: User_vote_tableCountAggregateInputType | true
    }

  export interface user_vote_tableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user_vote_table'], meta: { name: 'user_vote_table' } }
    /**
     * Find zero or one User_vote_table that matches the filter.
     * @param {user_vote_tableFindUniqueArgs} args - Arguments to find a User_vote_table
     * @example
     * // Get one User_vote_table
     * const user_vote_table = await prisma.user_vote_table.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends user_vote_tableFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, user_vote_tableFindUniqueArgs<ExtArgs>>
    ): Prisma__user_vote_tableClient<$Result.GetResult<Prisma.$user_vote_tablePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one User_vote_table that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {user_vote_tableFindUniqueOrThrowArgs} args - Arguments to find a User_vote_table
     * @example
     * // Get one User_vote_table
     * const user_vote_table = await prisma.user_vote_table.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends user_vote_tableFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, user_vote_tableFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__user_vote_tableClient<$Result.GetResult<Prisma.$user_vote_tablePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first User_vote_table that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_vote_tableFindFirstArgs} args - Arguments to find a User_vote_table
     * @example
     * // Get one User_vote_table
     * const user_vote_table = await prisma.user_vote_table.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends user_vote_tableFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, user_vote_tableFindFirstArgs<ExtArgs>>
    ): Prisma__user_vote_tableClient<$Result.GetResult<Prisma.$user_vote_tablePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first User_vote_table that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_vote_tableFindFirstOrThrowArgs} args - Arguments to find a User_vote_table
     * @example
     * // Get one User_vote_table
     * const user_vote_table = await prisma.user_vote_table.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends user_vote_tableFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, user_vote_tableFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__user_vote_tableClient<$Result.GetResult<Prisma.$user_vote_tablePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more User_vote_tables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_vote_tableFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_vote_tables
     * const user_vote_tables = await prisma.user_vote_table.findMany()
     * 
     * // Get first 10 User_vote_tables
     * const user_vote_tables = await prisma.user_vote_table.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const user_vote_tableWithUser_idOnly = await prisma.user_vote_table.findMany({ select: { user_id: true } })
     * 
    **/
    findMany<T extends user_vote_tableFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, user_vote_tableFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_vote_tablePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a User_vote_table.
     * @param {user_vote_tableCreateArgs} args - Arguments to create a User_vote_table.
     * @example
     * // Create one User_vote_table
     * const User_vote_table = await prisma.user_vote_table.create({
     *   data: {
     *     // ... data to create a User_vote_table
     *   }
     * })
     * 
    **/
    create<T extends user_vote_tableCreateArgs<ExtArgs>>(
      args: SelectSubset<T, user_vote_tableCreateArgs<ExtArgs>>
    ): Prisma__user_vote_tableClient<$Result.GetResult<Prisma.$user_vote_tablePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many User_vote_tables.
     *     @param {user_vote_tableCreateManyArgs} args - Arguments to create many User_vote_tables.
     *     @example
     *     // Create many User_vote_tables
     *     const user_vote_table = await prisma.user_vote_table.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends user_vote_tableCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, user_vote_tableCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User_vote_table.
     * @param {user_vote_tableDeleteArgs} args - Arguments to delete one User_vote_table.
     * @example
     * // Delete one User_vote_table
     * const User_vote_table = await prisma.user_vote_table.delete({
     *   where: {
     *     // ... filter to delete one User_vote_table
     *   }
     * })
     * 
    **/
    delete<T extends user_vote_tableDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, user_vote_tableDeleteArgs<ExtArgs>>
    ): Prisma__user_vote_tableClient<$Result.GetResult<Prisma.$user_vote_tablePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one User_vote_table.
     * @param {user_vote_tableUpdateArgs} args - Arguments to update one User_vote_table.
     * @example
     * // Update one User_vote_table
     * const user_vote_table = await prisma.user_vote_table.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends user_vote_tableUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, user_vote_tableUpdateArgs<ExtArgs>>
    ): Prisma__user_vote_tableClient<$Result.GetResult<Prisma.$user_vote_tablePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more User_vote_tables.
     * @param {user_vote_tableDeleteManyArgs} args - Arguments to filter User_vote_tables to delete.
     * @example
     * // Delete a few User_vote_tables
     * const { count } = await prisma.user_vote_table.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends user_vote_tableDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, user_vote_tableDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_vote_tables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_vote_tableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_vote_tables
     * const user_vote_table = await prisma.user_vote_table.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends user_vote_tableUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, user_vote_tableUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User_vote_table.
     * @param {user_vote_tableUpsertArgs} args - Arguments to update or create a User_vote_table.
     * @example
     * // Update or create a User_vote_table
     * const user_vote_table = await prisma.user_vote_table.upsert({
     *   create: {
     *     // ... data to create a User_vote_table
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_vote_table we want to update
     *   }
     * })
    **/
    upsert<T extends user_vote_tableUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, user_vote_tableUpsertArgs<ExtArgs>>
    ): Prisma__user_vote_tableClient<$Result.GetResult<Prisma.$user_vote_tablePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of User_vote_tables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_vote_tableCountArgs} args - Arguments to filter User_vote_tables to count.
     * @example
     * // Count the number of User_vote_tables
     * const count = await prisma.user_vote_table.count({
     *   where: {
     *     // ... the filter for the User_vote_tables we want to count
     *   }
     * })
    **/
    count<T extends user_vote_tableCountArgs>(
      args?: Subset<T, user_vote_tableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_vote_tableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_vote_table.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_vote_tableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_vote_tableAggregateArgs>(args: Subset<T, User_vote_tableAggregateArgs>): Prisma.PrismaPromise<GetUser_vote_tableAggregateType<T>>

    /**
     * Group by User_vote_table.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_vote_tableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends user_vote_tableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: user_vote_tableGroupByArgs['orderBy'] }
        : { orderBy?: user_vote_tableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, user_vote_tableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_vote_tableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user_vote_table model
   */
  readonly fields: user_vote_tableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user_vote_table.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__user_vote_tableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the user_vote_table model
   */ 
  interface user_vote_tableFieldRefs {
    readonly user_id: FieldRef<"user_vote_table", 'BigInt'>
    readonly bot_id: FieldRef<"user_vote_table", 'BigInt'>
    readonly expires_on: FieldRef<"user_vote_table", 'DateTime'>
    readonly lynxtag: FieldRef<"user_vote_table", 'String'>
  }
    

  // Custom InputTypes

  /**
   * user_vote_table findUnique
   */
  export type user_vote_tableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_vote_table
     */
    select?: user_vote_tableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_vote_tableInclude<ExtArgs> | null
    /**
     * Filter, which user_vote_table to fetch.
     */
    where: user_vote_tableWhereUniqueInput
  }


  /**
   * user_vote_table findUniqueOrThrow
   */
  export type user_vote_tableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_vote_table
     */
    select?: user_vote_tableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_vote_tableInclude<ExtArgs> | null
    /**
     * Filter, which user_vote_table to fetch.
     */
    where: user_vote_tableWhereUniqueInput
  }


  /**
   * user_vote_table findFirst
   */
  export type user_vote_tableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_vote_table
     */
    select?: user_vote_tableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_vote_tableInclude<ExtArgs> | null
    /**
     * Filter, which user_vote_table to fetch.
     */
    where?: user_vote_tableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_vote_tables to fetch.
     */
    orderBy?: user_vote_tableOrderByWithRelationInput | user_vote_tableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_vote_tables.
     */
    cursor?: user_vote_tableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_vote_tables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_vote_tables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_vote_tables.
     */
    distinct?: User_vote_tableScalarFieldEnum | User_vote_tableScalarFieldEnum[]
  }


  /**
   * user_vote_table findFirstOrThrow
   */
  export type user_vote_tableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_vote_table
     */
    select?: user_vote_tableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_vote_tableInclude<ExtArgs> | null
    /**
     * Filter, which user_vote_table to fetch.
     */
    where?: user_vote_tableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_vote_tables to fetch.
     */
    orderBy?: user_vote_tableOrderByWithRelationInput | user_vote_tableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_vote_tables.
     */
    cursor?: user_vote_tableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_vote_tables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_vote_tables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_vote_tables.
     */
    distinct?: User_vote_tableScalarFieldEnum | User_vote_tableScalarFieldEnum[]
  }


  /**
   * user_vote_table findMany
   */
  export type user_vote_tableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_vote_table
     */
    select?: user_vote_tableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_vote_tableInclude<ExtArgs> | null
    /**
     * Filter, which user_vote_tables to fetch.
     */
    where?: user_vote_tableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_vote_tables to fetch.
     */
    orderBy?: user_vote_tableOrderByWithRelationInput | user_vote_tableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_vote_tables.
     */
    cursor?: user_vote_tableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_vote_tables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_vote_tables.
     */
    skip?: number
    distinct?: User_vote_tableScalarFieldEnum | User_vote_tableScalarFieldEnum[]
  }


  /**
   * user_vote_table create
   */
  export type user_vote_tableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_vote_table
     */
    select?: user_vote_tableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_vote_tableInclude<ExtArgs> | null
    /**
     * The data needed to create a user_vote_table.
     */
    data: XOR<user_vote_tableCreateInput, user_vote_tableUncheckedCreateInput>
  }


  /**
   * user_vote_table createMany
   */
  export type user_vote_tableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many user_vote_tables.
     */
    data: user_vote_tableCreateManyInput | user_vote_tableCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * user_vote_table update
   */
  export type user_vote_tableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_vote_table
     */
    select?: user_vote_tableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_vote_tableInclude<ExtArgs> | null
    /**
     * The data needed to update a user_vote_table.
     */
    data: XOR<user_vote_tableUpdateInput, user_vote_tableUncheckedUpdateInput>
    /**
     * Choose, which user_vote_table to update.
     */
    where: user_vote_tableWhereUniqueInput
  }


  /**
   * user_vote_table updateMany
   */
  export type user_vote_tableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update user_vote_tables.
     */
    data: XOR<user_vote_tableUpdateManyMutationInput, user_vote_tableUncheckedUpdateManyInput>
    /**
     * Filter which user_vote_tables to update
     */
    where?: user_vote_tableWhereInput
  }


  /**
   * user_vote_table upsert
   */
  export type user_vote_tableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_vote_table
     */
    select?: user_vote_tableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_vote_tableInclude<ExtArgs> | null
    /**
     * The filter to search for the user_vote_table to update in case it exists.
     */
    where: user_vote_tableWhereUniqueInput
    /**
     * In case the user_vote_table found by the `where` argument doesn't exist, create a new user_vote_table with this data.
     */
    create: XOR<user_vote_tableCreateInput, user_vote_tableUncheckedCreateInput>
    /**
     * In case the user_vote_table was found with the provided `where` argument, update it with this data.
     */
    update: XOR<user_vote_tableUpdateInput, user_vote_tableUncheckedUpdateInput>
  }


  /**
   * user_vote_table delete
   */
  export type user_vote_tableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_vote_table
     */
    select?: user_vote_tableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_vote_tableInclude<ExtArgs> | null
    /**
     * Filter which user_vote_table to delete.
     */
    where: user_vote_tableWhereUniqueInput
  }


  /**
   * user_vote_table deleteMany
   */
  export type user_vote_tableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_vote_tables to delete
     */
    where?: user_vote_tableWhereInput
  }


  /**
   * user_vote_table without action
   */
  export type user_vote_tableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_vote_table
     */
    select?: user_vote_tableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_vote_tableInclude<ExtArgs> | null
  }



  /**
   * Model users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersAvgAggregateOutputType = {
    user_id: number | null
    state: number | null
    coins: number | null
    id: number | null
    vote_reminders: number | null
    vote_reminder_channel: number | null
    vote_reminders_servers: number | null
    vote_reminder_servers_channel: number | null
    experiments: number | null
    flags: number | null
  }

  export type UsersSumAggregateOutputType = {
    user_id: bigint | null
    state: number | null
    coins: number | null
    id: bigint | null
    vote_reminders: bigint[]
    vote_reminder_channel: bigint | null
    vote_reminders_servers: bigint[]
    vote_reminder_servers_channel: bigint | null
    experiments: number[]
    flags: number[]
  }

  export type UsersMinAggregateOutputType = {
    user_id: bigint | null
    api_token: string | null
    description: string | null
    username: string | null
    user_css: string | null
    state: number | null
    coins: number | null
    id: bigint | null
    site_lang: string | null
    profile_css: string | null
    vote_reminder_channel: bigint | null
    staff_verify_code: string | null
    vote_reminders_last_acked: Date | null
    vote_reminders_servers_last_acked: Date | null
    vote_reminder_servers_channel: bigint | null
    supabase_id: string | null
    totp_shared_key: string | null
    staff_password: string | null
    lynxtag: string | null
  }

  export type UsersMaxAggregateOutputType = {
    user_id: bigint | null
    api_token: string | null
    description: string | null
    username: string | null
    user_css: string | null
    state: number | null
    coins: number | null
    id: bigint | null
    site_lang: string | null
    profile_css: string | null
    vote_reminder_channel: bigint | null
    staff_verify_code: string | null
    vote_reminders_last_acked: Date | null
    vote_reminders_servers_last_acked: Date | null
    vote_reminder_servers_channel: bigint | null
    supabase_id: string | null
    totp_shared_key: string | null
    staff_password: string | null
    lynxtag: string | null
  }

  export type UsersCountAggregateOutputType = {
    user_id: number
    api_token: number
    description: number
    badges: number
    username: number
    user_css: number
    state: number
    coins: number
    id: number
    site_lang: number
    profile_css: number
    vote_reminders: number
    vote_reminder_channel: number
    staff_verify_code: number
    vote_reminders_last_acked: number
    vote_reminders_servers: number
    vote_reminders_servers_last_acked: number
    vote_reminder_servers_channel: number
    experiments: number
    flags: number
    extra_links: number
    supabase_id: number
    totp_shared_key: number
    staff_password: number
    lynxtag: number
    _all: number
  }


  export type UsersAvgAggregateInputType = {
    user_id?: true
    state?: true
    coins?: true
    id?: true
    vote_reminders?: true
    vote_reminder_channel?: true
    vote_reminders_servers?: true
    vote_reminder_servers_channel?: true
    experiments?: true
    flags?: true
  }

  export type UsersSumAggregateInputType = {
    user_id?: true
    state?: true
    coins?: true
    id?: true
    vote_reminders?: true
    vote_reminder_channel?: true
    vote_reminders_servers?: true
    vote_reminder_servers_channel?: true
    experiments?: true
    flags?: true
  }

  export type UsersMinAggregateInputType = {
    user_id?: true
    api_token?: true
    description?: true
    username?: true
    user_css?: true
    state?: true
    coins?: true
    id?: true
    site_lang?: true
    profile_css?: true
    vote_reminder_channel?: true
    staff_verify_code?: true
    vote_reminders_last_acked?: true
    vote_reminders_servers_last_acked?: true
    vote_reminder_servers_channel?: true
    supabase_id?: true
    totp_shared_key?: true
    staff_password?: true
    lynxtag?: true
  }

  export type UsersMaxAggregateInputType = {
    user_id?: true
    api_token?: true
    description?: true
    username?: true
    user_css?: true
    state?: true
    coins?: true
    id?: true
    site_lang?: true
    profile_css?: true
    vote_reminder_channel?: true
    staff_verify_code?: true
    vote_reminders_last_acked?: true
    vote_reminders_servers_last_acked?: true
    vote_reminder_servers_channel?: true
    supabase_id?: true
    totp_shared_key?: true
    staff_password?: true
    lynxtag?: true
  }

  export type UsersCountAggregateInputType = {
    user_id?: true
    api_token?: true
    description?: true
    badges?: true
    username?: true
    user_css?: true
    state?: true
    coins?: true
    id?: true
    site_lang?: true
    profile_css?: true
    vote_reminders?: true
    vote_reminder_channel?: true
    staff_verify_code?: true
    vote_reminders_last_acked?: true
    vote_reminders_servers?: true
    vote_reminders_servers_last_acked?: true
    vote_reminder_servers_channel?: true
    experiments?: true
    flags?: true
    extra_links?: true
    supabase_id?: true
    totp_shared_key?: true
    staff_password?: true
    lynxtag?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to aggregate.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
    orderBy?: usersOrderByWithAggregationInput | usersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _avg?: UsersAvgAggregateInputType
    _sum?: UsersSumAggregateInputType
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    user_id: bigint
    api_token: string
    description: string | null
    badges: string[]
    username: string | null
    user_css: string | null
    state: number
    coins: number | null
    id: bigint
    site_lang: string | null
    profile_css: string
    vote_reminders: bigint[]
    vote_reminder_channel: bigint | null
    staff_verify_code: string | null
    vote_reminders_last_acked: Date
    vote_reminders_servers: bigint[]
    vote_reminders_servers_last_acked: Date
    vote_reminder_servers_channel: bigint | null
    experiments: number[]
    flags: number[]
    extra_links: JsonValue
    supabase_id: string | null
    totp_shared_key: string | null
    staff_password: string | null
    lynxtag: string
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    api_token?: boolean
    description?: boolean
    badges?: boolean
    username?: boolean
    user_css?: boolean
    state?: boolean
    coins?: boolean
    id?: boolean
    site_lang?: boolean
    profile_css?: boolean
    vote_reminders?: boolean
    vote_reminder_channel?: boolean
    staff_verify_code?: boolean
    vote_reminders_last_acked?: boolean
    vote_reminders_servers?: boolean
    vote_reminders_servers_last_acked?: boolean
    vote_reminder_servers_channel?: boolean
    experiments?: boolean
    flags?: boolean
    extra_links?: boolean
    supabase_id?: boolean
    totp_shared_key?: boolean
    staff_password?: boolean
    lynxtag?: boolean
    bot_voters?: boolean | users$bot_votersArgs<ExtArgs>
    extra_data?: boolean | users$extra_dataArgs<ExtArgs>
    frostpaw_clients?: boolean | users$frostpaw_clientsArgs<ExtArgs>
    leave_of_absence?: boolean | users$leave_of_absenceArgs<ExtArgs>
    lynx_apps?: boolean | users$lynx_appsArgs<ExtArgs>
    lynx_logs?: boolean | users$lynx_logsArgs<ExtArgs>
    lynx_ratings?: boolean | users$lynx_ratingsArgs<ExtArgs>
    lynx_survey_responses?: boolean | users$lynx_survey_responsesArgs<ExtArgs>
    push_notifications?: boolean | users$push_notificationsArgs<ExtArgs>
    review_votes?: boolean | users$review_votesArgs<ExtArgs>
    reviews?: boolean | users$reviewsArgs<ExtArgs>
    server_audit_logs?: boolean | users$server_audit_logsArgs<ExtArgs>
    server_voters?: boolean | users$server_votersArgs<ExtArgs>
    servers?: boolean | users$serversArgs<ExtArgs>
    user_bot_logs?: boolean | users$user_bot_logsArgs<ExtArgs>
    user_connections?: boolean | users$user_connectionsArgs<ExtArgs>
    user_server_vote_table?: boolean | users$user_server_vote_tableArgs<ExtArgs>
    user_vote_table?: boolean | users$user_vote_tableArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type usersSelectScalar = {
    user_id?: boolean
    api_token?: boolean
    description?: boolean
    badges?: boolean
    username?: boolean
    user_css?: boolean
    state?: boolean
    coins?: boolean
    id?: boolean
    site_lang?: boolean
    profile_css?: boolean
    vote_reminders?: boolean
    vote_reminder_channel?: boolean
    staff_verify_code?: boolean
    vote_reminders_last_acked?: boolean
    vote_reminders_servers?: boolean
    vote_reminders_servers_last_acked?: boolean
    vote_reminder_servers_channel?: boolean
    experiments?: boolean
    flags?: boolean
    extra_links?: boolean
    supabase_id?: boolean
    totp_shared_key?: boolean
    staff_password?: boolean
    lynxtag?: boolean
  }

  export type usersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bot_voters?: boolean | users$bot_votersArgs<ExtArgs>
    extra_data?: boolean | users$extra_dataArgs<ExtArgs>
    frostpaw_clients?: boolean | users$frostpaw_clientsArgs<ExtArgs>
    leave_of_absence?: boolean | users$leave_of_absenceArgs<ExtArgs>
    lynx_apps?: boolean | users$lynx_appsArgs<ExtArgs>
    lynx_logs?: boolean | users$lynx_logsArgs<ExtArgs>
    lynx_ratings?: boolean | users$lynx_ratingsArgs<ExtArgs>
    lynx_survey_responses?: boolean | users$lynx_survey_responsesArgs<ExtArgs>
    push_notifications?: boolean | users$push_notificationsArgs<ExtArgs>
    review_votes?: boolean | users$review_votesArgs<ExtArgs>
    reviews?: boolean | users$reviewsArgs<ExtArgs>
    server_audit_logs?: boolean | users$server_audit_logsArgs<ExtArgs>
    server_voters?: boolean | users$server_votersArgs<ExtArgs>
    servers?: boolean | users$serversArgs<ExtArgs>
    user_bot_logs?: boolean | users$user_bot_logsArgs<ExtArgs>
    user_connections?: boolean | users$user_connectionsArgs<ExtArgs>
    user_server_vote_table?: boolean | users$user_server_vote_tableArgs<ExtArgs>
    user_vote_table?: boolean | users$user_vote_tableArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "users"
    objects: {
      bot_voters: Prisma.$bot_votersPayload<ExtArgs>[]
      extra_data: Prisma.$extra_dataPayload<ExtArgs>[]
      frostpaw_clients: Prisma.$frostpaw_clientsPayload<ExtArgs>[]
      leave_of_absence: Prisma.$leave_of_absencePayload<ExtArgs>[]
      lynx_apps: Prisma.$lynx_appsPayload<ExtArgs>[]
      lynx_logs: Prisma.$lynx_logsPayload<ExtArgs>[]
      lynx_ratings: Prisma.$lynx_ratingsPayload<ExtArgs>[]
      lynx_survey_responses: Prisma.$lynx_survey_responsesPayload<ExtArgs>[]
      push_notifications: Prisma.$push_notificationsPayload<ExtArgs>[]
      review_votes: Prisma.$review_votesPayload<ExtArgs>[]
      reviews: Prisma.$reviewsPayload<ExtArgs>[]
      server_audit_logs: Prisma.$server_audit_logsPayload<ExtArgs>[]
      server_voters: Prisma.$server_votersPayload<ExtArgs>[]
      servers: Prisma.$serversPayload<ExtArgs>[]
      user_bot_logs: Prisma.$user_bot_logsPayload<ExtArgs>[]
      user_connections: Prisma.$user_connectionsPayload<ExtArgs>[]
      user_server_vote_table: Prisma.$user_server_vote_tablePayload<ExtArgs> | null
      user_vote_table: Prisma.$user_vote_tablePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      user_id: bigint
      api_token: string
      description: string | null
      badges: string[]
      username: string | null
      user_css: string | null
      state: number
      coins: number | null
      id: bigint
      site_lang: string | null
      profile_css: string
      vote_reminders: bigint[]
      vote_reminder_channel: bigint | null
      staff_verify_code: string | null
      vote_reminders_last_acked: Date
      vote_reminders_servers: bigint[]
      vote_reminders_servers_last_acked: Date
      vote_reminder_servers_channel: bigint | null
      experiments: number[]
      flags: number[]
      extra_links: Prisma.JsonValue
      supabase_id: string | null
      totp_shared_key: string | null
      staff_password: string | null
      lynxtag: string
    }, ExtArgs["result"]["users"]>
    composites: {}
  }


  type usersGetPayload<S extends boolean | null | undefined | usersDefaultArgs> = $Result.GetResult<Prisma.$usersPayload, S>

  type usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<usersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users'], meta: { name: 'users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends usersFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, usersFindUniqueArgs<ExtArgs>>
    ): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Users that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, usersFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends usersFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, usersFindFirstArgs<ExtArgs>>
    ): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, usersFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const usersWithUser_idOnly = await prisma.users.findMany({ select: { user_id: true } })
     * 
    **/
    findMany<T extends usersFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, usersFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
    **/
    create<T extends usersCreateArgs<ExtArgs>>(
      args: SelectSubset<T, usersCreateArgs<ExtArgs>>
    ): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Users.
     *     @param {usersCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const users = await prisma.users.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends usersCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, usersCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
    **/
    delete<T extends usersDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, usersDeleteArgs<ExtArgs>>
    ): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends usersUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, usersUpdateArgs<ExtArgs>>
    ): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends usersDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, usersDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends usersUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, usersUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
    **/
    upsert<T extends usersUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, usersUpsertArgs<ExtArgs>>
    ): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usersGroupByArgs['orderBy'] }
        : { orderBy?: usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the users model
   */
  readonly fields: usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    bot_voters<T extends users$bot_votersArgs<ExtArgs> = {}>(args?: Subset<T, users$bot_votersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bot_votersPayload<ExtArgs>, T, 'findMany'> | Null>;

    extra_data<T extends users$extra_dataArgs<ExtArgs> = {}>(args?: Subset<T, users$extra_dataArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$extra_dataPayload<ExtArgs>, T, 'findMany'> | Null>;

    frostpaw_clients<T extends users$frostpaw_clientsArgs<ExtArgs> = {}>(args?: Subset<T, users$frostpaw_clientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$frostpaw_clientsPayload<ExtArgs>, T, 'findMany'> | Null>;

    leave_of_absence<T extends users$leave_of_absenceArgs<ExtArgs> = {}>(args?: Subset<T, users$leave_of_absenceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$leave_of_absencePayload<ExtArgs>, T, 'findMany'> | Null>;

    lynx_apps<T extends users$lynx_appsArgs<ExtArgs> = {}>(args?: Subset<T, users$lynx_appsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$lynx_appsPayload<ExtArgs>, T, 'findMany'> | Null>;

    lynx_logs<T extends users$lynx_logsArgs<ExtArgs> = {}>(args?: Subset<T, users$lynx_logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$lynx_logsPayload<ExtArgs>, T, 'findMany'> | Null>;

    lynx_ratings<T extends users$lynx_ratingsArgs<ExtArgs> = {}>(args?: Subset<T, users$lynx_ratingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$lynx_ratingsPayload<ExtArgs>, T, 'findMany'> | Null>;

    lynx_survey_responses<T extends users$lynx_survey_responsesArgs<ExtArgs> = {}>(args?: Subset<T, users$lynx_survey_responsesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$lynx_survey_responsesPayload<ExtArgs>, T, 'findMany'> | Null>;

    push_notifications<T extends users$push_notificationsArgs<ExtArgs> = {}>(args?: Subset<T, users$push_notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$push_notificationsPayload<ExtArgs>, T, 'findMany'> | Null>;

    review_votes<T extends users$review_votesArgs<ExtArgs> = {}>(args?: Subset<T, users$review_votesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$review_votesPayload<ExtArgs>, T, 'findMany'> | Null>;

    reviews<T extends users$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, users$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reviewsPayload<ExtArgs>, T, 'findMany'> | Null>;

    server_audit_logs<T extends users$server_audit_logsArgs<ExtArgs> = {}>(args?: Subset<T, users$server_audit_logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$server_audit_logsPayload<ExtArgs>, T, 'findMany'> | Null>;

    server_voters<T extends users$server_votersArgs<ExtArgs> = {}>(args?: Subset<T, users$server_votersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$server_votersPayload<ExtArgs>, T, 'findMany'> | Null>;

    servers<T extends users$serversArgs<ExtArgs> = {}>(args?: Subset<T, users$serversArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$serversPayload<ExtArgs>, T, 'findMany'> | Null>;

    user_bot_logs<T extends users$user_bot_logsArgs<ExtArgs> = {}>(args?: Subset<T, users$user_bot_logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_bot_logsPayload<ExtArgs>, T, 'findMany'> | Null>;

    user_connections<T extends users$user_connectionsArgs<ExtArgs> = {}>(args?: Subset<T, users$user_connectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_connectionsPayload<ExtArgs>, T, 'findMany'> | Null>;

    user_server_vote_table<T extends users$user_server_vote_tableArgs<ExtArgs> = {}>(args?: Subset<T, users$user_server_vote_tableArgs<ExtArgs>>): Prisma__user_server_vote_tableClient<$Result.GetResult<Prisma.$user_server_vote_tablePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    user_vote_table<T extends users$user_vote_tableArgs<ExtArgs> = {}>(args?: Subset<T, users$user_vote_tableArgs<ExtArgs>>): Prisma__user_vote_tableClient<$Result.GetResult<Prisma.$user_vote_tablePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the users model
   */ 
  interface usersFieldRefs {
    readonly user_id: FieldRef<"users", 'BigInt'>
    readonly api_token: FieldRef<"users", 'String'>
    readonly description: FieldRef<"users", 'String'>
    readonly badges: FieldRef<"users", 'String[]'>
    readonly username: FieldRef<"users", 'String'>
    readonly user_css: FieldRef<"users", 'String'>
    readonly state: FieldRef<"users", 'Int'>
    readonly coins: FieldRef<"users", 'Int'>
    readonly id: FieldRef<"users", 'BigInt'>
    readonly site_lang: FieldRef<"users", 'String'>
    readonly profile_css: FieldRef<"users", 'String'>
    readonly vote_reminders: FieldRef<"users", 'BigInt[]'>
    readonly vote_reminder_channel: FieldRef<"users", 'BigInt'>
    readonly staff_verify_code: FieldRef<"users", 'String'>
    readonly vote_reminders_last_acked: FieldRef<"users", 'DateTime'>
    readonly vote_reminders_servers: FieldRef<"users", 'BigInt[]'>
    readonly vote_reminders_servers_last_acked: FieldRef<"users", 'DateTime'>
    readonly vote_reminder_servers_channel: FieldRef<"users", 'BigInt'>
    readonly experiments: FieldRef<"users", 'Int[]'>
    readonly flags: FieldRef<"users", 'Int[]'>
    readonly extra_links: FieldRef<"users", 'Json'>
    readonly supabase_id: FieldRef<"users", 'String'>
    readonly totp_shared_key: FieldRef<"users", 'String'>
    readonly staff_password: FieldRef<"users", 'String'>
    readonly lynxtag: FieldRef<"users", 'String'>
  }
    

  // Custom InputTypes

  /**
   * users findUnique
   */
  export type usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }


  /**
   * users findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }


  /**
   * users findFirst
   */
  export type usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }


  /**
   * users findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }


  /**
   * users findMany
   */
  export type usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }


  /**
   * users create
   */
  export type usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to create a users.
     */
    data: XOR<usersCreateInput, usersUncheckedCreateInput>
  }


  /**
   * users createMany
   */
  export type usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * users update
   */
  export type usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to update a users.
     */
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     */
    where: usersWhereUniqueInput
  }


  /**
   * users updateMany
   */
  export type usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
  }


  /**
   * users upsert
   */
  export type usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The filter to search for the users to update in case it exists.
     */
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     */
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }


  /**
   * users delete
   */
  export type usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter which users to delete.
     */
    where: usersWhereUniqueInput
  }


  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: usersWhereInput
  }


  /**
   * users.bot_voters
   */
  export type users$bot_votersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bot_voters
     */
    select?: bot_votersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bot_votersInclude<ExtArgs> | null
    where?: bot_votersWhereInput
    orderBy?: bot_votersOrderByWithRelationInput | bot_votersOrderByWithRelationInput[]
    cursor?: bot_votersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Bot_votersScalarFieldEnum | Bot_votersScalarFieldEnum[]
  }


  /**
   * users.extra_data
   */
  export type users$extra_dataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the extra_data
     */
    select?: extra_dataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: extra_dataInclude<ExtArgs> | null
    where?: extra_dataWhereInput
    orderBy?: extra_dataOrderByWithRelationInput | extra_dataOrderByWithRelationInput[]
    cursor?: extra_dataWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Extra_dataScalarFieldEnum | Extra_dataScalarFieldEnum[]
  }


  /**
   * users.frostpaw_clients
   */
  export type users$frostpaw_clientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the frostpaw_clients
     */
    select?: frostpaw_clientsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: frostpaw_clientsInclude<ExtArgs> | null
    where?: frostpaw_clientsWhereInput
    orderBy?: frostpaw_clientsOrderByWithRelationInput | frostpaw_clientsOrderByWithRelationInput[]
    cursor?: frostpaw_clientsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Frostpaw_clientsScalarFieldEnum | Frostpaw_clientsScalarFieldEnum[]
  }


  /**
   * users.leave_of_absence
   */
  export type users$leave_of_absenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the leave_of_absence
     */
    select?: leave_of_absenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: leave_of_absenceInclude<ExtArgs> | null
    where?: leave_of_absenceWhereInput
    orderBy?: leave_of_absenceOrderByWithRelationInput | leave_of_absenceOrderByWithRelationInput[]
    cursor?: leave_of_absenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Leave_of_absenceScalarFieldEnum | Leave_of_absenceScalarFieldEnum[]
  }


  /**
   * users.lynx_apps
   */
  export type users$lynx_appsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lynx_apps
     */
    select?: lynx_appsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: lynx_appsInclude<ExtArgs> | null
    where?: lynx_appsWhereInput
    orderBy?: lynx_appsOrderByWithRelationInput | lynx_appsOrderByWithRelationInput[]
    cursor?: lynx_appsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Lynx_appsScalarFieldEnum | Lynx_appsScalarFieldEnum[]
  }


  /**
   * users.lynx_logs
   */
  export type users$lynx_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lynx_logs
     */
    select?: lynx_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: lynx_logsInclude<ExtArgs> | null
    where?: lynx_logsWhereInput
    orderBy?: lynx_logsOrderByWithRelationInput | lynx_logsOrderByWithRelationInput[]
    cursor?: lynx_logsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Lynx_logsScalarFieldEnum | Lynx_logsScalarFieldEnum[]
  }


  /**
   * users.lynx_ratings
   */
  export type users$lynx_ratingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lynx_ratings
     */
    select?: lynx_ratingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: lynx_ratingsInclude<ExtArgs> | null
    where?: lynx_ratingsWhereInput
    orderBy?: lynx_ratingsOrderByWithRelationInput | lynx_ratingsOrderByWithRelationInput[]
    cursor?: lynx_ratingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Lynx_ratingsScalarFieldEnum | Lynx_ratingsScalarFieldEnum[]
  }


  /**
   * users.lynx_survey_responses
   */
  export type users$lynx_survey_responsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lynx_survey_responses
     */
    select?: lynx_survey_responsesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: lynx_survey_responsesInclude<ExtArgs> | null
    where?: lynx_survey_responsesWhereInput
    orderBy?: lynx_survey_responsesOrderByWithRelationInput | lynx_survey_responsesOrderByWithRelationInput[]
    cursor?: lynx_survey_responsesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Lynx_survey_responsesScalarFieldEnum | Lynx_survey_responsesScalarFieldEnum[]
  }


  /**
   * users.push_notifications
   */
  export type users$push_notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the push_notifications
     */
    select?: push_notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: push_notificationsInclude<ExtArgs> | null
    where?: push_notificationsWhereInput
    orderBy?: push_notificationsOrderByWithRelationInput | push_notificationsOrderByWithRelationInput[]
    cursor?: push_notificationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Push_notificationsScalarFieldEnum | Push_notificationsScalarFieldEnum[]
  }


  /**
   * users.review_votes
   */
  export type users$review_votesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the review_votes
     */
    select?: review_votesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: review_votesInclude<ExtArgs> | null
    where?: review_votesWhereInput
    orderBy?: review_votesOrderByWithRelationInput | review_votesOrderByWithRelationInput[]
    cursor?: review_votesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Review_votesScalarFieldEnum | Review_votesScalarFieldEnum[]
  }


  /**
   * users.reviews
   */
  export type users$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reviewsInclude<ExtArgs> | null
    where?: reviewsWhereInput
    orderBy?: reviewsOrderByWithRelationInput | reviewsOrderByWithRelationInput[]
    cursor?: reviewsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewsScalarFieldEnum | ReviewsScalarFieldEnum[]
  }


  /**
   * users.server_audit_logs
   */
  export type users$server_audit_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the server_audit_logs
     */
    select?: server_audit_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: server_audit_logsInclude<ExtArgs> | null
    where?: server_audit_logsWhereInput
    orderBy?: server_audit_logsOrderByWithRelationInput | server_audit_logsOrderByWithRelationInput[]
    cursor?: server_audit_logsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Server_audit_logsScalarFieldEnum | Server_audit_logsScalarFieldEnum[]
  }


  /**
   * users.server_voters
   */
  export type users$server_votersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the server_voters
     */
    select?: server_votersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: server_votersInclude<ExtArgs> | null
    where?: server_votersWhereInput
    orderBy?: server_votersOrderByWithRelationInput | server_votersOrderByWithRelationInput[]
    cursor?: server_votersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Server_votersScalarFieldEnum | Server_votersScalarFieldEnum[]
  }


  /**
   * users.servers
   */
  export type users$serversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servers
     */
    select?: serversSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: serversInclude<ExtArgs> | null
    where?: serversWhereInput
    orderBy?: serversOrderByWithRelationInput | serversOrderByWithRelationInput[]
    cursor?: serversWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServersScalarFieldEnum | ServersScalarFieldEnum[]
  }


  /**
   * users.user_bot_logs
   */
  export type users$user_bot_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_bot_logs
     */
    select?: user_bot_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_bot_logsInclude<ExtArgs> | null
    where?: user_bot_logsWhereInput
    orderBy?: user_bot_logsOrderByWithRelationInput | user_bot_logsOrderByWithRelationInput[]
    cursor?: user_bot_logsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: User_bot_logsScalarFieldEnum | User_bot_logsScalarFieldEnum[]
  }


  /**
   * users.user_connections
   */
  export type users$user_connectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_connections
     */
    select?: user_connectionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_connectionsInclude<ExtArgs> | null
    where?: user_connectionsWhereInput
    orderBy?: user_connectionsOrderByWithRelationInput | user_connectionsOrderByWithRelationInput[]
    cursor?: user_connectionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: User_connectionsScalarFieldEnum | User_connectionsScalarFieldEnum[]
  }


  /**
   * users.user_server_vote_table
   */
  export type users$user_server_vote_tableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_server_vote_table
     */
    select?: user_server_vote_tableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_server_vote_tableInclude<ExtArgs> | null
    where?: user_server_vote_tableWhereInput
  }


  /**
   * users.user_vote_table
   */
  export type users$user_vote_tableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_vote_table
     */
    select?: user_vote_tableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_vote_tableInclude<ExtArgs> | null
    where?: user_vote_tableWhereInput
  }


  /**
   * users without action
   */
  export type usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude<ExtArgs> | null
  }



  /**
   * Model vanity
   */

  export type AggregateVanity = {
    _count: VanityCountAggregateOutputType | null
    _avg: VanityAvgAggregateOutputType | null
    _sum: VanitySumAggregateOutputType | null
    _min: VanityMinAggregateOutputType | null
    _max: VanityMaxAggregateOutputType | null
  }

  export type VanityAvgAggregateOutputType = {
    type: number | null
    redirect: number | null
  }

  export type VanitySumAggregateOutputType = {
    type: number | null
    redirect: bigint | null
  }

  export type VanityMinAggregateOutputType = {
    type: number | null
    vanity_url: string | null
    redirect: bigint | null
    lynxtag: string | null
  }

  export type VanityMaxAggregateOutputType = {
    type: number | null
    vanity_url: string | null
    redirect: bigint | null
    lynxtag: string | null
  }

  export type VanityCountAggregateOutputType = {
    type: number
    vanity_url: number
    redirect: number
    lynxtag: number
    _all: number
  }


  export type VanityAvgAggregateInputType = {
    type?: true
    redirect?: true
  }

  export type VanitySumAggregateInputType = {
    type?: true
    redirect?: true
  }

  export type VanityMinAggregateInputType = {
    type?: true
    vanity_url?: true
    redirect?: true
    lynxtag?: true
  }

  export type VanityMaxAggregateInputType = {
    type?: true
    vanity_url?: true
    redirect?: true
    lynxtag?: true
  }

  export type VanityCountAggregateInputType = {
    type?: true
    vanity_url?: true
    redirect?: true
    lynxtag?: true
    _all?: true
  }

  export type VanityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which vanity to aggregate.
     */
    where?: vanityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vanities to fetch.
     */
    orderBy?: vanityOrderByWithRelationInput | vanityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: vanityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vanities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vanities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned vanities
    **/
    _count?: true | VanityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VanityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VanitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VanityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VanityMaxAggregateInputType
  }

  export type GetVanityAggregateType<T extends VanityAggregateArgs> = {
        [P in keyof T & keyof AggregateVanity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVanity[P]>
      : GetScalarType<T[P], AggregateVanity[P]>
  }




  export type vanityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: vanityWhereInput
    orderBy?: vanityOrderByWithAggregationInput | vanityOrderByWithAggregationInput[]
    by: VanityScalarFieldEnum[] | VanityScalarFieldEnum
    having?: vanityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VanityCountAggregateInputType | true
    _avg?: VanityAvgAggregateInputType
    _sum?: VanitySumAggregateInputType
    _min?: VanityMinAggregateInputType
    _max?: VanityMaxAggregateInputType
  }

  export type VanityGroupByOutputType = {
    type: number | null
    vanity_url: string | null
    redirect: bigint | null
    lynxtag: string
    _count: VanityCountAggregateOutputType | null
    _avg: VanityAvgAggregateOutputType | null
    _sum: VanitySumAggregateOutputType | null
    _min: VanityMinAggregateOutputType | null
    _max: VanityMaxAggregateOutputType | null
  }

  type GetVanityGroupByPayload<T extends vanityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VanityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VanityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VanityGroupByOutputType[P]>
            : GetScalarType<T[P], VanityGroupByOutputType[P]>
        }
      >
    >


  export type vanitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    type?: boolean
    vanity_url?: boolean
    redirect?: boolean
    lynxtag?: boolean
  }, ExtArgs["result"]["vanity"]>

  export type vanitySelectScalar = {
    type?: boolean
    vanity_url?: boolean
    redirect?: boolean
    lynxtag?: boolean
  }


  export type $vanityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "vanity"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      type: number | null
      vanity_url: string | null
      redirect: bigint | null
      lynxtag: string
    }, ExtArgs["result"]["vanity"]>
    composites: {}
  }


  type vanityGetPayload<S extends boolean | null | undefined | vanityDefaultArgs> = $Result.GetResult<Prisma.$vanityPayload, S>

  type vanityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<vanityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VanityCountAggregateInputType | true
    }

  export interface vanityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['vanity'], meta: { name: 'vanity' } }
    /**
     * Find zero or one Vanity that matches the filter.
     * @param {vanityFindUniqueArgs} args - Arguments to find a Vanity
     * @example
     * // Get one Vanity
     * const vanity = await prisma.vanity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends vanityFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, vanityFindUniqueArgs<ExtArgs>>
    ): Prisma__vanityClient<$Result.GetResult<Prisma.$vanityPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Vanity that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {vanityFindUniqueOrThrowArgs} args - Arguments to find a Vanity
     * @example
     * // Get one Vanity
     * const vanity = await prisma.vanity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends vanityFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, vanityFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__vanityClient<$Result.GetResult<Prisma.$vanityPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Vanity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vanityFindFirstArgs} args - Arguments to find a Vanity
     * @example
     * // Get one Vanity
     * const vanity = await prisma.vanity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends vanityFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, vanityFindFirstArgs<ExtArgs>>
    ): Prisma__vanityClient<$Result.GetResult<Prisma.$vanityPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Vanity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vanityFindFirstOrThrowArgs} args - Arguments to find a Vanity
     * @example
     * // Get one Vanity
     * const vanity = await prisma.vanity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends vanityFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, vanityFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__vanityClient<$Result.GetResult<Prisma.$vanityPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Vanities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vanityFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vanities
     * const vanities = await prisma.vanity.findMany()
     * 
     * // Get first 10 Vanities
     * const vanities = await prisma.vanity.findMany({ take: 10 })
     * 
     * // Only select the `type`
     * const vanityWithTypeOnly = await prisma.vanity.findMany({ select: { type: true } })
     * 
    **/
    findMany<T extends vanityFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, vanityFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$vanityPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Vanity.
     * @param {vanityCreateArgs} args - Arguments to create a Vanity.
     * @example
     * // Create one Vanity
     * const Vanity = await prisma.vanity.create({
     *   data: {
     *     // ... data to create a Vanity
     *   }
     * })
     * 
    **/
    create<T extends vanityCreateArgs<ExtArgs>>(
      args: SelectSubset<T, vanityCreateArgs<ExtArgs>>
    ): Prisma__vanityClient<$Result.GetResult<Prisma.$vanityPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Vanities.
     *     @param {vanityCreateManyArgs} args - Arguments to create many Vanities.
     *     @example
     *     // Create many Vanities
     *     const vanity = await prisma.vanity.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends vanityCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, vanityCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Vanity.
     * @param {vanityDeleteArgs} args - Arguments to delete one Vanity.
     * @example
     * // Delete one Vanity
     * const Vanity = await prisma.vanity.delete({
     *   where: {
     *     // ... filter to delete one Vanity
     *   }
     * })
     * 
    **/
    delete<T extends vanityDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, vanityDeleteArgs<ExtArgs>>
    ): Prisma__vanityClient<$Result.GetResult<Prisma.$vanityPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Vanity.
     * @param {vanityUpdateArgs} args - Arguments to update one Vanity.
     * @example
     * // Update one Vanity
     * const vanity = await prisma.vanity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends vanityUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, vanityUpdateArgs<ExtArgs>>
    ): Prisma__vanityClient<$Result.GetResult<Prisma.$vanityPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Vanities.
     * @param {vanityDeleteManyArgs} args - Arguments to filter Vanities to delete.
     * @example
     * // Delete a few Vanities
     * const { count } = await prisma.vanity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends vanityDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, vanityDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vanities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vanityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vanities
     * const vanity = await prisma.vanity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends vanityUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, vanityUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Vanity.
     * @param {vanityUpsertArgs} args - Arguments to update or create a Vanity.
     * @example
     * // Update or create a Vanity
     * const vanity = await prisma.vanity.upsert({
     *   create: {
     *     // ... data to create a Vanity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vanity we want to update
     *   }
     * })
    **/
    upsert<T extends vanityUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, vanityUpsertArgs<ExtArgs>>
    ): Prisma__vanityClient<$Result.GetResult<Prisma.$vanityPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Vanities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vanityCountArgs} args - Arguments to filter Vanities to count.
     * @example
     * // Count the number of Vanities
     * const count = await prisma.vanity.count({
     *   where: {
     *     // ... the filter for the Vanities we want to count
     *   }
     * })
    **/
    count<T extends vanityCountArgs>(
      args?: Subset<T, vanityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VanityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vanity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VanityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VanityAggregateArgs>(args: Subset<T, VanityAggregateArgs>): Prisma.PrismaPromise<GetVanityAggregateType<T>>

    /**
     * Group by Vanity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vanityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends vanityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: vanityGroupByArgs['orderBy'] }
        : { orderBy?: vanityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, vanityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVanityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the vanity model
   */
  readonly fields: vanityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for vanity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__vanityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the vanity model
   */ 
  interface vanityFieldRefs {
    readonly type: FieldRef<"vanity", 'Int'>
    readonly vanity_url: FieldRef<"vanity", 'String'>
    readonly redirect: FieldRef<"vanity", 'BigInt'>
    readonly lynxtag: FieldRef<"vanity", 'String'>
  }
    

  // Custom InputTypes

  /**
   * vanity findUnique
   */
  export type vanityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vanity
     */
    select?: vanitySelect<ExtArgs> | null
    /**
     * Filter, which vanity to fetch.
     */
    where: vanityWhereUniqueInput
  }


  /**
   * vanity findUniqueOrThrow
   */
  export type vanityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vanity
     */
    select?: vanitySelect<ExtArgs> | null
    /**
     * Filter, which vanity to fetch.
     */
    where: vanityWhereUniqueInput
  }


  /**
   * vanity findFirst
   */
  export type vanityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vanity
     */
    select?: vanitySelect<ExtArgs> | null
    /**
     * Filter, which vanity to fetch.
     */
    where?: vanityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vanities to fetch.
     */
    orderBy?: vanityOrderByWithRelationInput | vanityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for vanities.
     */
    cursor?: vanityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vanities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vanities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of vanities.
     */
    distinct?: VanityScalarFieldEnum | VanityScalarFieldEnum[]
  }


  /**
   * vanity findFirstOrThrow
   */
  export type vanityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vanity
     */
    select?: vanitySelect<ExtArgs> | null
    /**
     * Filter, which vanity to fetch.
     */
    where?: vanityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vanities to fetch.
     */
    orderBy?: vanityOrderByWithRelationInput | vanityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for vanities.
     */
    cursor?: vanityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vanities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vanities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of vanities.
     */
    distinct?: VanityScalarFieldEnum | VanityScalarFieldEnum[]
  }


  /**
   * vanity findMany
   */
  export type vanityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vanity
     */
    select?: vanitySelect<ExtArgs> | null
    /**
     * Filter, which vanities to fetch.
     */
    where?: vanityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vanities to fetch.
     */
    orderBy?: vanityOrderByWithRelationInput | vanityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing vanities.
     */
    cursor?: vanityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vanities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vanities.
     */
    skip?: number
    distinct?: VanityScalarFieldEnum | VanityScalarFieldEnum[]
  }


  /**
   * vanity create
   */
  export type vanityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vanity
     */
    select?: vanitySelect<ExtArgs> | null
    /**
     * The data needed to create a vanity.
     */
    data?: XOR<vanityCreateInput, vanityUncheckedCreateInput>
  }


  /**
   * vanity createMany
   */
  export type vanityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many vanities.
     */
    data: vanityCreateManyInput | vanityCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * vanity update
   */
  export type vanityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vanity
     */
    select?: vanitySelect<ExtArgs> | null
    /**
     * The data needed to update a vanity.
     */
    data: XOR<vanityUpdateInput, vanityUncheckedUpdateInput>
    /**
     * Choose, which vanity to update.
     */
    where: vanityWhereUniqueInput
  }


  /**
   * vanity updateMany
   */
  export type vanityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update vanities.
     */
    data: XOR<vanityUpdateManyMutationInput, vanityUncheckedUpdateManyInput>
    /**
     * Filter which vanities to update
     */
    where?: vanityWhereInput
  }


  /**
   * vanity upsert
   */
  export type vanityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vanity
     */
    select?: vanitySelect<ExtArgs> | null
    /**
     * The filter to search for the vanity to update in case it exists.
     */
    where: vanityWhereUniqueInput
    /**
     * In case the vanity found by the `where` argument doesn't exist, create a new vanity with this data.
     */
    create: XOR<vanityCreateInput, vanityUncheckedCreateInput>
    /**
     * In case the vanity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<vanityUpdateInput, vanityUncheckedUpdateInput>
  }


  /**
   * vanity delete
   */
  export type vanityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vanity
     */
    select?: vanitySelect<ExtArgs> | null
    /**
     * Filter which vanity to delete.
     */
    where: vanityWhereUniqueInput
  }


  /**
   * vanity deleteMany
   */
  export type vanityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which vanities to delete
     */
    where?: vanityWhereInput
  }


  /**
   * vanity without action
   */
  export type vanityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vanity
     */
    select?: vanitySelect<ExtArgs> | null
  }



  /**
   * Model ws_events
   */

  export type AggregateWs_events = {
    _count: Ws_eventsCountAggregateOutputType | null
    _avg: Ws_eventsAvgAggregateOutputType | null
    _sum: Ws_eventsSumAggregateOutputType | null
    _min: Ws_eventsMinAggregateOutputType | null
    _max: Ws_eventsMaxAggregateOutputType | null
  }

  export type Ws_eventsAvgAggregateOutputType = {
    id: number | null
  }

  export type Ws_eventsSumAggregateOutputType = {
    id: bigint | null
  }

  export type Ws_eventsMinAggregateOutputType = {
    id: bigint | null
    type: string | null
    ts: Date | null
    lynxtag: string | null
  }

  export type Ws_eventsMaxAggregateOutputType = {
    id: bigint | null
    type: string | null
    ts: Date | null
    lynxtag: string | null
  }

  export type Ws_eventsCountAggregateOutputType = {
    id: number
    type: number
    ts: number
    event: number
    lynxtag: number
    _all: number
  }


  export type Ws_eventsAvgAggregateInputType = {
    id?: true
  }

  export type Ws_eventsSumAggregateInputType = {
    id?: true
  }

  export type Ws_eventsMinAggregateInputType = {
    id?: true
    type?: true
    ts?: true
    lynxtag?: true
  }

  export type Ws_eventsMaxAggregateInputType = {
    id?: true
    type?: true
    ts?: true
    lynxtag?: true
  }

  export type Ws_eventsCountAggregateInputType = {
    id?: true
    type?: true
    ts?: true
    event?: true
    lynxtag?: true
    _all?: true
  }

  export type Ws_eventsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ws_events to aggregate.
     */
    where?: ws_eventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ws_events to fetch.
     */
    orderBy?: ws_eventsOrderByWithRelationInput | ws_eventsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ws_eventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ws_events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ws_events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ws_events
    **/
    _count?: true | Ws_eventsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Ws_eventsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Ws_eventsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ws_eventsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ws_eventsMaxAggregateInputType
  }

  export type GetWs_eventsAggregateType<T extends Ws_eventsAggregateArgs> = {
        [P in keyof T & keyof AggregateWs_events]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWs_events[P]>
      : GetScalarType<T[P], AggregateWs_events[P]>
  }




  export type ws_eventsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ws_eventsWhereInput
    orderBy?: ws_eventsOrderByWithAggregationInput | ws_eventsOrderByWithAggregationInput[]
    by: Ws_eventsScalarFieldEnum[] | Ws_eventsScalarFieldEnum
    having?: ws_eventsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ws_eventsCountAggregateInputType | true
    _avg?: Ws_eventsAvgAggregateInputType
    _sum?: Ws_eventsSumAggregateInputType
    _min?: Ws_eventsMinAggregateInputType
    _max?: Ws_eventsMaxAggregateInputType
  }

  export type Ws_eventsGroupByOutputType = {
    id: bigint
    type: string
    ts: Date
    event: JsonValue
    lynxtag: string
    _count: Ws_eventsCountAggregateOutputType | null
    _avg: Ws_eventsAvgAggregateOutputType | null
    _sum: Ws_eventsSumAggregateOutputType | null
    _min: Ws_eventsMinAggregateOutputType | null
    _max: Ws_eventsMaxAggregateOutputType | null
  }

  type GetWs_eventsGroupByPayload<T extends ws_eventsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Ws_eventsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ws_eventsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ws_eventsGroupByOutputType[P]>
            : GetScalarType<T[P], Ws_eventsGroupByOutputType[P]>
        }
      >
    >


  export type ws_eventsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    ts?: boolean
    event?: boolean
    lynxtag?: boolean
  }, ExtArgs["result"]["ws_events"]>

  export type ws_eventsSelectScalar = {
    id?: boolean
    type?: boolean
    ts?: boolean
    event?: boolean
    lynxtag?: boolean
  }


  export type $ws_eventsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ws_events"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      type: string
      ts: Date
      event: Prisma.JsonValue
      lynxtag: string
    }, ExtArgs["result"]["ws_events"]>
    composites: {}
  }


  type ws_eventsGetPayload<S extends boolean | null | undefined | ws_eventsDefaultArgs> = $Result.GetResult<Prisma.$ws_eventsPayload, S>

  type ws_eventsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ws_eventsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Ws_eventsCountAggregateInputType | true
    }

  export interface ws_eventsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ws_events'], meta: { name: 'ws_events' } }
    /**
     * Find zero or one Ws_events that matches the filter.
     * @param {ws_eventsFindUniqueArgs} args - Arguments to find a Ws_events
     * @example
     * // Get one Ws_events
     * const ws_events = await prisma.ws_events.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ws_eventsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ws_eventsFindUniqueArgs<ExtArgs>>
    ): Prisma__ws_eventsClient<$Result.GetResult<Prisma.$ws_eventsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Ws_events that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ws_eventsFindUniqueOrThrowArgs} args - Arguments to find a Ws_events
     * @example
     * // Get one Ws_events
     * const ws_events = await prisma.ws_events.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ws_eventsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ws_eventsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ws_eventsClient<$Result.GetResult<Prisma.$ws_eventsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Ws_events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ws_eventsFindFirstArgs} args - Arguments to find a Ws_events
     * @example
     * // Get one Ws_events
     * const ws_events = await prisma.ws_events.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ws_eventsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ws_eventsFindFirstArgs<ExtArgs>>
    ): Prisma__ws_eventsClient<$Result.GetResult<Prisma.$ws_eventsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Ws_events that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ws_eventsFindFirstOrThrowArgs} args - Arguments to find a Ws_events
     * @example
     * // Get one Ws_events
     * const ws_events = await prisma.ws_events.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ws_eventsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ws_eventsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ws_eventsClient<$Result.GetResult<Prisma.$ws_eventsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Ws_events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ws_eventsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ws_events
     * const ws_events = await prisma.ws_events.findMany()
     * 
     * // Get first 10 Ws_events
     * const ws_events = await prisma.ws_events.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ws_eventsWithIdOnly = await prisma.ws_events.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ws_eventsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ws_eventsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ws_eventsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Ws_events.
     * @param {ws_eventsCreateArgs} args - Arguments to create a Ws_events.
     * @example
     * // Create one Ws_events
     * const Ws_events = await prisma.ws_events.create({
     *   data: {
     *     // ... data to create a Ws_events
     *   }
     * })
     * 
    **/
    create<T extends ws_eventsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ws_eventsCreateArgs<ExtArgs>>
    ): Prisma__ws_eventsClient<$Result.GetResult<Prisma.$ws_eventsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Ws_events.
     *     @param {ws_eventsCreateManyArgs} args - Arguments to create many Ws_events.
     *     @example
     *     // Create many Ws_events
     *     const ws_events = await prisma.ws_events.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ws_eventsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ws_eventsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Ws_events.
     * @param {ws_eventsDeleteArgs} args - Arguments to delete one Ws_events.
     * @example
     * // Delete one Ws_events
     * const Ws_events = await prisma.ws_events.delete({
     *   where: {
     *     // ... filter to delete one Ws_events
     *   }
     * })
     * 
    **/
    delete<T extends ws_eventsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ws_eventsDeleteArgs<ExtArgs>>
    ): Prisma__ws_eventsClient<$Result.GetResult<Prisma.$ws_eventsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Ws_events.
     * @param {ws_eventsUpdateArgs} args - Arguments to update one Ws_events.
     * @example
     * // Update one Ws_events
     * const ws_events = await prisma.ws_events.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ws_eventsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ws_eventsUpdateArgs<ExtArgs>>
    ): Prisma__ws_eventsClient<$Result.GetResult<Prisma.$ws_eventsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Ws_events.
     * @param {ws_eventsDeleteManyArgs} args - Arguments to filter Ws_events to delete.
     * @example
     * // Delete a few Ws_events
     * const { count } = await prisma.ws_events.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ws_eventsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ws_eventsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ws_events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ws_eventsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ws_events
     * const ws_events = await prisma.ws_events.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ws_eventsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ws_eventsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ws_events.
     * @param {ws_eventsUpsertArgs} args - Arguments to update or create a Ws_events.
     * @example
     * // Update or create a Ws_events
     * const ws_events = await prisma.ws_events.upsert({
     *   create: {
     *     // ... data to create a Ws_events
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ws_events we want to update
     *   }
     * })
    **/
    upsert<T extends ws_eventsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ws_eventsUpsertArgs<ExtArgs>>
    ): Prisma__ws_eventsClient<$Result.GetResult<Prisma.$ws_eventsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Ws_events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ws_eventsCountArgs} args - Arguments to filter Ws_events to count.
     * @example
     * // Count the number of Ws_events
     * const count = await prisma.ws_events.count({
     *   where: {
     *     // ... the filter for the Ws_events we want to count
     *   }
     * })
    **/
    count<T extends ws_eventsCountArgs>(
      args?: Subset<T, ws_eventsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ws_eventsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ws_events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ws_eventsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ws_eventsAggregateArgs>(args: Subset<T, Ws_eventsAggregateArgs>): Prisma.PrismaPromise<GetWs_eventsAggregateType<T>>

    /**
     * Group by Ws_events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ws_eventsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ws_eventsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ws_eventsGroupByArgs['orderBy'] }
        : { orderBy?: ws_eventsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ws_eventsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWs_eventsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ws_events model
   */
  readonly fields: ws_eventsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ws_events.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ws_eventsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ws_events model
   */ 
  interface ws_eventsFieldRefs {
    readonly id: FieldRef<"ws_events", 'BigInt'>
    readonly type: FieldRef<"ws_events", 'String'>
    readonly ts: FieldRef<"ws_events", 'DateTime'>
    readonly event: FieldRef<"ws_events", 'Json'>
    readonly lynxtag: FieldRef<"ws_events", 'String'>
  }
    

  // Custom InputTypes

  /**
   * ws_events findUnique
   */
  export type ws_eventsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ws_events
     */
    select?: ws_eventsSelect<ExtArgs> | null
    /**
     * Filter, which ws_events to fetch.
     */
    where: ws_eventsWhereUniqueInput
  }


  /**
   * ws_events findUniqueOrThrow
   */
  export type ws_eventsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ws_events
     */
    select?: ws_eventsSelect<ExtArgs> | null
    /**
     * Filter, which ws_events to fetch.
     */
    where: ws_eventsWhereUniqueInput
  }


  /**
   * ws_events findFirst
   */
  export type ws_eventsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ws_events
     */
    select?: ws_eventsSelect<ExtArgs> | null
    /**
     * Filter, which ws_events to fetch.
     */
    where?: ws_eventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ws_events to fetch.
     */
    orderBy?: ws_eventsOrderByWithRelationInput | ws_eventsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ws_events.
     */
    cursor?: ws_eventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ws_events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ws_events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ws_events.
     */
    distinct?: Ws_eventsScalarFieldEnum | Ws_eventsScalarFieldEnum[]
  }


  /**
   * ws_events findFirstOrThrow
   */
  export type ws_eventsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ws_events
     */
    select?: ws_eventsSelect<ExtArgs> | null
    /**
     * Filter, which ws_events to fetch.
     */
    where?: ws_eventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ws_events to fetch.
     */
    orderBy?: ws_eventsOrderByWithRelationInput | ws_eventsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ws_events.
     */
    cursor?: ws_eventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ws_events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ws_events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ws_events.
     */
    distinct?: Ws_eventsScalarFieldEnum | Ws_eventsScalarFieldEnum[]
  }


  /**
   * ws_events findMany
   */
  export type ws_eventsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ws_events
     */
    select?: ws_eventsSelect<ExtArgs> | null
    /**
     * Filter, which ws_events to fetch.
     */
    where?: ws_eventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ws_events to fetch.
     */
    orderBy?: ws_eventsOrderByWithRelationInput | ws_eventsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ws_events.
     */
    cursor?: ws_eventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ws_events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ws_events.
     */
    skip?: number
    distinct?: Ws_eventsScalarFieldEnum | Ws_eventsScalarFieldEnum[]
  }


  /**
   * ws_events create
   */
  export type ws_eventsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ws_events
     */
    select?: ws_eventsSelect<ExtArgs> | null
    /**
     * The data needed to create a ws_events.
     */
    data: XOR<ws_eventsCreateInput, ws_eventsUncheckedCreateInput>
  }


  /**
   * ws_events createMany
   */
  export type ws_eventsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ws_events.
     */
    data: ws_eventsCreateManyInput | ws_eventsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ws_events update
   */
  export type ws_eventsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ws_events
     */
    select?: ws_eventsSelect<ExtArgs> | null
    /**
     * The data needed to update a ws_events.
     */
    data: XOR<ws_eventsUpdateInput, ws_eventsUncheckedUpdateInput>
    /**
     * Choose, which ws_events to update.
     */
    where: ws_eventsWhereUniqueInput
  }


  /**
   * ws_events updateMany
   */
  export type ws_eventsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ws_events.
     */
    data: XOR<ws_eventsUpdateManyMutationInput, ws_eventsUncheckedUpdateManyInput>
    /**
     * Filter which ws_events to update
     */
    where?: ws_eventsWhereInput
  }


  /**
   * ws_events upsert
   */
  export type ws_eventsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ws_events
     */
    select?: ws_eventsSelect<ExtArgs> | null
    /**
     * The filter to search for the ws_events to update in case it exists.
     */
    where: ws_eventsWhereUniqueInput
    /**
     * In case the ws_events found by the `where` argument doesn't exist, create a new ws_events with this data.
     */
    create: XOR<ws_eventsCreateInput, ws_eventsUncheckedCreateInput>
    /**
     * In case the ws_events was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ws_eventsUpdateInput, ws_eventsUncheckedUpdateInput>
  }


  /**
   * ws_events delete
   */
  export type ws_eventsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ws_events
     */
    select?: ws_eventsSelect<ExtArgs> | null
    /**
     * Filter which ws_events to delete.
     */
    where: ws_eventsWhereUniqueInput
  }


  /**
   * ws_events deleteMany
   */
  export type ws_eventsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ws_events to delete
     */
    where?: ws_eventsWhereInput
  }


  /**
   * ws_events without action
   */
  export type ws_eventsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ws_events
     */
    select?: ws_eventsSelect<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const Bot_commandsScalarFieldEnum: {
    id: 'id',
    bot_id: 'bot_id',
    cmd_type: 'cmd_type',
    groups: 'groups',
    name: 'name',
    vote_locked: 'vote_locked',
    description: 'description',
    args: 'args',
    examples: 'examples',
    premium_only: 'premium_only',
    notes: 'notes',
    doc_link: 'doc_link',
    nsfw: 'nsfw',
    lynxtag: 'lynxtag'
  };

  export type Bot_commandsScalarFieldEnum = (typeof Bot_commandsScalarFieldEnum)[keyof typeof Bot_commandsScalarFieldEnum]


  export const Bot_eventsScalarFieldEnum: {
    bot_id: 'bot_id',
    event_type: 'event_type',
    ts: 'ts',
    reason: 'reason',
    css: 'css',
    id: 'id',
    lynxtag: 'lynxtag'
  };

  export type Bot_eventsScalarFieldEnum = (typeof Bot_eventsScalarFieldEnum)[keyof typeof Bot_eventsScalarFieldEnum]


  export const Bot_list_featureScalarFieldEnum: {
    feature_id: 'feature_id',
    name: 'name',
    iname: 'iname',
    description: 'description',
    positive: 'positive',
    lynxtag: 'lynxtag'
  };

  export type Bot_list_featureScalarFieldEnum = (typeof Bot_list_featureScalarFieldEnum)[keyof typeof Bot_list_featureScalarFieldEnum]


  export const Bot_list_tagsScalarFieldEnum: {
    id: 'id',
    icon: 'icon',
    lynxtag: 'lynxtag'
  };

  export type Bot_list_tagsScalarFieldEnum = (typeof Bot_list_tagsScalarFieldEnum)[keyof typeof Bot_list_tagsScalarFieldEnum]


  export const Bot_ownerScalarFieldEnum: {
    bot_id: 'bot_id',
    owner: 'owner',
    main: 'main',
    id: 'id',
    lynxtag: 'lynxtag'
  };

  export type Bot_ownerScalarFieldEnum = (typeof Bot_ownerScalarFieldEnum)[keyof typeof Bot_ownerScalarFieldEnum]


  export const Bot_packsScalarFieldEnum: {
    id: 'id',
    icon: 'icon',
    banner: 'banner',
    owner: 'owner',
    bots: 'bots',
    description: 'description',
    name: 'name',
    created_at: 'created_at',
    lynxtag: 'lynxtag'
  };

  export type Bot_packsScalarFieldEnum = (typeof Bot_packsScalarFieldEnum)[keyof typeof Bot_packsScalarFieldEnum]


  export const Bot_promotionsScalarFieldEnum: {
    id: 'id',
    bot_id: 'bot_id',
    title: 'title',
    info: 'info',
    css: 'css',
    type: 'type',
    lynxtag: 'lynxtag'
  };

  export type Bot_promotionsScalarFieldEnum = (typeof Bot_promotionsScalarFieldEnum)[keyof typeof Bot_promotionsScalarFieldEnum]


  export const Bot_stats_votes_pmScalarFieldEnum: {
    bot_id: 'bot_id',
    votes: 'votes',
    epoch: 'epoch',
    lynxtag: 'lynxtag'
  };

  export type Bot_stats_votes_pmScalarFieldEnum = (typeof Bot_stats_votes_pmScalarFieldEnum)[keyof typeof Bot_stats_votes_pmScalarFieldEnum]


  export const Bot_tagsScalarFieldEnum: {
    bot_id: 'bot_id',
    tag: 'tag',
    id: 'id',
    lynxtag: 'lynxtag'
  };

  export type Bot_tagsScalarFieldEnum = (typeof Bot_tagsScalarFieldEnum)[keyof typeof Bot_tagsScalarFieldEnum]


  export const Bot_votersScalarFieldEnum: {
    bot_id: 'bot_id',
    user_id: 'user_id',
    timestamps: 'timestamps',
    lynxtag: 'lynxtag'
  };

  export type Bot_votersScalarFieldEnum = (typeof Bot_votersScalarFieldEnum)[keyof typeof Bot_votersScalarFieldEnum]


  export const BotsScalarFieldEnum: {
    bot_id: 'bot_id',
    votes: 'votes',
    guild_count: 'guild_count',
    shard_count: 'shard_count',
    bot_library: 'bot_library',
    webhook: 'webhook',
    description: 'description',
    long_description: 'long_description',
    prefix: 'prefix',
    api_token: 'api_token',
    banner_card: 'banner_card',
    created_at: 'created_at',
    invite: 'invite',
    features: 'features',
    invite_amount: 'invite_amount',
    user_count: 'user_count',
    css: 'css',
    shards: 'shards',
    username_cached: 'username_cached',
    state: 'state',
    long_description_type: 'long_description_type',
    verifier: 'verifier',
    last_stats_post: 'last_stats_post',
    webhook_secret: 'webhook_secret',
    webhook_type: 'webhook_type',
    di_text: 'di_text',
    id: 'id',
    banner_page: 'banner_page',
    total_votes: 'total_votes',
    client_id: 'client_id',
    flags: 'flags',
    uptime_checks_total: 'uptime_checks_total',
    uptime_checks_failed: 'uptime_checks_failed',
    page_style: 'page_style',
    webhook_hmac_only: 'webhook_hmac_only',
    last_updated_at: 'last_updated_at',
    avatar_cached: 'avatar_cached',
    disc_cached: 'disc_cached',
    extra_links: 'extra_links',
    lynxtag: 'lynxtag'
  };

  export type BotsScalarFieldEnum = (typeof BotsScalarFieldEnum)[keyof typeof BotsScalarFieldEnum]


  export const Extra_dataScalarFieldEnum: {
    name: 'name',
    value: 'value',
    user_id: 'user_id',
    lynxtag: 'lynxtag'
  };

  export type Extra_dataScalarFieldEnum = (typeof Extra_dataScalarFieldEnum)[keyof typeof Extra_dataScalarFieldEnum]


  export const FeaturesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    viewed_as: 'viewed_as',
    lynxtag: 'lynxtag'
  };

  export type FeaturesScalarFieldEnum = (typeof FeaturesScalarFieldEnum)[keyof typeof FeaturesScalarFieldEnum]


  export const Frostpaw_clientsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    domain: 'domain',
    privacy_policy: 'privacy_policy',
    secret: 'secret',
    owner_id: 'owner_id',
    lynxtag: 'lynxtag',
    verified: 'verified'
  };

  export type Frostpaw_clientsScalarFieldEnum = (typeof Frostpaw_clientsScalarFieldEnum)[keyof typeof Frostpaw_clientsScalarFieldEnum]


  export const Leave_of_absenceScalarFieldEnum: {
    reason: 'reason',
    start_date: 'start_date',
    user_id: 'user_id',
    id: 'id',
    lynxtag: 'lynxtag'
  };

  export type Leave_of_absenceScalarFieldEnum = (typeof Leave_of_absenceScalarFieldEnum)[keyof typeof Leave_of_absenceScalarFieldEnum]


  export const Lynx_appsScalarFieldEnum: {
    user_id: 'user_id',
    app_id: 'app_id',
    questions: 'questions',
    answers: 'answers',
    app_version: 'app_version',
    created_at: 'created_at',
    lynxtag: 'lynxtag'
  };

  export type Lynx_appsScalarFieldEnum = (typeof Lynx_appsScalarFieldEnum)[keyof typeof Lynx_appsScalarFieldEnum]


  export const Lynx_dataScalarFieldEnum: {
    default_user_experiments: 'default_user_experiments',
    id: 'id',
    lynxtag: 'lynxtag'
  };

  export type Lynx_dataScalarFieldEnum = (typeof Lynx_dataScalarFieldEnum)[keyof typeof Lynx_dataScalarFieldEnum]


  export const Lynx_logsScalarFieldEnum: {
    user_id: 'user_id',
    method: 'method',
    url: 'url',
    status_code: 'status_code',
    request_time: 'request_time',
    lynxtag: 'lynxtag'
  };

  export type Lynx_logsScalarFieldEnum = (typeof Lynx_logsScalarFieldEnum)[keyof typeof Lynx_logsScalarFieldEnum]


  export const Lynx_notificationsScalarFieldEnum: {
    acked_users: 'acked_users',
    message: 'message',
    type: 'type',
    id: 'id',
    staff_only: 'staff_only',
    lynxtag: 'lynxtag'
  };

  export type Lynx_notificationsScalarFieldEnum = (typeof Lynx_notificationsScalarFieldEnum)[keyof typeof Lynx_notificationsScalarFieldEnum]


  export const Lynx_ratingsScalarFieldEnum: {
    id: 'id',
    feedback: 'feedback',
    username_cached: 'username_cached',
    user_id: 'user_id',
    page: 'page',
    lynxtag: 'lynxtag'
  };

  export type Lynx_ratingsScalarFieldEnum = (typeof Lynx_ratingsScalarFieldEnum)[keyof typeof Lynx_ratingsScalarFieldEnum]


  export const Lynx_survey_responsesScalarFieldEnum: {
    id: 'id',
    questions: 'questions',
    answers: 'answers',
    username_cached: 'username_cached',
    user_id: 'user_id',
    survey_id: 'survey_id',
    lynxtag: 'lynxtag'
  };

  export type Lynx_survey_responsesScalarFieldEnum = (typeof Lynx_survey_responsesScalarFieldEnum)[keyof typeof Lynx_survey_responsesScalarFieldEnum]


  export const Lynx_surveysScalarFieldEnum: {
    id: 'id',
    title: 'title',
    questions: 'questions',
    created_at: 'created_at',
    lynxtag: 'lynxtag'
  };

  export type Lynx_surveysScalarFieldEnum = (typeof Lynx_surveysScalarFieldEnum)[keyof typeof Lynx_surveysScalarFieldEnum]


  export const MigrationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    app_name: 'app_name',
    ran_on: 'ran_on',
    lynxtag: 'lynxtag'
  };

  export type MigrationScalarFieldEnum = (typeof MigrationScalarFieldEnum)[keyof typeof MigrationScalarFieldEnum]


  export const Piccolo_userScalarFieldEnum: {
    id: 'id',
    username: 'username',
    password: 'password',
    email: 'email',
    active: 'active',
    admin: 'admin',
    first_name: 'first_name',
    last_name: 'last_name',
    superuser: 'superuser',
    last_login: 'last_login',
    lynxtag: 'lynxtag'
  };

  export type Piccolo_userScalarFieldEnum = (typeof Piccolo_userScalarFieldEnum)[keyof typeof Piccolo_userScalarFieldEnum]


  export const Platform_mapScalarFieldEnum: {
    fates_id: 'fates_id',
    platform_id: 'platform_id',
    lynxtag: 'lynxtag'
  };

  export type Platform_mapScalarFieldEnum = (typeof Platform_mapScalarFieldEnum)[keyof typeof Platform_mapScalarFieldEnum]


  export const Push_notificationsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    token: 'token'
  };

  export type Push_notificationsScalarFieldEnum = (typeof Push_notificationsScalarFieldEnum)[keyof typeof Push_notificationsScalarFieldEnum]


  export const Review_votesScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    upvote: 'upvote',
    lynxtag: 'lynxtag'
  };

  export type Review_votesScalarFieldEnum = (typeof Review_votesScalarFieldEnum)[keyof typeof Review_votesScalarFieldEnum]


  export const ReviewsScalarFieldEnum: {
    id: 'id',
    target_id: 'target_id',
    user_id: 'user_id',
    star_rating: 'star_rating',
    review_text: 'review_text',
    flagged: 'flagged',
    epoch: 'epoch',
    target_type: 'target_type',
    parent_id: 'parent_id',
    lynxtag: 'lynxtag'
  };

  export type ReviewsScalarFieldEnum = (typeof ReviewsScalarFieldEnum)[keyof typeof ReviewsScalarFieldEnum]


  export const Server_audit_logsScalarFieldEnum: {
    guild_id: 'guild_id',
    user_id: 'user_id',
    username: 'username',
    user_guild_perms: 'user_guild_perms',
    field: 'field',
    value: 'value',
    action_time: 'action_time',
    action_id: 'action_id',
    lynxtag: 'lynxtag'
  };

  export type Server_audit_logsScalarFieldEnum = (typeof Server_audit_logsScalarFieldEnum)[keyof typeof Server_audit_logsScalarFieldEnum]


  export const Server_tagsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    owner_guild: 'owner_guild',
    iconify_data: 'iconify_data',
    lynxtag: 'lynxtag'
  };

  export type Server_tagsScalarFieldEnum = (typeof Server_tagsScalarFieldEnum)[keyof typeof Server_tagsScalarFieldEnum]


  export const Server_votersScalarFieldEnum: {
    guild_id: 'guild_id',
    user_id: 'user_id',
    timestamps: 'timestamps',
    lynxtag: 'lynxtag'
  };

  export type Server_votersScalarFieldEnum = (typeof Server_votersScalarFieldEnum)[keyof typeof Server_votersScalarFieldEnum]


  export const ServersScalarFieldEnum: {
    guild_id: 'guild_id',
    votes: 'votes',
    webhook: 'webhook',
    description: 'description',
    long_description: 'long_description',
    css: 'css',
    api_token: 'api_token',
    invite_amount: 'invite_amount',
    invite_url: 'invite_url',
    name_cached: 'name_cached',
    long_description_type: 'long_description_type',
    state: 'state',
    created_at: 'created_at',
    avatar_cached: 'avatar_cached',
    invite_channel: 'invite_channel',
    guild_count: 'guild_count',
    banner_card: 'banner_card',
    banner_page: 'banner_page',
    webhook_secret: 'webhook_secret',
    webhook_type: 'webhook_type',
    total_votes: 'total_votes',
    tags: 'tags',
    owner_id: 'owner_id',
    flags: 'flags',
    autorole_votes: 'autorole_votes',
    whitelist_form: 'whitelist_form',
    webhook_hmac_only: 'webhook_hmac_only',
    old_state: 'old_state',
    user_whitelist: 'user_whitelist',
    user_blacklist: 'user_blacklist',
    extra_links: 'extra_links',
    lynxtag: 'lynxtag'
  };

  export type ServersScalarFieldEnum = (typeof ServersScalarFieldEnum)[keyof typeof ServersScalarFieldEnum]


  export const SessionsScalarFieldEnum: {
    id: 'id',
    token: 'token',
    user_id: 'user_id',
    expiry_date: 'expiry_date',
    max_expiry_date: 'max_expiry_date',
    lynxtag: 'lynxtag'
  };

  export type SessionsScalarFieldEnum = (typeof SessionsScalarFieldEnum)[keyof typeof SessionsScalarFieldEnum]


  export const User_bot_logsScalarFieldEnum: {
    user_id: 'user_id',
    bot_id: 'bot_id',
    action_time: 'action_time',
    action: 'action',
    context: 'context',
    lynxtag: 'lynxtag'
  };

  export type User_bot_logsScalarFieldEnum = (typeof User_bot_logsScalarFieldEnum)[keyof typeof User_bot_logsScalarFieldEnum]


  export const User_connectionsScalarFieldEnum: {
    user_id: 'user_id',
    client_id: 'client_id',
    refresh_token: 'refresh_token',
    expires_on: 'expires_on',
    lynxtag: 'lynxtag'
  };

  export type User_connectionsScalarFieldEnum = (typeof User_connectionsScalarFieldEnum)[keyof typeof User_connectionsScalarFieldEnum]


  export const User_server_vote_tableScalarFieldEnum: {
    user_id: 'user_id',
    guild_id: 'guild_id',
    expires_on: 'expires_on',
    lynxtag: 'lynxtag'
  };

  export type User_server_vote_tableScalarFieldEnum = (typeof User_server_vote_tableScalarFieldEnum)[keyof typeof User_server_vote_tableScalarFieldEnum]


  export const User_vote_tableScalarFieldEnum: {
    user_id: 'user_id',
    bot_id: 'bot_id',
    expires_on: 'expires_on',
    lynxtag: 'lynxtag'
  };

  export type User_vote_tableScalarFieldEnum = (typeof User_vote_tableScalarFieldEnum)[keyof typeof User_vote_tableScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    user_id: 'user_id',
    api_token: 'api_token',
    description: 'description',
    badges: 'badges',
    username: 'username',
    user_css: 'user_css',
    state: 'state',
    coins: 'coins',
    id: 'id',
    site_lang: 'site_lang',
    profile_css: 'profile_css',
    vote_reminders: 'vote_reminders',
    vote_reminder_channel: 'vote_reminder_channel',
    staff_verify_code: 'staff_verify_code',
    vote_reminders_last_acked: 'vote_reminders_last_acked',
    vote_reminders_servers: 'vote_reminders_servers',
    vote_reminders_servers_last_acked: 'vote_reminders_servers_last_acked',
    vote_reminder_servers_channel: 'vote_reminder_servers_channel',
    experiments: 'experiments',
    flags: 'flags',
    extra_links: 'extra_links',
    supabase_id: 'supabase_id',
    totp_shared_key: 'totp_shared_key',
    staff_password: 'staff_password',
    lynxtag: 'lynxtag'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const VanityScalarFieldEnum: {
    type: 'type',
    vanity_url: 'vanity_url',
    redirect: 'redirect',
    lynxtag: 'lynxtag'
  };

  export type VanityScalarFieldEnum = (typeof VanityScalarFieldEnum)[keyof typeof VanityScalarFieldEnum]


  export const Ws_eventsScalarFieldEnum: {
    id: 'id',
    type: 'type',
    ts: 'ts',
    event: 'event',
    lynxtag: 'lynxtag'
  };

  export type Ws_eventsScalarFieldEnum = (typeof Ws_eventsScalarFieldEnum)[keyof typeof Ws_eventsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type bot_commandsWhereInput = {
    AND?: bot_commandsWhereInput | bot_commandsWhereInput[]
    OR?: bot_commandsWhereInput[]
    NOT?: bot_commandsWhereInput | bot_commandsWhereInput[]
    id?: UuidFilter<"bot_commands"> | string
    bot_id?: BigIntFilter<"bot_commands"> | bigint | number
    cmd_type?: IntFilter<"bot_commands"> | number
    groups?: StringNullableListFilter<"bot_commands">
    name?: StringFilter<"bot_commands"> | string
    vote_locked?: BoolFilter<"bot_commands"> | boolean
    description?: StringFilter<"bot_commands"> | string
    args?: StringNullableListFilter<"bot_commands">
    examples?: StringNullableListFilter<"bot_commands">
    premium_only?: BoolFilter<"bot_commands"> | boolean
    notes?: StringNullableListFilter<"bot_commands">
    doc_link?: StringNullableFilter<"bot_commands"> | string | null
    nsfw?: BoolNullableFilter<"bot_commands"> | boolean | null
    lynxtag?: UuidFilter<"bot_commands"> | string
    bots?: XOR<BotsRelationFilter, botsWhereInput>
  }

  export type bot_commandsOrderByWithRelationInput = {
    id?: SortOrder
    bot_id?: SortOrder
    cmd_type?: SortOrder
    groups?: SortOrder
    name?: SortOrder
    vote_locked?: SortOrder
    description?: SortOrder
    args?: SortOrder
    examples?: SortOrder
    premium_only?: SortOrder
    notes?: SortOrder
    doc_link?: SortOrderInput | SortOrder
    nsfw?: SortOrderInput | SortOrder
    lynxtag?: SortOrder
    bots?: botsOrderByWithRelationInput
  }

  export type bot_commandsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    lynxtag?: string
    AND?: bot_commandsWhereInput | bot_commandsWhereInput[]
    OR?: bot_commandsWhereInput[]
    NOT?: bot_commandsWhereInput | bot_commandsWhereInput[]
    bot_id?: BigIntFilter<"bot_commands"> | bigint | number
    cmd_type?: IntFilter<"bot_commands"> | number
    groups?: StringNullableListFilter<"bot_commands">
    name?: StringFilter<"bot_commands"> | string
    vote_locked?: BoolFilter<"bot_commands"> | boolean
    description?: StringFilter<"bot_commands"> | string
    args?: StringNullableListFilter<"bot_commands">
    examples?: StringNullableListFilter<"bot_commands">
    premium_only?: BoolFilter<"bot_commands"> | boolean
    notes?: StringNullableListFilter<"bot_commands">
    doc_link?: StringNullableFilter<"bot_commands"> | string | null
    nsfw?: BoolNullableFilter<"bot_commands"> | boolean | null
    bots?: XOR<BotsRelationFilter, botsWhereInput>
  }, "id" | "lynxtag">

  export type bot_commandsOrderByWithAggregationInput = {
    id?: SortOrder
    bot_id?: SortOrder
    cmd_type?: SortOrder
    groups?: SortOrder
    name?: SortOrder
    vote_locked?: SortOrder
    description?: SortOrder
    args?: SortOrder
    examples?: SortOrder
    premium_only?: SortOrder
    notes?: SortOrder
    doc_link?: SortOrderInput | SortOrder
    nsfw?: SortOrderInput | SortOrder
    lynxtag?: SortOrder
    _count?: bot_commandsCountOrderByAggregateInput
    _avg?: bot_commandsAvgOrderByAggregateInput
    _max?: bot_commandsMaxOrderByAggregateInput
    _min?: bot_commandsMinOrderByAggregateInput
    _sum?: bot_commandsSumOrderByAggregateInput
  }

  export type bot_commandsScalarWhereWithAggregatesInput = {
    AND?: bot_commandsScalarWhereWithAggregatesInput | bot_commandsScalarWhereWithAggregatesInput[]
    OR?: bot_commandsScalarWhereWithAggregatesInput[]
    NOT?: bot_commandsScalarWhereWithAggregatesInput | bot_commandsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"bot_commands"> | string
    bot_id?: BigIntWithAggregatesFilter<"bot_commands"> | bigint | number
    cmd_type?: IntWithAggregatesFilter<"bot_commands"> | number
    groups?: StringNullableListFilter<"bot_commands">
    name?: StringWithAggregatesFilter<"bot_commands"> | string
    vote_locked?: BoolWithAggregatesFilter<"bot_commands"> | boolean
    description?: StringWithAggregatesFilter<"bot_commands"> | string
    args?: StringNullableListFilter<"bot_commands">
    examples?: StringNullableListFilter<"bot_commands">
    premium_only?: BoolWithAggregatesFilter<"bot_commands"> | boolean
    notes?: StringNullableListFilter<"bot_commands">
    doc_link?: StringNullableWithAggregatesFilter<"bot_commands"> | string | null
    nsfw?: BoolNullableWithAggregatesFilter<"bot_commands"> | boolean | null
    lynxtag?: UuidWithAggregatesFilter<"bot_commands"> | string
  }

  export type bot_eventsWhereInput = {
    AND?: bot_eventsWhereInput | bot_eventsWhereInput[]
    OR?: bot_eventsWhereInput[]
    NOT?: bot_eventsWhereInput | bot_eventsWhereInput[]
    bot_id?: BigIntFilter<"bot_events"> | bigint | number
    event_type?: IntFilter<"bot_events"> | number
    ts?: DateTimeFilter<"bot_events"> | Date | string
    reason?: StringFilter<"bot_events"> | string
    css?: StringFilter<"bot_events"> | string
    id?: UuidFilter<"bot_events"> | string
    lynxtag?: UuidFilter<"bot_events"> | string
    bots?: XOR<BotsRelationFilter, botsWhereInput>
  }

  export type bot_eventsOrderByWithRelationInput = {
    bot_id?: SortOrder
    event_type?: SortOrder
    ts?: SortOrder
    reason?: SortOrder
    css?: SortOrder
    id?: SortOrder
    lynxtag?: SortOrder
    bots?: botsOrderByWithRelationInput
  }

  export type bot_eventsWhereUniqueInput = Prisma.AtLeast<{
    lynxtag?: string
    AND?: bot_eventsWhereInput | bot_eventsWhereInput[]
    OR?: bot_eventsWhereInput[]
    NOT?: bot_eventsWhereInput | bot_eventsWhereInput[]
    bot_id?: BigIntFilter<"bot_events"> | bigint | number
    event_type?: IntFilter<"bot_events"> | number
    ts?: DateTimeFilter<"bot_events"> | Date | string
    reason?: StringFilter<"bot_events"> | string
    css?: StringFilter<"bot_events"> | string
    id?: UuidFilter<"bot_events"> | string
    bots?: XOR<BotsRelationFilter, botsWhereInput>
  }, "lynxtag">

  export type bot_eventsOrderByWithAggregationInput = {
    bot_id?: SortOrder
    event_type?: SortOrder
    ts?: SortOrder
    reason?: SortOrder
    css?: SortOrder
    id?: SortOrder
    lynxtag?: SortOrder
    _count?: bot_eventsCountOrderByAggregateInput
    _avg?: bot_eventsAvgOrderByAggregateInput
    _max?: bot_eventsMaxOrderByAggregateInput
    _min?: bot_eventsMinOrderByAggregateInput
    _sum?: bot_eventsSumOrderByAggregateInput
  }

  export type bot_eventsScalarWhereWithAggregatesInput = {
    AND?: bot_eventsScalarWhereWithAggregatesInput | bot_eventsScalarWhereWithAggregatesInput[]
    OR?: bot_eventsScalarWhereWithAggregatesInput[]
    NOT?: bot_eventsScalarWhereWithAggregatesInput | bot_eventsScalarWhereWithAggregatesInput[]
    bot_id?: BigIntWithAggregatesFilter<"bot_events"> | bigint | number
    event_type?: IntWithAggregatesFilter<"bot_events"> | number
    ts?: DateTimeWithAggregatesFilter<"bot_events"> | Date | string
    reason?: StringWithAggregatesFilter<"bot_events"> | string
    css?: StringWithAggregatesFilter<"bot_events"> | string
    id?: UuidWithAggregatesFilter<"bot_events"> | string
    lynxtag?: UuidWithAggregatesFilter<"bot_events"> | string
  }

  export type bot_list_featureWhereInput = {
    AND?: bot_list_featureWhereInput | bot_list_featureWhereInput[]
    OR?: bot_list_featureWhereInput[]
    NOT?: bot_list_featureWhereInput | bot_list_featureWhereInput[]
    feature_id?: IntFilter<"bot_list_feature"> | number
    name?: StringFilter<"bot_list_feature"> | string
    iname?: StringFilter<"bot_list_feature"> | string
    description?: StringNullableFilter<"bot_list_feature"> | string | null
    positive?: IntNullableFilter<"bot_list_feature"> | number | null
    lynxtag?: UuidFilter<"bot_list_feature"> | string
  }

  export type bot_list_featureOrderByWithRelationInput = {
    feature_id?: SortOrder
    name?: SortOrder
    iname?: SortOrder
    description?: SortOrderInput | SortOrder
    positive?: SortOrderInput | SortOrder
    lynxtag?: SortOrder
  }

  export type bot_list_featureWhereUniqueInput = Prisma.AtLeast<{
    feature_id?: number
    name?: string
    iname?: string
    lynxtag?: string
    AND?: bot_list_featureWhereInput | bot_list_featureWhereInput[]
    OR?: bot_list_featureWhereInput[]
    NOT?: bot_list_featureWhereInput | bot_list_featureWhereInput[]
    description?: StringNullableFilter<"bot_list_feature"> | string | null
    positive?: IntNullableFilter<"bot_list_feature"> | number | null
  }, "feature_id" | "name" | "iname" | "lynxtag">

  export type bot_list_featureOrderByWithAggregationInput = {
    feature_id?: SortOrder
    name?: SortOrder
    iname?: SortOrder
    description?: SortOrderInput | SortOrder
    positive?: SortOrderInput | SortOrder
    lynxtag?: SortOrder
    _count?: bot_list_featureCountOrderByAggregateInput
    _avg?: bot_list_featureAvgOrderByAggregateInput
    _max?: bot_list_featureMaxOrderByAggregateInput
    _min?: bot_list_featureMinOrderByAggregateInput
    _sum?: bot_list_featureSumOrderByAggregateInput
  }

  export type bot_list_featureScalarWhereWithAggregatesInput = {
    AND?: bot_list_featureScalarWhereWithAggregatesInput | bot_list_featureScalarWhereWithAggregatesInput[]
    OR?: bot_list_featureScalarWhereWithAggregatesInput[]
    NOT?: bot_list_featureScalarWhereWithAggregatesInput | bot_list_featureScalarWhereWithAggregatesInput[]
    feature_id?: IntWithAggregatesFilter<"bot_list_feature"> | number
    name?: StringWithAggregatesFilter<"bot_list_feature"> | string
    iname?: StringWithAggregatesFilter<"bot_list_feature"> | string
    description?: StringNullableWithAggregatesFilter<"bot_list_feature"> | string | null
    positive?: IntNullableWithAggregatesFilter<"bot_list_feature"> | number | null
    lynxtag?: UuidWithAggregatesFilter<"bot_list_feature"> | string
  }

  export type bot_list_tagsWhereInput = {
    AND?: bot_list_tagsWhereInput | bot_list_tagsWhereInput[]
    OR?: bot_list_tagsWhereInput[]
    NOT?: bot_list_tagsWhereInput | bot_list_tagsWhereInput[]
    id?: StringFilter<"bot_list_tags"> | string
    icon?: StringFilter<"bot_list_tags"> | string
    lynxtag?: UuidFilter<"bot_list_tags"> | string
    bot_tags?: Bot_tagsListRelationFilter
  }

  export type bot_list_tagsOrderByWithRelationInput = {
    id?: SortOrder
    icon?: SortOrder
    lynxtag?: SortOrder
    bot_tags?: bot_tagsOrderByRelationAggregateInput
  }

  export type bot_list_tagsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    icon?: string
    lynxtag?: string
    AND?: bot_list_tagsWhereInput | bot_list_tagsWhereInput[]
    OR?: bot_list_tagsWhereInput[]
    NOT?: bot_list_tagsWhereInput | bot_list_tagsWhereInput[]
    bot_tags?: Bot_tagsListRelationFilter
  }, "id" | "icon" | "lynxtag">

  export type bot_list_tagsOrderByWithAggregationInput = {
    id?: SortOrder
    icon?: SortOrder
    lynxtag?: SortOrder
    _count?: bot_list_tagsCountOrderByAggregateInput
    _max?: bot_list_tagsMaxOrderByAggregateInput
    _min?: bot_list_tagsMinOrderByAggregateInput
  }

  export type bot_list_tagsScalarWhereWithAggregatesInput = {
    AND?: bot_list_tagsScalarWhereWithAggregatesInput | bot_list_tagsScalarWhereWithAggregatesInput[]
    OR?: bot_list_tagsScalarWhereWithAggregatesInput[]
    NOT?: bot_list_tagsScalarWhereWithAggregatesInput | bot_list_tagsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"bot_list_tags"> | string
    icon?: StringWithAggregatesFilter<"bot_list_tags"> | string
    lynxtag?: UuidWithAggregatesFilter<"bot_list_tags"> | string
  }

  export type bot_ownerWhereInput = {
    AND?: bot_ownerWhereInput | bot_ownerWhereInput[]
    OR?: bot_ownerWhereInput[]
    NOT?: bot_ownerWhereInput | bot_ownerWhereInput[]
    bot_id?: BigIntFilter<"bot_owner"> | bigint | number
    owner?: BigIntFilter<"bot_owner"> | bigint | number
    main?: BoolNullableFilter<"bot_owner"> | boolean | null
    id?: IntFilter<"bot_owner"> | number
    lynxtag?: UuidFilter<"bot_owner"> | string
    bots?: XOR<BotsRelationFilter, botsWhereInput>
  }

  export type bot_ownerOrderByWithRelationInput = {
    bot_id?: SortOrder
    owner?: SortOrder
    main?: SortOrderInput | SortOrder
    id?: SortOrder
    lynxtag?: SortOrder
    bots?: botsOrderByWithRelationInput
  }

  export type bot_ownerWhereUniqueInput = Prisma.AtLeast<{
    lynxtag?: string
    AND?: bot_ownerWhereInput | bot_ownerWhereInput[]
    OR?: bot_ownerWhereInput[]
    NOT?: bot_ownerWhereInput | bot_ownerWhereInput[]
    bot_id?: BigIntFilter<"bot_owner"> | bigint | number
    owner?: BigIntFilter<"bot_owner"> | bigint | number
    main?: BoolNullableFilter<"bot_owner"> | boolean | null
    id?: IntFilter<"bot_owner"> | number
    bots?: XOR<BotsRelationFilter, botsWhereInput>
  }, "lynxtag">

  export type bot_ownerOrderByWithAggregationInput = {
    bot_id?: SortOrder
    owner?: SortOrder
    main?: SortOrderInput | SortOrder
    id?: SortOrder
    lynxtag?: SortOrder
    _count?: bot_ownerCountOrderByAggregateInput
    _avg?: bot_ownerAvgOrderByAggregateInput
    _max?: bot_ownerMaxOrderByAggregateInput
    _min?: bot_ownerMinOrderByAggregateInput
    _sum?: bot_ownerSumOrderByAggregateInput
  }

  export type bot_ownerScalarWhereWithAggregatesInput = {
    AND?: bot_ownerScalarWhereWithAggregatesInput | bot_ownerScalarWhereWithAggregatesInput[]
    OR?: bot_ownerScalarWhereWithAggregatesInput[]
    NOT?: bot_ownerScalarWhereWithAggregatesInput | bot_ownerScalarWhereWithAggregatesInput[]
    bot_id?: BigIntWithAggregatesFilter<"bot_owner"> | bigint | number
    owner?: BigIntWithAggregatesFilter<"bot_owner"> | bigint | number
    main?: BoolNullableWithAggregatesFilter<"bot_owner"> | boolean | null
    id?: IntWithAggregatesFilter<"bot_owner"> | number
    lynxtag?: UuidWithAggregatesFilter<"bot_owner"> | string
  }

  export type bot_packsWhereInput = {
    AND?: bot_packsWhereInput | bot_packsWhereInput[]
    OR?: bot_packsWhereInput[]
    NOT?: bot_packsWhereInput | bot_packsWhereInput[]
    id?: UuidFilter<"bot_packs"> | string
    icon?: StringNullableFilter<"bot_packs"> | string | null
    banner?: StringNullableFilter<"bot_packs"> | string | null
    owner?: BigIntFilter<"bot_packs"> | bigint | number
    bots?: BigIntNullableListFilter<"bot_packs">
    description?: StringFilter<"bot_packs"> | string
    name?: StringFilter<"bot_packs"> | string
    created_at?: DateTimeNullableFilter<"bot_packs"> | Date | string | null
    lynxtag?: UuidFilter<"bot_packs"> | string
  }

  export type bot_packsOrderByWithRelationInput = {
    id?: SortOrder
    icon?: SortOrderInput | SortOrder
    banner?: SortOrderInput | SortOrder
    owner?: SortOrder
    bots?: SortOrder
    description?: SortOrder
    name?: SortOrder
    created_at?: SortOrderInput | SortOrder
    lynxtag?: SortOrder
  }

  export type bot_packsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    lynxtag?: string
    AND?: bot_packsWhereInput | bot_packsWhereInput[]
    OR?: bot_packsWhereInput[]
    NOT?: bot_packsWhereInput | bot_packsWhereInput[]
    icon?: StringNullableFilter<"bot_packs"> | string | null
    banner?: StringNullableFilter<"bot_packs"> | string | null
    owner?: BigIntFilter<"bot_packs"> | bigint | number
    bots?: BigIntNullableListFilter<"bot_packs">
    description?: StringFilter<"bot_packs"> | string
    name?: StringFilter<"bot_packs"> | string
    created_at?: DateTimeNullableFilter<"bot_packs"> | Date | string | null
  }, "id" | "lynxtag">

  export type bot_packsOrderByWithAggregationInput = {
    id?: SortOrder
    icon?: SortOrderInput | SortOrder
    banner?: SortOrderInput | SortOrder
    owner?: SortOrder
    bots?: SortOrder
    description?: SortOrder
    name?: SortOrder
    created_at?: SortOrderInput | SortOrder
    lynxtag?: SortOrder
    _count?: bot_packsCountOrderByAggregateInput
    _avg?: bot_packsAvgOrderByAggregateInput
    _max?: bot_packsMaxOrderByAggregateInput
    _min?: bot_packsMinOrderByAggregateInput
    _sum?: bot_packsSumOrderByAggregateInput
  }

  export type bot_packsScalarWhereWithAggregatesInput = {
    AND?: bot_packsScalarWhereWithAggregatesInput | bot_packsScalarWhereWithAggregatesInput[]
    OR?: bot_packsScalarWhereWithAggregatesInput[]
    NOT?: bot_packsScalarWhereWithAggregatesInput | bot_packsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"bot_packs"> | string
    icon?: StringNullableWithAggregatesFilter<"bot_packs"> | string | null
    banner?: StringNullableWithAggregatesFilter<"bot_packs"> | string | null
    owner?: BigIntWithAggregatesFilter<"bot_packs"> | bigint | number
    bots?: BigIntNullableListFilter<"bot_packs">
    description?: StringWithAggregatesFilter<"bot_packs"> | string
    name?: StringWithAggregatesFilter<"bot_packs"> | string
    created_at?: DateTimeNullableWithAggregatesFilter<"bot_packs"> | Date | string | null
    lynxtag?: UuidWithAggregatesFilter<"bot_packs"> | string
  }

  export type bot_promotionsWhereInput = {
    AND?: bot_promotionsWhereInput | bot_promotionsWhereInput[]
    OR?: bot_promotionsWhereInput[]
    NOT?: bot_promotionsWhereInput | bot_promotionsWhereInput[]
    id?: UuidFilter<"bot_promotions"> | string
    bot_id?: BigIntNullableFilter<"bot_promotions"> | bigint | number | null
    title?: StringNullableFilter<"bot_promotions"> | string | null
    info?: StringNullableFilter<"bot_promotions"> | string | null
    css?: StringNullableFilter<"bot_promotions"> | string | null
    type?: IntNullableFilter<"bot_promotions"> | number | null
    lynxtag?: UuidFilter<"bot_promotions"> | string
    bots?: XOR<BotsNullableRelationFilter, botsWhereInput> | null
  }

  export type bot_promotionsOrderByWithRelationInput = {
    id?: SortOrder
    bot_id?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    info?: SortOrderInput | SortOrder
    css?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    lynxtag?: SortOrder
    bots?: botsOrderByWithRelationInput
  }

  export type bot_promotionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    lynxtag?: string
    AND?: bot_promotionsWhereInput | bot_promotionsWhereInput[]
    OR?: bot_promotionsWhereInput[]
    NOT?: bot_promotionsWhereInput | bot_promotionsWhereInput[]
    bot_id?: BigIntNullableFilter<"bot_promotions"> | bigint | number | null
    title?: StringNullableFilter<"bot_promotions"> | string | null
    info?: StringNullableFilter<"bot_promotions"> | string | null
    css?: StringNullableFilter<"bot_promotions"> | string | null
    type?: IntNullableFilter<"bot_promotions"> | number | null
    bots?: XOR<BotsNullableRelationFilter, botsWhereInput> | null
  }, "id" | "lynxtag">

  export type bot_promotionsOrderByWithAggregationInput = {
    id?: SortOrder
    bot_id?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    info?: SortOrderInput | SortOrder
    css?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    lynxtag?: SortOrder
    _count?: bot_promotionsCountOrderByAggregateInput
    _avg?: bot_promotionsAvgOrderByAggregateInput
    _max?: bot_promotionsMaxOrderByAggregateInput
    _min?: bot_promotionsMinOrderByAggregateInput
    _sum?: bot_promotionsSumOrderByAggregateInput
  }

  export type bot_promotionsScalarWhereWithAggregatesInput = {
    AND?: bot_promotionsScalarWhereWithAggregatesInput | bot_promotionsScalarWhereWithAggregatesInput[]
    OR?: bot_promotionsScalarWhereWithAggregatesInput[]
    NOT?: bot_promotionsScalarWhereWithAggregatesInput | bot_promotionsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"bot_promotions"> | string
    bot_id?: BigIntNullableWithAggregatesFilter<"bot_promotions"> | bigint | number | null
    title?: StringNullableWithAggregatesFilter<"bot_promotions"> | string | null
    info?: StringNullableWithAggregatesFilter<"bot_promotions"> | string | null
    css?: StringNullableWithAggregatesFilter<"bot_promotions"> | string | null
    type?: IntNullableWithAggregatesFilter<"bot_promotions"> | number | null
    lynxtag?: UuidWithAggregatesFilter<"bot_promotions"> | string
  }

  export type bot_stats_votes_pmWhereInput = {
    AND?: bot_stats_votes_pmWhereInput | bot_stats_votes_pmWhereInput[]
    OR?: bot_stats_votes_pmWhereInput[]
    NOT?: bot_stats_votes_pmWhereInput | bot_stats_votes_pmWhereInput[]
    bot_id?: BigIntNullableFilter<"bot_stats_votes_pm"> | bigint | number | null
    votes?: BigIntNullableFilter<"bot_stats_votes_pm"> | bigint | number | null
    epoch?: BigIntNullableFilter<"bot_stats_votes_pm"> | bigint | number | null
    lynxtag?: UuidFilter<"bot_stats_votes_pm"> | string
  }

  export type bot_stats_votes_pmOrderByWithRelationInput = {
    bot_id?: SortOrderInput | SortOrder
    votes?: SortOrderInput | SortOrder
    epoch?: SortOrderInput | SortOrder
    lynxtag?: SortOrder
  }

  export type bot_stats_votes_pmWhereUniqueInput = Prisma.AtLeast<{
    lynxtag?: string
    AND?: bot_stats_votes_pmWhereInput | bot_stats_votes_pmWhereInput[]
    OR?: bot_stats_votes_pmWhereInput[]
    NOT?: bot_stats_votes_pmWhereInput | bot_stats_votes_pmWhereInput[]
    bot_id?: BigIntNullableFilter<"bot_stats_votes_pm"> | bigint | number | null
    votes?: BigIntNullableFilter<"bot_stats_votes_pm"> | bigint | number | null
    epoch?: BigIntNullableFilter<"bot_stats_votes_pm"> | bigint | number | null
  }, "lynxtag">

  export type bot_stats_votes_pmOrderByWithAggregationInput = {
    bot_id?: SortOrderInput | SortOrder
    votes?: SortOrderInput | SortOrder
    epoch?: SortOrderInput | SortOrder
    lynxtag?: SortOrder
    _count?: bot_stats_votes_pmCountOrderByAggregateInput
    _avg?: bot_stats_votes_pmAvgOrderByAggregateInput
    _max?: bot_stats_votes_pmMaxOrderByAggregateInput
    _min?: bot_stats_votes_pmMinOrderByAggregateInput
    _sum?: bot_stats_votes_pmSumOrderByAggregateInput
  }

  export type bot_stats_votes_pmScalarWhereWithAggregatesInput = {
    AND?: bot_stats_votes_pmScalarWhereWithAggregatesInput | bot_stats_votes_pmScalarWhereWithAggregatesInput[]
    OR?: bot_stats_votes_pmScalarWhereWithAggregatesInput[]
    NOT?: bot_stats_votes_pmScalarWhereWithAggregatesInput | bot_stats_votes_pmScalarWhereWithAggregatesInput[]
    bot_id?: BigIntNullableWithAggregatesFilter<"bot_stats_votes_pm"> | bigint | number | null
    votes?: BigIntNullableWithAggregatesFilter<"bot_stats_votes_pm"> | bigint | number | null
    epoch?: BigIntNullableWithAggregatesFilter<"bot_stats_votes_pm"> | bigint | number | null
    lynxtag?: UuidWithAggregatesFilter<"bot_stats_votes_pm"> | string
  }

  export type bot_tagsWhereInput = {
    AND?: bot_tagsWhereInput | bot_tagsWhereInput[]
    OR?: bot_tagsWhereInput[]
    NOT?: bot_tagsWhereInput | bot_tagsWhereInput[]
    bot_id?: BigIntFilter<"bot_tags"> | bigint | number
    tag?: StringFilter<"bot_tags"> | string
    id?: IntFilter<"bot_tags"> | number
    lynxtag?: UuidFilter<"bot_tags"> | string
    bots?: XOR<BotsRelationFilter, botsWhereInput>
    bot_list_tags?: XOR<Bot_list_tagsRelationFilter, bot_list_tagsWhereInput>
  }

  export type bot_tagsOrderByWithRelationInput = {
    bot_id?: SortOrder
    tag?: SortOrder
    id?: SortOrder
    lynxtag?: SortOrder
    bots?: botsOrderByWithRelationInput
    bot_list_tags?: bot_list_tagsOrderByWithRelationInput
  }

  export type bot_tagsWhereUniqueInput = Prisma.AtLeast<{
    lynxtag?: string
    AND?: bot_tagsWhereInput | bot_tagsWhereInput[]
    OR?: bot_tagsWhereInput[]
    NOT?: bot_tagsWhereInput | bot_tagsWhereInput[]
    bot_id?: BigIntFilter<"bot_tags"> | bigint | number
    tag?: StringFilter<"bot_tags"> | string
    id?: IntFilter<"bot_tags"> | number
    bots?: XOR<BotsRelationFilter, botsWhereInput>
    bot_list_tags?: XOR<Bot_list_tagsRelationFilter, bot_list_tagsWhereInput>
  }, "lynxtag">

  export type bot_tagsOrderByWithAggregationInput = {
    bot_id?: SortOrder
    tag?: SortOrder
    id?: SortOrder
    lynxtag?: SortOrder
    _count?: bot_tagsCountOrderByAggregateInput
    _avg?: bot_tagsAvgOrderByAggregateInput
    _max?: bot_tagsMaxOrderByAggregateInput
    _min?: bot_tagsMinOrderByAggregateInput
    _sum?: bot_tagsSumOrderByAggregateInput
  }

  export type bot_tagsScalarWhereWithAggregatesInput = {
    AND?: bot_tagsScalarWhereWithAggregatesInput | bot_tagsScalarWhereWithAggregatesInput[]
    OR?: bot_tagsScalarWhereWithAggregatesInput[]
    NOT?: bot_tagsScalarWhereWithAggregatesInput | bot_tagsScalarWhereWithAggregatesInput[]
    bot_id?: BigIntWithAggregatesFilter<"bot_tags"> | bigint | number
    tag?: StringWithAggregatesFilter<"bot_tags"> | string
    id?: IntWithAggregatesFilter<"bot_tags"> | number
    lynxtag?: UuidWithAggregatesFilter<"bot_tags"> | string
  }

  export type bot_votersWhereInput = {
    AND?: bot_votersWhereInput | bot_votersWhereInput[]
    OR?: bot_votersWhereInput[]
    NOT?: bot_votersWhereInput | bot_votersWhereInput[]
    bot_id?: BigIntFilter<"bot_voters"> | bigint | number
    user_id?: BigIntFilter<"bot_voters"> | bigint | number
    timestamps?: DateTimeNullableListFilter<"bot_voters">
    lynxtag?: UuidFilter<"bot_voters"> | string
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type bot_votersOrderByWithRelationInput = {
    bot_id?: SortOrder
    user_id?: SortOrder
    timestamps?: SortOrder
    lynxtag?: SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type bot_votersWhereUniqueInput = Prisma.AtLeast<{
    lynxtag?: string
    AND?: bot_votersWhereInput | bot_votersWhereInput[]
    OR?: bot_votersWhereInput[]
    NOT?: bot_votersWhereInput | bot_votersWhereInput[]
    bot_id?: BigIntFilter<"bot_voters"> | bigint | number
    user_id?: BigIntFilter<"bot_voters"> | bigint | number
    timestamps?: DateTimeNullableListFilter<"bot_voters">
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }, "lynxtag">

  export type bot_votersOrderByWithAggregationInput = {
    bot_id?: SortOrder
    user_id?: SortOrder
    timestamps?: SortOrder
    lynxtag?: SortOrder
    _count?: bot_votersCountOrderByAggregateInput
    _avg?: bot_votersAvgOrderByAggregateInput
    _max?: bot_votersMaxOrderByAggregateInput
    _min?: bot_votersMinOrderByAggregateInput
    _sum?: bot_votersSumOrderByAggregateInput
  }

  export type bot_votersScalarWhereWithAggregatesInput = {
    AND?: bot_votersScalarWhereWithAggregatesInput | bot_votersScalarWhereWithAggregatesInput[]
    OR?: bot_votersScalarWhereWithAggregatesInput[]
    NOT?: bot_votersScalarWhereWithAggregatesInput | bot_votersScalarWhereWithAggregatesInput[]
    bot_id?: BigIntWithAggregatesFilter<"bot_voters"> | bigint | number
    user_id?: BigIntWithAggregatesFilter<"bot_voters"> | bigint | number
    timestamps?: DateTimeNullableListFilter<"bot_voters">
    lynxtag?: UuidWithAggregatesFilter<"bot_voters"> | string
  }

  export type botsWhereInput = {
    AND?: botsWhereInput | botsWhereInput[]
    OR?: botsWhereInput[]
    NOT?: botsWhereInput | botsWhereInput[]
    bot_id?: BigIntFilter<"bots"> | bigint | number
    votes?: BigIntNullableFilter<"bots"> | bigint | number | null
    guild_count?: BigIntNullableFilter<"bots"> | bigint | number | null
    shard_count?: BigIntNullableFilter<"bots"> | bigint | number | null
    bot_library?: StringNullableFilter<"bots"> | string | null
    webhook?: StringNullableFilter<"bots"> | string | null
    description?: StringFilter<"bots"> | string
    long_description?: StringFilter<"bots"> | string
    prefix?: StringNullableFilter<"bots"> | string | null
    api_token?: StringNullableFilter<"bots"> | string | null
    banner_card?: StringNullableFilter<"bots"> | string | null
    created_at?: DateTimeFilter<"bots"> | Date | string
    invite?: StringFilter<"bots"> | string
    features?: StringNullableListFilter<"bots">
    invite_amount?: IntNullableFilter<"bots"> | number | null
    user_count?: BigIntNullableFilter<"bots"> | bigint | number | null
    css?: StringNullableFilter<"bots"> | string | null
    shards?: IntNullableListFilter<"bots">
    username_cached?: StringFilter<"bots"> | string
    state?: IntFilter<"bots"> | number
    long_description_type?: IntFilter<"bots"> | number
    verifier?: BigIntNullableFilter<"bots"> | bigint | number | null
    last_stats_post?: DateTimeFilter<"bots"> | Date | string
    webhook_secret?: StringNullableFilter<"bots"> | string | null
    webhook_type?: IntNullableFilter<"bots"> | number | null
    di_text?: StringNullableFilter<"bots"> | string | null
    id?: BigIntFilter<"bots"> | bigint | number
    banner_page?: StringNullableFilter<"bots"> | string | null
    total_votes?: BigIntNullableFilter<"bots"> | bigint | number | null
    client_id?: BigIntNullableFilter<"bots"> | bigint | number | null
    flags?: IntNullableListFilter<"bots">
    uptime_checks_total?: IntNullableFilter<"bots"> | number | null
    uptime_checks_failed?: IntNullableFilter<"bots"> | number | null
    page_style?: IntFilter<"bots"> | number
    webhook_hmac_only?: BoolNullableFilter<"bots"> | boolean | null
    last_updated_at?: DateTimeFilter<"bots"> | Date | string
    avatar_cached?: StringFilter<"bots"> | string
    disc_cached?: StringFilter<"bots"> | string
    extra_links?: JsonFilter<"bots">
    lynxtag?: UuidFilter<"bots"> | string
    bot_commands?: Bot_commandsListRelationFilter
    bot_events?: Bot_eventsListRelationFilter
    bot_owner?: Bot_ownerListRelationFilter
    bot_promotions?: Bot_promotionsListRelationFilter
    bot_tags?: Bot_tagsListRelationFilter
  }

  export type botsOrderByWithRelationInput = {
    bot_id?: SortOrder
    votes?: SortOrderInput | SortOrder
    guild_count?: SortOrderInput | SortOrder
    shard_count?: SortOrderInput | SortOrder
    bot_library?: SortOrderInput | SortOrder
    webhook?: SortOrderInput | SortOrder
    description?: SortOrder
    long_description?: SortOrder
    prefix?: SortOrderInput | SortOrder
    api_token?: SortOrderInput | SortOrder
    banner_card?: SortOrderInput | SortOrder
    created_at?: SortOrder
    invite?: SortOrder
    features?: SortOrder
    invite_amount?: SortOrderInput | SortOrder
    user_count?: SortOrderInput | SortOrder
    css?: SortOrderInput | SortOrder
    shards?: SortOrder
    username_cached?: SortOrder
    state?: SortOrder
    long_description_type?: SortOrder
    verifier?: SortOrderInput | SortOrder
    last_stats_post?: SortOrder
    webhook_secret?: SortOrderInput | SortOrder
    webhook_type?: SortOrderInput | SortOrder
    di_text?: SortOrderInput | SortOrder
    id?: SortOrder
    banner_page?: SortOrderInput | SortOrder
    total_votes?: SortOrderInput | SortOrder
    client_id?: SortOrderInput | SortOrder
    flags?: SortOrder
    uptime_checks_total?: SortOrderInput | SortOrder
    uptime_checks_failed?: SortOrderInput | SortOrder
    page_style?: SortOrder
    webhook_hmac_only?: SortOrderInput | SortOrder
    last_updated_at?: SortOrder
    avatar_cached?: SortOrder
    disc_cached?: SortOrder
    extra_links?: SortOrder
    lynxtag?: SortOrder
    bot_commands?: bot_commandsOrderByRelationAggregateInput
    bot_events?: bot_eventsOrderByRelationAggregateInput
    bot_owner?: bot_ownerOrderByRelationAggregateInput
    bot_promotions?: bot_promotionsOrderByRelationAggregateInput
    bot_tags?: bot_tagsOrderByRelationAggregateInput
  }

  export type botsWhereUniqueInput = Prisma.AtLeast<{
    bot_id?: bigint | number
    api_token?: string
    lynxtag?: string
    AND?: botsWhereInput | botsWhereInput[]
    OR?: botsWhereInput[]
    NOT?: botsWhereInput | botsWhereInput[]
    votes?: BigIntNullableFilter<"bots"> | bigint | number | null
    guild_count?: BigIntNullableFilter<"bots"> | bigint | number | null
    shard_count?: BigIntNullableFilter<"bots"> | bigint | number | null
    bot_library?: StringNullableFilter<"bots"> | string | null
    webhook?: StringNullableFilter<"bots"> | string | null
    description?: StringFilter<"bots"> | string
    long_description?: StringFilter<"bots"> | string
    prefix?: StringNullableFilter<"bots"> | string | null
    banner_card?: StringNullableFilter<"bots"> | string | null
    created_at?: DateTimeFilter<"bots"> | Date | string
    invite?: StringFilter<"bots"> | string
    features?: StringNullableListFilter<"bots">
    invite_amount?: IntNullableFilter<"bots"> | number | null
    user_count?: BigIntNullableFilter<"bots"> | bigint | number | null
    css?: StringNullableFilter<"bots"> | string | null
    shards?: IntNullableListFilter<"bots">
    username_cached?: StringFilter<"bots"> | string
    state?: IntFilter<"bots"> | number
    long_description_type?: IntFilter<"bots"> | number
    verifier?: BigIntNullableFilter<"bots"> | bigint | number | null
    last_stats_post?: DateTimeFilter<"bots"> | Date | string
    webhook_secret?: StringNullableFilter<"bots"> | string | null
    webhook_type?: IntNullableFilter<"bots"> | number | null
    di_text?: StringNullableFilter<"bots"> | string | null
    id?: BigIntFilter<"bots"> | bigint | number
    banner_page?: StringNullableFilter<"bots"> | string | null
    total_votes?: BigIntNullableFilter<"bots"> | bigint | number | null
    client_id?: BigIntNullableFilter<"bots"> | bigint | number | null
    flags?: IntNullableListFilter<"bots">
    uptime_checks_total?: IntNullableFilter<"bots"> | number | null
    uptime_checks_failed?: IntNullableFilter<"bots"> | number | null
    page_style?: IntFilter<"bots"> | number
    webhook_hmac_only?: BoolNullableFilter<"bots"> | boolean | null
    last_updated_at?: DateTimeFilter<"bots"> | Date | string
    avatar_cached?: StringFilter<"bots"> | string
    disc_cached?: StringFilter<"bots"> | string
    extra_links?: JsonFilter<"bots">
    bot_commands?: Bot_commandsListRelationFilter
    bot_events?: Bot_eventsListRelationFilter
    bot_owner?: Bot_ownerListRelationFilter
    bot_promotions?: Bot_promotionsListRelationFilter
    bot_tags?: Bot_tagsListRelationFilter
  }, "bot_id" | "api_token" | "lynxtag">

  export type botsOrderByWithAggregationInput = {
    bot_id?: SortOrder
    votes?: SortOrderInput | SortOrder
    guild_count?: SortOrderInput | SortOrder
    shard_count?: SortOrderInput | SortOrder
    bot_library?: SortOrderInput | SortOrder
    webhook?: SortOrderInput | SortOrder
    description?: SortOrder
    long_description?: SortOrder
    prefix?: SortOrderInput | SortOrder
    api_token?: SortOrderInput | SortOrder
    banner_card?: SortOrderInput | SortOrder
    created_at?: SortOrder
    invite?: SortOrder
    features?: SortOrder
    invite_amount?: SortOrderInput | SortOrder
    user_count?: SortOrderInput | SortOrder
    css?: SortOrderInput | SortOrder
    shards?: SortOrder
    username_cached?: SortOrder
    state?: SortOrder
    long_description_type?: SortOrder
    verifier?: SortOrderInput | SortOrder
    last_stats_post?: SortOrder
    webhook_secret?: SortOrderInput | SortOrder
    webhook_type?: SortOrderInput | SortOrder
    di_text?: SortOrderInput | SortOrder
    id?: SortOrder
    banner_page?: SortOrderInput | SortOrder
    total_votes?: SortOrderInput | SortOrder
    client_id?: SortOrderInput | SortOrder
    flags?: SortOrder
    uptime_checks_total?: SortOrderInput | SortOrder
    uptime_checks_failed?: SortOrderInput | SortOrder
    page_style?: SortOrder
    webhook_hmac_only?: SortOrderInput | SortOrder
    last_updated_at?: SortOrder
    avatar_cached?: SortOrder
    disc_cached?: SortOrder
    extra_links?: SortOrder
    lynxtag?: SortOrder
    _count?: botsCountOrderByAggregateInput
    _avg?: botsAvgOrderByAggregateInput
    _max?: botsMaxOrderByAggregateInput
    _min?: botsMinOrderByAggregateInput
    _sum?: botsSumOrderByAggregateInput
  }

  export type botsScalarWhereWithAggregatesInput = {
    AND?: botsScalarWhereWithAggregatesInput | botsScalarWhereWithAggregatesInput[]
    OR?: botsScalarWhereWithAggregatesInput[]
    NOT?: botsScalarWhereWithAggregatesInput | botsScalarWhereWithAggregatesInput[]
    bot_id?: BigIntWithAggregatesFilter<"bots"> | bigint | number
    votes?: BigIntNullableWithAggregatesFilter<"bots"> | bigint | number | null
    guild_count?: BigIntNullableWithAggregatesFilter<"bots"> | bigint | number | null
    shard_count?: BigIntNullableWithAggregatesFilter<"bots"> | bigint | number | null
    bot_library?: StringNullableWithAggregatesFilter<"bots"> | string | null
    webhook?: StringNullableWithAggregatesFilter<"bots"> | string | null
    description?: StringWithAggregatesFilter<"bots"> | string
    long_description?: StringWithAggregatesFilter<"bots"> | string
    prefix?: StringNullableWithAggregatesFilter<"bots"> | string | null
    api_token?: StringNullableWithAggregatesFilter<"bots"> | string | null
    banner_card?: StringNullableWithAggregatesFilter<"bots"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"bots"> | Date | string
    invite?: StringWithAggregatesFilter<"bots"> | string
    features?: StringNullableListFilter<"bots">
    invite_amount?: IntNullableWithAggregatesFilter<"bots"> | number | null
    user_count?: BigIntNullableWithAggregatesFilter<"bots"> | bigint | number | null
    css?: StringNullableWithAggregatesFilter<"bots"> | string | null
    shards?: IntNullableListFilter<"bots">
    username_cached?: StringWithAggregatesFilter<"bots"> | string
    state?: IntWithAggregatesFilter<"bots"> | number
    long_description_type?: IntWithAggregatesFilter<"bots"> | number
    verifier?: BigIntNullableWithAggregatesFilter<"bots"> | bigint | number | null
    last_stats_post?: DateTimeWithAggregatesFilter<"bots"> | Date | string
    webhook_secret?: StringNullableWithAggregatesFilter<"bots"> | string | null
    webhook_type?: IntNullableWithAggregatesFilter<"bots"> | number | null
    di_text?: StringNullableWithAggregatesFilter<"bots"> | string | null
    id?: BigIntWithAggregatesFilter<"bots"> | bigint | number
    banner_page?: StringNullableWithAggregatesFilter<"bots"> | string | null
    total_votes?: BigIntNullableWithAggregatesFilter<"bots"> | bigint | number | null
    client_id?: BigIntNullableWithAggregatesFilter<"bots"> | bigint | number | null
    flags?: IntNullableListFilter<"bots">
    uptime_checks_total?: IntNullableWithAggregatesFilter<"bots"> | number | null
    uptime_checks_failed?: IntNullableWithAggregatesFilter<"bots"> | number | null
    page_style?: IntWithAggregatesFilter<"bots"> | number
    webhook_hmac_only?: BoolNullableWithAggregatesFilter<"bots"> | boolean | null
    last_updated_at?: DateTimeWithAggregatesFilter<"bots"> | Date | string
    avatar_cached?: StringWithAggregatesFilter<"bots"> | string
    disc_cached?: StringWithAggregatesFilter<"bots"> | string
    extra_links?: JsonWithAggregatesFilter<"bots">
    lynxtag?: UuidWithAggregatesFilter<"bots"> | string
  }

  export type extra_dataWhereInput = {
    AND?: extra_dataWhereInput | extra_dataWhereInput[]
    OR?: extra_dataWhereInput[]
    NOT?: extra_dataWhereInput | extra_dataWhereInput[]
    name?: StringNullableFilter<"extra_data"> | string | null
    value?: JsonNullableFilter<"extra_data">
    user_id?: BigIntNullableFilter<"extra_data"> | bigint | number | null
    lynxtag?: UuidFilter<"extra_data"> | string
    users?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
  }

  export type extra_dataOrderByWithRelationInput = {
    name?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    lynxtag?: SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type extra_dataWhereUniqueInput = Prisma.AtLeast<{
    lynxtag?: string
    AND?: extra_dataWhereInput | extra_dataWhereInput[]
    OR?: extra_dataWhereInput[]
    NOT?: extra_dataWhereInput | extra_dataWhereInput[]
    name?: StringNullableFilter<"extra_data"> | string | null
    value?: JsonNullableFilter<"extra_data">
    user_id?: BigIntNullableFilter<"extra_data"> | bigint | number | null
    users?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
  }, "lynxtag">

  export type extra_dataOrderByWithAggregationInput = {
    name?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    lynxtag?: SortOrder
    _count?: extra_dataCountOrderByAggregateInput
    _avg?: extra_dataAvgOrderByAggregateInput
    _max?: extra_dataMaxOrderByAggregateInput
    _min?: extra_dataMinOrderByAggregateInput
    _sum?: extra_dataSumOrderByAggregateInput
  }

  export type extra_dataScalarWhereWithAggregatesInput = {
    AND?: extra_dataScalarWhereWithAggregatesInput | extra_dataScalarWhereWithAggregatesInput[]
    OR?: extra_dataScalarWhereWithAggregatesInput[]
    NOT?: extra_dataScalarWhereWithAggregatesInput | extra_dataScalarWhereWithAggregatesInput[]
    name?: StringNullableWithAggregatesFilter<"extra_data"> | string | null
    value?: JsonNullableWithAggregatesFilter<"extra_data">
    user_id?: BigIntNullableWithAggregatesFilter<"extra_data"> | bigint | number | null
    lynxtag?: UuidWithAggregatesFilter<"extra_data"> | string
  }

  export type featuresWhereInput = {
    AND?: featuresWhereInput | featuresWhereInput[]
    OR?: featuresWhereInput[]
    NOT?: featuresWhereInput | featuresWhereInput[]
    id?: StringFilter<"features"> | string
    name?: StringFilter<"features"> | string
    description?: StringFilter<"features"> | string
    viewed_as?: StringFilter<"features"> | string
    lynxtag?: UuidFilter<"features"> | string
  }

  export type featuresOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    viewed_as?: SortOrder
    lynxtag?: SortOrder
  }

  export type featuresWhereUniqueInput = Prisma.AtLeast<{
    lynxtag?: string
    AND?: featuresWhereInput | featuresWhereInput[]
    OR?: featuresWhereInput[]
    NOT?: featuresWhereInput | featuresWhereInput[]
    id?: StringFilter<"features"> | string
    name?: StringFilter<"features"> | string
    description?: StringFilter<"features"> | string
    viewed_as?: StringFilter<"features"> | string
  }, "lynxtag">

  export type featuresOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    viewed_as?: SortOrder
    lynxtag?: SortOrder
    _count?: featuresCountOrderByAggregateInput
    _max?: featuresMaxOrderByAggregateInput
    _min?: featuresMinOrderByAggregateInput
  }

  export type featuresScalarWhereWithAggregatesInput = {
    AND?: featuresScalarWhereWithAggregatesInput | featuresScalarWhereWithAggregatesInput[]
    OR?: featuresScalarWhereWithAggregatesInput[]
    NOT?: featuresScalarWhereWithAggregatesInput | featuresScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"features"> | string
    name?: StringWithAggregatesFilter<"features"> | string
    description?: StringWithAggregatesFilter<"features"> | string
    viewed_as?: StringWithAggregatesFilter<"features"> | string
    lynxtag?: UuidWithAggregatesFilter<"features"> | string
  }

  export type frostpaw_clientsWhereInput = {
    AND?: frostpaw_clientsWhereInput | frostpaw_clientsWhereInput[]
    OR?: frostpaw_clientsWhereInput[]
    NOT?: frostpaw_clientsWhereInput | frostpaw_clientsWhereInput[]
    id?: StringFilter<"frostpaw_clients"> | string
    name?: StringFilter<"frostpaw_clients"> | string
    domain?: StringFilter<"frostpaw_clients"> | string
    privacy_policy?: StringFilter<"frostpaw_clients"> | string
    secret?: StringFilter<"frostpaw_clients"> | string
    owner_id?: BigIntFilter<"frostpaw_clients"> | bigint | number
    lynxtag?: UuidFilter<"frostpaw_clients"> | string
    verified?: BoolFilter<"frostpaw_clients"> | boolean
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type frostpaw_clientsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    domain?: SortOrder
    privacy_policy?: SortOrder
    secret?: SortOrder
    owner_id?: SortOrder
    lynxtag?: SortOrder
    verified?: SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type frostpaw_clientsWhereUniqueInput = Prisma.AtLeast<{
    lynxtag?: string
    AND?: frostpaw_clientsWhereInput | frostpaw_clientsWhereInput[]
    OR?: frostpaw_clientsWhereInput[]
    NOT?: frostpaw_clientsWhereInput | frostpaw_clientsWhereInput[]
    id?: StringFilter<"frostpaw_clients"> | string
    name?: StringFilter<"frostpaw_clients"> | string
    domain?: StringFilter<"frostpaw_clients"> | string
    privacy_policy?: StringFilter<"frostpaw_clients"> | string
    secret?: StringFilter<"frostpaw_clients"> | string
    owner_id?: BigIntFilter<"frostpaw_clients"> | bigint | number
    verified?: BoolFilter<"frostpaw_clients"> | boolean
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }, "lynxtag">

  export type frostpaw_clientsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    domain?: SortOrder
    privacy_policy?: SortOrder
    secret?: SortOrder
    owner_id?: SortOrder
    lynxtag?: SortOrder
    verified?: SortOrder
    _count?: frostpaw_clientsCountOrderByAggregateInput
    _avg?: frostpaw_clientsAvgOrderByAggregateInput
    _max?: frostpaw_clientsMaxOrderByAggregateInput
    _min?: frostpaw_clientsMinOrderByAggregateInput
    _sum?: frostpaw_clientsSumOrderByAggregateInput
  }

  export type frostpaw_clientsScalarWhereWithAggregatesInput = {
    AND?: frostpaw_clientsScalarWhereWithAggregatesInput | frostpaw_clientsScalarWhereWithAggregatesInput[]
    OR?: frostpaw_clientsScalarWhereWithAggregatesInput[]
    NOT?: frostpaw_clientsScalarWhereWithAggregatesInput | frostpaw_clientsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"frostpaw_clients"> | string
    name?: StringWithAggregatesFilter<"frostpaw_clients"> | string
    domain?: StringWithAggregatesFilter<"frostpaw_clients"> | string
    privacy_policy?: StringWithAggregatesFilter<"frostpaw_clients"> | string
    secret?: StringWithAggregatesFilter<"frostpaw_clients"> | string
    owner_id?: BigIntWithAggregatesFilter<"frostpaw_clients"> | bigint | number
    lynxtag?: UuidWithAggregatesFilter<"frostpaw_clients"> | string
    verified?: BoolWithAggregatesFilter<"frostpaw_clients"> | boolean
  }

  export type leave_of_absenceWhereInput = {
    AND?: leave_of_absenceWhereInput | leave_of_absenceWhereInput[]
    OR?: leave_of_absenceWhereInput[]
    NOT?: leave_of_absenceWhereInput | leave_of_absenceWhereInput[]
    reason?: StringNullableFilter<"leave_of_absence"> | string | null
    start_date?: DateTimeNullableFilter<"leave_of_absence"> | Date | string | null
    user_id?: BigIntNullableFilter<"leave_of_absence"> | bigint | number | null
    id?: IntFilter<"leave_of_absence"> | number
    lynxtag?: UuidFilter<"leave_of_absence"> | string
    users?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
  }

  export type leave_of_absenceOrderByWithRelationInput = {
    reason?: SortOrderInput | SortOrder
    start_date?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    id?: SortOrder
    lynxtag?: SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type leave_of_absenceWhereUniqueInput = Prisma.AtLeast<{
    lynxtag?: string
    AND?: leave_of_absenceWhereInput | leave_of_absenceWhereInput[]
    OR?: leave_of_absenceWhereInput[]
    NOT?: leave_of_absenceWhereInput | leave_of_absenceWhereInput[]
    reason?: StringNullableFilter<"leave_of_absence"> | string | null
    start_date?: DateTimeNullableFilter<"leave_of_absence"> | Date | string | null
    user_id?: BigIntNullableFilter<"leave_of_absence"> | bigint | number | null
    id?: IntFilter<"leave_of_absence"> | number
    users?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
  }, "lynxtag">

  export type leave_of_absenceOrderByWithAggregationInput = {
    reason?: SortOrderInput | SortOrder
    start_date?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    id?: SortOrder
    lynxtag?: SortOrder
    _count?: leave_of_absenceCountOrderByAggregateInput
    _avg?: leave_of_absenceAvgOrderByAggregateInput
    _max?: leave_of_absenceMaxOrderByAggregateInput
    _min?: leave_of_absenceMinOrderByAggregateInput
    _sum?: leave_of_absenceSumOrderByAggregateInput
  }

  export type leave_of_absenceScalarWhereWithAggregatesInput = {
    AND?: leave_of_absenceScalarWhereWithAggregatesInput | leave_of_absenceScalarWhereWithAggregatesInput[]
    OR?: leave_of_absenceScalarWhereWithAggregatesInput[]
    NOT?: leave_of_absenceScalarWhereWithAggregatesInput | leave_of_absenceScalarWhereWithAggregatesInput[]
    reason?: StringNullableWithAggregatesFilter<"leave_of_absence"> | string | null
    start_date?: DateTimeNullableWithAggregatesFilter<"leave_of_absence"> | Date | string | null
    user_id?: BigIntNullableWithAggregatesFilter<"leave_of_absence"> | bigint | number | null
    id?: IntWithAggregatesFilter<"leave_of_absence"> | number
    lynxtag?: UuidWithAggregatesFilter<"leave_of_absence"> | string
  }

  export type lynx_appsWhereInput = {
    AND?: lynx_appsWhereInput | lynx_appsWhereInput[]
    OR?: lynx_appsWhereInput[]
    NOT?: lynx_appsWhereInput | lynx_appsWhereInput[]
    user_id?: BigIntNullableFilter<"lynx_apps"> | bigint | number | null
    app_id?: UuidFilter<"lynx_apps"> | string
    questions?: JsonNullableFilter<"lynx_apps">
    answers?: JsonNullableFilter<"lynx_apps">
    app_version?: IntNullableFilter<"lynx_apps"> | number | null
    created_at?: DateTimeNullableFilter<"lynx_apps"> | Date | string | null
    lynxtag?: UuidFilter<"lynx_apps"> | string
    users?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
  }

  export type lynx_appsOrderByWithRelationInput = {
    user_id?: SortOrderInput | SortOrder
    app_id?: SortOrder
    questions?: SortOrderInput | SortOrder
    answers?: SortOrderInput | SortOrder
    app_version?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    lynxtag?: SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type lynx_appsWhereUniqueInput = Prisma.AtLeast<{
    app_id?: string
    lynxtag?: string
    AND?: lynx_appsWhereInput | lynx_appsWhereInput[]
    OR?: lynx_appsWhereInput[]
    NOT?: lynx_appsWhereInput | lynx_appsWhereInput[]
    user_id?: BigIntNullableFilter<"lynx_apps"> | bigint | number | null
    questions?: JsonNullableFilter<"lynx_apps">
    answers?: JsonNullableFilter<"lynx_apps">
    app_version?: IntNullableFilter<"lynx_apps"> | number | null
    created_at?: DateTimeNullableFilter<"lynx_apps"> | Date | string | null
    users?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
  }, "app_id" | "lynxtag">

  export type lynx_appsOrderByWithAggregationInput = {
    user_id?: SortOrderInput | SortOrder
    app_id?: SortOrder
    questions?: SortOrderInput | SortOrder
    answers?: SortOrderInput | SortOrder
    app_version?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    lynxtag?: SortOrder
    _count?: lynx_appsCountOrderByAggregateInput
    _avg?: lynx_appsAvgOrderByAggregateInput
    _max?: lynx_appsMaxOrderByAggregateInput
    _min?: lynx_appsMinOrderByAggregateInput
    _sum?: lynx_appsSumOrderByAggregateInput
  }

  export type lynx_appsScalarWhereWithAggregatesInput = {
    AND?: lynx_appsScalarWhereWithAggregatesInput | lynx_appsScalarWhereWithAggregatesInput[]
    OR?: lynx_appsScalarWhereWithAggregatesInput[]
    NOT?: lynx_appsScalarWhereWithAggregatesInput | lynx_appsScalarWhereWithAggregatesInput[]
    user_id?: BigIntNullableWithAggregatesFilter<"lynx_apps"> | bigint | number | null
    app_id?: UuidWithAggregatesFilter<"lynx_apps"> | string
    questions?: JsonNullableWithAggregatesFilter<"lynx_apps">
    answers?: JsonNullableWithAggregatesFilter<"lynx_apps">
    app_version?: IntNullableWithAggregatesFilter<"lynx_apps"> | number | null
    created_at?: DateTimeNullableWithAggregatesFilter<"lynx_apps"> | Date | string | null
    lynxtag?: UuidWithAggregatesFilter<"lynx_apps"> | string
  }

  export type lynx_dataWhereInput = {
    AND?: lynx_dataWhereInput | lynx_dataWhereInput[]
    OR?: lynx_dataWhereInput[]
    NOT?: lynx_dataWhereInput | lynx_dataWhereInput[]
    default_user_experiments?: IntNullableListFilter<"lynx_data">
    id?: IntFilter<"lynx_data"> | number
    lynxtag?: UuidFilter<"lynx_data"> | string
  }

  export type lynx_dataOrderByWithRelationInput = {
    default_user_experiments?: SortOrder
    id?: SortOrder
    lynxtag?: SortOrder
  }

  export type lynx_dataWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    lynxtag?: string
    AND?: lynx_dataWhereInput | lynx_dataWhereInput[]
    OR?: lynx_dataWhereInput[]
    NOT?: lynx_dataWhereInput | lynx_dataWhereInput[]
    default_user_experiments?: IntNullableListFilter<"lynx_data">
  }, "id" | "lynxtag">

  export type lynx_dataOrderByWithAggregationInput = {
    default_user_experiments?: SortOrder
    id?: SortOrder
    lynxtag?: SortOrder
    _count?: lynx_dataCountOrderByAggregateInput
    _avg?: lynx_dataAvgOrderByAggregateInput
    _max?: lynx_dataMaxOrderByAggregateInput
    _min?: lynx_dataMinOrderByAggregateInput
    _sum?: lynx_dataSumOrderByAggregateInput
  }

  export type lynx_dataScalarWhereWithAggregatesInput = {
    AND?: lynx_dataScalarWhereWithAggregatesInput | lynx_dataScalarWhereWithAggregatesInput[]
    OR?: lynx_dataScalarWhereWithAggregatesInput[]
    NOT?: lynx_dataScalarWhereWithAggregatesInput | lynx_dataScalarWhereWithAggregatesInput[]
    default_user_experiments?: IntNullableListFilter<"lynx_data">
    id?: IntWithAggregatesFilter<"lynx_data"> | number
    lynxtag?: UuidWithAggregatesFilter<"lynx_data"> | string
  }

  export type lynx_logsWhereInput = {
    AND?: lynx_logsWhereInput | lynx_logsWhereInput[]
    OR?: lynx_logsWhereInput[]
    NOT?: lynx_logsWhereInput | lynx_logsWhereInput[]
    user_id?: BigIntFilter<"lynx_logs"> | bigint | number
    method?: StringFilter<"lynx_logs"> | string
    url?: StringFilter<"lynx_logs"> | string
    status_code?: IntFilter<"lynx_logs"> | number
    request_time?: DateTimeNullableFilter<"lynx_logs"> | Date | string | null
    lynxtag?: UuidFilter<"lynx_logs"> | string
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type lynx_logsOrderByWithRelationInput = {
    user_id?: SortOrder
    method?: SortOrder
    url?: SortOrder
    status_code?: SortOrder
    request_time?: SortOrderInput | SortOrder
    lynxtag?: SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type lynx_logsWhereUniqueInput = Prisma.AtLeast<{
    lynxtag?: string
    AND?: lynx_logsWhereInput | lynx_logsWhereInput[]
    OR?: lynx_logsWhereInput[]
    NOT?: lynx_logsWhereInput | lynx_logsWhereInput[]
    user_id?: BigIntFilter<"lynx_logs"> | bigint | number
    method?: StringFilter<"lynx_logs"> | string
    url?: StringFilter<"lynx_logs"> | string
    status_code?: IntFilter<"lynx_logs"> | number
    request_time?: DateTimeNullableFilter<"lynx_logs"> | Date | string | null
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }, "lynxtag">

  export type lynx_logsOrderByWithAggregationInput = {
    user_id?: SortOrder
    method?: SortOrder
    url?: SortOrder
    status_code?: SortOrder
    request_time?: SortOrderInput | SortOrder
    lynxtag?: SortOrder
    _count?: lynx_logsCountOrderByAggregateInput
    _avg?: lynx_logsAvgOrderByAggregateInput
    _max?: lynx_logsMaxOrderByAggregateInput
    _min?: lynx_logsMinOrderByAggregateInput
    _sum?: lynx_logsSumOrderByAggregateInput
  }

  export type lynx_logsScalarWhereWithAggregatesInput = {
    AND?: lynx_logsScalarWhereWithAggregatesInput | lynx_logsScalarWhereWithAggregatesInput[]
    OR?: lynx_logsScalarWhereWithAggregatesInput[]
    NOT?: lynx_logsScalarWhereWithAggregatesInput | lynx_logsScalarWhereWithAggregatesInput[]
    user_id?: BigIntWithAggregatesFilter<"lynx_logs"> | bigint | number
    method?: StringWithAggregatesFilter<"lynx_logs"> | string
    url?: StringWithAggregatesFilter<"lynx_logs"> | string
    status_code?: IntWithAggregatesFilter<"lynx_logs"> | number
    request_time?: DateTimeNullableWithAggregatesFilter<"lynx_logs"> | Date | string | null
    lynxtag?: UuidWithAggregatesFilter<"lynx_logs"> | string
  }

  export type lynx_notificationsWhereInput = {
    AND?: lynx_notificationsWhereInput | lynx_notificationsWhereInput[]
    OR?: lynx_notificationsWhereInput[]
    NOT?: lynx_notificationsWhereInput | lynx_notificationsWhereInput[]
    acked_users?: BigIntNullableListFilter<"lynx_notifications">
    message?: StringFilter<"lynx_notifications"> | string
    type?: StringFilter<"lynx_notifications"> | string
    id?: UuidFilter<"lynx_notifications"> | string
    staff_only?: BoolNullableFilter<"lynx_notifications"> | boolean | null
    lynxtag?: UuidFilter<"lynx_notifications"> | string
  }

  export type lynx_notificationsOrderByWithRelationInput = {
    acked_users?: SortOrder
    message?: SortOrder
    type?: SortOrder
    id?: SortOrder
    staff_only?: SortOrderInput | SortOrder
    lynxtag?: SortOrder
  }

  export type lynx_notificationsWhereUniqueInput = Prisma.AtLeast<{
    lynxtag?: string
    AND?: lynx_notificationsWhereInput | lynx_notificationsWhereInput[]
    OR?: lynx_notificationsWhereInput[]
    NOT?: lynx_notificationsWhereInput | lynx_notificationsWhereInput[]
    acked_users?: BigIntNullableListFilter<"lynx_notifications">
    message?: StringFilter<"lynx_notifications"> | string
    type?: StringFilter<"lynx_notifications"> | string
    id?: UuidFilter<"lynx_notifications"> | string
    staff_only?: BoolNullableFilter<"lynx_notifications"> | boolean | null
  }, "lynxtag">

  export type lynx_notificationsOrderByWithAggregationInput = {
    acked_users?: SortOrder
    message?: SortOrder
    type?: SortOrder
    id?: SortOrder
    staff_only?: SortOrderInput | SortOrder
    lynxtag?: SortOrder
    _count?: lynx_notificationsCountOrderByAggregateInput
    _avg?: lynx_notificationsAvgOrderByAggregateInput
    _max?: lynx_notificationsMaxOrderByAggregateInput
    _min?: lynx_notificationsMinOrderByAggregateInput
    _sum?: lynx_notificationsSumOrderByAggregateInput
  }

  export type lynx_notificationsScalarWhereWithAggregatesInput = {
    AND?: lynx_notificationsScalarWhereWithAggregatesInput | lynx_notificationsScalarWhereWithAggregatesInput[]
    OR?: lynx_notificationsScalarWhereWithAggregatesInput[]
    NOT?: lynx_notificationsScalarWhereWithAggregatesInput | lynx_notificationsScalarWhereWithAggregatesInput[]
    acked_users?: BigIntNullableListFilter<"lynx_notifications">
    message?: StringWithAggregatesFilter<"lynx_notifications"> | string
    type?: StringWithAggregatesFilter<"lynx_notifications"> | string
    id?: UuidWithAggregatesFilter<"lynx_notifications"> | string
    staff_only?: BoolNullableWithAggregatesFilter<"lynx_notifications"> | boolean | null
    lynxtag?: UuidWithAggregatesFilter<"lynx_notifications"> | string
  }

  export type lynx_ratingsWhereInput = {
    AND?: lynx_ratingsWhereInput | lynx_ratingsWhereInput[]
    OR?: lynx_ratingsWhereInput[]
    NOT?: lynx_ratingsWhereInput | lynx_ratingsWhereInput[]
    id?: UuidFilter<"lynx_ratings"> | string
    feedback?: StringFilter<"lynx_ratings"> | string
    username_cached?: StringFilter<"lynx_ratings"> | string
    user_id?: BigIntNullableFilter<"lynx_ratings"> | bigint | number | null
    page?: StringFilter<"lynx_ratings"> | string
    lynxtag?: UuidFilter<"lynx_ratings"> | string
    users?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
  }

  export type lynx_ratingsOrderByWithRelationInput = {
    id?: SortOrder
    feedback?: SortOrder
    username_cached?: SortOrder
    user_id?: SortOrderInput | SortOrder
    page?: SortOrder
    lynxtag?: SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type lynx_ratingsWhereUniqueInput = Prisma.AtLeast<{
    lynxtag?: string
    AND?: lynx_ratingsWhereInput | lynx_ratingsWhereInput[]
    OR?: lynx_ratingsWhereInput[]
    NOT?: lynx_ratingsWhereInput | lynx_ratingsWhereInput[]
    id?: UuidFilter<"lynx_ratings"> | string
    feedback?: StringFilter<"lynx_ratings"> | string
    username_cached?: StringFilter<"lynx_ratings"> | string
    user_id?: BigIntNullableFilter<"lynx_ratings"> | bigint | number | null
    page?: StringFilter<"lynx_ratings"> | string
    users?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
  }, "lynxtag">

  export type lynx_ratingsOrderByWithAggregationInput = {
    id?: SortOrder
    feedback?: SortOrder
    username_cached?: SortOrder
    user_id?: SortOrderInput | SortOrder
    page?: SortOrder
    lynxtag?: SortOrder
    _count?: lynx_ratingsCountOrderByAggregateInput
    _avg?: lynx_ratingsAvgOrderByAggregateInput
    _max?: lynx_ratingsMaxOrderByAggregateInput
    _min?: lynx_ratingsMinOrderByAggregateInput
    _sum?: lynx_ratingsSumOrderByAggregateInput
  }

  export type lynx_ratingsScalarWhereWithAggregatesInput = {
    AND?: lynx_ratingsScalarWhereWithAggregatesInput | lynx_ratingsScalarWhereWithAggregatesInput[]
    OR?: lynx_ratingsScalarWhereWithAggregatesInput[]
    NOT?: lynx_ratingsScalarWhereWithAggregatesInput | lynx_ratingsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"lynx_ratings"> | string
    feedback?: StringWithAggregatesFilter<"lynx_ratings"> | string
    username_cached?: StringWithAggregatesFilter<"lynx_ratings"> | string
    user_id?: BigIntNullableWithAggregatesFilter<"lynx_ratings"> | bigint | number | null
    page?: StringWithAggregatesFilter<"lynx_ratings"> | string
    lynxtag?: UuidWithAggregatesFilter<"lynx_ratings"> | string
  }

  export type lynx_survey_responsesWhereInput = {
    AND?: lynx_survey_responsesWhereInput | lynx_survey_responsesWhereInput[]
    OR?: lynx_survey_responsesWhereInput[]
    NOT?: lynx_survey_responsesWhereInput | lynx_survey_responsesWhereInput[]
    id?: UuidFilter<"lynx_survey_responses"> | string
    questions?: JsonFilter<"lynx_survey_responses">
    answers?: JsonFilter<"lynx_survey_responses">
    username_cached?: StringFilter<"lynx_survey_responses"> | string
    user_id?: BigIntNullableFilter<"lynx_survey_responses"> | bigint | number | null
    survey_id?: UuidFilter<"lynx_survey_responses"> | string
    lynxtag?: UuidFilter<"lynx_survey_responses"> | string
    lynx_surveys?: XOR<Lynx_surveysRelationFilter, lynx_surveysWhereInput>
    users?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
  }

  export type lynx_survey_responsesOrderByWithRelationInput = {
    id?: SortOrder
    questions?: SortOrder
    answers?: SortOrder
    username_cached?: SortOrder
    user_id?: SortOrderInput | SortOrder
    survey_id?: SortOrder
    lynxtag?: SortOrder
    lynx_surveys?: lynx_surveysOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
  }

  export type lynx_survey_responsesWhereUniqueInput = Prisma.AtLeast<{
    lynxtag?: string
    AND?: lynx_survey_responsesWhereInput | lynx_survey_responsesWhereInput[]
    OR?: lynx_survey_responsesWhereInput[]
    NOT?: lynx_survey_responsesWhereInput | lynx_survey_responsesWhereInput[]
    id?: UuidFilter<"lynx_survey_responses"> | string
    questions?: JsonFilter<"lynx_survey_responses">
    answers?: JsonFilter<"lynx_survey_responses">
    username_cached?: StringFilter<"lynx_survey_responses"> | string
    user_id?: BigIntNullableFilter<"lynx_survey_responses"> | bigint | number | null
    survey_id?: UuidFilter<"lynx_survey_responses"> | string
    lynx_surveys?: XOR<Lynx_surveysRelationFilter, lynx_surveysWhereInput>
    users?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
  }, "lynxtag">

  export type lynx_survey_responsesOrderByWithAggregationInput = {
    id?: SortOrder
    questions?: SortOrder
    answers?: SortOrder
    username_cached?: SortOrder
    user_id?: SortOrderInput | SortOrder
    survey_id?: SortOrder
    lynxtag?: SortOrder
    _count?: lynx_survey_responsesCountOrderByAggregateInput
    _avg?: lynx_survey_responsesAvgOrderByAggregateInput
    _max?: lynx_survey_responsesMaxOrderByAggregateInput
    _min?: lynx_survey_responsesMinOrderByAggregateInput
    _sum?: lynx_survey_responsesSumOrderByAggregateInput
  }

  export type lynx_survey_responsesScalarWhereWithAggregatesInput = {
    AND?: lynx_survey_responsesScalarWhereWithAggregatesInput | lynx_survey_responsesScalarWhereWithAggregatesInput[]
    OR?: lynx_survey_responsesScalarWhereWithAggregatesInput[]
    NOT?: lynx_survey_responsesScalarWhereWithAggregatesInput | lynx_survey_responsesScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"lynx_survey_responses"> | string
    questions?: JsonWithAggregatesFilter<"lynx_survey_responses">
    answers?: JsonWithAggregatesFilter<"lynx_survey_responses">
    username_cached?: StringWithAggregatesFilter<"lynx_survey_responses"> | string
    user_id?: BigIntNullableWithAggregatesFilter<"lynx_survey_responses"> | bigint | number | null
    survey_id?: UuidWithAggregatesFilter<"lynx_survey_responses"> | string
    lynxtag?: UuidWithAggregatesFilter<"lynx_survey_responses"> | string
  }

  export type lynx_surveysWhereInput = {
    AND?: lynx_surveysWhereInput | lynx_surveysWhereInput[]
    OR?: lynx_surveysWhereInput[]
    NOT?: lynx_surveysWhereInput | lynx_surveysWhereInput[]
    id?: UuidFilter<"lynx_surveys"> | string
    title?: StringFilter<"lynx_surveys"> | string
    questions?: JsonFilter<"lynx_surveys">
    created_at?: DateTimeNullableFilter<"lynx_surveys"> | Date | string | null
    lynxtag?: UuidFilter<"lynx_surveys"> | string
    lynx_survey_responses?: Lynx_survey_responsesListRelationFilter
  }

  export type lynx_surveysOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    questions?: SortOrder
    created_at?: SortOrderInput | SortOrder
    lynxtag?: SortOrder
    lynx_survey_responses?: lynx_survey_responsesOrderByRelationAggregateInput
  }

  export type lynx_surveysWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    lynxtag?: string
    AND?: lynx_surveysWhereInput | lynx_surveysWhereInput[]
    OR?: lynx_surveysWhereInput[]
    NOT?: lynx_surveysWhereInput | lynx_surveysWhereInput[]
    title?: StringFilter<"lynx_surveys"> | string
    questions?: JsonFilter<"lynx_surveys">
    created_at?: DateTimeNullableFilter<"lynx_surveys"> | Date | string | null
    lynx_survey_responses?: Lynx_survey_responsesListRelationFilter
  }, "id" | "lynxtag">

  export type lynx_surveysOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    questions?: SortOrder
    created_at?: SortOrderInput | SortOrder
    lynxtag?: SortOrder
    _count?: lynx_surveysCountOrderByAggregateInput
    _max?: lynx_surveysMaxOrderByAggregateInput
    _min?: lynx_surveysMinOrderByAggregateInput
  }

  export type lynx_surveysScalarWhereWithAggregatesInput = {
    AND?: lynx_surveysScalarWhereWithAggregatesInput | lynx_surveysScalarWhereWithAggregatesInput[]
    OR?: lynx_surveysScalarWhereWithAggregatesInput[]
    NOT?: lynx_surveysScalarWhereWithAggregatesInput | lynx_surveysScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"lynx_surveys"> | string
    title?: StringWithAggregatesFilter<"lynx_surveys"> | string
    questions?: JsonWithAggregatesFilter<"lynx_surveys">
    created_at?: DateTimeNullableWithAggregatesFilter<"lynx_surveys"> | Date | string | null
    lynxtag?: UuidWithAggregatesFilter<"lynx_surveys"> | string
  }

  export type migrationWhereInput = {
    AND?: migrationWhereInput | migrationWhereInput[]
    OR?: migrationWhereInput[]
    NOT?: migrationWhereInput | migrationWhereInput[]
    id?: IntFilter<"migration"> | number
    name?: StringFilter<"migration"> | string
    app_name?: StringFilter<"migration"> | string
    ran_on?: DateTimeFilter<"migration"> | Date | string
    lynxtag?: UuidFilter<"migration"> | string
  }

  export type migrationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    app_name?: SortOrder
    ran_on?: SortOrder
    lynxtag?: SortOrder
  }

  export type migrationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    lynxtag?: string
    AND?: migrationWhereInput | migrationWhereInput[]
    OR?: migrationWhereInput[]
    NOT?: migrationWhereInput | migrationWhereInput[]
    name?: StringFilter<"migration"> | string
    app_name?: StringFilter<"migration"> | string
    ran_on?: DateTimeFilter<"migration"> | Date | string
  }, "id" | "lynxtag">

  export type migrationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    app_name?: SortOrder
    ran_on?: SortOrder
    lynxtag?: SortOrder
    _count?: migrationCountOrderByAggregateInput
    _avg?: migrationAvgOrderByAggregateInput
    _max?: migrationMaxOrderByAggregateInput
    _min?: migrationMinOrderByAggregateInput
    _sum?: migrationSumOrderByAggregateInput
  }

  export type migrationScalarWhereWithAggregatesInput = {
    AND?: migrationScalarWhereWithAggregatesInput | migrationScalarWhereWithAggregatesInput[]
    OR?: migrationScalarWhereWithAggregatesInput[]
    NOT?: migrationScalarWhereWithAggregatesInput | migrationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"migration"> | number
    name?: StringWithAggregatesFilter<"migration"> | string
    app_name?: StringWithAggregatesFilter<"migration"> | string
    ran_on?: DateTimeWithAggregatesFilter<"migration"> | Date | string
    lynxtag?: UuidWithAggregatesFilter<"migration"> | string
  }

  export type piccolo_userWhereInput = {
    AND?: piccolo_userWhereInput | piccolo_userWhereInput[]
    OR?: piccolo_userWhereInput[]
    NOT?: piccolo_userWhereInput | piccolo_userWhereInput[]
    id?: IntFilter<"piccolo_user"> | number
    username?: StringFilter<"piccolo_user"> | string
    password?: StringFilter<"piccolo_user"> | string
    email?: StringFilter<"piccolo_user"> | string
    active?: BoolFilter<"piccolo_user"> | boolean
    admin?: BoolFilter<"piccolo_user"> | boolean
    first_name?: StringNullableFilter<"piccolo_user"> | string | null
    last_name?: StringNullableFilter<"piccolo_user"> | string | null
    superuser?: BoolFilter<"piccolo_user"> | boolean
    last_login?: DateTimeNullableFilter<"piccolo_user"> | Date | string | null
    lynxtag?: UuidFilter<"piccolo_user"> | string
  }

  export type piccolo_userOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    email?: SortOrder
    active?: SortOrder
    admin?: SortOrder
    first_name?: SortOrderInput | SortOrder
    last_name?: SortOrderInput | SortOrder
    superuser?: SortOrder
    last_login?: SortOrderInput | SortOrder
    lynxtag?: SortOrder
  }

  export type piccolo_userWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    username?: string
    email?: string
    lynxtag?: string
    AND?: piccolo_userWhereInput | piccolo_userWhereInput[]
    OR?: piccolo_userWhereInput[]
    NOT?: piccolo_userWhereInput | piccolo_userWhereInput[]
    password?: StringFilter<"piccolo_user"> | string
    active?: BoolFilter<"piccolo_user"> | boolean
    admin?: BoolFilter<"piccolo_user"> | boolean
    first_name?: StringNullableFilter<"piccolo_user"> | string | null
    last_name?: StringNullableFilter<"piccolo_user"> | string | null
    superuser?: BoolFilter<"piccolo_user"> | boolean
    last_login?: DateTimeNullableFilter<"piccolo_user"> | Date | string | null
  }, "id" | "username" | "email" | "lynxtag">

  export type piccolo_userOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    email?: SortOrder
    active?: SortOrder
    admin?: SortOrder
    first_name?: SortOrderInput | SortOrder
    last_name?: SortOrderInput | SortOrder
    superuser?: SortOrder
    last_login?: SortOrderInput | SortOrder
    lynxtag?: SortOrder
    _count?: piccolo_userCountOrderByAggregateInput
    _avg?: piccolo_userAvgOrderByAggregateInput
    _max?: piccolo_userMaxOrderByAggregateInput
    _min?: piccolo_userMinOrderByAggregateInput
    _sum?: piccolo_userSumOrderByAggregateInput
  }

  export type piccolo_userScalarWhereWithAggregatesInput = {
    AND?: piccolo_userScalarWhereWithAggregatesInput | piccolo_userScalarWhereWithAggregatesInput[]
    OR?: piccolo_userScalarWhereWithAggregatesInput[]
    NOT?: piccolo_userScalarWhereWithAggregatesInput | piccolo_userScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"piccolo_user"> | number
    username?: StringWithAggregatesFilter<"piccolo_user"> | string
    password?: StringWithAggregatesFilter<"piccolo_user"> | string
    email?: StringWithAggregatesFilter<"piccolo_user"> | string
    active?: BoolWithAggregatesFilter<"piccolo_user"> | boolean
    admin?: BoolWithAggregatesFilter<"piccolo_user"> | boolean
    first_name?: StringNullableWithAggregatesFilter<"piccolo_user"> | string | null
    last_name?: StringNullableWithAggregatesFilter<"piccolo_user"> | string | null
    superuser?: BoolWithAggregatesFilter<"piccolo_user"> | boolean
    last_login?: DateTimeNullableWithAggregatesFilter<"piccolo_user"> | Date | string | null
    lynxtag?: UuidWithAggregatesFilter<"piccolo_user"> | string
  }

  export type platform_mapWhereInput = {
    AND?: platform_mapWhereInput | platform_mapWhereInput[]
    OR?: platform_mapWhereInput[]
    NOT?: platform_mapWhereInput | platform_mapWhereInput[]
    fates_id?: DecimalFilter<"platform_map"> | Decimal | DecimalJsLike | number | string
    platform_id?: StringFilter<"platform_map"> | string
    lynxtag?: UuidFilter<"platform_map"> | string
  }

  export type platform_mapOrderByWithRelationInput = {
    fates_id?: SortOrder
    platform_id?: SortOrder
    lynxtag?: SortOrder
  }

  export type platform_mapWhereUniqueInput = Prisma.AtLeast<{
    lynxtag?: string
    AND?: platform_mapWhereInput | platform_mapWhereInput[]
    OR?: platform_mapWhereInput[]
    NOT?: platform_mapWhereInput | platform_mapWhereInput[]
    fates_id?: DecimalFilter<"platform_map"> | Decimal | DecimalJsLike | number | string
    platform_id?: StringFilter<"platform_map"> | string
  }, "lynxtag">

  export type platform_mapOrderByWithAggregationInput = {
    fates_id?: SortOrder
    platform_id?: SortOrder
    lynxtag?: SortOrder
    _count?: platform_mapCountOrderByAggregateInput
    _avg?: platform_mapAvgOrderByAggregateInput
    _max?: platform_mapMaxOrderByAggregateInput
    _min?: platform_mapMinOrderByAggregateInput
    _sum?: platform_mapSumOrderByAggregateInput
  }

  export type platform_mapScalarWhereWithAggregatesInput = {
    AND?: platform_mapScalarWhereWithAggregatesInput | platform_mapScalarWhereWithAggregatesInput[]
    OR?: platform_mapScalarWhereWithAggregatesInput[]
    NOT?: platform_mapScalarWhereWithAggregatesInput | platform_mapScalarWhereWithAggregatesInput[]
    fates_id?: DecimalWithAggregatesFilter<"platform_map"> | Decimal | DecimalJsLike | number | string
    platform_id?: StringWithAggregatesFilter<"platform_map"> | string
    lynxtag?: UuidWithAggregatesFilter<"platform_map"> | string
  }

  export type push_notificationsWhereInput = {
    AND?: push_notificationsWhereInput | push_notificationsWhereInput[]
    OR?: push_notificationsWhereInput[]
    NOT?: push_notificationsWhereInput | push_notificationsWhereInput[]
    id?: UuidFilter<"push_notifications"> | string
    user_id?: BigIntFilter<"push_notifications"> | bigint | number
    token?: StringFilter<"push_notifications"> | string
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type push_notificationsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    token?: SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type push_notificationsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: push_notificationsWhereInput | push_notificationsWhereInput[]
    OR?: push_notificationsWhereInput[]
    NOT?: push_notificationsWhereInput | push_notificationsWhereInput[]
    user_id?: BigIntFilter<"push_notifications"> | bigint | number
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }, "id" | "token">

  export type push_notificationsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    token?: SortOrder
    _count?: push_notificationsCountOrderByAggregateInput
    _avg?: push_notificationsAvgOrderByAggregateInput
    _max?: push_notificationsMaxOrderByAggregateInput
    _min?: push_notificationsMinOrderByAggregateInput
    _sum?: push_notificationsSumOrderByAggregateInput
  }

  export type push_notificationsScalarWhereWithAggregatesInput = {
    AND?: push_notificationsScalarWhereWithAggregatesInput | push_notificationsScalarWhereWithAggregatesInput[]
    OR?: push_notificationsScalarWhereWithAggregatesInput[]
    NOT?: push_notificationsScalarWhereWithAggregatesInput | push_notificationsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"push_notifications"> | string
    user_id?: BigIntWithAggregatesFilter<"push_notifications"> | bigint | number
    token?: StringWithAggregatesFilter<"push_notifications"> | string
  }

  export type review_votesWhereInput = {
    AND?: review_votesWhereInput | review_votesWhereInput[]
    OR?: review_votesWhereInput[]
    NOT?: review_votesWhereInput | review_votesWhereInput[]
    id?: UuidFilter<"review_votes"> | string
    user_id?: BigIntFilter<"review_votes"> | bigint | number
    upvote?: BoolFilter<"review_votes"> | boolean
    lynxtag?: UuidFilter<"review_votes"> | string
    reviews?: XOR<ReviewsRelationFilter, reviewsWhereInput>
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type review_votesOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    upvote?: SortOrder
    lynxtag?: SortOrder
    reviews?: reviewsOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
  }

  export type review_votesWhereUniqueInput = Prisma.AtLeast<{
    lynxtag?: string
    id_user_id?: review_votesIdUser_idCompoundUniqueInput
    AND?: review_votesWhereInput | review_votesWhereInput[]
    OR?: review_votesWhereInput[]
    NOT?: review_votesWhereInput | review_votesWhereInput[]
    id?: UuidFilter<"review_votes"> | string
    user_id?: BigIntFilter<"review_votes"> | bigint | number
    upvote?: BoolFilter<"review_votes"> | boolean
    reviews?: XOR<ReviewsRelationFilter, reviewsWhereInput>
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }, "id_user_id" | "lynxtag">

  export type review_votesOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    upvote?: SortOrder
    lynxtag?: SortOrder
    _count?: review_votesCountOrderByAggregateInput
    _avg?: review_votesAvgOrderByAggregateInput
    _max?: review_votesMaxOrderByAggregateInput
    _min?: review_votesMinOrderByAggregateInput
    _sum?: review_votesSumOrderByAggregateInput
  }

  export type review_votesScalarWhereWithAggregatesInput = {
    AND?: review_votesScalarWhereWithAggregatesInput | review_votesScalarWhereWithAggregatesInput[]
    OR?: review_votesScalarWhereWithAggregatesInput[]
    NOT?: review_votesScalarWhereWithAggregatesInput | review_votesScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"review_votes"> | string
    user_id?: BigIntWithAggregatesFilter<"review_votes"> | bigint | number
    upvote?: BoolWithAggregatesFilter<"review_votes"> | boolean
    lynxtag?: UuidWithAggregatesFilter<"review_votes"> | string
  }

  export type reviewsWhereInput = {
    AND?: reviewsWhereInput | reviewsWhereInput[]
    OR?: reviewsWhereInput[]
    NOT?: reviewsWhereInput | reviewsWhereInput[]
    id?: UuidFilter<"reviews"> | string
    target_id?: BigIntFilter<"reviews"> | bigint | number
    user_id?: BigIntFilter<"reviews"> | bigint | number
    star_rating?: DecimalFilter<"reviews"> | Decimal | DecimalJsLike | number | string
    review_text?: StringFilter<"reviews"> | string
    flagged?: BoolFilter<"reviews"> | boolean
    epoch?: BigIntNullableListFilter<"reviews">
    target_type?: IntNullableFilter<"reviews"> | number | null
    parent_id?: UuidNullableFilter<"reviews"> | string | null
    lynxtag?: UuidFilter<"reviews"> | string
    review_votes?: Review_votesListRelationFilter
    reviews?: XOR<ReviewsNullableRelationFilter, reviewsWhereInput> | null
    other_reviews?: ReviewsListRelationFilter
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type reviewsOrderByWithRelationInput = {
    id?: SortOrder
    target_id?: SortOrder
    user_id?: SortOrder
    star_rating?: SortOrder
    review_text?: SortOrder
    flagged?: SortOrder
    epoch?: SortOrder
    target_type?: SortOrderInput | SortOrder
    parent_id?: SortOrderInput | SortOrder
    lynxtag?: SortOrder
    review_votes?: review_votesOrderByRelationAggregateInput
    reviews?: reviewsOrderByWithRelationInput
    other_reviews?: reviewsOrderByRelationAggregateInput
    users?: usersOrderByWithRelationInput
  }

  export type reviewsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    lynxtag?: string
    AND?: reviewsWhereInput | reviewsWhereInput[]
    OR?: reviewsWhereInput[]
    NOT?: reviewsWhereInput | reviewsWhereInput[]
    target_id?: BigIntFilter<"reviews"> | bigint | number
    user_id?: BigIntFilter<"reviews"> | bigint | number
    star_rating?: DecimalFilter<"reviews"> | Decimal | DecimalJsLike | number | string
    review_text?: StringFilter<"reviews"> | string
    flagged?: BoolFilter<"reviews"> | boolean
    epoch?: BigIntNullableListFilter<"reviews">
    target_type?: IntNullableFilter<"reviews"> | number | null
    parent_id?: UuidNullableFilter<"reviews"> | string | null
    review_votes?: Review_votesListRelationFilter
    reviews?: XOR<ReviewsNullableRelationFilter, reviewsWhereInput> | null
    other_reviews?: ReviewsListRelationFilter
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }, "id" | "lynxtag">

  export type reviewsOrderByWithAggregationInput = {
    id?: SortOrder
    target_id?: SortOrder
    user_id?: SortOrder
    star_rating?: SortOrder
    review_text?: SortOrder
    flagged?: SortOrder
    epoch?: SortOrder
    target_type?: SortOrderInput | SortOrder
    parent_id?: SortOrderInput | SortOrder
    lynxtag?: SortOrder
    _count?: reviewsCountOrderByAggregateInput
    _avg?: reviewsAvgOrderByAggregateInput
    _max?: reviewsMaxOrderByAggregateInput
    _min?: reviewsMinOrderByAggregateInput
    _sum?: reviewsSumOrderByAggregateInput
  }

  export type reviewsScalarWhereWithAggregatesInput = {
    AND?: reviewsScalarWhereWithAggregatesInput | reviewsScalarWhereWithAggregatesInput[]
    OR?: reviewsScalarWhereWithAggregatesInput[]
    NOT?: reviewsScalarWhereWithAggregatesInput | reviewsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"reviews"> | string
    target_id?: BigIntWithAggregatesFilter<"reviews"> | bigint | number
    user_id?: BigIntWithAggregatesFilter<"reviews"> | bigint | number
    star_rating?: DecimalWithAggregatesFilter<"reviews"> | Decimal | DecimalJsLike | number | string
    review_text?: StringWithAggregatesFilter<"reviews"> | string
    flagged?: BoolWithAggregatesFilter<"reviews"> | boolean
    epoch?: BigIntNullableListFilter<"reviews">
    target_type?: IntNullableWithAggregatesFilter<"reviews"> | number | null
    parent_id?: UuidNullableWithAggregatesFilter<"reviews"> | string | null
    lynxtag?: UuidWithAggregatesFilter<"reviews"> | string
  }

  export type server_audit_logsWhereInput = {
    AND?: server_audit_logsWhereInput | server_audit_logsWhereInput[]
    OR?: server_audit_logsWhereInput[]
    NOT?: server_audit_logsWhereInput | server_audit_logsWhereInput[]
    guild_id?: BigIntFilter<"server_audit_logs"> | bigint | number
    user_id?: BigIntFilter<"server_audit_logs"> | bigint | number
    username?: StringFilter<"server_audit_logs"> | string
    user_guild_perms?: StringFilter<"server_audit_logs"> | string
    field?: StringFilter<"server_audit_logs"> | string
    value?: StringFilter<"server_audit_logs"> | string
    action_time?: DateTimeFilter<"server_audit_logs"> | Date | string
    action_id?: UuidFilter<"server_audit_logs"> | string
    lynxtag?: UuidFilter<"server_audit_logs"> | string
    servers?: XOR<ServersRelationFilter, serversWhereInput>
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type server_audit_logsOrderByWithRelationInput = {
    guild_id?: SortOrder
    user_id?: SortOrder
    username?: SortOrder
    user_guild_perms?: SortOrder
    field?: SortOrder
    value?: SortOrder
    action_time?: SortOrder
    action_id?: SortOrder
    lynxtag?: SortOrder
    servers?: serversOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
  }

  export type server_audit_logsWhereUniqueInput = Prisma.AtLeast<{
    action_id?: string
    lynxtag?: string
    AND?: server_audit_logsWhereInput | server_audit_logsWhereInput[]
    OR?: server_audit_logsWhereInput[]
    NOT?: server_audit_logsWhereInput | server_audit_logsWhereInput[]
    guild_id?: BigIntFilter<"server_audit_logs"> | bigint | number
    user_id?: BigIntFilter<"server_audit_logs"> | bigint | number
    username?: StringFilter<"server_audit_logs"> | string
    user_guild_perms?: StringFilter<"server_audit_logs"> | string
    field?: StringFilter<"server_audit_logs"> | string
    value?: StringFilter<"server_audit_logs"> | string
    action_time?: DateTimeFilter<"server_audit_logs"> | Date | string
    servers?: XOR<ServersRelationFilter, serversWhereInput>
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }, "action_id" | "lynxtag">

  export type server_audit_logsOrderByWithAggregationInput = {
    guild_id?: SortOrder
    user_id?: SortOrder
    username?: SortOrder
    user_guild_perms?: SortOrder
    field?: SortOrder
    value?: SortOrder
    action_time?: SortOrder
    action_id?: SortOrder
    lynxtag?: SortOrder
    _count?: server_audit_logsCountOrderByAggregateInput
    _avg?: server_audit_logsAvgOrderByAggregateInput
    _max?: server_audit_logsMaxOrderByAggregateInput
    _min?: server_audit_logsMinOrderByAggregateInput
    _sum?: server_audit_logsSumOrderByAggregateInput
  }

  export type server_audit_logsScalarWhereWithAggregatesInput = {
    AND?: server_audit_logsScalarWhereWithAggregatesInput | server_audit_logsScalarWhereWithAggregatesInput[]
    OR?: server_audit_logsScalarWhereWithAggregatesInput[]
    NOT?: server_audit_logsScalarWhereWithAggregatesInput | server_audit_logsScalarWhereWithAggregatesInput[]
    guild_id?: BigIntWithAggregatesFilter<"server_audit_logs"> | bigint | number
    user_id?: BigIntWithAggregatesFilter<"server_audit_logs"> | bigint | number
    username?: StringWithAggregatesFilter<"server_audit_logs"> | string
    user_guild_perms?: StringWithAggregatesFilter<"server_audit_logs"> | string
    field?: StringWithAggregatesFilter<"server_audit_logs"> | string
    value?: StringWithAggregatesFilter<"server_audit_logs"> | string
    action_time?: DateTimeWithAggregatesFilter<"server_audit_logs"> | Date | string
    action_id?: UuidWithAggregatesFilter<"server_audit_logs"> | string
    lynxtag?: UuidWithAggregatesFilter<"server_audit_logs"> | string
  }

  export type server_tagsWhereInput = {
    AND?: server_tagsWhereInput | server_tagsWhereInput[]
    OR?: server_tagsWhereInput[]
    NOT?: server_tagsWhereInput | server_tagsWhereInput[]
    id?: StringFilter<"server_tags"> | string
    name?: StringFilter<"server_tags"> | string
    owner_guild?: BigIntFilter<"server_tags"> | bigint | number
    iconify_data?: StringFilter<"server_tags"> | string
    lynxtag?: UuidFilter<"server_tags"> | string
  }

  export type server_tagsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    owner_guild?: SortOrder
    iconify_data?: SortOrder
    lynxtag?: SortOrder
  }

  export type server_tagsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    lynxtag?: string
    AND?: server_tagsWhereInput | server_tagsWhereInput[]
    OR?: server_tagsWhereInput[]
    NOT?: server_tagsWhereInput | server_tagsWhereInput[]
    owner_guild?: BigIntFilter<"server_tags"> | bigint | number
    iconify_data?: StringFilter<"server_tags"> | string
  }, "id" | "name" | "lynxtag">

  export type server_tagsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    owner_guild?: SortOrder
    iconify_data?: SortOrder
    lynxtag?: SortOrder
    _count?: server_tagsCountOrderByAggregateInput
    _avg?: server_tagsAvgOrderByAggregateInput
    _max?: server_tagsMaxOrderByAggregateInput
    _min?: server_tagsMinOrderByAggregateInput
    _sum?: server_tagsSumOrderByAggregateInput
  }

  export type server_tagsScalarWhereWithAggregatesInput = {
    AND?: server_tagsScalarWhereWithAggregatesInput | server_tagsScalarWhereWithAggregatesInput[]
    OR?: server_tagsScalarWhereWithAggregatesInput[]
    NOT?: server_tagsScalarWhereWithAggregatesInput | server_tagsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"server_tags"> | string
    name?: StringWithAggregatesFilter<"server_tags"> | string
    owner_guild?: BigIntWithAggregatesFilter<"server_tags"> | bigint | number
    iconify_data?: StringWithAggregatesFilter<"server_tags"> | string
    lynxtag?: UuidWithAggregatesFilter<"server_tags"> | string
  }

  export type server_votersWhereInput = {
    AND?: server_votersWhereInput | server_votersWhereInput[]
    OR?: server_votersWhereInput[]
    NOT?: server_votersWhereInput | server_votersWhereInput[]
    guild_id?: BigIntFilter<"server_voters"> | bigint | number
    user_id?: BigIntFilter<"server_voters"> | bigint | number
    timestamps?: DateTimeNullableListFilter<"server_voters">
    lynxtag?: UuidFilter<"server_voters"> | string
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type server_votersOrderByWithRelationInput = {
    guild_id?: SortOrder
    user_id?: SortOrder
    timestamps?: SortOrder
    lynxtag?: SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type server_votersWhereUniqueInput = Prisma.AtLeast<{
    lynxtag?: string
    AND?: server_votersWhereInput | server_votersWhereInput[]
    OR?: server_votersWhereInput[]
    NOT?: server_votersWhereInput | server_votersWhereInput[]
    guild_id?: BigIntFilter<"server_voters"> | bigint | number
    user_id?: BigIntFilter<"server_voters"> | bigint | number
    timestamps?: DateTimeNullableListFilter<"server_voters">
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }, "lynxtag">

  export type server_votersOrderByWithAggregationInput = {
    guild_id?: SortOrder
    user_id?: SortOrder
    timestamps?: SortOrder
    lynxtag?: SortOrder
    _count?: server_votersCountOrderByAggregateInput
    _avg?: server_votersAvgOrderByAggregateInput
    _max?: server_votersMaxOrderByAggregateInput
    _min?: server_votersMinOrderByAggregateInput
    _sum?: server_votersSumOrderByAggregateInput
  }

  export type server_votersScalarWhereWithAggregatesInput = {
    AND?: server_votersScalarWhereWithAggregatesInput | server_votersScalarWhereWithAggregatesInput[]
    OR?: server_votersScalarWhereWithAggregatesInput[]
    NOT?: server_votersScalarWhereWithAggregatesInput | server_votersScalarWhereWithAggregatesInput[]
    guild_id?: BigIntWithAggregatesFilter<"server_voters"> | bigint | number
    user_id?: BigIntWithAggregatesFilter<"server_voters"> | bigint | number
    timestamps?: DateTimeNullableListFilter<"server_voters">
    lynxtag?: UuidWithAggregatesFilter<"server_voters"> | string
  }

  export type serversWhereInput = {
    AND?: serversWhereInput | serversWhereInput[]
    OR?: serversWhereInput[]
    NOT?: serversWhereInput | serversWhereInput[]
    guild_id?: BigIntFilter<"servers"> | bigint | number
    votes?: BigIntNullableFilter<"servers"> | bigint | number | null
    webhook?: StringNullableFilter<"servers"> | string | null
    description?: StringFilter<"servers"> | string
    long_description?: StringFilter<"servers"> | string
    css?: StringNullableFilter<"servers"> | string | null
    api_token?: StringFilter<"servers"> | string
    invite_amount?: IntNullableFilter<"servers"> | number | null
    invite_url?: StringNullableFilter<"servers"> | string | null
    name_cached?: StringFilter<"servers"> | string
    long_description_type?: IntNullableFilter<"servers"> | number | null
    state?: IntFilter<"servers"> | number
    created_at?: DateTimeFilter<"servers"> | Date | string
    avatar_cached?: StringNullableFilter<"servers"> | string | null
    invite_channel?: BigIntNullableFilter<"servers"> | bigint | number | null
    guild_count?: BigIntNullableFilter<"servers"> | bigint | number | null
    banner_card?: StringNullableFilter<"servers"> | string | null
    banner_page?: StringNullableFilter<"servers"> | string | null
    webhook_secret?: StringNullableFilter<"servers"> | string | null
    webhook_type?: IntNullableFilter<"servers"> | number | null
    total_votes?: BigIntNullableFilter<"servers"> | bigint | number | null
    tags?: StringNullableListFilter<"servers">
    owner_id?: BigIntFilter<"servers"> | bigint | number
    flags?: IntNullableListFilter<"servers">
    autorole_votes?: BigIntNullableListFilter<"servers">
    whitelist_form?: StringNullableFilter<"servers"> | string | null
    webhook_hmac_only?: BoolNullableFilter<"servers"> | boolean | null
    old_state?: IntFilter<"servers"> | number
    user_whitelist?: BigIntNullableListFilter<"servers">
    user_blacklist?: BigIntNullableListFilter<"servers">
    extra_links?: JsonFilter<"servers">
    lynxtag?: UuidFilter<"servers"> | string
    server_audit_logs?: Server_audit_logsListRelationFilter
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type serversOrderByWithRelationInput = {
    guild_id?: SortOrder
    votes?: SortOrderInput | SortOrder
    webhook?: SortOrderInput | SortOrder
    description?: SortOrder
    long_description?: SortOrder
    css?: SortOrderInput | SortOrder
    api_token?: SortOrder
    invite_amount?: SortOrderInput | SortOrder
    invite_url?: SortOrderInput | SortOrder
    name_cached?: SortOrder
    long_description_type?: SortOrderInput | SortOrder
    state?: SortOrder
    created_at?: SortOrder
    avatar_cached?: SortOrderInput | SortOrder
    invite_channel?: SortOrderInput | SortOrder
    guild_count?: SortOrderInput | SortOrder
    banner_card?: SortOrderInput | SortOrder
    banner_page?: SortOrderInput | SortOrder
    webhook_secret?: SortOrderInput | SortOrder
    webhook_type?: SortOrderInput | SortOrder
    total_votes?: SortOrderInput | SortOrder
    tags?: SortOrder
    owner_id?: SortOrder
    flags?: SortOrder
    autorole_votes?: SortOrder
    whitelist_form?: SortOrderInput | SortOrder
    webhook_hmac_only?: SortOrderInput | SortOrder
    old_state?: SortOrder
    user_whitelist?: SortOrder
    user_blacklist?: SortOrder
    extra_links?: SortOrder
    lynxtag?: SortOrder
    server_audit_logs?: server_audit_logsOrderByRelationAggregateInput
    users?: usersOrderByWithRelationInput
  }

  export type serversWhereUniqueInput = Prisma.AtLeast<{
    guild_id?: bigint | number
    api_token?: string
    lynxtag?: string
    AND?: serversWhereInput | serversWhereInput[]
    OR?: serversWhereInput[]
    NOT?: serversWhereInput | serversWhereInput[]
    votes?: BigIntNullableFilter<"servers"> | bigint | number | null
    webhook?: StringNullableFilter<"servers"> | string | null
    description?: StringFilter<"servers"> | string
    long_description?: StringFilter<"servers"> | string
    css?: StringNullableFilter<"servers"> | string | null
    invite_amount?: IntNullableFilter<"servers"> | number | null
    invite_url?: StringNullableFilter<"servers"> | string | null
    name_cached?: StringFilter<"servers"> | string
    long_description_type?: IntNullableFilter<"servers"> | number | null
    state?: IntFilter<"servers"> | number
    created_at?: DateTimeFilter<"servers"> | Date | string
    avatar_cached?: StringNullableFilter<"servers"> | string | null
    invite_channel?: BigIntNullableFilter<"servers"> | bigint | number | null
    guild_count?: BigIntNullableFilter<"servers"> | bigint | number | null
    banner_card?: StringNullableFilter<"servers"> | string | null
    banner_page?: StringNullableFilter<"servers"> | string | null
    webhook_secret?: StringNullableFilter<"servers"> | string | null
    webhook_type?: IntNullableFilter<"servers"> | number | null
    total_votes?: BigIntNullableFilter<"servers"> | bigint | number | null
    tags?: StringNullableListFilter<"servers">
    owner_id?: BigIntFilter<"servers"> | bigint | number
    flags?: IntNullableListFilter<"servers">
    autorole_votes?: BigIntNullableListFilter<"servers">
    whitelist_form?: StringNullableFilter<"servers"> | string | null
    webhook_hmac_only?: BoolNullableFilter<"servers"> | boolean | null
    old_state?: IntFilter<"servers"> | number
    user_whitelist?: BigIntNullableListFilter<"servers">
    user_blacklist?: BigIntNullableListFilter<"servers">
    extra_links?: JsonFilter<"servers">
    server_audit_logs?: Server_audit_logsListRelationFilter
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }, "guild_id" | "api_token" | "lynxtag">

  export type serversOrderByWithAggregationInput = {
    guild_id?: SortOrder
    votes?: SortOrderInput | SortOrder
    webhook?: SortOrderInput | SortOrder
    description?: SortOrder
    long_description?: SortOrder
    css?: SortOrderInput | SortOrder
    api_token?: SortOrder
    invite_amount?: SortOrderInput | SortOrder
    invite_url?: SortOrderInput | SortOrder
    name_cached?: SortOrder
    long_description_type?: SortOrderInput | SortOrder
    state?: SortOrder
    created_at?: SortOrder
    avatar_cached?: SortOrderInput | SortOrder
    invite_channel?: SortOrderInput | SortOrder
    guild_count?: SortOrderInput | SortOrder
    banner_card?: SortOrderInput | SortOrder
    banner_page?: SortOrderInput | SortOrder
    webhook_secret?: SortOrderInput | SortOrder
    webhook_type?: SortOrderInput | SortOrder
    total_votes?: SortOrderInput | SortOrder
    tags?: SortOrder
    owner_id?: SortOrder
    flags?: SortOrder
    autorole_votes?: SortOrder
    whitelist_form?: SortOrderInput | SortOrder
    webhook_hmac_only?: SortOrderInput | SortOrder
    old_state?: SortOrder
    user_whitelist?: SortOrder
    user_blacklist?: SortOrder
    extra_links?: SortOrder
    lynxtag?: SortOrder
    _count?: serversCountOrderByAggregateInput
    _avg?: serversAvgOrderByAggregateInput
    _max?: serversMaxOrderByAggregateInput
    _min?: serversMinOrderByAggregateInput
    _sum?: serversSumOrderByAggregateInput
  }

  export type serversScalarWhereWithAggregatesInput = {
    AND?: serversScalarWhereWithAggregatesInput | serversScalarWhereWithAggregatesInput[]
    OR?: serversScalarWhereWithAggregatesInput[]
    NOT?: serversScalarWhereWithAggregatesInput | serversScalarWhereWithAggregatesInput[]
    guild_id?: BigIntWithAggregatesFilter<"servers"> | bigint | number
    votes?: BigIntNullableWithAggregatesFilter<"servers"> | bigint | number | null
    webhook?: StringNullableWithAggregatesFilter<"servers"> | string | null
    description?: StringWithAggregatesFilter<"servers"> | string
    long_description?: StringWithAggregatesFilter<"servers"> | string
    css?: StringNullableWithAggregatesFilter<"servers"> | string | null
    api_token?: StringWithAggregatesFilter<"servers"> | string
    invite_amount?: IntNullableWithAggregatesFilter<"servers"> | number | null
    invite_url?: StringNullableWithAggregatesFilter<"servers"> | string | null
    name_cached?: StringWithAggregatesFilter<"servers"> | string
    long_description_type?: IntNullableWithAggregatesFilter<"servers"> | number | null
    state?: IntWithAggregatesFilter<"servers"> | number
    created_at?: DateTimeWithAggregatesFilter<"servers"> | Date | string
    avatar_cached?: StringNullableWithAggregatesFilter<"servers"> | string | null
    invite_channel?: BigIntNullableWithAggregatesFilter<"servers"> | bigint | number | null
    guild_count?: BigIntNullableWithAggregatesFilter<"servers"> | bigint | number | null
    banner_card?: StringNullableWithAggregatesFilter<"servers"> | string | null
    banner_page?: StringNullableWithAggregatesFilter<"servers"> | string | null
    webhook_secret?: StringNullableWithAggregatesFilter<"servers"> | string | null
    webhook_type?: IntNullableWithAggregatesFilter<"servers"> | number | null
    total_votes?: BigIntNullableWithAggregatesFilter<"servers"> | bigint | number | null
    tags?: StringNullableListFilter<"servers">
    owner_id?: BigIntWithAggregatesFilter<"servers"> | bigint | number
    flags?: IntNullableListFilter<"servers">
    autorole_votes?: BigIntNullableListFilter<"servers">
    whitelist_form?: StringNullableWithAggregatesFilter<"servers"> | string | null
    webhook_hmac_only?: BoolNullableWithAggregatesFilter<"servers"> | boolean | null
    old_state?: IntWithAggregatesFilter<"servers"> | number
    user_whitelist?: BigIntNullableListFilter<"servers">
    user_blacklist?: BigIntNullableListFilter<"servers">
    extra_links?: JsonWithAggregatesFilter<"servers">
    lynxtag?: UuidWithAggregatesFilter<"servers"> | string
  }

  export type sessionsWhereInput = {
    AND?: sessionsWhereInput | sessionsWhereInput[]
    OR?: sessionsWhereInput[]
    NOT?: sessionsWhereInput | sessionsWhereInput[]
    id?: IntFilter<"sessions"> | number
    token?: StringFilter<"sessions"> | string
    user_id?: IntFilter<"sessions"> | number
    expiry_date?: DateTimeFilter<"sessions"> | Date | string
    max_expiry_date?: DateTimeFilter<"sessions"> | Date | string
    lynxtag?: UuidFilter<"sessions"> | string
  }

  export type sessionsOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    user_id?: SortOrder
    expiry_date?: SortOrder
    max_expiry_date?: SortOrder
    lynxtag?: SortOrder
  }

  export type sessionsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    lynxtag?: string
    AND?: sessionsWhereInput | sessionsWhereInput[]
    OR?: sessionsWhereInput[]
    NOT?: sessionsWhereInput | sessionsWhereInput[]
    token?: StringFilter<"sessions"> | string
    user_id?: IntFilter<"sessions"> | number
    expiry_date?: DateTimeFilter<"sessions"> | Date | string
    max_expiry_date?: DateTimeFilter<"sessions"> | Date | string
  }, "id" | "lynxtag">

  export type sessionsOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    user_id?: SortOrder
    expiry_date?: SortOrder
    max_expiry_date?: SortOrder
    lynxtag?: SortOrder
    _count?: sessionsCountOrderByAggregateInput
    _avg?: sessionsAvgOrderByAggregateInput
    _max?: sessionsMaxOrderByAggregateInput
    _min?: sessionsMinOrderByAggregateInput
    _sum?: sessionsSumOrderByAggregateInput
  }

  export type sessionsScalarWhereWithAggregatesInput = {
    AND?: sessionsScalarWhereWithAggregatesInput | sessionsScalarWhereWithAggregatesInput[]
    OR?: sessionsScalarWhereWithAggregatesInput[]
    NOT?: sessionsScalarWhereWithAggregatesInput | sessionsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"sessions"> | number
    token?: StringWithAggregatesFilter<"sessions"> | string
    user_id?: IntWithAggregatesFilter<"sessions"> | number
    expiry_date?: DateTimeWithAggregatesFilter<"sessions"> | Date | string
    max_expiry_date?: DateTimeWithAggregatesFilter<"sessions"> | Date | string
    lynxtag?: UuidWithAggregatesFilter<"sessions"> | string
  }

  export type user_bot_logsWhereInput = {
    AND?: user_bot_logsWhereInput | user_bot_logsWhereInput[]
    OR?: user_bot_logsWhereInput[]
    NOT?: user_bot_logsWhereInput | user_bot_logsWhereInput[]
    user_id?: BigIntFilter<"user_bot_logs"> | bigint | number
    bot_id?: BigIntFilter<"user_bot_logs"> | bigint | number
    action_time?: DateTimeFilter<"user_bot_logs"> | Date | string
    action?: IntFilter<"user_bot_logs"> | number
    context?: StringNullableFilter<"user_bot_logs"> | string | null
    lynxtag?: UuidFilter<"user_bot_logs"> | string
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type user_bot_logsOrderByWithRelationInput = {
    user_id?: SortOrder
    bot_id?: SortOrder
    action_time?: SortOrder
    action?: SortOrder
    context?: SortOrderInput | SortOrder
    lynxtag?: SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type user_bot_logsWhereUniqueInput = Prisma.AtLeast<{
    lynxtag?: string
    AND?: user_bot_logsWhereInput | user_bot_logsWhereInput[]
    OR?: user_bot_logsWhereInput[]
    NOT?: user_bot_logsWhereInput | user_bot_logsWhereInput[]
    user_id?: BigIntFilter<"user_bot_logs"> | bigint | number
    bot_id?: BigIntFilter<"user_bot_logs"> | bigint | number
    action_time?: DateTimeFilter<"user_bot_logs"> | Date | string
    action?: IntFilter<"user_bot_logs"> | number
    context?: StringNullableFilter<"user_bot_logs"> | string | null
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }, "lynxtag">

  export type user_bot_logsOrderByWithAggregationInput = {
    user_id?: SortOrder
    bot_id?: SortOrder
    action_time?: SortOrder
    action?: SortOrder
    context?: SortOrderInput | SortOrder
    lynxtag?: SortOrder
    _count?: user_bot_logsCountOrderByAggregateInput
    _avg?: user_bot_logsAvgOrderByAggregateInput
    _max?: user_bot_logsMaxOrderByAggregateInput
    _min?: user_bot_logsMinOrderByAggregateInput
    _sum?: user_bot_logsSumOrderByAggregateInput
  }

  export type user_bot_logsScalarWhereWithAggregatesInput = {
    AND?: user_bot_logsScalarWhereWithAggregatesInput | user_bot_logsScalarWhereWithAggregatesInput[]
    OR?: user_bot_logsScalarWhereWithAggregatesInput[]
    NOT?: user_bot_logsScalarWhereWithAggregatesInput | user_bot_logsScalarWhereWithAggregatesInput[]
    user_id?: BigIntWithAggregatesFilter<"user_bot_logs"> | bigint | number
    bot_id?: BigIntWithAggregatesFilter<"user_bot_logs"> | bigint | number
    action_time?: DateTimeWithAggregatesFilter<"user_bot_logs"> | Date | string
    action?: IntWithAggregatesFilter<"user_bot_logs"> | number
    context?: StringNullableWithAggregatesFilter<"user_bot_logs"> | string | null
    lynxtag?: UuidWithAggregatesFilter<"user_bot_logs"> | string
  }

  export type user_connectionsWhereInput = {
    AND?: user_connectionsWhereInput | user_connectionsWhereInput[]
    OR?: user_connectionsWhereInput[]
    NOT?: user_connectionsWhereInput | user_connectionsWhereInput[]
    user_id?: BigIntFilter<"user_connections"> | bigint | number
    client_id?: StringFilter<"user_connections"> | string
    refresh_token?: StringFilter<"user_connections"> | string
    expires_on?: DateTimeFilter<"user_connections"> | Date | string
    lynxtag?: UuidFilter<"user_connections"> | string
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type user_connectionsOrderByWithRelationInput = {
    user_id?: SortOrder
    client_id?: SortOrder
    refresh_token?: SortOrder
    expires_on?: SortOrder
    lynxtag?: SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type user_connectionsWhereUniqueInput = Prisma.AtLeast<{
    lynxtag?: string
    AND?: user_connectionsWhereInput | user_connectionsWhereInput[]
    OR?: user_connectionsWhereInput[]
    NOT?: user_connectionsWhereInput | user_connectionsWhereInput[]
    user_id?: BigIntFilter<"user_connections"> | bigint | number
    client_id?: StringFilter<"user_connections"> | string
    refresh_token?: StringFilter<"user_connections"> | string
    expires_on?: DateTimeFilter<"user_connections"> | Date | string
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }, "lynxtag">

  export type user_connectionsOrderByWithAggregationInput = {
    user_id?: SortOrder
    client_id?: SortOrder
    refresh_token?: SortOrder
    expires_on?: SortOrder
    lynxtag?: SortOrder
    _count?: user_connectionsCountOrderByAggregateInput
    _avg?: user_connectionsAvgOrderByAggregateInput
    _max?: user_connectionsMaxOrderByAggregateInput
    _min?: user_connectionsMinOrderByAggregateInput
    _sum?: user_connectionsSumOrderByAggregateInput
  }

  export type user_connectionsScalarWhereWithAggregatesInput = {
    AND?: user_connectionsScalarWhereWithAggregatesInput | user_connectionsScalarWhereWithAggregatesInput[]
    OR?: user_connectionsScalarWhereWithAggregatesInput[]
    NOT?: user_connectionsScalarWhereWithAggregatesInput | user_connectionsScalarWhereWithAggregatesInput[]
    user_id?: BigIntWithAggregatesFilter<"user_connections"> | bigint | number
    client_id?: StringWithAggregatesFilter<"user_connections"> | string
    refresh_token?: StringWithAggregatesFilter<"user_connections"> | string
    expires_on?: DateTimeWithAggregatesFilter<"user_connections"> | Date | string
    lynxtag?: UuidWithAggregatesFilter<"user_connections"> | string
  }

  export type user_server_vote_tableWhereInput = {
    AND?: user_server_vote_tableWhereInput | user_server_vote_tableWhereInput[]
    OR?: user_server_vote_tableWhereInput[]
    NOT?: user_server_vote_tableWhereInput | user_server_vote_tableWhereInput[]
    user_id?: BigIntFilter<"user_server_vote_table"> | bigint | number
    guild_id?: BigIntFilter<"user_server_vote_table"> | bigint | number
    expires_on?: DateTimeNullableFilter<"user_server_vote_table"> | Date | string | null
    lynxtag?: UuidFilter<"user_server_vote_table"> | string
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type user_server_vote_tableOrderByWithRelationInput = {
    user_id?: SortOrder
    guild_id?: SortOrder
    expires_on?: SortOrderInput | SortOrder
    lynxtag?: SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type user_server_vote_tableWhereUniqueInput = Prisma.AtLeast<{
    user_id?: bigint | number
    lynxtag?: string
    AND?: user_server_vote_tableWhereInput | user_server_vote_tableWhereInput[]
    OR?: user_server_vote_tableWhereInput[]
    NOT?: user_server_vote_tableWhereInput | user_server_vote_tableWhereInput[]
    guild_id?: BigIntFilter<"user_server_vote_table"> | bigint | number
    expires_on?: DateTimeNullableFilter<"user_server_vote_table"> | Date | string | null
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }, "user_id" | "lynxtag">

  export type user_server_vote_tableOrderByWithAggregationInput = {
    user_id?: SortOrder
    guild_id?: SortOrder
    expires_on?: SortOrderInput | SortOrder
    lynxtag?: SortOrder
    _count?: user_server_vote_tableCountOrderByAggregateInput
    _avg?: user_server_vote_tableAvgOrderByAggregateInput
    _max?: user_server_vote_tableMaxOrderByAggregateInput
    _min?: user_server_vote_tableMinOrderByAggregateInput
    _sum?: user_server_vote_tableSumOrderByAggregateInput
  }

  export type user_server_vote_tableScalarWhereWithAggregatesInput = {
    AND?: user_server_vote_tableScalarWhereWithAggregatesInput | user_server_vote_tableScalarWhereWithAggregatesInput[]
    OR?: user_server_vote_tableScalarWhereWithAggregatesInput[]
    NOT?: user_server_vote_tableScalarWhereWithAggregatesInput | user_server_vote_tableScalarWhereWithAggregatesInput[]
    user_id?: BigIntWithAggregatesFilter<"user_server_vote_table"> | bigint | number
    guild_id?: BigIntWithAggregatesFilter<"user_server_vote_table"> | bigint | number
    expires_on?: DateTimeNullableWithAggregatesFilter<"user_server_vote_table"> | Date | string | null
    lynxtag?: UuidWithAggregatesFilter<"user_server_vote_table"> | string
  }

  export type user_vote_tableWhereInput = {
    AND?: user_vote_tableWhereInput | user_vote_tableWhereInput[]
    OR?: user_vote_tableWhereInput[]
    NOT?: user_vote_tableWhereInput | user_vote_tableWhereInput[]
    user_id?: BigIntFilter<"user_vote_table"> | bigint | number
    bot_id?: BigIntFilter<"user_vote_table"> | bigint | number
    expires_on?: DateTimeNullableFilter<"user_vote_table"> | Date | string | null
    lynxtag?: UuidFilter<"user_vote_table"> | string
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type user_vote_tableOrderByWithRelationInput = {
    user_id?: SortOrder
    bot_id?: SortOrder
    expires_on?: SortOrderInput | SortOrder
    lynxtag?: SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type user_vote_tableWhereUniqueInput = Prisma.AtLeast<{
    user_id?: bigint | number
    lynxtag?: string
    AND?: user_vote_tableWhereInput | user_vote_tableWhereInput[]
    OR?: user_vote_tableWhereInput[]
    NOT?: user_vote_tableWhereInput | user_vote_tableWhereInput[]
    bot_id?: BigIntFilter<"user_vote_table"> | bigint | number
    expires_on?: DateTimeNullableFilter<"user_vote_table"> | Date | string | null
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }, "user_id" | "lynxtag">

  export type user_vote_tableOrderByWithAggregationInput = {
    user_id?: SortOrder
    bot_id?: SortOrder
    expires_on?: SortOrderInput | SortOrder
    lynxtag?: SortOrder
    _count?: user_vote_tableCountOrderByAggregateInput
    _avg?: user_vote_tableAvgOrderByAggregateInput
    _max?: user_vote_tableMaxOrderByAggregateInput
    _min?: user_vote_tableMinOrderByAggregateInput
    _sum?: user_vote_tableSumOrderByAggregateInput
  }

  export type user_vote_tableScalarWhereWithAggregatesInput = {
    AND?: user_vote_tableScalarWhereWithAggregatesInput | user_vote_tableScalarWhereWithAggregatesInput[]
    OR?: user_vote_tableScalarWhereWithAggregatesInput[]
    NOT?: user_vote_tableScalarWhereWithAggregatesInput | user_vote_tableScalarWhereWithAggregatesInput[]
    user_id?: BigIntWithAggregatesFilter<"user_vote_table"> | bigint | number
    bot_id?: BigIntWithAggregatesFilter<"user_vote_table"> | bigint | number
    expires_on?: DateTimeNullableWithAggregatesFilter<"user_vote_table"> | Date | string | null
    lynxtag?: UuidWithAggregatesFilter<"user_vote_table"> | string
  }

  export type usersWhereInput = {
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    user_id?: BigIntFilter<"users"> | bigint | number
    api_token?: StringFilter<"users"> | string
    description?: StringNullableFilter<"users"> | string | null
    badges?: StringNullableListFilter<"users">
    username?: StringNullableFilter<"users"> | string | null
    user_css?: StringNullableFilter<"users"> | string | null
    state?: IntFilter<"users"> | number
    coins?: IntNullableFilter<"users"> | number | null
    id?: BigIntFilter<"users"> | bigint | number
    site_lang?: StringNullableFilter<"users"> | string | null
    profile_css?: StringFilter<"users"> | string
    vote_reminders?: BigIntNullableListFilter<"users">
    vote_reminder_channel?: BigIntNullableFilter<"users"> | bigint | number | null
    staff_verify_code?: StringNullableFilter<"users"> | string | null
    vote_reminders_last_acked?: DateTimeFilter<"users"> | Date | string
    vote_reminders_servers?: BigIntNullableListFilter<"users">
    vote_reminders_servers_last_acked?: DateTimeFilter<"users"> | Date | string
    vote_reminder_servers_channel?: BigIntNullableFilter<"users"> | bigint | number | null
    experiments?: IntNullableListFilter<"users">
    flags?: IntNullableListFilter<"users">
    extra_links?: JsonFilter<"users">
    supabase_id?: UuidNullableFilter<"users"> | string | null
    totp_shared_key?: StringNullableFilter<"users"> | string | null
    staff_password?: StringNullableFilter<"users"> | string | null
    lynxtag?: UuidFilter<"users"> | string
    bot_voters?: Bot_votersListRelationFilter
    extra_data?: Extra_dataListRelationFilter
    frostpaw_clients?: Frostpaw_clientsListRelationFilter
    leave_of_absence?: Leave_of_absenceListRelationFilter
    lynx_apps?: Lynx_appsListRelationFilter
    lynx_logs?: Lynx_logsListRelationFilter
    lynx_ratings?: Lynx_ratingsListRelationFilter
    lynx_survey_responses?: Lynx_survey_responsesListRelationFilter
    push_notifications?: Push_notificationsListRelationFilter
    review_votes?: Review_votesListRelationFilter
    reviews?: ReviewsListRelationFilter
    server_audit_logs?: Server_audit_logsListRelationFilter
    server_voters?: Server_votersListRelationFilter
    servers?: ServersListRelationFilter
    user_bot_logs?: User_bot_logsListRelationFilter
    user_connections?: User_connectionsListRelationFilter
    user_server_vote_table?: XOR<User_server_vote_tableNullableRelationFilter, user_server_vote_tableWhereInput> | null
    user_vote_table?: XOR<User_vote_tableNullableRelationFilter, user_vote_tableWhereInput> | null
  }

  export type usersOrderByWithRelationInput = {
    user_id?: SortOrder
    api_token?: SortOrder
    description?: SortOrderInput | SortOrder
    badges?: SortOrder
    username?: SortOrderInput | SortOrder
    user_css?: SortOrderInput | SortOrder
    state?: SortOrder
    coins?: SortOrderInput | SortOrder
    id?: SortOrder
    site_lang?: SortOrderInput | SortOrder
    profile_css?: SortOrder
    vote_reminders?: SortOrder
    vote_reminder_channel?: SortOrderInput | SortOrder
    staff_verify_code?: SortOrderInput | SortOrder
    vote_reminders_last_acked?: SortOrder
    vote_reminders_servers?: SortOrder
    vote_reminders_servers_last_acked?: SortOrder
    vote_reminder_servers_channel?: SortOrderInput | SortOrder
    experiments?: SortOrder
    flags?: SortOrder
    extra_links?: SortOrder
    supabase_id?: SortOrderInput | SortOrder
    totp_shared_key?: SortOrderInput | SortOrder
    staff_password?: SortOrderInput | SortOrder
    lynxtag?: SortOrder
    bot_voters?: bot_votersOrderByRelationAggregateInput
    extra_data?: extra_dataOrderByRelationAggregateInput
    frostpaw_clients?: frostpaw_clientsOrderByRelationAggregateInput
    leave_of_absence?: leave_of_absenceOrderByRelationAggregateInput
    lynx_apps?: lynx_appsOrderByRelationAggregateInput
    lynx_logs?: lynx_logsOrderByRelationAggregateInput
    lynx_ratings?: lynx_ratingsOrderByRelationAggregateInput
    lynx_survey_responses?: lynx_survey_responsesOrderByRelationAggregateInput
    push_notifications?: push_notificationsOrderByRelationAggregateInput
    review_votes?: review_votesOrderByRelationAggregateInput
    reviews?: reviewsOrderByRelationAggregateInput
    server_audit_logs?: server_audit_logsOrderByRelationAggregateInput
    server_voters?: server_votersOrderByRelationAggregateInput
    servers?: serversOrderByRelationAggregateInput
    user_bot_logs?: user_bot_logsOrderByRelationAggregateInput
    user_connections?: user_connectionsOrderByRelationAggregateInput
    user_server_vote_table?: user_server_vote_tableOrderByWithRelationInput
    user_vote_table?: user_vote_tableOrderByWithRelationInput
  }

  export type usersWhereUniqueInput = Prisma.AtLeast<{
    user_id?: bigint | number
    lynxtag?: string
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    api_token?: StringFilter<"users"> | string
    description?: StringNullableFilter<"users"> | string | null
    badges?: StringNullableListFilter<"users">
    username?: StringNullableFilter<"users"> | string | null
    user_css?: StringNullableFilter<"users"> | string | null
    state?: IntFilter<"users"> | number
    coins?: IntNullableFilter<"users"> | number | null
    id?: BigIntFilter<"users"> | bigint | number
    site_lang?: StringNullableFilter<"users"> | string | null
    profile_css?: StringFilter<"users"> | string
    vote_reminders?: BigIntNullableListFilter<"users">
    vote_reminder_channel?: BigIntNullableFilter<"users"> | bigint | number | null
    staff_verify_code?: StringNullableFilter<"users"> | string | null
    vote_reminders_last_acked?: DateTimeFilter<"users"> | Date | string
    vote_reminders_servers?: BigIntNullableListFilter<"users">
    vote_reminders_servers_last_acked?: DateTimeFilter<"users"> | Date | string
    vote_reminder_servers_channel?: BigIntNullableFilter<"users"> | bigint | number | null
    experiments?: IntNullableListFilter<"users">
    flags?: IntNullableListFilter<"users">
    extra_links?: JsonFilter<"users">
    supabase_id?: UuidNullableFilter<"users"> | string | null
    totp_shared_key?: StringNullableFilter<"users"> | string | null
    staff_password?: StringNullableFilter<"users"> | string | null
    bot_voters?: Bot_votersListRelationFilter
    extra_data?: Extra_dataListRelationFilter
    frostpaw_clients?: Frostpaw_clientsListRelationFilter
    leave_of_absence?: Leave_of_absenceListRelationFilter
    lynx_apps?: Lynx_appsListRelationFilter
    lynx_logs?: Lynx_logsListRelationFilter
    lynx_ratings?: Lynx_ratingsListRelationFilter
    lynx_survey_responses?: Lynx_survey_responsesListRelationFilter
    push_notifications?: Push_notificationsListRelationFilter
    review_votes?: Review_votesListRelationFilter
    reviews?: ReviewsListRelationFilter
    server_audit_logs?: Server_audit_logsListRelationFilter
    server_voters?: Server_votersListRelationFilter
    servers?: ServersListRelationFilter
    user_bot_logs?: User_bot_logsListRelationFilter
    user_connections?: User_connectionsListRelationFilter
    user_server_vote_table?: XOR<User_server_vote_tableNullableRelationFilter, user_server_vote_tableWhereInput> | null
    user_vote_table?: XOR<User_vote_tableNullableRelationFilter, user_vote_tableWhereInput> | null
  }, "user_id" | "lynxtag">

  export type usersOrderByWithAggregationInput = {
    user_id?: SortOrder
    api_token?: SortOrder
    description?: SortOrderInput | SortOrder
    badges?: SortOrder
    username?: SortOrderInput | SortOrder
    user_css?: SortOrderInput | SortOrder
    state?: SortOrder
    coins?: SortOrderInput | SortOrder
    id?: SortOrder
    site_lang?: SortOrderInput | SortOrder
    profile_css?: SortOrder
    vote_reminders?: SortOrder
    vote_reminder_channel?: SortOrderInput | SortOrder
    staff_verify_code?: SortOrderInput | SortOrder
    vote_reminders_last_acked?: SortOrder
    vote_reminders_servers?: SortOrder
    vote_reminders_servers_last_acked?: SortOrder
    vote_reminder_servers_channel?: SortOrderInput | SortOrder
    experiments?: SortOrder
    flags?: SortOrder
    extra_links?: SortOrder
    supabase_id?: SortOrderInput | SortOrder
    totp_shared_key?: SortOrderInput | SortOrder
    staff_password?: SortOrderInput | SortOrder
    lynxtag?: SortOrder
    _count?: usersCountOrderByAggregateInput
    _avg?: usersAvgOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
    _sum?: usersSumOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    OR?: usersScalarWhereWithAggregatesInput[]
    NOT?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    user_id?: BigIntWithAggregatesFilter<"users"> | bigint | number
    api_token?: StringWithAggregatesFilter<"users"> | string
    description?: StringNullableWithAggregatesFilter<"users"> | string | null
    badges?: StringNullableListFilter<"users">
    username?: StringNullableWithAggregatesFilter<"users"> | string | null
    user_css?: StringNullableWithAggregatesFilter<"users"> | string | null
    state?: IntWithAggregatesFilter<"users"> | number
    coins?: IntNullableWithAggregatesFilter<"users"> | number | null
    id?: BigIntWithAggregatesFilter<"users"> | bigint | number
    site_lang?: StringNullableWithAggregatesFilter<"users"> | string | null
    profile_css?: StringWithAggregatesFilter<"users"> | string
    vote_reminders?: BigIntNullableListFilter<"users">
    vote_reminder_channel?: BigIntNullableWithAggregatesFilter<"users"> | bigint | number | null
    staff_verify_code?: StringNullableWithAggregatesFilter<"users"> | string | null
    vote_reminders_last_acked?: DateTimeWithAggregatesFilter<"users"> | Date | string
    vote_reminders_servers?: BigIntNullableListFilter<"users">
    vote_reminders_servers_last_acked?: DateTimeWithAggregatesFilter<"users"> | Date | string
    vote_reminder_servers_channel?: BigIntNullableWithAggregatesFilter<"users"> | bigint | number | null
    experiments?: IntNullableListFilter<"users">
    flags?: IntNullableListFilter<"users">
    extra_links?: JsonWithAggregatesFilter<"users">
    supabase_id?: UuidNullableWithAggregatesFilter<"users"> | string | null
    totp_shared_key?: StringNullableWithAggregatesFilter<"users"> | string | null
    staff_password?: StringNullableWithAggregatesFilter<"users"> | string | null
    lynxtag?: UuidWithAggregatesFilter<"users"> | string
  }

  export type vanityWhereInput = {
    AND?: vanityWhereInput | vanityWhereInput[]
    OR?: vanityWhereInput[]
    NOT?: vanityWhereInput | vanityWhereInput[]
    type?: IntNullableFilter<"vanity"> | number | null
    vanity_url?: StringNullableFilter<"vanity"> | string | null
    redirect?: BigIntNullableFilter<"vanity"> | bigint | number | null
    lynxtag?: UuidFilter<"vanity"> | string
  }

  export type vanityOrderByWithRelationInput = {
    type?: SortOrderInput | SortOrder
    vanity_url?: SortOrderInput | SortOrder
    redirect?: SortOrderInput | SortOrder
    lynxtag?: SortOrder
  }

  export type vanityWhereUniqueInput = Prisma.AtLeast<{
    vanity_url?: string
    redirect?: bigint | number
    lynxtag?: string
    AND?: vanityWhereInput | vanityWhereInput[]
    OR?: vanityWhereInput[]
    NOT?: vanityWhereInput | vanityWhereInput[]
    type?: IntNullableFilter<"vanity"> | number | null
  }, "vanity_url" | "redirect" | "lynxtag">

  export type vanityOrderByWithAggregationInput = {
    type?: SortOrderInput | SortOrder
    vanity_url?: SortOrderInput | SortOrder
    redirect?: SortOrderInput | SortOrder
    lynxtag?: SortOrder
    _count?: vanityCountOrderByAggregateInput
    _avg?: vanityAvgOrderByAggregateInput
    _max?: vanityMaxOrderByAggregateInput
    _min?: vanityMinOrderByAggregateInput
    _sum?: vanitySumOrderByAggregateInput
  }

  export type vanityScalarWhereWithAggregatesInput = {
    AND?: vanityScalarWhereWithAggregatesInput | vanityScalarWhereWithAggregatesInput[]
    OR?: vanityScalarWhereWithAggregatesInput[]
    NOT?: vanityScalarWhereWithAggregatesInput | vanityScalarWhereWithAggregatesInput[]
    type?: IntNullableWithAggregatesFilter<"vanity"> | number | null
    vanity_url?: StringNullableWithAggregatesFilter<"vanity"> | string | null
    redirect?: BigIntNullableWithAggregatesFilter<"vanity"> | bigint | number | null
    lynxtag?: UuidWithAggregatesFilter<"vanity"> | string
  }

  export type ws_eventsWhereInput = {
    AND?: ws_eventsWhereInput | ws_eventsWhereInput[]
    OR?: ws_eventsWhereInput[]
    NOT?: ws_eventsWhereInput | ws_eventsWhereInput[]
    id?: BigIntFilter<"ws_events"> | bigint | number
    type?: StringFilter<"ws_events"> | string
    ts?: DateTimeFilter<"ws_events"> | Date | string
    event?: JsonFilter<"ws_events">
    lynxtag?: UuidFilter<"ws_events"> | string
  }

  export type ws_eventsOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    ts?: SortOrder
    event?: SortOrder
    lynxtag?: SortOrder
  }

  export type ws_eventsWhereUniqueInput = Prisma.AtLeast<{
    lynxtag?: string
    AND?: ws_eventsWhereInput | ws_eventsWhereInput[]
    OR?: ws_eventsWhereInput[]
    NOT?: ws_eventsWhereInput | ws_eventsWhereInput[]
    id?: BigIntFilter<"ws_events"> | bigint | number
    type?: StringFilter<"ws_events"> | string
    ts?: DateTimeFilter<"ws_events"> | Date | string
    event?: JsonFilter<"ws_events">
  }, "lynxtag">

  export type ws_eventsOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    ts?: SortOrder
    event?: SortOrder
    lynxtag?: SortOrder
    _count?: ws_eventsCountOrderByAggregateInput
    _avg?: ws_eventsAvgOrderByAggregateInput
    _max?: ws_eventsMaxOrderByAggregateInput
    _min?: ws_eventsMinOrderByAggregateInput
    _sum?: ws_eventsSumOrderByAggregateInput
  }

  export type ws_eventsScalarWhereWithAggregatesInput = {
    AND?: ws_eventsScalarWhereWithAggregatesInput | ws_eventsScalarWhereWithAggregatesInput[]
    OR?: ws_eventsScalarWhereWithAggregatesInput[]
    NOT?: ws_eventsScalarWhereWithAggregatesInput | ws_eventsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"ws_events"> | bigint | number
    type?: StringWithAggregatesFilter<"ws_events"> | string
    ts?: DateTimeWithAggregatesFilter<"ws_events"> | Date | string
    event?: JsonWithAggregatesFilter<"ws_events">
    lynxtag?: UuidWithAggregatesFilter<"ws_events"> | string
  }

  export type bot_commandsCreateInput = {
    id?: string
    cmd_type: number
    groups?: bot_commandsCreategroupsInput | string[]
    name: string
    vote_locked?: boolean
    description: string
    args?: bot_commandsCreateargsInput | string[]
    examples?: bot_commandsCreateexamplesInput | string[]
    premium_only?: boolean
    notes?: bot_commandsCreatenotesInput | string[]
    doc_link?: string | null
    nsfw?: boolean | null
    lynxtag?: string
    bots: botsCreateNestedOneWithoutBot_commandsInput
  }

  export type bot_commandsUncheckedCreateInput = {
    id?: string
    bot_id: bigint | number
    cmd_type: number
    groups?: bot_commandsCreategroupsInput | string[]
    name: string
    vote_locked?: boolean
    description: string
    args?: bot_commandsCreateargsInput | string[]
    examples?: bot_commandsCreateexamplesInput | string[]
    premium_only?: boolean
    notes?: bot_commandsCreatenotesInput | string[]
    doc_link?: string | null
    nsfw?: boolean | null
    lynxtag?: string
  }

  export type bot_commandsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cmd_type?: IntFieldUpdateOperationsInput | number
    groups?: bot_commandsUpdategroupsInput | string[]
    name?: StringFieldUpdateOperationsInput | string
    vote_locked?: BoolFieldUpdateOperationsInput | boolean
    description?: StringFieldUpdateOperationsInput | string
    args?: bot_commandsUpdateargsInput | string[]
    examples?: bot_commandsUpdateexamplesInput | string[]
    premium_only?: BoolFieldUpdateOperationsInput | boolean
    notes?: bot_commandsUpdatenotesInput | string[]
    doc_link?: NullableStringFieldUpdateOperationsInput | string | null
    nsfw?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lynxtag?: StringFieldUpdateOperationsInput | string
    bots?: botsUpdateOneRequiredWithoutBot_commandsNestedInput
  }

  export type bot_commandsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bot_id?: BigIntFieldUpdateOperationsInput | bigint | number
    cmd_type?: IntFieldUpdateOperationsInput | number
    groups?: bot_commandsUpdategroupsInput | string[]
    name?: StringFieldUpdateOperationsInput | string
    vote_locked?: BoolFieldUpdateOperationsInput | boolean
    description?: StringFieldUpdateOperationsInput | string
    args?: bot_commandsUpdateargsInput | string[]
    examples?: bot_commandsUpdateexamplesInput | string[]
    premium_only?: BoolFieldUpdateOperationsInput | boolean
    notes?: bot_commandsUpdatenotesInput | string[]
    doc_link?: NullableStringFieldUpdateOperationsInput | string | null
    nsfw?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type bot_commandsCreateManyInput = {
    id?: string
    bot_id: bigint | number
    cmd_type: number
    groups?: bot_commandsCreategroupsInput | string[]
    name: string
    vote_locked?: boolean
    description: string
    args?: bot_commandsCreateargsInput | string[]
    examples?: bot_commandsCreateexamplesInput | string[]
    premium_only?: boolean
    notes?: bot_commandsCreatenotesInput | string[]
    doc_link?: string | null
    nsfw?: boolean | null
    lynxtag?: string
  }

  export type bot_commandsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    cmd_type?: IntFieldUpdateOperationsInput | number
    groups?: bot_commandsUpdategroupsInput | string[]
    name?: StringFieldUpdateOperationsInput | string
    vote_locked?: BoolFieldUpdateOperationsInput | boolean
    description?: StringFieldUpdateOperationsInput | string
    args?: bot_commandsUpdateargsInput | string[]
    examples?: bot_commandsUpdateexamplesInput | string[]
    premium_only?: BoolFieldUpdateOperationsInput | boolean
    notes?: bot_commandsUpdatenotesInput | string[]
    doc_link?: NullableStringFieldUpdateOperationsInput | string | null
    nsfw?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type bot_commandsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bot_id?: BigIntFieldUpdateOperationsInput | bigint | number
    cmd_type?: IntFieldUpdateOperationsInput | number
    groups?: bot_commandsUpdategroupsInput | string[]
    name?: StringFieldUpdateOperationsInput | string
    vote_locked?: BoolFieldUpdateOperationsInput | boolean
    description?: StringFieldUpdateOperationsInput | string
    args?: bot_commandsUpdateargsInput | string[]
    examples?: bot_commandsUpdateexamplesInput | string[]
    premium_only?: BoolFieldUpdateOperationsInput | boolean
    notes?: bot_commandsUpdatenotesInput | string[]
    doc_link?: NullableStringFieldUpdateOperationsInput | string | null
    nsfw?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type bot_eventsCreateInput = {
    event_type: number
    ts?: Date | string
    reason: string
    css?: string
    id?: string
    lynxtag?: string
    bots: botsCreateNestedOneWithoutBot_eventsInput
  }

  export type bot_eventsUncheckedCreateInput = {
    bot_id: bigint | number
    event_type: number
    ts?: Date | string
    reason: string
    css?: string
    id?: string
    lynxtag?: string
  }

  export type bot_eventsUpdateInput = {
    event_type?: IntFieldUpdateOperationsInput | number
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: StringFieldUpdateOperationsInput | string
    css?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
    lynxtag?: StringFieldUpdateOperationsInput | string
    bots?: botsUpdateOneRequiredWithoutBot_eventsNestedInput
  }

  export type bot_eventsUncheckedUpdateInput = {
    bot_id?: BigIntFieldUpdateOperationsInput | bigint | number
    event_type?: IntFieldUpdateOperationsInput | number
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: StringFieldUpdateOperationsInput | string
    css?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type bot_eventsCreateManyInput = {
    bot_id: bigint | number
    event_type: number
    ts?: Date | string
    reason: string
    css?: string
    id?: string
    lynxtag?: string
  }

  export type bot_eventsUpdateManyMutationInput = {
    event_type?: IntFieldUpdateOperationsInput | number
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: StringFieldUpdateOperationsInput | string
    css?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type bot_eventsUncheckedUpdateManyInput = {
    bot_id?: BigIntFieldUpdateOperationsInput | bigint | number
    event_type?: IntFieldUpdateOperationsInput | number
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: StringFieldUpdateOperationsInput | string
    css?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type bot_list_featureCreateInput = {
    feature_id: number
    name: string
    iname: string
    description?: string | null
    positive?: number | null
    lynxtag?: string
  }

  export type bot_list_featureUncheckedCreateInput = {
    feature_id: number
    name: string
    iname: string
    description?: string | null
    positive?: number | null
    lynxtag?: string
  }

  export type bot_list_featureUpdateInput = {
    feature_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    iname?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    positive?: NullableIntFieldUpdateOperationsInput | number | null
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type bot_list_featureUncheckedUpdateInput = {
    feature_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    iname?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    positive?: NullableIntFieldUpdateOperationsInput | number | null
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type bot_list_featureCreateManyInput = {
    feature_id: number
    name: string
    iname: string
    description?: string | null
    positive?: number | null
    lynxtag?: string
  }

  export type bot_list_featureUpdateManyMutationInput = {
    feature_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    iname?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    positive?: NullableIntFieldUpdateOperationsInput | number | null
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type bot_list_featureUncheckedUpdateManyInput = {
    feature_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    iname?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    positive?: NullableIntFieldUpdateOperationsInput | number | null
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type bot_list_tagsCreateInput = {
    id: string
    icon: string
    lynxtag?: string
    bot_tags?: bot_tagsCreateNestedManyWithoutBot_list_tagsInput
  }

  export type bot_list_tagsUncheckedCreateInput = {
    id: string
    icon: string
    lynxtag?: string
    bot_tags?: bot_tagsUncheckedCreateNestedManyWithoutBot_list_tagsInput
  }

  export type bot_list_tagsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    lynxtag?: StringFieldUpdateOperationsInput | string
    bot_tags?: bot_tagsUpdateManyWithoutBot_list_tagsNestedInput
  }

  export type bot_list_tagsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    lynxtag?: StringFieldUpdateOperationsInput | string
    bot_tags?: bot_tagsUncheckedUpdateManyWithoutBot_list_tagsNestedInput
  }

  export type bot_list_tagsCreateManyInput = {
    id: string
    icon: string
    lynxtag?: string
  }

  export type bot_list_tagsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type bot_list_tagsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type bot_ownerCreateInput = {
    owner: bigint | number
    main?: boolean | null
    id?: number
    lynxtag?: string
    bots: botsCreateNestedOneWithoutBot_ownerInput
  }

  export type bot_ownerUncheckedCreateInput = {
    bot_id: bigint | number
    owner: bigint | number
    main?: boolean | null
    id?: number
    lynxtag?: string
  }

  export type bot_ownerUpdateInput = {
    owner?: BigIntFieldUpdateOperationsInput | bigint | number
    main?: NullableBoolFieldUpdateOperationsInput | boolean | null
    id?: IntFieldUpdateOperationsInput | number
    lynxtag?: StringFieldUpdateOperationsInput | string
    bots?: botsUpdateOneRequiredWithoutBot_ownerNestedInput
  }

  export type bot_ownerUncheckedUpdateInput = {
    bot_id?: BigIntFieldUpdateOperationsInput | bigint | number
    owner?: BigIntFieldUpdateOperationsInput | bigint | number
    main?: NullableBoolFieldUpdateOperationsInput | boolean | null
    id?: IntFieldUpdateOperationsInput | number
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type bot_ownerCreateManyInput = {
    bot_id: bigint | number
    owner: bigint | number
    main?: boolean | null
    id?: number
    lynxtag?: string
  }

  export type bot_ownerUpdateManyMutationInput = {
    owner?: BigIntFieldUpdateOperationsInput | bigint | number
    main?: NullableBoolFieldUpdateOperationsInput | boolean | null
    id?: IntFieldUpdateOperationsInput | number
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type bot_ownerUncheckedUpdateManyInput = {
    bot_id?: BigIntFieldUpdateOperationsInput | bigint | number
    owner?: BigIntFieldUpdateOperationsInput | bigint | number
    main?: NullableBoolFieldUpdateOperationsInput | boolean | null
    id?: IntFieldUpdateOperationsInput | number
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type bot_packsCreateInput = {
    id?: string
    icon?: string | null
    banner?: string | null
    owner: bigint | number
    bots?: bot_packsCreatebotsInput | bigint[] | number[]
    description: string
    name: string
    created_at?: Date | string | null
    lynxtag?: string
  }

  export type bot_packsUncheckedCreateInput = {
    id?: string
    icon?: string | null
    banner?: string | null
    owner: bigint | number
    bots?: bot_packsCreatebotsInput | bigint[] | number[]
    description: string
    name: string
    created_at?: Date | string | null
    lynxtag?: string
  }

  export type bot_packsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    owner?: BigIntFieldUpdateOperationsInput | bigint | number
    bots?: bot_packsUpdatebotsInput | bigint[] | number[]
    description?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type bot_packsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    owner?: BigIntFieldUpdateOperationsInput | bigint | number
    bots?: bot_packsUpdatebotsInput | bigint[] | number[]
    description?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type bot_packsCreateManyInput = {
    id?: string
    icon?: string | null
    banner?: string | null
    owner: bigint | number
    bots?: bot_packsCreatebotsInput | bigint[] | number[]
    description: string
    name: string
    created_at?: Date | string | null
    lynxtag?: string
  }

  export type bot_packsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    owner?: BigIntFieldUpdateOperationsInput | bigint | number
    bots?: bot_packsUpdatebotsInput | bigint[] | number[]
    description?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type bot_packsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    owner?: BigIntFieldUpdateOperationsInput | bigint | number
    bots?: bot_packsUpdatebotsInput | bigint[] | number[]
    description?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type bot_promotionsCreateInput = {
    id?: string
    title?: string | null
    info?: string | null
    css?: string | null
    type?: number | null
    lynxtag?: string
    bots?: botsCreateNestedOneWithoutBot_promotionsInput
  }

  export type bot_promotionsUncheckedCreateInput = {
    id?: string
    bot_id?: bigint | number | null
    title?: string | null
    info?: string | null
    css?: string | null
    type?: number | null
    lynxtag?: string
  }

  export type bot_promotionsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    info?: NullableStringFieldUpdateOperationsInput | string | null
    css?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    lynxtag?: StringFieldUpdateOperationsInput | string
    bots?: botsUpdateOneWithoutBot_promotionsNestedInput
  }

  export type bot_promotionsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bot_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    info?: NullableStringFieldUpdateOperationsInput | string | null
    css?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type bot_promotionsCreateManyInput = {
    id?: string
    bot_id?: bigint | number | null
    title?: string | null
    info?: string | null
    css?: string | null
    type?: number | null
    lynxtag?: string
  }

  export type bot_promotionsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    info?: NullableStringFieldUpdateOperationsInput | string | null
    css?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type bot_promotionsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bot_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    info?: NullableStringFieldUpdateOperationsInput | string | null
    css?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type bot_stats_votes_pmCreateInput = {
    bot_id?: bigint | number | null
    votes?: bigint | number | null
    epoch?: bigint | number | null
    lynxtag?: string
  }

  export type bot_stats_votes_pmUncheckedCreateInput = {
    bot_id?: bigint | number | null
    votes?: bigint | number | null
    epoch?: bigint | number | null
    lynxtag?: string
  }

  export type bot_stats_votes_pmUpdateInput = {
    bot_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    votes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    epoch?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type bot_stats_votes_pmUncheckedUpdateInput = {
    bot_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    votes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    epoch?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type bot_stats_votes_pmCreateManyInput = {
    bot_id?: bigint | number | null
    votes?: bigint | number | null
    epoch?: bigint | number | null
    lynxtag?: string
  }

  export type bot_stats_votes_pmUpdateManyMutationInput = {
    bot_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    votes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    epoch?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type bot_stats_votes_pmUncheckedUpdateManyInput = {
    bot_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    votes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    epoch?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type bot_tagsCreateInput = {
    id?: number
    lynxtag?: string
    bots: botsCreateNestedOneWithoutBot_tagsInput
    bot_list_tags: bot_list_tagsCreateNestedOneWithoutBot_tagsInput
  }

  export type bot_tagsUncheckedCreateInput = {
    bot_id: bigint | number
    tag: string
    id?: number
    lynxtag?: string
  }

  export type bot_tagsUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    lynxtag?: StringFieldUpdateOperationsInput | string
    bots?: botsUpdateOneRequiredWithoutBot_tagsNestedInput
    bot_list_tags?: bot_list_tagsUpdateOneRequiredWithoutBot_tagsNestedInput
  }

  export type bot_tagsUncheckedUpdateInput = {
    bot_id?: BigIntFieldUpdateOperationsInput | bigint | number
    tag?: StringFieldUpdateOperationsInput | string
    id?: IntFieldUpdateOperationsInput | number
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type bot_tagsCreateManyInput = {
    bot_id: bigint | number
    tag: string
    id?: number
    lynxtag?: string
  }

  export type bot_tagsUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type bot_tagsUncheckedUpdateManyInput = {
    bot_id?: BigIntFieldUpdateOperationsInput | bigint | number
    tag?: StringFieldUpdateOperationsInput | string
    id?: IntFieldUpdateOperationsInput | number
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type bot_votersCreateInput = {
    bot_id: bigint | number
    timestamps?: bot_votersCreatetimestampsInput | Date[] | string[]
    lynxtag?: string
    users: usersCreateNestedOneWithoutBot_votersInput
  }

  export type bot_votersUncheckedCreateInput = {
    bot_id: bigint | number
    user_id: bigint | number
    timestamps?: bot_votersCreatetimestampsInput | Date[] | string[]
    lynxtag?: string
  }

  export type bot_votersUpdateInput = {
    bot_id?: BigIntFieldUpdateOperationsInput | bigint | number
    timestamps?: bot_votersUpdatetimestampsInput | Date[] | string[]
    lynxtag?: StringFieldUpdateOperationsInput | string
    users?: usersUpdateOneRequiredWithoutBot_votersNestedInput
  }

  export type bot_votersUncheckedUpdateInput = {
    bot_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    timestamps?: bot_votersUpdatetimestampsInput | Date[] | string[]
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type bot_votersCreateManyInput = {
    bot_id: bigint | number
    user_id: bigint | number
    timestamps?: bot_votersCreatetimestampsInput | Date[] | string[]
    lynxtag?: string
  }

  export type bot_votersUpdateManyMutationInput = {
    bot_id?: BigIntFieldUpdateOperationsInput | bigint | number
    timestamps?: bot_votersUpdatetimestampsInput | Date[] | string[]
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type bot_votersUncheckedUpdateManyInput = {
    bot_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    timestamps?: bot_votersUpdatetimestampsInput | Date[] | string[]
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type botsCreateInput = {
    bot_id: bigint | number
    votes?: bigint | number | null
    guild_count?: bigint | number | null
    shard_count?: bigint | number | null
    bot_library?: string | null
    webhook?: string | null
    description: string
    long_description: string
    prefix?: string | null
    api_token?: string | null
    banner_card?: string | null
    created_at?: Date | string
    invite?: string
    features?: botsCreatefeaturesInput | string[]
    invite_amount?: number | null
    user_count?: bigint | number | null
    css?: string | null
    shards?: botsCreateshardsInput | number[]
    username_cached?: string
    state?: number
    long_description_type: number
    verifier?: bigint | number | null
    last_stats_post?: Date | string
    webhook_secret?: string | null
    webhook_type?: number | null
    di_text?: string | null
    id: bigint | number
    banner_page?: string | null
    total_votes?: bigint | number | null
    client_id?: bigint | number | null
    flags?: botsCreateflagsInput | number[]
    uptime_checks_total?: number | null
    uptime_checks_failed?: number | null
    page_style?: number
    webhook_hmac_only?: boolean | null
    last_updated_at?: Date | string
    avatar_cached?: string
    disc_cached?: string
    extra_links?: JsonNullValueInput | InputJsonValue
    lynxtag?: string
    bot_commands?: bot_commandsCreateNestedManyWithoutBotsInput
    bot_events?: bot_eventsCreateNestedManyWithoutBotsInput
    bot_owner?: bot_ownerCreateNestedManyWithoutBotsInput
    bot_promotions?: bot_promotionsCreateNestedManyWithoutBotsInput
    bot_tags?: bot_tagsCreateNestedManyWithoutBotsInput
  }

  export type botsUncheckedCreateInput = {
    bot_id: bigint | number
    votes?: bigint | number | null
    guild_count?: bigint | number | null
    shard_count?: bigint | number | null
    bot_library?: string | null
    webhook?: string | null
    description: string
    long_description: string
    prefix?: string | null
    api_token?: string | null
    banner_card?: string | null
    created_at?: Date | string
    invite?: string
    features?: botsCreatefeaturesInput | string[]
    invite_amount?: number | null
    user_count?: bigint | number | null
    css?: string | null
    shards?: botsCreateshardsInput | number[]
    username_cached?: string
    state?: number
    long_description_type: number
    verifier?: bigint | number | null
    last_stats_post?: Date | string
    webhook_secret?: string | null
    webhook_type?: number | null
    di_text?: string | null
    id: bigint | number
    banner_page?: string | null
    total_votes?: bigint | number | null
    client_id?: bigint | number | null
    flags?: botsCreateflagsInput | number[]
    uptime_checks_total?: number | null
    uptime_checks_failed?: number | null
    page_style?: number
    webhook_hmac_only?: boolean | null
    last_updated_at?: Date | string
    avatar_cached?: string
    disc_cached?: string
    extra_links?: JsonNullValueInput | InputJsonValue
    lynxtag?: string
    bot_commands?: bot_commandsUncheckedCreateNestedManyWithoutBotsInput
    bot_events?: bot_eventsUncheckedCreateNestedManyWithoutBotsInput
    bot_owner?: bot_ownerUncheckedCreateNestedManyWithoutBotsInput
    bot_promotions?: bot_promotionsUncheckedCreateNestedManyWithoutBotsInput
    bot_tags?: bot_tagsUncheckedCreateNestedManyWithoutBotsInput
  }

  export type botsUpdateInput = {
    bot_id?: BigIntFieldUpdateOperationsInput | bigint | number
    votes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    guild_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    shard_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    bot_library?: NullableStringFieldUpdateOperationsInput | string | null
    webhook?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    long_description?: StringFieldUpdateOperationsInput | string
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    api_token?: NullableStringFieldUpdateOperationsInput | string | null
    banner_card?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    invite?: StringFieldUpdateOperationsInput | string
    features?: botsUpdatefeaturesInput | string[]
    invite_amount?: NullableIntFieldUpdateOperationsInput | number | null
    user_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    css?: NullableStringFieldUpdateOperationsInput | string | null
    shards?: botsUpdateshardsInput | number[]
    username_cached?: StringFieldUpdateOperationsInput | string
    state?: IntFieldUpdateOperationsInput | number
    long_description_type?: IntFieldUpdateOperationsInput | number
    verifier?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    last_stats_post?: DateTimeFieldUpdateOperationsInput | Date | string
    webhook_secret?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_type?: NullableIntFieldUpdateOperationsInput | number | null
    di_text?: NullableStringFieldUpdateOperationsInput | string | null
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    banner_page?: NullableStringFieldUpdateOperationsInput | string | null
    total_votes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    client_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    flags?: botsUpdateflagsInput | number[]
    uptime_checks_total?: NullableIntFieldUpdateOperationsInput | number | null
    uptime_checks_failed?: NullableIntFieldUpdateOperationsInput | number | null
    page_style?: IntFieldUpdateOperationsInput | number
    webhook_hmac_only?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar_cached?: StringFieldUpdateOperationsInput | string
    disc_cached?: StringFieldUpdateOperationsInput | string
    extra_links?: JsonNullValueInput | InputJsonValue
    lynxtag?: StringFieldUpdateOperationsInput | string
    bot_commands?: bot_commandsUpdateManyWithoutBotsNestedInput
    bot_events?: bot_eventsUpdateManyWithoutBotsNestedInput
    bot_owner?: bot_ownerUpdateManyWithoutBotsNestedInput
    bot_promotions?: bot_promotionsUpdateManyWithoutBotsNestedInput
    bot_tags?: bot_tagsUpdateManyWithoutBotsNestedInput
  }

  export type botsUncheckedUpdateInput = {
    bot_id?: BigIntFieldUpdateOperationsInput | bigint | number
    votes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    guild_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    shard_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    bot_library?: NullableStringFieldUpdateOperationsInput | string | null
    webhook?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    long_description?: StringFieldUpdateOperationsInput | string
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    api_token?: NullableStringFieldUpdateOperationsInput | string | null
    banner_card?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    invite?: StringFieldUpdateOperationsInput | string
    features?: botsUpdatefeaturesInput | string[]
    invite_amount?: NullableIntFieldUpdateOperationsInput | number | null
    user_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    css?: NullableStringFieldUpdateOperationsInput | string | null
    shards?: botsUpdateshardsInput | number[]
    username_cached?: StringFieldUpdateOperationsInput | string
    state?: IntFieldUpdateOperationsInput | number
    long_description_type?: IntFieldUpdateOperationsInput | number
    verifier?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    last_stats_post?: DateTimeFieldUpdateOperationsInput | Date | string
    webhook_secret?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_type?: NullableIntFieldUpdateOperationsInput | number | null
    di_text?: NullableStringFieldUpdateOperationsInput | string | null
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    banner_page?: NullableStringFieldUpdateOperationsInput | string | null
    total_votes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    client_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    flags?: botsUpdateflagsInput | number[]
    uptime_checks_total?: NullableIntFieldUpdateOperationsInput | number | null
    uptime_checks_failed?: NullableIntFieldUpdateOperationsInput | number | null
    page_style?: IntFieldUpdateOperationsInput | number
    webhook_hmac_only?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar_cached?: StringFieldUpdateOperationsInput | string
    disc_cached?: StringFieldUpdateOperationsInput | string
    extra_links?: JsonNullValueInput | InputJsonValue
    lynxtag?: StringFieldUpdateOperationsInput | string
    bot_commands?: bot_commandsUncheckedUpdateManyWithoutBotsNestedInput
    bot_events?: bot_eventsUncheckedUpdateManyWithoutBotsNestedInput
    bot_owner?: bot_ownerUncheckedUpdateManyWithoutBotsNestedInput
    bot_promotions?: bot_promotionsUncheckedUpdateManyWithoutBotsNestedInput
    bot_tags?: bot_tagsUncheckedUpdateManyWithoutBotsNestedInput
  }

  export type botsCreateManyInput = {
    bot_id: bigint | number
    votes?: bigint | number | null
    guild_count?: bigint | number | null
    shard_count?: bigint | number | null
    bot_library?: string | null
    webhook?: string | null
    description: string
    long_description: string
    prefix?: string | null
    api_token?: string | null
    banner_card?: string | null
    created_at?: Date | string
    invite?: string
    features?: botsCreatefeaturesInput | string[]
    invite_amount?: number | null
    user_count?: bigint | number | null
    css?: string | null
    shards?: botsCreateshardsInput | number[]
    username_cached?: string
    state?: number
    long_description_type: number
    verifier?: bigint | number | null
    last_stats_post?: Date | string
    webhook_secret?: string | null
    webhook_type?: number | null
    di_text?: string | null
    id: bigint | number
    banner_page?: string | null
    total_votes?: bigint | number | null
    client_id?: bigint | number | null
    flags?: botsCreateflagsInput | number[]
    uptime_checks_total?: number | null
    uptime_checks_failed?: number | null
    page_style?: number
    webhook_hmac_only?: boolean | null
    last_updated_at?: Date | string
    avatar_cached?: string
    disc_cached?: string
    extra_links?: JsonNullValueInput | InputJsonValue
    lynxtag?: string
  }

  export type botsUpdateManyMutationInput = {
    bot_id?: BigIntFieldUpdateOperationsInput | bigint | number
    votes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    guild_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    shard_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    bot_library?: NullableStringFieldUpdateOperationsInput | string | null
    webhook?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    long_description?: StringFieldUpdateOperationsInput | string
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    api_token?: NullableStringFieldUpdateOperationsInput | string | null
    banner_card?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    invite?: StringFieldUpdateOperationsInput | string
    features?: botsUpdatefeaturesInput | string[]
    invite_amount?: NullableIntFieldUpdateOperationsInput | number | null
    user_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    css?: NullableStringFieldUpdateOperationsInput | string | null
    shards?: botsUpdateshardsInput | number[]
    username_cached?: StringFieldUpdateOperationsInput | string
    state?: IntFieldUpdateOperationsInput | number
    long_description_type?: IntFieldUpdateOperationsInput | number
    verifier?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    last_stats_post?: DateTimeFieldUpdateOperationsInput | Date | string
    webhook_secret?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_type?: NullableIntFieldUpdateOperationsInput | number | null
    di_text?: NullableStringFieldUpdateOperationsInput | string | null
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    banner_page?: NullableStringFieldUpdateOperationsInput | string | null
    total_votes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    client_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    flags?: botsUpdateflagsInput | number[]
    uptime_checks_total?: NullableIntFieldUpdateOperationsInput | number | null
    uptime_checks_failed?: NullableIntFieldUpdateOperationsInput | number | null
    page_style?: IntFieldUpdateOperationsInput | number
    webhook_hmac_only?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar_cached?: StringFieldUpdateOperationsInput | string
    disc_cached?: StringFieldUpdateOperationsInput | string
    extra_links?: JsonNullValueInput | InputJsonValue
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type botsUncheckedUpdateManyInput = {
    bot_id?: BigIntFieldUpdateOperationsInput | bigint | number
    votes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    guild_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    shard_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    bot_library?: NullableStringFieldUpdateOperationsInput | string | null
    webhook?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    long_description?: StringFieldUpdateOperationsInput | string
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    api_token?: NullableStringFieldUpdateOperationsInput | string | null
    banner_card?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    invite?: StringFieldUpdateOperationsInput | string
    features?: botsUpdatefeaturesInput | string[]
    invite_amount?: NullableIntFieldUpdateOperationsInput | number | null
    user_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    css?: NullableStringFieldUpdateOperationsInput | string | null
    shards?: botsUpdateshardsInput | number[]
    username_cached?: StringFieldUpdateOperationsInput | string
    state?: IntFieldUpdateOperationsInput | number
    long_description_type?: IntFieldUpdateOperationsInput | number
    verifier?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    last_stats_post?: DateTimeFieldUpdateOperationsInput | Date | string
    webhook_secret?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_type?: NullableIntFieldUpdateOperationsInput | number | null
    di_text?: NullableStringFieldUpdateOperationsInput | string | null
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    banner_page?: NullableStringFieldUpdateOperationsInput | string | null
    total_votes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    client_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    flags?: botsUpdateflagsInput | number[]
    uptime_checks_total?: NullableIntFieldUpdateOperationsInput | number | null
    uptime_checks_failed?: NullableIntFieldUpdateOperationsInput | number | null
    page_style?: IntFieldUpdateOperationsInput | number
    webhook_hmac_only?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar_cached?: StringFieldUpdateOperationsInput | string
    disc_cached?: StringFieldUpdateOperationsInput | string
    extra_links?: JsonNullValueInput | InputJsonValue
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type extra_dataCreateInput = {
    name?: string | null
    value?: NullableJsonNullValueInput | InputJsonValue
    lynxtag?: string
    users?: usersCreateNestedOneWithoutExtra_dataInput
  }

  export type extra_dataUncheckedCreateInput = {
    name?: string | null
    value?: NullableJsonNullValueInput | InputJsonValue
    user_id?: bigint | number | null
    lynxtag?: string
  }

  export type extra_dataUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableJsonNullValueInput | InputJsonValue
    lynxtag?: StringFieldUpdateOperationsInput | string
    users?: usersUpdateOneWithoutExtra_dataNestedInput
  }

  export type extra_dataUncheckedUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableJsonNullValueInput | InputJsonValue
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type extra_dataCreateManyInput = {
    name?: string | null
    value?: NullableJsonNullValueInput | InputJsonValue
    user_id?: bigint | number | null
    lynxtag?: string
  }

  export type extra_dataUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableJsonNullValueInput | InputJsonValue
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type extra_dataUncheckedUpdateManyInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableJsonNullValueInput | InputJsonValue
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type featuresCreateInput = {
    id: string
    name: string
    description: string
    viewed_as: string
    lynxtag?: string
  }

  export type featuresUncheckedCreateInput = {
    id: string
    name: string
    description: string
    viewed_as: string
    lynxtag?: string
  }

  export type featuresUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    viewed_as?: StringFieldUpdateOperationsInput | string
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type featuresUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    viewed_as?: StringFieldUpdateOperationsInput | string
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type featuresCreateManyInput = {
    id: string
    name: string
    description: string
    viewed_as: string
    lynxtag?: string
  }

  export type featuresUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    viewed_as?: StringFieldUpdateOperationsInput | string
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type featuresUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    viewed_as?: StringFieldUpdateOperationsInput | string
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type frostpaw_clientsCreateInput = {
    id: string
    name: string
    domain: string
    privacy_policy: string
    secret: string
    lynxtag?: string
    verified?: boolean
    users: usersCreateNestedOneWithoutFrostpaw_clientsInput
  }

  export type frostpaw_clientsUncheckedCreateInput = {
    id: string
    name: string
    domain: string
    privacy_policy: string
    secret: string
    owner_id: bigint | number
    lynxtag?: string
    verified?: boolean
  }

  export type frostpaw_clientsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    privacy_policy?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    lynxtag?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    users?: usersUpdateOneRequiredWithoutFrostpaw_clientsNestedInput
  }

  export type frostpaw_clientsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    privacy_policy?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    owner_id?: BigIntFieldUpdateOperationsInput | bigint | number
    lynxtag?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type frostpaw_clientsCreateManyInput = {
    id: string
    name: string
    domain: string
    privacy_policy: string
    secret: string
    owner_id: bigint | number
    lynxtag?: string
    verified?: boolean
  }

  export type frostpaw_clientsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    privacy_policy?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    lynxtag?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type frostpaw_clientsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    privacy_policy?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    owner_id?: BigIntFieldUpdateOperationsInput | bigint | number
    lynxtag?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type leave_of_absenceCreateInput = {
    reason?: string | null
    start_date?: Date | string | null
    id?: number
    lynxtag?: string
    users?: usersCreateNestedOneWithoutLeave_of_absenceInput
  }

  export type leave_of_absenceUncheckedCreateInput = {
    reason?: string | null
    start_date?: Date | string | null
    user_id?: bigint | number | null
    id?: number
    lynxtag?: string
  }

  export type leave_of_absenceUpdateInput = {
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id?: IntFieldUpdateOperationsInput | number
    lynxtag?: StringFieldUpdateOperationsInput | string
    users?: usersUpdateOneWithoutLeave_of_absenceNestedInput
  }

  export type leave_of_absenceUncheckedUpdateInput = {
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    id?: IntFieldUpdateOperationsInput | number
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type leave_of_absenceCreateManyInput = {
    reason?: string | null
    start_date?: Date | string | null
    user_id?: bigint | number | null
    id?: number
    lynxtag?: string
  }

  export type leave_of_absenceUpdateManyMutationInput = {
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id?: IntFieldUpdateOperationsInput | number
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type leave_of_absenceUncheckedUpdateManyInput = {
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    id?: IntFieldUpdateOperationsInput | number
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type lynx_appsCreateInput = {
    app_id?: string
    questions?: NullableJsonNullValueInput | InputJsonValue
    answers?: NullableJsonNullValueInput | InputJsonValue
    app_version?: number | null
    created_at?: Date | string | null
    lynxtag?: string
    users?: usersCreateNestedOneWithoutLynx_appsInput
  }

  export type lynx_appsUncheckedCreateInput = {
    user_id?: bigint | number | null
    app_id?: string
    questions?: NullableJsonNullValueInput | InputJsonValue
    answers?: NullableJsonNullValueInput | InputJsonValue
    app_version?: number | null
    created_at?: Date | string | null
    lynxtag?: string
  }

  export type lynx_appsUpdateInput = {
    app_id?: StringFieldUpdateOperationsInput | string
    questions?: NullableJsonNullValueInput | InputJsonValue
    answers?: NullableJsonNullValueInput | InputJsonValue
    app_version?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
    users?: usersUpdateOneWithoutLynx_appsNestedInput
  }

  export type lynx_appsUncheckedUpdateInput = {
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    app_id?: StringFieldUpdateOperationsInput | string
    questions?: NullableJsonNullValueInput | InputJsonValue
    answers?: NullableJsonNullValueInput | InputJsonValue
    app_version?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type lynx_appsCreateManyInput = {
    user_id?: bigint | number | null
    app_id?: string
    questions?: NullableJsonNullValueInput | InputJsonValue
    answers?: NullableJsonNullValueInput | InputJsonValue
    app_version?: number | null
    created_at?: Date | string | null
    lynxtag?: string
  }

  export type lynx_appsUpdateManyMutationInput = {
    app_id?: StringFieldUpdateOperationsInput | string
    questions?: NullableJsonNullValueInput | InputJsonValue
    answers?: NullableJsonNullValueInput | InputJsonValue
    app_version?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type lynx_appsUncheckedUpdateManyInput = {
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    app_id?: StringFieldUpdateOperationsInput | string
    questions?: NullableJsonNullValueInput | InputJsonValue
    answers?: NullableJsonNullValueInput | InputJsonValue
    app_version?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type lynx_dataCreateInput = {
    default_user_experiments?: lynx_dataCreatedefault_user_experimentsInput | number[]
    lynxtag?: string
  }

  export type lynx_dataUncheckedCreateInput = {
    default_user_experiments?: lynx_dataCreatedefault_user_experimentsInput | number[]
    id?: number
    lynxtag?: string
  }

  export type lynx_dataUpdateInput = {
    default_user_experiments?: lynx_dataUpdatedefault_user_experimentsInput | number[]
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type lynx_dataUncheckedUpdateInput = {
    default_user_experiments?: lynx_dataUpdatedefault_user_experimentsInput | number[]
    id?: IntFieldUpdateOperationsInput | number
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type lynx_dataCreateManyInput = {
    default_user_experiments?: lynx_dataCreatedefault_user_experimentsInput | number[]
    id?: number
    lynxtag?: string
  }

  export type lynx_dataUpdateManyMutationInput = {
    default_user_experiments?: lynx_dataUpdatedefault_user_experimentsInput | number[]
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type lynx_dataUncheckedUpdateManyInput = {
    default_user_experiments?: lynx_dataUpdatedefault_user_experimentsInput | number[]
    id?: IntFieldUpdateOperationsInput | number
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type lynx_logsCreateInput = {
    method: string
    url: string
    status_code: number
    request_time?: Date | string | null
    lynxtag?: string
    users: usersCreateNestedOneWithoutLynx_logsInput
  }

  export type lynx_logsUncheckedCreateInput = {
    user_id: bigint | number
    method: string
    url: string
    status_code: number
    request_time?: Date | string | null
    lynxtag?: string
  }

  export type lynx_logsUpdateInput = {
    method?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    status_code?: IntFieldUpdateOperationsInput | number
    request_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
    users?: usersUpdateOneRequiredWithoutLynx_logsNestedInput
  }

  export type lynx_logsUncheckedUpdateInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    method?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    status_code?: IntFieldUpdateOperationsInput | number
    request_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type lynx_logsCreateManyInput = {
    user_id: bigint | number
    method: string
    url: string
    status_code: number
    request_time?: Date | string | null
    lynxtag?: string
  }

  export type lynx_logsUpdateManyMutationInput = {
    method?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    status_code?: IntFieldUpdateOperationsInput | number
    request_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type lynx_logsUncheckedUpdateManyInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    method?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    status_code?: IntFieldUpdateOperationsInput | number
    request_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type lynx_notificationsCreateInput = {
    acked_users?: lynx_notificationsCreateacked_usersInput | bigint[] | number[]
    message: string
    type: string
    id?: string
    staff_only?: boolean | null
    lynxtag?: string
  }

  export type lynx_notificationsUncheckedCreateInput = {
    acked_users?: lynx_notificationsCreateacked_usersInput | bigint[] | number[]
    message: string
    type: string
    id?: string
    staff_only?: boolean | null
    lynxtag?: string
  }

  export type lynx_notificationsUpdateInput = {
    acked_users?: lynx_notificationsUpdateacked_usersInput | bigint[] | number[]
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
    staff_only?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type lynx_notificationsUncheckedUpdateInput = {
    acked_users?: lynx_notificationsUpdateacked_usersInput | bigint[] | number[]
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
    staff_only?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type lynx_notificationsCreateManyInput = {
    acked_users?: lynx_notificationsCreateacked_usersInput | bigint[] | number[]
    message: string
    type: string
    id?: string
    staff_only?: boolean | null
    lynxtag?: string
  }

  export type lynx_notificationsUpdateManyMutationInput = {
    acked_users?: lynx_notificationsUpdateacked_usersInput | bigint[] | number[]
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
    staff_only?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type lynx_notificationsUncheckedUpdateManyInput = {
    acked_users?: lynx_notificationsUpdateacked_usersInput | bigint[] | number[]
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
    staff_only?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type lynx_ratingsCreateInput = {
    id?: string
    feedback: string
    username_cached: string
    page: string
    lynxtag?: string
    users?: usersCreateNestedOneWithoutLynx_ratingsInput
  }

  export type lynx_ratingsUncheckedCreateInput = {
    id?: string
    feedback: string
    username_cached: string
    user_id?: bigint | number | null
    page: string
    lynxtag?: string
  }

  export type lynx_ratingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    feedback?: StringFieldUpdateOperationsInput | string
    username_cached?: StringFieldUpdateOperationsInput | string
    page?: StringFieldUpdateOperationsInput | string
    lynxtag?: StringFieldUpdateOperationsInput | string
    users?: usersUpdateOneWithoutLynx_ratingsNestedInput
  }

  export type lynx_ratingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    feedback?: StringFieldUpdateOperationsInput | string
    username_cached?: StringFieldUpdateOperationsInput | string
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    page?: StringFieldUpdateOperationsInput | string
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type lynx_ratingsCreateManyInput = {
    id?: string
    feedback: string
    username_cached: string
    user_id?: bigint | number | null
    page: string
    lynxtag?: string
  }

  export type lynx_ratingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    feedback?: StringFieldUpdateOperationsInput | string
    username_cached?: StringFieldUpdateOperationsInput | string
    page?: StringFieldUpdateOperationsInput | string
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type lynx_ratingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    feedback?: StringFieldUpdateOperationsInput | string
    username_cached?: StringFieldUpdateOperationsInput | string
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    page?: StringFieldUpdateOperationsInput | string
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type lynx_survey_responsesCreateInput = {
    id?: string
    questions: JsonNullValueInput | InputJsonValue
    answers: JsonNullValueInput | InputJsonValue
    username_cached: string
    lynxtag?: string
    lynx_surveys: lynx_surveysCreateNestedOneWithoutLynx_survey_responsesInput
    users?: usersCreateNestedOneWithoutLynx_survey_responsesInput
  }

  export type lynx_survey_responsesUncheckedCreateInput = {
    id?: string
    questions: JsonNullValueInput | InputJsonValue
    answers: JsonNullValueInput | InputJsonValue
    username_cached: string
    user_id?: bigint | number | null
    survey_id: string
    lynxtag?: string
  }

  export type lynx_survey_responsesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    questions?: JsonNullValueInput | InputJsonValue
    answers?: JsonNullValueInput | InputJsonValue
    username_cached?: StringFieldUpdateOperationsInput | string
    lynxtag?: StringFieldUpdateOperationsInput | string
    lynx_surveys?: lynx_surveysUpdateOneRequiredWithoutLynx_survey_responsesNestedInput
    users?: usersUpdateOneWithoutLynx_survey_responsesNestedInput
  }

  export type lynx_survey_responsesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    questions?: JsonNullValueInput | InputJsonValue
    answers?: JsonNullValueInput | InputJsonValue
    username_cached?: StringFieldUpdateOperationsInput | string
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    survey_id?: StringFieldUpdateOperationsInput | string
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type lynx_survey_responsesCreateManyInput = {
    id?: string
    questions: JsonNullValueInput | InputJsonValue
    answers: JsonNullValueInput | InputJsonValue
    username_cached: string
    user_id?: bigint | number | null
    survey_id: string
    lynxtag?: string
  }

  export type lynx_survey_responsesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    questions?: JsonNullValueInput | InputJsonValue
    answers?: JsonNullValueInput | InputJsonValue
    username_cached?: StringFieldUpdateOperationsInput | string
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type lynx_survey_responsesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    questions?: JsonNullValueInput | InputJsonValue
    answers?: JsonNullValueInput | InputJsonValue
    username_cached?: StringFieldUpdateOperationsInput | string
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    survey_id?: StringFieldUpdateOperationsInput | string
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type lynx_surveysCreateInput = {
    id?: string
    title: string
    questions: JsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    lynxtag?: string
    lynx_survey_responses?: lynx_survey_responsesCreateNestedManyWithoutLynx_surveysInput
  }

  export type lynx_surveysUncheckedCreateInput = {
    id?: string
    title: string
    questions: JsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    lynxtag?: string
    lynx_survey_responses?: lynx_survey_responsesUncheckedCreateNestedManyWithoutLynx_surveysInput
  }

  export type lynx_surveysUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    questions?: JsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
    lynx_survey_responses?: lynx_survey_responsesUpdateManyWithoutLynx_surveysNestedInput
  }

  export type lynx_surveysUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    questions?: JsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
    lynx_survey_responses?: lynx_survey_responsesUncheckedUpdateManyWithoutLynx_surveysNestedInput
  }

  export type lynx_surveysCreateManyInput = {
    id?: string
    title: string
    questions: JsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    lynxtag?: string
  }

  export type lynx_surveysUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    questions?: JsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type lynx_surveysUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    questions?: JsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type migrationCreateInput = {
    name?: string
    app_name?: string
    ran_on?: Date | string
    lynxtag?: string
  }

  export type migrationUncheckedCreateInput = {
    id?: number
    name?: string
    app_name?: string
    ran_on?: Date | string
    lynxtag?: string
  }

  export type migrationUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    app_name?: StringFieldUpdateOperationsInput | string
    ran_on?: DateTimeFieldUpdateOperationsInput | Date | string
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type migrationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    app_name?: StringFieldUpdateOperationsInput | string
    ran_on?: DateTimeFieldUpdateOperationsInput | Date | string
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type migrationCreateManyInput = {
    id?: number
    name?: string
    app_name?: string
    ran_on?: Date | string
    lynxtag?: string
  }

  export type migrationUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    app_name?: StringFieldUpdateOperationsInput | string
    ran_on?: DateTimeFieldUpdateOperationsInput | Date | string
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type migrationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    app_name?: StringFieldUpdateOperationsInput | string
    ran_on?: DateTimeFieldUpdateOperationsInput | Date | string
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type piccolo_userCreateInput = {
    username?: string
    password?: string
    email?: string
    active?: boolean
    admin?: boolean
    first_name?: string | null
    last_name?: string | null
    superuser?: boolean
    last_login?: Date | string | null
    lynxtag?: string
  }

  export type piccolo_userUncheckedCreateInput = {
    id?: number
    username?: string
    password?: string
    email?: string
    active?: boolean
    admin?: boolean
    first_name?: string | null
    last_name?: string | null
    superuser?: boolean
    last_login?: Date | string | null
    lynxtag?: string
  }

  export type piccolo_userUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    admin?: BoolFieldUpdateOperationsInput | boolean
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    superuser?: BoolFieldUpdateOperationsInput | boolean
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type piccolo_userUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    admin?: BoolFieldUpdateOperationsInput | boolean
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    superuser?: BoolFieldUpdateOperationsInput | boolean
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type piccolo_userCreateManyInput = {
    id?: number
    username?: string
    password?: string
    email?: string
    active?: boolean
    admin?: boolean
    first_name?: string | null
    last_name?: string | null
    superuser?: boolean
    last_login?: Date | string | null
    lynxtag?: string
  }

  export type piccolo_userUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    admin?: BoolFieldUpdateOperationsInput | boolean
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    superuser?: BoolFieldUpdateOperationsInput | boolean
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type piccolo_userUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    admin?: BoolFieldUpdateOperationsInput | boolean
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    superuser?: BoolFieldUpdateOperationsInput | boolean
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type platform_mapCreateInput = {
    fates_id: Decimal | DecimalJsLike | number | string
    platform_id: string
    lynxtag?: string
  }

  export type platform_mapUncheckedCreateInput = {
    fates_id: Decimal | DecimalJsLike | number | string
    platform_id: string
    lynxtag?: string
  }

  export type platform_mapUpdateInput = {
    fates_id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    platform_id?: StringFieldUpdateOperationsInput | string
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type platform_mapUncheckedUpdateInput = {
    fates_id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    platform_id?: StringFieldUpdateOperationsInput | string
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type platform_mapCreateManyInput = {
    fates_id: Decimal | DecimalJsLike | number | string
    platform_id: string
    lynxtag?: string
  }

  export type platform_mapUpdateManyMutationInput = {
    fates_id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    platform_id?: StringFieldUpdateOperationsInput | string
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type platform_mapUncheckedUpdateManyInput = {
    fates_id?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    platform_id?: StringFieldUpdateOperationsInput | string
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type push_notificationsCreateInput = {
    id?: string
    token: string
    users: usersCreateNestedOneWithoutPush_notificationsInput
  }

  export type push_notificationsUncheckedCreateInput = {
    id?: string
    user_id: bigint | number
    token: string
  }

  export type push_notificationsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    users?: usersUpdateOneRequiredWithoutPush_notificationsNestedInput
  }

  export type push_notificationsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    token?: StringFieldUpdateOperationsInput | string
  }

  export type push_notificationsCreateManyInput = {
    id?: string
    user_id: bigint | number
    token: string
  }

  export type push_notificationsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
  }

  export type push_notificationsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    token?: StringFieldUpdateOperationsInput | string
  }

  export type review_votesCreateInput = {
    upvote: boolean
    lynxtag?: string
    reviews: reviewsCreateNestedOneWithoutReview_votesInput
    users: usersCreateNestedOneWithoutReview_votesInput
  }

  export type review_votesUncheckedCreateInput = {
    id: string
    user_id: bigint | number
    upvote: boolean
    lynxtag?: string
  }

  export type review_votesUpdateInput = {
    upvote?: BoolFieldUpdateOperationsInput | boolean
    lynxtag?: StringFieldUpdateOperationsInput | string
    reviews?: reviewsUpdateOneRequiredWithoutReview_votesNestedInput
    users?: usersUpdateOneRequiredWithoutReview_votesNestedInput
  }

  export type review_votesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    upvote?: BoolFieldUpdateOperationsInput | boolean
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type review_votesCreateManyInput = {
    id: string
    user_id: bigint | number
    upvote: boolean
    lynxtag?: string
  }

  export type review_votesUpdateManyMutationInput = {
    upvote?: BoolFieldUpdateOperationsInput | boolean
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type review_votesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    upvote?: BoolFieldUpdateOperationsInput | boolean
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type reviewsCreateInput = {
    id?: string
    target_id: bigint | number
    star_rating?: Decimal | DecimalJsLike | number | string
    review_text: string
    flagged?: boolean
    epoch?: reviewsCreateepochInput | bigint[] | number[]
    target_type?: number | null
    lynxtag?: string
    review_votes?: review_votesCreateNestedManyWithoutReviewsInput
    reviews?: reviewsCreateNestedOneWithoutOther_reviewsInput
    other_reviews?: reviewsCreateNestedManyWithoutReviewsInput
    users: usersCreateNestedOneWithoutReviewsInput
  }

  export type reviewsUncheckedCreateInput = {
    id?: string
    target_id: bigint | number
    user_id: bigint | number
    star_rating?: Decimal | DecimalJsLike | number | string
    review_text: string
    flagged?: boolean
    epoch?: reviewsCreateepochInput | bigint[] | number[]
    target_type?: number | null
    parent_id?: string | null
    lynxtag?: string
    review_votes?: review_votesUncheckedCreateNestedManyWithoutReviewsInput
    other_reviews?: reviewsUncheckedCreateNestedManyWithoutReviewsInput
  }

  export type reviewsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    target_id?: BigIntFieldUpdateOperationsInput | bigint | number
    star_rating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    review_text?: StringFieldUpdateOperationsInput | string
    flagged?: BoolFieldUpdateOperationsInput | boolean
    epoch?: reviewsUpdateepochInput | bigint[] | number[]
    target_type?: NullableIntFieldUpdateOperationsInput | number | null
    lynxtag?: StringFieldUpdateOperationsInput | string
    review_votes?: review_votesUpdateManyWithoutReviewsNestedInput
    reviews?: reviewsUpdateOneWithoutOther_reviewsNestedInput
    other_reviews?: reviewsUpdateManyWithoutReviewsNestedInput
    users?: usersUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type reviewsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    target_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    star_rating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    review_text?: StringFieldUpdateOperationsInput | string
    flagged?: BoolFieldUpdateOperationsInput | boolean
    epoch?: reviewsUpdateepochInput | bigint[] | number[]
    target_type?: NullableIntFieldUpdateOperationsInput | number | null
    parent_id?: NullableStringFieldUpdateOperationsInput | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
    review_votes?: review_votesUncheckedUpdateManyWithoutReviewsNestedInput
    other_reviews?: reviewsUncheckedUpdateManyWithoutReviewsNestedInput
  }

  export type reviewsCreateManyInput = {
    id?: string
    target_id: bigint | number
    user_id: bigint | number
    star_rating?: Decimal | DecimalJsLike | number | string
    review_text: string
    flagged?: boolean
    epoch?: reviewsCreateepochInput | bigint[] | number[]
    target_type?: number | null
    parent_id?: string | null
    lynxtag?: string
  }

  export type reviewsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    target_id?: BigIntFieldUpdateOperationsInput | bigint | number
    star_rating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    review_text?: StringFieldUpdateOperationsInput | string
    flagged?: BoolFieldUpdateOperationsInput | boolean
    epoch?: reviewsUpdateepochInput | bigint[] | number[]
    target_type?: NullableIntFieldUpdateOperationsInput | number | null
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type reviewsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    target_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    star_rating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    review_text?: StringFieldUpdateOperationsInput | string
    flagged?: BoolFieldUpdateOperationsInput | boolean
    epoch?: reviewsUpdateepochInput | bigint[] | number[]
    target_type?: NullableIntFieldUpdateOperationsInput | number | null
    parent_id?: NullableStringFieldUpdateOperationsInput | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type server_audit_logsCreateInput = {
    username: string
    user_guild_perms: string
    field: string
    value: string
    action_time?: Date | string
    action_id?: string
    lynxtag?: string
    servers: serversCreateNestedOneWithoutServer_audit_logsInput
    users: usersCreateNestedOneWithoutServer_audit_logsInput
  }

  export type server_audit_logsUncheckedCreateInput = {
    guild_id: bigint | number
    user_id: bigint | number
    username: string
    user_guild_perms: string
    field: string
    value: string
    action_time?: Date | string
    action_id?: string
    lynxtag?: string
  }

  export type server_audit_logsUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    user_guild_perms?: StringFieldUpdateOperationsInput | string
    field?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    action_time?: DateTimeFieldUpdateOperationsInput | Date | string
    action_id?: StringFieldUpdateOperationsInput | string
    lynxtag?: StringFieldUpdateOperationsInput | string
    servers?: serversUpdateOneRequiredWithoutServer_audit_logsNestedInput
    users?: usersUpdateOneRequiredWithoutServer_audit_logsNestedInput
  }

  export type server_audit_logsUncheckedUpdateInput = {
    guild_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    username?: StringFieldUpdateOperationsInput | string
    user_guild_perms?: StringFieldUpdateOperationsInput | string
    field?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    action_time?: DateTimeFieldUpdateOperationsInput | Date | string
    action_id?: StringFieldUpdateOperationsInput | string
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type server_audit_logsCreateManyInput = {
    guild_id: bigint | number
    user_id: bigint | number
    username: string
    user_guild_perms: string
    field: string
    value: string
    action_time?: Date | string
    action_id?: string
    lynxtag?: string
  }

  export type server_audit_logsUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    user_guild_perms?: StringFieldUpdateOperationsInput | string
    field?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    action_time?: DateTimeFieldUpdateOperationsInput | Date | string
    action_id?: StringFieldUpdateOperationsInput | string
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type server_audit_logsUncheckedUpdateManyInput = {
    guild_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    username?: StringFieldUpdateOperationsInput | string
    user_guild_perms?: StringFieldUpdateOperationsInput | string
    field?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    action_time?: DateTimeFieldUpdateOperationsInput | Date | string
    action_id?: StringFieldUpdateOperationsInput | string
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type server_tagsCreateInput = {
    id: string
    name: string
    owner_guild: bigint | number
    iconify_data: string
    lynxtag?: string
  }

  export type server_tagsUncheckedCreateInput = {
    id: string
    name: string
    owner_guild: bigint | number
    iconify_data: string
    lynxtag?: string
  }

  export type server_tagsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    owner_guild?: BigIntFieldUpdateOperationsInput | bigint | number
    iconify_data?: StringFieldUpdateOperationsInput | string
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type server_tagsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    owner_guild?: BigIntFieldUpdateOperationsInput | bigint | number
    iconify_data?: StringFieldUpdateOperationsInput | string
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type server_tagsCreateManyInput = {
    id: string
    name: string
    owner_guild: bigint | number
    iconify_data: string
    lynxtag?: string
  }

  export type server_tagsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    owner_guild?: BigIntFieldUpdateOperationsInput | bigint | number
    iconify_data?: StringFieldUpdateOperationsInput | string
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type server_tagsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    owner_guild?: BigIntFieldUpdateOperationsInput | bigint | number
    iconify_data?: StringFieldUpdateOperationsInput | string
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type server_votersCreateInput = {
    guild_id: bigint | number
    timestamps?: server_votersCreatetimestampsInput | Date[] | string[]
    lynxtag?: string
    users: usersCreateNestedOneWithoutServer_votersInput
  }

  export type server_votersUncheckedCreateInput = {
    guild_id: bigint | number
    user_id: bigint | number
    timestamps?: server_votersCreatetimestampsInput | Date[] | string[]
    lynxtag?: string
  }

  export type server_votersUpdateInput = {
    guild_id?: BigIntFieldUpdateOperationsInput | bigint | number
    timestamps?: server_votersUpdatetimestampsInput | Date[] | string[]
    lynxtag?: StringFieldUpdateOperationsInput | string
    users?: usersUpdateOneRequiredWithoutServer_votersNestedInput
  }

  export type server_votersUncheckedUpdateInput = {
    guild_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    timestamps?: server_votersUpdatetimestampsInput | Date[] | string[]
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type server_votersCreateManyInput = {
    guild_id: bigint | number
    user_id: bigint | number
    timestamps?: server_votersCreatetimestampsInput | Date[] | string[]
    lynxtag?: string
  }

  export type server_votersUpdateManyMutationInput = {
    guild_id?: BigIntFieldUpdateOperationsInput | bigint | number
    timestamps?: server_votersUpdatetimestampsInput | Date[] | string[]
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type server_votersUncheckedUpdateManyInput = {
    guild_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    timestamps?: server_votersUpdatetimestampsInput | Date[] | string[]
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type serversCreateInput = {
    guild_id: bigint | number
    votes?: bigint | number | null
    webhook?: string | null
    description?: string
    long_description?: string
    css?: string | null
    api_token: string
    invite_amount?: number | null
    invite_url?: string | null
    name_cached: string
    long_description_type?: number | null
    state?: number
    created_at?: Date | string
    avatar_cached?: string | null
    invite_channel?: bigint | number | null
    guild_count?: bigint | number | null
    banner_card?: string | null
    banner_page?: string | null
    webhook_secret?: string | null
    webhook_type?: number | null
    total_votes?: bigint | number | null
    tags?: serversCreatetagsInput | string[]
    flags?: serversCreateflagsInput | number[]
    autorole_votes?: serversCreateautorole_votesInput | bigint[] | number[]
    whitelist_form?: string | null
    webhook_hmac_only?: boolean | null
    old_state?: number
    user_whitelist?: serversCreateuser_whitelistInput | bigint[] | number[]
    user_blacklist?: serversCreateuser_blacklistInput | bigint[] | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    lynxtag?: string
    server_audit_logs?: server_audit_logsCreateNestedManyWithoutServersInput
    users: usersCreateNestedOneWithoutServersInput
  }

  export type serversUncheckedCreateInput = {
    guild_id: bigint | number
    votes?: bigint | number | null
    webhook?: string | null
    description?: string
    long_description?: string
    css?: string | null
    api_token: string
    invite_amount?: number | null
    invite_url?: string | null
    name_cached: string
    long_description_type?: number | null
    state?: number
    created_at?: Date | string
    avatar_cached?: string | null
    invite_channel?: bigint | number | null
    guild_count?: bigint | number | null
    banner_card?: string | null
    banner_page?: string | null
    webhook_secret?: string | null
    webhook_type?: number | null
    total_votes?: bigint | number | null
    tags?: serversCreatetagsInput | string[]
    owner_id: bigint | number
    flags?: serversCreateflagsInput | number[]
    autorole_votes?: serversCreateautorole_votesInput | bigint[] | number[]
    whitelist_form?: string | null
    webhook_hmac_only?: boolean | null
    old_state?: number
    user_whitelist?: serversCreateuser_whitelistInput | bigint[] | number[]
    user_blacklist?: serversCreateuser_blacklistInput | bigint[] | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    lynxtag?: string
    server_audit_logs?: server_audit_logsUncheckedCreateNestedManyWithoutServersInput
  }

  export type serversUpdateInput = {
    guild_id?: BigIntFieldUpdateOperationsInput | bigint | number
    votes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    webhook?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    long_description?: StringFieldUpdateOperationsInput | string
    css?: NullableStringFieldUpdateOperationsInput | string | null
    api_token?: StringFieldUpdateOperationsInput | string
    invite_amount?: NullableIntFieldUpdateOperationsInput | number | null
    invite_url?: NullableStringFieldUpdateOperationsInput | string | null
    name_cached?: StringFieldUpdateOperationsInput | string
    long_description_type?: NullableIntFieldUpdateOperationsInput | number | null
    state?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar_cached?: NullableStringFieldUpdateOperationsInput | string | null
    invite_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    guild_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    banner_card?: NullableStringFieldUpdateOperationsInput | string | null
    banner_page?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_secret?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_type?: NullableIntFieldUpdateOperationsInput | number | null
    total_votes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    tags?: serversUpdatetagsInput | string[]
    flags?: serversUpdateflagsInput | number[]
    autorole_votes?: serversUpdateautorole_votesInput | bigint[] | number[]
    whitelist_form?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_hmac_only?: NullableBoolFieldUpdateOperationsInput | boolean | null
    old_state?: IntFieldUpdateOperationsInput | number
    user_whitelist?: serversUpdateuser_whitelistInput | bigint[] | number[]
    user_blacklist?: serversUpdateuser_blacklistInput | bigint[] | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    lynxtag?: StringFieldUpdateOperationsInput | string
    server_audit_logs?: server_audit_logsUpdateManyWithoutServersNestedInput
    users?: usersUpdateOneRequiredWithoutServersNestedInput
  }

  export type serversUncheckedUpdateInput = {
    guild_id?: BigIntFieldUpdateOperationsInput | bigint | number
    votes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    webhook?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    long_description?: StringFieldUpdateOperationsInput | string
    css?: NullableStringFieldUpdateOperationsInput | string | null
    api_token?: StringFieldUpdateOperationsInput | string
    invite_amount?: NullableIntFieldUpdateOperationsInput | number | null
    invite_url?: NullableStringFieldUpdateOperationsInput | string | null
    name_cached?: StringFieldUpdateOperationsInput | string
    long_description_type?: NullableIntFieldUpdateOperationsInput | number | null
    state?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar_cached?: NullableStringFieldUpdateOperationsInput | string | null
    invite_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    guild_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    banner_card?: NullableStringFieldUpdateOperationsInput | string | null
    banner_page?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_secret?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_type?: NullableIntFieldUpdateOperationsInput | number | null
    total_votes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    tags?: serversUpdatetagsInput | string[]
    owner_id?: BigIntFieldUpdateOperationsInput | bigint | number
    flags?: serversUpdateflagsInput | number[]
    autorole_votes?: serversUpdateautorole_votesInput | bigint[] | number[]
    whitelist_form?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_hmac_only?: NullableBoolFieldUpdateOperationsInput | boolean | null
    old_state?: IntFieldUpdateOperationsInput | number
    user_whitelist?: serversUpdateuser_whitelistInput | bigint[] | number[]
    user_blacklist?: serversUpdateuser_blacklistInput | bigint[] | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    lynxtag?: StringFieldUpdateOperationsInput | string
    server_audit_logs?: server_audit_logsUncheckedUpdateManyWithoutServersNestedInput
  }

  export type serversCreateManyInput = {
    guild_id: bigint | number
    votes?: bigint | number | null
    webhook?: string | null
    description?: string
    long_description?: string
    css?: string | null
    api_token: string
    invite_amount?: number | null
    invite_url?: string | null
    name_cached: string
    long_description_type?: number | null
    state?: number
    created_at?: Date | string
    avatar_cached?: string | null
    invite_channel?: bigint | number | null
    guild_count?: bigint | number | null
    banner_card?: string | null
    banner_page?: string | null
    webhook_secret?: string | null
    webhook_type?: number | null
    total_votes?: bigint | number | null
    tags?: serversCreatetagsInput | string[]
    owner_id: bigint | number
    flags?: serversCreateflagsInput | number[]
    autorole_votes?: serversCreateautorole_votesInput | bigint[] | number[]
    whitelist_form?: string | null
    webhook_hmac_only?: boolean | null
    old_state?: number
    user_whitelist?: serversCreateuser_whitelistInput | bigint[] | number[]
    user_blacklist?: serversCreateuser_blacklistInput | bigint[] | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    lynxtag?: string
  }

  export type serversUpdateManyMutationInput = {
    guild_id?: BigIntFieldUpdateOperationsInput | bigint | number
    votes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    webhook?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    long_description?: StringFieldUpdateOperationsInput | string
    css?: NullableStringFieldUpdateOperationsInput | string | null
    api_token?: StringFieldUpdateOperationsInput | string
    invite_amount?: NullableIntFieldUpdateOperationsInput | number | null
    invite_url?: NullableStringFieldUpdateOperationsInput | string | null
    name_cached?: StringFieldUpdateOperationsInput | string
    long_description_type?: NullableIntFieldUpdateOperationsInput | number | null
    state?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar_cached?: NullableStringFieldUpdateOperationsInput | string | null
    invite_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    guild_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    banner_card?: NullableStringFieldUpdateOperationsInput | string | null
    banner_page?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_secret?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_type?: NullableIntFieldUpdateOperationsInput | number | null
    total_votes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    tags?: serversUpdatetagsInput | string[]
    flags?: serversUpdateflagsInput | number[]
    autorole_votes?: serversUpdateautorole_votesInput | bigint[] | number[]
    whitelist_form?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_hmac_only?: NullableBoolFieldUpdateOperationsInput | boolean | null
    old_state?: IntFieldUpdateOperationsInput | number
    user_whitelist?: serversUpdateuser_whitelistInput | bigint[] | number[]
    user_blacklist?: serversUpdateuser_blacklistInput | bigint[] | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type serversUncheckedUpdateManyInput = {
    guild_id?: BigIntFieldUpdateOperationsInput | bigint | number
    votes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    webhook?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    long_description?: StringFieldUpdateOperationsInput | string
    css?: NullableStringFieldUpdateOperationsInput | string | null
    api_token?: StringFieldUpdateOperationsInput | string
    invite_amount?: NullableIntFieldUpdateOperationsInput | number | null
    invite_url?: NullableStringFieldUpdateOperationsInput | string | null
    name_cached?: StringFieldUpdateOperationsInput | string
    long_description_type?: NullableIntFieldUpdateOperationsInput | number | null
    state?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar_cached?: NullableStringFieldUpdateOperationsInput | string | null
    invite_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    guild_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    banner_card?: NullableStringFieldUpdateOperationsInput | string | null
    banner_page?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_secret?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_type?: NullableIntFieldUpdateOperationsInput | number | null
    total_votes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    tags?: serversUpdatetagsInput | string[]
    owner_id?: BigIntFieldUpdateOperationsInput | bigint | number
    flags?: serversUpdateflagsInput | number[]
    autorole_votes?: serversUpdateautorole_votesInput | bigint[] | number[]
    whitelist_form?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_hmac_only?: NullableBoolFieldUpdateOperationsInput | boolean | null
    old_state?: IntFieldUpdateOperationsInput | number
    user_whitelist?: serversUpdateuser_whitelistInput | bigint[] | number[]
    user_blacklist?: serversUpdateuser_blacklistInput | bigint[] | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type sessionsCreateInput = {
    token?: string
    user_id?: number
    expiry_date?: Date | string
    max_expiry_date?: Date | string
    lynxtag?: string
  }

  export type sessionsUncheckedCreateInput = {
    id?: number
    token?: string
    user_id?: number
    expiry_date?: Date | string
    max_expiry_date?: Date | string
    lynxtag?: string
  }

  export type sessionsUpdateInput = {
    token?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    expiry_date?: DateTimeFieldUpdateOperationsInput | Date | string
    max_expiry_date?: DateTimeFieldUpdateOperationsInput | Date | string
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type sessionsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    expiry_date?: DateTimeFieldUpdateOperationsInput | Date | string
    max_expiry_date?: DateTimeFieldUpdateOperationsInput | Date | string
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type sessionsCreateManyInput = {
    id?: number
    token?: string
    user_id?: number
    expiry_date?: Date | string
    max_expiry_date?: Date | string
    lynxtag?: string
  }

  export type sessionsUpdateManyMutationInput = {
    token?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    expiry_date?: DateTimeFieldUpdateOperationsInput | Date | string
    max_expiry_date?: DateTimeFieldUpdateOperationsInput | Date | string
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type sessionsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    expiry_date?: DateTimeFieldUpdateOperationsInput | Date | string
    max_expiry_date?: DateTimeFieldUpdateOperationsInput | Date | string
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type user_bot_logsCreateInput = {
    bot_id: bigint | number
    action_time?: Date | string
    action: number
    context?: string | null
    lynxtag?: string
    users: usersCreateNestedOneWithoutUser_bot_logsInput
  }

  export type user_bot_logsUncheckedCreateInput = {
    user_id: bigint | number
    bot_id: bigint | number
    action_time?: Date | string
    action: number
    context?: string | null
    lynxtag?: string
  }

  export type user_bot_logsUpdateInput = {
    bot_id?: BigIntFieldUpdateOperationsInput | bigint | number
    action_time?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: IntFieldUpdateOperationsInput | number
    context?: NullableStringFieldUpdateOperationsInput | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
    users?: usersUpdateOneRequiredWithoutUser_bot_logsNestedInput
  }

  export type user_bot_logsUncheckedUpdateInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    bot_id?: BigIntFieldUpdateOperationsInput | bigint | number
    action_time?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: IntFieldUpdateOperationsInput | number
    context?: NullableStringFieldUpdateOperationsInput | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type user_bot_logsCreateManyInput = {
    user_id: bigint | number
    bot_id: bigint | number
    action_time?: Date | string
    action: number
    context?: string | null
    lynxtag?: string
  }

  export type user_bot_logsUpdateManyMutationInput = {
    bot_id?: BigIntFieldUpdateOperationsInput | bigint | number
    action_time?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: IntFieldUpdateOperationsInput | number
    context?: NullableStringFieldUpdateOperationsInput | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type user_bot_logsUncheckedUpdateManyInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    bot_id?: BigIntFieldUpdateOperationsInput | bigint | number
    action_time?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: IntFieldUpdateOperationsInput | number
    context?: NullableStringFieldUpdateOperationsInput | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type user_connectionsCreateInput = {
    client_id: string
    refresh_token: string
    expires_on?: Date | string
    lynxtag?: string
    users: usersCreateNestedOneWithoutUser_connectionsInput
  }

  export type user_connectionsUncheckedCreateInput = {
    user_id: bigint | number
    client_id: string
    refresh_token: string
    expires_on?: Date | string
    lynxtag?: string
  }

  export type user_connectionsUpdateInput = {
    client_id?: StringFieldUpdateOperationsInput | string
    refresh_token?: StringFieldUpdateOperationsInput | string
    expires_on?: DateTimeFieldUpdateOperationsInput | Date | string
    lynxtag?: StringFieldUpdateOperationsInput | string
    users?: usersUpdateOneRequiredWithoutUser_connectionsNestedInput
  }

  export type user_connectionsUncheckedUpdateInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    client_id?: StringFieldUpdateOperationsInput | string
    refresh_token?: StringFieldUpdateOperationsInput | string
    expires_on?: DateTimeFieldUpdateOperationsInput | Date | string
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type user_connectionsCreateManyInput = {
    user_id: bigint | number
    client_id: string
    refresh_token: string
    expires_on?: Date | string
    lynxtag?: string
  }

  export type user_connectionsUpdateManyMutationInput = {
    client_id?: StringFieldUpdateOperationsInput | string
    refresh_token?: StringFieldUpdateOperationsInput | string
    expires_on?: DateTimeFieldUpdateOperationsInput | Date | string
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type user_connectionsUncheckedUpdateManyInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    client_id?: StringFieldUpdateOperationsInput | string
    refresh_token?: StringFieldUpdateOperationsInput | string
    expires_on?: DateTimeFieldUpdateOperationsInput | Date | string
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type user_server_vote_tableCreateInput = {
    guild_id: bigint | number
    expires_on?: Date | string | null
    lynxtag?: string
    users: usersCreateNestedOneWithoutUser_server_vote_tableInput
  }

  export type user_server_vote_tableUncheckedCreateInput = {
    user_id: bigint | number
    guild_id: bigint | number
    expires_on?: Date | string | null
    lynxtag?: string
  }

  export type user_server_vote_tableUpdateInput = {
    guild_id?: BigIntFieldUpdateOperationsInput | bigint | number
    expires_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
    users?: usersUpdateOneRequiredWithoutUser_server_vote_tableNestedInput
  }

  export type user_server_vote_tableUncheckedUpdateInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    guild_id?: BigIntFieldUpdateOperationsInput | bigint | number
    expires_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type user_server_vote_tableCreateManyInput = {
    user_id: bigint | number
    guild_id: bigint | number
    expires_on?: Date | string | null
    lynxtag?: string
  }

  export type user_server_vote_tableUpdateManyMutationInput = {
    guild_id?: BigIntFieldUpdateOperationsInput | bigint | number
    expires_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type user_server_vote_tableUncheckedUpdateManyInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    guild_id?: BigIntFieldUpdateOperationsInput | bigint | number
    expires_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type user_vote_tableCreateInput = {
    bot_id: bigint | number
    expires_on?: Date | string | null
    lynxtag?: string
    users: usersCreateNestedOneWithoutUser_vote_tableInput
  }

  export type user_vote_tableUncheckedCreateInput = {
    user_id: bigint | number
    bot_id: bigint | number
    expires_on?: Date | string | null
    lynxtag?: string
  }

  export type user_vote_tableUpdateInput = {
    bot_id?: BigIntFieldUpdateOperationsInput | bigint | number
    expires_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
    users?: usersUpdateOneRequiredWithoutUser_vote_tableNestedInput
  }

  export type user_vote_tableUncheckedUpdateInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    bot_id?: BigIntFieldUpdateOperationsInput | bigint | number
    expires_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type user_vote_tableCreateManyInput = {
    user_id: bigint | number
    bot_id: bigint | number
    expires_on?: Date | string | null
    lynxtag?: string
  }

  export type user_vote_tableUpdateManyMutationInput = {
    bot_id?: BigIntFieldUpdateOperationsInput | bigint | number
    expires_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type user_vote_tableUncheckedUpdateManyInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    bot_id?: BigIntFieldUpdateOperationsInput | bigint | number
    expires_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type usersCreateInput = {
    user_id: bigint | number
    api_token: string
    description?: string | null
    badges?: usersCreatebadgesInput | string[]
    username?: string | null
    user_css?: string | null
    state?: number
    coins?: number | null
    id: bigint | number
    site_lang?: string | null
    profile_css?: string
    vote_reminders?: usersCreatevote_remindersInput | bigint[] | number[]
    vote_reminder_channel?: bigint | number | null
    staff_verify_code?: string | null
    vote_reminders_last_acked?: Date | string
    vote_reminders_servers?: usersCreatevote_reminders_serversInput | bigint[] | number[]
    vote_reminders_servers_last_acked?: Date | string
    vote_reminder_servers_channel?: bigint | number | null
    experiments?: usersCreateexperimentsInput | number[]
    flags?: usersCreateflagsInput | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    supabase_id?: string | null
    totp_shared_key?: string | null
    staff_password?: string | null
    lynxtag?: string
    bot_voters?: bot_votersCreateNestedManyWithoutUsersInput
    extra_data?: extra_dataCreateNestedManyWithoutUsersInput
    frostpaw_clients?: frostpaw_clientsCreateNestedManyWithoutUsersInput
    leave_of_absence?: leave_of_absenceCreateNestedManyWithoutUsersInput
    lynx_apps?: lynx_appsCreateNestedManyWithoutUsersInput
    lynx_logs?: lynx_logsCreateNestedManyWithoutUsersInput
    lynx_ratings?: lynx_ratingsCreateNestedManyWithoutUsersInput
    lynx_survey_responses?: lynx_survey_responsesCreateNestedManyWithoutUsersInput
    push_notifications?: push_notificationsCreateNestedManyWithoutUsersInput
    review_votes?: review_votesCreateNestedManyWithoutUsersInput
    reviews?: reviewsCreateNestedManyWithoutUsersInput
    server_audit_logs?: server_audit_logsCreateNestedManyWithoutUsersInput
    server_voters?: server_votersCreateNestedManyWithoutUsersInput
    servers?: serversCreateNestedManyWithoutUsersInput
    user_bot_logs?: user_bot_logsCreateNestedManyWithoutUsersInput
    user_connections?: user_connectionsCreateNestedManyWithoutUsersInput
    user_server_vote_table?: user_server_vote_tableCreateNestedOneWithoutUsersInput
    user_vote_table?: user_vote_tableCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateInput = {
    user_id: bigint | number
    api_token: string
    description?: string | null
    badges?: usersCreatebadgesInput | string[]
    username?: string | null
    user_css?: string | null
    state?: number
    coins?: number | null
    id: bigint | number
    site_lang?: string | null
    profile_css?: string
    vote_reminders?: usersCreatevote_remindersInput | bigint[] | number[]
    vote_reminder_channel?: bigint | number | null
    staff_verify_code?: string | null
    vote_reminders_last_acked?: Date | string
    vote_reminders_servers?: usersCreatevote_reminders_serversInput | bigint[] | number[]
    vote_reminders_servers_last_acked?: Date | string
    vote_reminder_servers_channel?: bigint | number | null
    experiments?: usersCreateexperimentsInput | number[]
    flags?: usersCreateflagsInput | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    supabase_id?: string | null
    totp_shared_key?: string | null
    staff_password?: string | null
    lynxtag?: string
    bot_voters?: bot_votersUncheckedCreateNestedManyWithoutUsersInput
    extra_data?: extra_dataUncheckedCreateNestedManyWithoutUsersInput
    frostpaw_clients?: frostpaw_clientsUncheckedCreateNestedManyWithoutUsersInput
    leave_of_absence?: leave_of_absenceUncheckedCreateNestedManyWithoutUsersInput
    lynx_apps?: lynx_appsUncheckedCreateNestedManyWithoutUsersInput
    lynx_logs?: lynx_logsUncheckedCreateNestedManyWithoutUsersInput
    lynx_ratings?: lynx_ratingsUncheckedCreateNestedManyWithoutUsersInput
    lynx_survey_responses?: lynx_survey_responsesUncheckedCreateNestedManyWithoutUsersInput
    push_notifications?: push_notificationsUncheckedCreateNestedManyWithoutUsersInput
    review_votes?: review_votesUncheckedCreateNestedManyWithoutUsersInput
    reviews?: reviewsUncheckedCreateNestedManyWithoutUsersInput
    server_audit_logs?: server_audit_logsUncheckedCreateNestedManyWithoutUsersInput
    server_voters?: server_votersUncheckedCreateNestedManyWithoutUsersInput
    servers?: serversUncheckedCreateNestedManyWithoutUsersInput
    user_bot_logs?: user_bot_logsUncheckedCreateNestedManyWithoutUsersInput
    user_connections?: user_connectionsUncheckedCreateNestedManyWithoutUsersInput
    user_server_vote_table?: user_server_vote_tableUncheckedCreateNestedOneWithoutUsersInput
    user_vote_table?: user_vote_tableUncheckedCreateNestedOneWithoutUsersInput
  }

  export type usersUpdateInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    api_token?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    badges?: usersUpdatebadgesInput | string[]
    username?: NullableStringFieldUpdateOperationsInput | string | null
    user_css?: NullableStringFieldUpdateOperationsInput | string | null
    state?: IntFieldUpdateOperationsInput | number
    coins?: NullableIntFieldUpdateOperationsInput | number | null
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    site_lang?: NullableStringFieldUpdateOperationsInput | string | null
    profile_css?: StringFieldUpdateOperationsInput | string
    vote_reminders?: usersUpdatevote_remindersInput | bigint[] | number[]
    vote_reminder_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    staff_verify_code?: NullableStringFieldUpdateOperationsInput | string | null
    vote_reminders_last_acked?: DateTimeFieldUpdateOperationsInput | Date | string
    vote_reminders_servers?: usersUpdatevote_reminders_serversInput | bigint[] | number[]
    vote_reminders_servers_last_acked?: DateTimeFieldUpdateOperationsInput | Date | string
    vote_reminder_servers_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    experiments?: usersUpdateexperimentsInput | number[]
    flags?: usersUpdateflagsInput | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    totp_shared_key?: NullableStringFieldUpdateOperationsInput | string | null
    staff_password?: NullableStringFieldUpdateOperationsInput | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
    bot_voters?: bot_votersUpdateManyWithoutUsersNestedInput
    extra_data?: extra_dataUpdateManyWithoutUsersNestedInput
    frostpaw_clients?: frostpaw_clientsUpdateManyWithoutUsersNestedInput
    leave_of_absence?: leave_of_absenceUpdateManyWithoutUsersNestedInput
    lynx_apps?: lynx_appsUpdateManyWithoutUsersNestedInput
    lynx_logs?: lynx_logsUpdateManyWithoutUsersNestedInput
    lynx_ratings?: lynx_ratingsUpdateManyWithoutUsersNestedInput
    lynx_survey_responses?: lynx_survey_responsesUpdateManyWithoutUsersNestedInput
    push_notifications?: push_notificationsUpdateManyWithoutUsersNestedInput
    review_votes?: review_votesUpdateManyWithoutUsersNestedInput
    reviews?: reviewsUpdateManyWithoutUsersNestedInput
    server_audit_logs?: server_audit_logsUpdateManyWithoutUsersNestedInput
    server_voters?: server_votersUpdateManyWithoutUsersNestedInput
    servers?: serversUpdateManyWithoutUsersNestedInput
    user_bot_logs?: user_bot_logsUpdateManyWithoutUsersNestedInput
    user_connections?: user_connectionsUpdateManyWithoutUsersNestedInput
    user_server_vote_table?: user_server_vote_tableUpdateOneWithoutUsersNestedInput
    user_vote_table?: user_vote_tableUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    api_token?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    badges?: usersUpdatebadgesInput | string[]
    username?: NullableStringFieldUpdateOperationsInput | string | null
    user_css?: NullableStringFieldUpdateOperationsInput | string | null
    state?: IntFieldUpdateOperationsInput | number
    coins?: NullableIntFieldUpdateOperationsInput | number | null
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    site_lang?: NullableStringFieldUpdateOperationsInput | string | null
    profile_css?: StringFieldUpdateOperationsInput | string
    vote_reminders?: usersUpdatevote_remindersInput | bigint[] | number[]
    vote_reminder_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    staff_verify_code?: NullableStringFieldUpdateOperationsInput | string | null
    vote_reminders_last_acked?: DateTimeFieldUpdateOperationsInput | Date | string
    vote_reminders_servers?: usersUpdatevote_reminders_serversInput | bigint[] | number[]
    vote_reminders_servers_last_acked?: DateTimeFieldUpdateOperationsInput | Date | string
    vote_reminder_servers_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    experiments?: usersUpdateexperimentsInput | number[]
    flags?: usersUpdateflagsInput | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    totp_shared_key?: NullableStringFieldUpdateOperationsInput | string | null
    staff_password?: NullableStringFieldUpdateOperationsInput | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
    bot_voters?: bot_votersUncheckedUpdateManyWithoutUsersNestedInput
    extra_data?: extra_dataUncheckedUpdateManyWithoutUsersNestedInput
    frostpaw_clients?: frostpaw_clientsUncheckedUpdateManyWithoutUsersNestedInput
    leave_of_absence?: leave_of_absenceUncheckedUpdateManyWithoutUsersNestedInput
    lynx_apps?: lynx_appsUncheckedUpdateManyWithoutUsersNestedInput
    lynx_logs?: lynx_logsUncheckedUpdateManyWithoutUsersNestedInput
    lynx_ratings?: lynx_ratingsUncheckedUpdateManyWithoutUsersNestedInput
    lynx_survey_responses?: lynx_survey_responsesUncheckedUpdateManyWithoutUsersNestedInput
    push_notifications?: push_notificationsUncheckedUpdateManyWithoutUsersNestedInput
    review_votes?: review_votesUncheckedUpdateManyWithoutUsersNestedInput
    reviews?: reviewsUncheckedUpdateManyWithoutUsersNestedInput
    server_audit_logs?: server_audit_logsUncheckedUpdateManyWithoutUsersNestedInput
    server_voters?: server_votersUncheckedUpdateManyWithoutUsersNestedInput
    servers?: serversUncheckedUpdateManyWithoutUsersNestedInput
    user_bot_logs?: user_bot_logsUncheckedUpdateManyWithoutUsersNestedInput
    user_connections?: user_connectionsUncheckedUpdateManyWithoutUsersNestedInput
    user_server_vote_table?: user_server_vote_tableUncheckedUpdateOneWithoutUsersNestedInput
    user_vote_table?: user_vote_tableUncheckedUpdateOneWithoutUsersNestedInput
  }

  export type usersCreateManyInput = {
    user_id: bigint | number
    api_token: string
    description?: string | null
    badges?: usersCreatebadgesInput | string[]
    username?: string | null
    user_css?: string | null
    state?: number
    coins?: number | null
    id: bigint | number
    site_lang?: string | null
    profile_css?: string
    vote_reminders?: usersCreatevote_remindersInput | bigint[] | number[]
    vote_reminder_channel?: bigint | number | null
    staff_verify_code?: string | null
    vote_reminders_last_acked?: Date | string
    vote_reminders_servers?: usersCreatevote_reminders_serversInput | bigint[] | number[]
    vote_reminders_servers_last_acked?: Date | string
    vote_reminder_servers_channel?: bigint | number | null
    experiments?: usersCreateexperimentsInput | number[]
    flags?: usersCreateflagsInput | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    supabase_id?: string | null
    totp_shared_key?: string | null
    staff_password?: string | null
    lynxtag?: string
  }

  export type usersUpdateManyMutationInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    api_token?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    badges?: usersUpdatebadgesInput | string[]
    username?: NullableStringFieldUpdateOperationsInput | string | null
    user_css?: NullableStringFieldUpdateOperationsInput | string | null
    state?: IntFieldUpdateOperationsInput | number
    coins?: NullableIntFieldUpdateOperationsInput | number | null
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    site_lang?: NullableStringFieldUpdateOperationsInput | string | null
    profile_css?: StringFieldUpdateOperationsInput | string
    vote_reminders?: usersUpdatevote_remindersInput | bigint[] | number[]
    vote_reminder_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    staff_verify_code?: NullableStringFieldUpdateOperationsInput | string | null
    vote_reminders_last_acked?: DateTimeFieldUpdateOperationsInput | Date | string
    vote_reminders_servers?: usersUpdatevote_reminders_serversInput | bigint[] | number[]
    vote_reminders_servers_last_acked?: DateTimeFieldUpdateOperationsInput | Date | string
    vote_reminder_servers_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    experiments?: usersUpdateexperimentsInput | number[]
    flags?: usersUpdateflagsInput | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    totp_shared_key?: NullableStringFieldUpdateOperationsInput | string | null
    staff_password?: NullableStringFieldUpdateOperationsInput | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type usersUncheckedUpdateManyInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    api_token?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    badges?: usersUpdatebadgesInput | string[]
    username?: NullableStringFieldUpdateOperationsInput | string | null
    user_css?: NullableStringFieldUpdateOperationsInput | string | null
    state?: IntFieldUpdateOperationsInput | number
    coins?: NullableIntFieldUpdateOperationsInput | number | null
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    site_lang?: NullableStringFieldUpdateOperationsInput | string | null
    profile_css?: StringFieldUpdateOperationsInput | string
    vote_reminders?: usersUpdatevote_remindersInput | bigint[] | number[]
    vote_reminder_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    staff_verify_code?: NullableStringFieldUpdateOperationsInput | string | null
    vote_reminders_last_acked?: DateTimeFieldUpdateOperationsInput | Date | string
    vote_reminders_servers?: usersUpdatevote_reminders_serversInput | bigint[] | number[]
    vote_reminders_servers_last_acked?: DateTimeFieldUpdateOperationsInput | Date | string
    vote_reminder_servers_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    experiments?: usersUpdateexperimentsInput | number[]
    flags?: usersUpdateflagsInput | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    totp_shared_key?: NullableStringFieldUpdateOperationsInput | string | null
    staff_password?: NullableStringFieldUpdateOperationsInput | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type vanityCreateInput = {
    type?: number | null
    vanity_url?: string | null
    redirect?: bigint | number | null
    lynxtag?: string
  }

  export type vanityUncheckedCreateInput = {
    type?: number | null
    vanity_url?: string | null
    redirect?: bigint | number | null
    lynxtag?: string
  }

  export type vanityUpdateInput = {
    type?: NullableIntFieldUpdateOperationsInput | number | null
    vanity_url?: NullableStringFieldUpdateOperationsInput | string | null
    redirect?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type vanityUncheckedUpdateInput = {
    type?: NullableIntFieldUpdateOperationsInput | number | null
    vanity_url?: NullableStringFieldUpdateOperationsInput | string | null
    redirect?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type vanityCreateManyInput = {
    type?: number | null
    vanity_url?: string | null
    redirect?: bigint | number | null
    lynxtag?: string
  }

  export type vanityUpdateManyMutationInput = {
    type?: NullableIntFieldUpdateOperationsInput | number | null
    vanity_url?: NullableStringFieldUpdateOperationsInput | string | null
    redirect?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type vanityUncheckedUpdateManyInput = {
    type?: NullableIntFieldUpdateOperationsInput | number | null
    vanity_url?: NullableStringFieldUpdateOperationsInput | string | null
    redirect?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type ws_eventsCreateInput = {
    id: bigint | number
    type: string
    ts?: Date | string
    event: JsonNullValueInput | InputJsonValue
    lynxtag?: string
  }

  export type ws_eventsUncheckedCreateInput = {
    id: bigint | number
    type: string
    ts?: Date | string
    event: JsonNullValueInput | InputJsonValue
    lynxtag?: string
  }

  export type ws_eventsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    type?: StringFieldUpdateOperationsInput | string
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: JsonNullValueInput | InputJsonValue
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type ws_eventsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    type?: StringFieldUpdateOperationsInput | string
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: JsonNullValueInput | InputJsonValue
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type ws_eventsCreateManyInput = {
    id: bigint | number
    type: string
    ts?: Date | string
    event: JsonNullValueInput | InputJsonValue
    lynxtag?: string
  }

  export type ws_eventsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    type?: StringFieldUpdateOperationsInput | string
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: JsonNullValueInput | InputJsonValue
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type ws_eventsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    type?: StringFieldUpdateOperationsInput | string
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: JsonNullValueInput | InputJsonValue
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type BotsRelationFilter = {
    is?: botsWhereInput
    isNot?: botsWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type bot_commandsCountOrderByAggregateInput = {
    id?: SortOrder
    bot_id?: SortOrder
    cmd_type?: SortOrder
    groups?: SortOrder
    name?: SortOrder
    vote_locked?: SortOrder
    description?: SortOrder
    args?: SortOrder
    examples?: SortOrder
    premium_only?: SortOrder
    notes?: SortOrder
    doc_link?: SortOrder
    nsfw?: SortOrder
    lynxtag?: SortOrder
  }

  export type bot_commandsAvgOrderByAggregateInput = {
    bot_id?: SortOrder
    cmd_type?: SortOrder
  }

  export type bot_commandsMaxOrderByAggregateInput = {
    id?: SortOrder
    bot_id?: SortOrder
    cmd_type?: SortOrder
    name?: SortOrder
    vote_locked?: SortOrder
    description?: SortOrder
    premium_only?: SortOrder
    doc_link?: SortOrder
    nsfw?: SortOrder
    lynxtag?: SortOrder
  }

  export type bot_commandsMinOrderByAggregateInput = {
    id?: SortOrder
    bot_id?: SortOrder
    cmd_type?: SortOrder
    name?: SortOrder
    vote_locked?: SortOrder
    description?: SortOrder
    premium_only?: SortOrder
    doc_link?: SortOrder
    nsfw?: SortOrder
    lynxtag?: SortOrder
  }

  export type bot_commandsSumOrderByAggregateInput = {
    bot_id?: SortOrder
    cmd_type?: SortOrder
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type bot_eventsCountOrderByAggregateInput = {
    bot_id?: SortOrder
    event_type?: SortOrder
    ts?: SortOrder
    reason?: SortOrder
    css?: SortOrder
    id?: SortOrder
    lynxtag?: SortOrder
  }

  export type bot_eventsAvgOrderByAggregateInput = {
    bot_id?: SortOrder
    event_type?: SortOrder
  }

  export type bot_eventsMaxOrderByAggregateInput = {
    bot_id?: SortOrder
    event_type?: SortOrder
    ts?: SortOrder
    reason?: SortOrder
    css?: SortOrder
    id?: SortOrder
    lynxtag?: SortOrder
  }

  export type bot_eventsMinOrderByAggregateInput = {
    bot_id?: SortOrder
    event_type?: SortOrder
    ts?: SortOrder
    reason?: SortOrder
    css?: SortOrder
    id?: SortOrder
    lynxtag?: SortOrder
  }

  export type bot_eventsSumOrderByAggregateInput = {
    bot_id?: SortOrder
    event_type?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type bot_list_featureCountOrderByAggregateInput = {
    feature_id?: SortOrder
    name?: SortOrder
    iname?: SortOrder
    description?: SortOrder
    positive?: SortOrder
    lynxtag?: SortOrder
  }

  export type bot_list_featureAvgOrderByAggregateInput = {
    feature_id?: SortOrder
    positive?: SortOrder
  }

  export type bot_list_featureMaxOrderByAggregateInput = {
    feature_id?: SortOrder
    name?: SortOrder
    iname?: SortOrder
    description?: SortOrder
    positive?: SortOrder
    lynxtag?: SortOrder
  }

  export type bot_list_featureMinOrderByAggregateInput = {
    feature_id?: SortOrder
    name?: SortOrder
    iname?: SortOrder
    description?: SortOrder
    positive?: SortOrder
    lynxtag?: SortOrder
  }

  export type bot_list_featureSumOrderByAggregateInput = {
    feature_id?: SortOrder
    positive?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type Bot_tagsListRelationFilter = {
    every?: bot_tagsWhereInput
    some?: bot_tagsWhereInput
    none?: bot_tagsWhereInput
  }

  export type bot_tagsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type bot_list_tagsCountOrderByAggregateInput = {
    id?: SortOrder
    icon?: SortOrder
    lynxtag?: SortOrder
  }

  export type bot_list_tagsMaxOrderByAggregateInput = {
    id?: SortOrder
    icon?: SortOrder
    lynxtag?: SortOrder
  }

  export type bot_list_tagsMinOrderByAggregateInput = {
    id?: SortOrder
    icon?: SortOrder
    lynxtag?: SortOrder
  }

  export type bot_ownerCountOrderByAggregateInput = {
    bot_id?: SortOrder
    owner?: SortOrder
    main?: SortOrder
    id?: SortOrder
    lynxtag?: SortOrder
  }

  export type bot_ownerAvgOrderByAggregateInput = {
    bot_id?: SortOrder
    owner?: SortOrder
    id?: SortOrder
  }

  export type bot_ownerMaxOrderByAggregateInput = {
    bot_id?: SortOrder
    owner?: SortOrder
    main?: SortOrder
    id?: SortOrder
    lynxtag?: SortOrder
  }

  export type bot_ownerMinOrderByAggregateInput = {
    bot_id?: SortOrder
    owner?: SortOrder
    main?: SortOrder
    id?: SortOrder
    lynxtag?: SortOrder
  }

  export type bot_ownerSumOrderByAggregateInput = {
    bot_id?: SortOrder
    owner?: SortOrder
    id?: SortOrder
  }

  export type BigIntNullableListFilter<$PrismaModel = never> = {
    equals?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    has?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    hasEvery?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    hasSome?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type bot_packsCountOrderByAggregateInput = {
    id?: SortOrder
    icon?: SortOrder
    banner?: SortOrder
    owner?: SortOrder
    bots?: SortOrder
    description?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    lynxtag?: SortOrder
  }

  export type bot_packsAvgOrderByAggregateInput = {
    owner?: SortOrder
    bots?: SortOrder
  }

  export type bot_packsMaxOrderByAggregateInput = {
    id?: SortOrder
    icon?: SortOrder
    banner?: SortOrder
    owner?: SortOrder
    description?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    lynxtag?: SortOrder
  }

  export type bot_packsMinOrderByAggregateInput = {
    id?: SortOrder
    icon?: SortOrder
    banner?: SortOrder
    owner?: SortOrder
    description?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    lynxtag?: SortOrder
  }

  export type bot_packsSumOrderByAggregateInput = {
    owner?: SortOrder
    bots?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type BotsNullableRelationFilter = {
    is?: botsWhereInput | null
    isNot?: botsWhereInput | null
  }

  export type bot_promotionsCountOrderByAggregateInput = {
    id?: SortOrder
    bot_id?: SortOrder
    title?: SortOrder
    info?: SortOrder
    css?: SortOrder
    type?: SortOrder
    lynxtag?: SortOrder
  }

  export type bot_promotionsAvgOrderByAggregateInput = {
    bot_id?: SortOrder
    type?: SortOrder
  }

  export type bot_promotionsMaxOrderByAggregateInput = {
    id?: SortOrder
    bot_id?: SortOrder
    title?: SortOrder
    info?: SortOrder
    css?: SortOrder
    type?: SortOrder
    lynxtag?: SortOrder
  }

  export type bot_promotionsMinOrderByAggregateInput = {
    id?: SortOrder
    bot_id?: SortOrder
    title?: SortOrder
    info?: SortOrder
    css?: SortOrder
    type?: SortOrder
    lynxtag?: SortOrder
  }

  export type bot_promotionsSumOrderByAggregateInput = {
    bot_id?: SortOrder
    type?: SortOrder
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type bot_stats_votes_pmCountOrderByAggregateInput = {
    bot_id?: SortOrder
    votes?: SortOrder
    epoch?: SortOrder
    lynxtag?: SortOrder
  }

  export type bot_stats_votes_pmAvgOrderByAggregateInput = {
    bot_id?: SortOrder
    votes?: SortOrder
    epoch?: SortOrder
  }

  export type bot_stats_votes_pmMaxOrderByAggregateInput = {
    bot_id?: SortOrder
    votes?: SortOrder
    epoch?: SortOrder
    lynxtag?: SortOrder
  }

  export type bot_stats_votes_pmMinOrderByAggregateInput = {
    bot_id?: SortOrder
    votes?: SortOrder
    epoch?: SortOrder
    lynxtag?: SortOrder
  }

  export type bot_stats_votes_pmSumOrderByAggregateInput = {
    bot_id?: SortOrder
    votes?: SortOrder
    epoch?: SortOrder
  }

  export type Bot_list_tagsRelationFilter = {
    is?: bot_list_tagsWhereInput
    isNot?: bot_list_tagsWhereInput
  }

  export type bot_tagsCountOrderByAggregateInput = {
    bot_id?: SortOrder
    tag?: SortOrder
    id?: SortOrder
    lynxtag?: SortOrder
  }

  export type bot_tagsAvgOrderByAggregateInput = {
    bot_id?: SortOrder
    id?: SortOrder
  }

  export type bot_tagsMaxOrderByAggregateInput = {
    bot_id?: SortOrder
    tag?: SortOrder
    id?: SortOrder
    lynxtag?: SortOrder
  }

  export type bot_tagsMinOrderByAggregateInput = {
    bot_id?: SortOrder
    tag?: SortOrder
    id?: SortOrder
    lynxtag?: SortOrder
  }

  export type bot_tagsSumOrderByAggregateInput = {
    bot_id?: SortOrder
    id?: SortOrder
  }

  export type DateTimeNullableListFilter<$PrismaModel = never> = {
    equals?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    has?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    hasEvery?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    hasSome?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type UsersRelationFilter = {
    is?: usersWhereInput
    isNot?: usersWhereInput
  }

  export type bot_votersCountOrderByAggregateInput = {
    bot_id?: SortOrder
    user_id?: SortOrder
    timestamps?: SortOrder
    lynxtag?: SortOrder
  }

  export type bot_votersAvgOrderByAggregateInput = {
    bot_id?: SortOrder
    user_id?: SortOrder
  }

  export type bot_votersMaxOrderByAggregateInput = {
    bot_id?: SortOrder
    user_id?: SortOrder
    lynxtag?: SortOrder
  }

  export type bot_votersMinOrderByAggregateInput = {
    bot_id?: SortOrder
    user_id?: SortOrder
    lynxtag?: SortOrder
  }

  export type bot_votersSumOrderByAggregateInput = {
    bot_id?: SortOrder
    user_id?: SortOrder
  }

  export type IntNullableListFilter<$PrismaModel = never> = {
    equals?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    has?: number | IntFieldRefInput<$PrismaModel> | null
    hasEvery?: number[] | ListIntFieldRefInput<$PrismaModel>
    hasSome?: number[] | ListIntFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type Bot_commandsListRelationFilter = {
    every?: bot_commandsWhereInput
    some?: bot_commandsWhereInput
    none?: bot_commandsWhereInput
  }

  export type Bot_eventsListRelationFilter = {
    every?: bot_eventsWhereInput
    some?: bot_eventsWhereInput
    none?: bot_eventsWhereInput
  }

  export type Bot_ownerListRelationFilter = {
    every?: bot_ownerWhereInput
    some?: bot_ownerWhereInput
    none?: bot_ownerWhereInput
  }

  export type Bot_promotionsListRelationFilter = {
    every?: bot_promotionsWhereInput
    some?: bot_promotionsWhereInput
    none?: bot_promotionsWhereInput
  }

  export type bot_commandsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type bot_eventsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type bot_ownerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type bot_promotionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type botsCountOrderByAggregateInput = {
    bot_id?: SortOrder
    votes?: SortOrder
    guild_count?: SortOrder
    shard_count?: SortOrder
    bot_library?: SortOrder
    webhook?: SortOrder
    description?: SortOrder
    long_description?: SortOrder
    prefix?: SortOrder
    api_token?: SortOrder
    banner_card?: SortOrder
    created_at?: SortOrder
    invite?: SortOrder
    features?: SortOrder
    invite_amount?: SortOrder
    user_count?: SortOrder
    css?: SortOrder
    shards?: SortOrder
    username_cached?: SortOrder
    state?: SortOrder
    long_description_type?: SortOrder
    verifier?: SortOrder
    last_stats_post?: SortOrder
    webhook_secret?: SortOrder
    webhook_type?: SortOrder
    di_text?: SortOrder
    id?: SortOrder
    banner_page?: SortOrder
    total_votes?: SortOrder
    client_id?: SortOrder
    flags?: SortOrder
    uptime_checks_total?: SortOrder
    uptime_checks_failed?: SortOrder
    page_style?: SortOrder
    webhook_hmac_only?: SortOrder
    last_updated_at?: SortOrder
    avatar_cached?: SortOrder
    disc_cached?: SortOrder
    extra_links?: SortOrder
    lynxtag?: SortOrder
  }

  export type botsAvgOrderByAggregateInput = {
    bot_id?: SortOrder
    votes?: SortOrder
    guild_count?: SortOrder
    shard_count?: SortOrder
    invite_amount?: SortOrder
    user_count?: SortOrder
    shards?: SortOrder
    state?: SortOrder
    long_description_type?: SortOrder
    verifier?: SortOrder
    webhook_type?: SortOrder
    id?: SortOrder
    total_votes?: SortOrder
    client_id?: SortOrder
    flags?: SortOrder
    uptime_checks_total?: SortOrder
    uptime_checks_failed?: SortOrder
    page_style?: SortOrder
  }

  export type botsMaxOrderByAggregateInput = {
    bot_id?: SortOrder
    votes?: SortOrder
    guild_count?: SortOrder
    shard_count?: SortOrder
    bot_library?: SortOrder
    webhook?: SortOrder
    description?: SortOrder
    long_description?: SortOrder
    prefix?: SortOrder
    api_token?: SortOrder
    banner_card?: SortOrder
    created_at?: SortOrder
    invite?: SortOrder
    invite_amount?: SortOrder
    user_count?: SortOrder
    css?: SortOrder
    username_cached?: SortOrder
    state?: SortOrder
    long_description_type?: SortOrder
    verifier?: SortOrder
    last_stats_post?: SortOrder
    webhook_secret?: SortOrder
    webhook_type?: SortOrder
    di_text?: SortOrder
    id?: SortOrder
    banner_page?: SortOrder
    total_votes?: SortOrder
    client_id?: SortOrder
    uptime_checks_total?: SortOrder
    uptime_checks_failed?: SortOrder
    page_style?: SortOrder
    webhook_hmac_only?: SortOrder
    last_updated_at?: SortOrder
    avatar_cached?: SortOrder
    disc_cached?: SortOrder
    lynxtag?: SortOrder
  }

  export type botsMinOrderByAggregateInput = {
    bot_id?: SortOrder
    votes?: SortOrder
    guild_count?: SortOrder
    shard_count?: SortOrder
    bot_library?: SortOrder
    webhook?: SortOrder
    description?: SortOrder
    long_description?: SortOrder
    prefix?: SortOrder
    api_token?: SortOrder
    banner_card?: SortOrder
    created_at?: SortOrder
    invite?: SortOrder
    invite_amount?: SortOrder
    user_count?: SortOrder
    css?: SortOrder
    username_cached?: SortOrder
    state?: SortOrder
    long_description_type?: SortOrder
    verifier?: SortOrder
    last_stats_post?: SortOrder
    webhook_secret?: SortOrder
    webhook_type?: SortOrder
    di_text?: SortOrder
    id?: SortOrder
    banner_page?: SortOrder
    total_votes?: SortOrder
    client_id?: SortOrder
    uptime_checks_total?: SortOrder
    uptime_checks_failed?: SortOrder
    page_style?: SortOrder
    webhook_hmac_only?: SortOrder
    last_updated_at?: SortOrder
    avatar_cached?: SortOrder
    disc_cached?: SortOrder
    lynxtag?: SortOrder
  }

  export type botsSumOrderByAggregateInput = {
    bot_id?: SortOrder
    votes?: SortOrder
    guild_count?: SortOrder
    shard_count?: SortOrder
    invite_amount?: SortOrder
    user_count?: SortOrder
    shards?: SortOrder
    state?: SortOrder
    long_description_type?: SortOrder
    verifier?: SortOrder
    webhook_type?: SortOrder
    id?: SortOrder
    total_votes?: SortOrder
    client_id?: SortOrder
    flags?: SortOrder
    uptime_checks_total?: SortOrder
    uptime_checks_failed?: SortOrder
    page_style?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UsersNullableRelationFilter = {
    is?: usersWhereInput | null
    isNot?: usersWhereInput | null
  }

  export type extra_dataCountOrderByAggregateInput = {
    name?: SortOrder
    value?: SortOrder
    user_id?: SortOrder
    lynxtag?: SortOrder
  }

  export type extra_dataAvgOrderByAggregateInput = {
    user_id?: SortOrder
  }

  export type extra_dataMaxOrderByAggregateInput = {
    name?: SortOrder
    user_id?: SortOrder
    lynxtag?: SortOrder
  }

  export type extra_dataMinOrderByAggregateInput = {
    name?: SortOrder
    user_id?: SortOrder
    lynxtag?: SortOrder
  }

  export type extra_dataSumOrderByAggregateInput = {
    user_id?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type featuresCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    viewed_as?: SortOrder
    lynxtag?: SortOrder
  }

  export type featuresMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    viewed_as?: SortOrder
    lynxtag?: SortOrder
  }

  export type featuresMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    viewed_as?: SortOrder
    lynxtag?: SortOrder
  }

  export type frostpaw_clientsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    domain?: SortOrder
    privacy_policy?: SortOrder
    secret?: SortOrder
    owner_id?: SortOrder
    lynxtag?: SortOrder
    verified?: SortOrder
  }

  export type frostpaw_clientsAvgOrderByAggregateInput = {
    owner_id?: SortOrder
  }

  export type frostpaw_clientsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    domain?: SortOrder
    privacy_policy?: SortOrder
    secret?: SortOrder
    owner_id?: SortOrder
    lynxtag?: SortOrder
    verified?: SortOrder
  }

  export type frostpaw_clientsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    domain?: SortOrder
    privacy_policy?: SortOrder
    secret?: SortOrder
    owner_id?: SortOrder
    lynxtag?: SortOrder
    verified?: SortOrder
  }

  export type frostpaw_clientsSumOrderByAggregateInput = {
    owner_id?: SortOrder
  }

  export type leave_of_absenceCountOrderByAggregateInput = {
    reason?: SortOrder
    start_date?: SortOrder
    user_id?: SortOrder
    id?: SortOrder
    lynxtag?: SortOrder
  }

  export type leave_of_absenceAvgOrderByAggregateInput = {
    user_id?: SortOrder
    id?: SortOrder
  }

  export type leave_of_absenceMaxOrderByAggregateInput = {
    reason?: SortOrder
    start_date?: SortOrder
    user_id?: SortOrder
    id?: SortOrder
    lynxtag?: SortOrder
  }

  export type leave_of_absenceMinOrderByAggregateInput = {
    reason?: SortOrder
    start_date?: SortOrder
    user_id?: SortOrder
    id?: SortOrder
    lynxtag?: SortOrder
  }

  export type leave_of_absenceSumOrderByAggregateInput = {
    user_id?: SortOrder
    id?: SortOrder
  }

  export type lynx_appsCountOrderByAggregateInput = {
    user_id?: SortOrder
    app_id?: SortOrder
    questions?: SortOrder
    answers?: SortOrder
    app_version?: SortOrder
    created_at?: SortOrder
    lynxtag?: SortOrder
  }

  export type lynx_appsAvgOrderByAggregateInput = {
    user_id?: SortOrder
    app_version?: SortOrder
  }

  export type lynx_appsMaxOrderByAggregateInput = {
    user_id?: SortOrder
    app_id?: SortOrder
    app_version?: SortOrder
    created_at?: SortOrder
    lynxtag?: SortOrder
  }

  export type lynx_appsMinOrderByAggregateInput = {
    user_id?: SortOrder
    app_id?: SortOrder
    app_version?: SortOrder
    created_at?: SortOrder
    lynxtag?: SortOrder
  }

  export type lynx_appsSumOrderByAggregateInput = {
    user_id?: SortOrder
    app_version?: SortOrder
  }

  export type lynx_dataCountOrderByAggregateInput = {
    default_user_experiments?: SortOrder
    id?: SortOrder
    lynxtag?: SortOrder
  }

  export type lynx_dataAvgOrderByAggregateInput = {
    default_user_experiments?: SortOrder
    id?: SortOrder
  }

  export type lynx_dataMaxOrderByAggregateInput = {
    id?: SortOrder
    lynxtag?: SortOrder
  }

  export type lynx_dataMinOrderByAggregateInput = {
    id?: SortOrder
    lynxtag?: SortOrder
  }

  export type lynx_dataSumOrderByAggregateInput = {
    default_user_experiments?: SortOrder
    id?: SortOrder
  }

  export type lynx_logsCountOrderByAggregateInput = {
    user_id?: SortOrder
    method?: SortOrder
    url?: SortOrder
    status_code?: SortOrder
    request_time?: SortOrder
    lynxtag?: SortOrder
  }

  export type lynx_logsAvgOrderByAggregateInput = {
    user_id?: SortOrder
    status_code?: SortOrder
  }

  export type lynx_logsMaxOrderByAggregateInput = {
    user_id?: SortOrder
    method?: SortOrder
    url?: SortOrder
    status_code?: SortOrder
    request_time?: SortOrder
    lynxtag?: SortOrder
  }

  export type lynx_logsMinOrderByAggregateInput = {
    user_id?: SortOrder
    method?: SortOrder
    url?: SortOrder
    status_code?: SortOrder
    request_time?: SortOrder
    lynxtag?: SortOrder
  }

  export type lynx_logsSumOrderByAggregateInput = {
    user_id?: SortOrder
    status_code?: SortOrder
  }

  export type lynx_notificationsCountOrderByAggregateInput = {
    acked_users?: SortOrder
    message?: SortOrder
    type?: SortOrder
    id?: SortOrder
    staff_only?: SortOrder
    lynxtag?: SortOrder
  }

  export type lynx_notificationsAvgOrderByAggregateInput = {
    acked_users?: SortOrder
  }

  export type lynx_notificationsMaxOrderByAggregateInput = {
    message?: SortOrder
    type?: SortOrder
    id?: SortOrder
    staff_only?: SortOrder
    lynxtag?: SortOrder
  }

  export type lynx_notificationsMinOrderByAggregateInput = {
    message?: SortOrder
    type?: SortOrder
    id?: SortOrder
    staff_only?: SortOrder
    lynxtag?: SortOrder
  }

  export type lynx_notificationsSumOrderByAggregateInput = {
    acked_users?: SortOrder
  }

  export type lynx_ratingsCountOrderByAggregateInput = {
    id?: SortOrder
    feedback?: SortOrder
    username_cached?: SortOrder
    user_id?: SortOrder
    page?: SortOrder
    lynxtag?: SortOrder
  }

  export type lynx_ratingsAvgOrderByAggregateInput = {
    user_id?: SortOrder
  }

  export type lynx_ratingsMaxOrderByAggregateInput = {
    id?: SortOrder
    feedback?: SortOrder
    username_cached?: SortOrder
    user_id?: SortOrder
    page?: SortOrder
    lynxtag?: SortOrder
  }

  export type lynx_ratingsMinOrderByAggregateInput = {
    id?: SortOrder
    feedback?: SortOrder
    username_cached?: SortOrder
    user_id?: SortOrder
    page?: SortOrder
    lynxtag?: SortOrder
  }

  export type lynx_ratingsSumOrderByAggregateInput = {
    user_id?: SortOrder
  }

  export type Lynx_surveysRelationFilter = {
    is?: lynx_surveysWhereInput
    isNot?: lynx_surveysWhereInput
  }

  export type lynx_survey_responsesCountOrderByAggregateInput = {
    id?: SortOrder
    questions?: SortOrder
    answers?: SortOrder
    username_cached?: SortOrder
    user_id?: SortOrder
    survey_id?: SortOrder
    lynxtag?: SortOrder
  }

  export type lynx_survey_responsesAvgOrderByAggregateInput = {
    user_id?: SortOrder
  }

  export type lynx_survey_responsesMaxOrderByAggregateInput = {
    id?: SortOrder
    username_cached?: SortOrder
    user_id?: SortOrder
    survey_id?: SortOrder
    lynxtag?: SortOrder
  }

  export type lynx_survey_responsesMinOrderByAggregateInput = {
    id?: SortOrder
    username_cached?: SortOrder
    user_id?: SortOrder
    survey_id?: SortOrder
    lynxtag?: SortOrder
  }

  export type lynx_survey_responsesSumOrderByAggregateInput = {
    user_id?: SortOrder
  }

  export type Lynx_survey_responsesListRelationFilter = {
    every?: lynx_survey_responsesWhereInput
    some?: lynx_survey_responsesWhereInput
    none?: lynx_survey_responsesWhereInput
  }

  export type lynx_survey_responsesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type lynx_surveysCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    questions?: SortOrder
    created_at?: SortOrder
    lynxtag?: SortOrder
  }

  export type lynx_surveysMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    created_at?: SortOrder
    lynxtag?: SortOrder
  }

  export type lynx_surveysMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    created_at?: SortOrder
    lynxtag?: SortOrder
  }

  export type migrationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    app_name?: SortOrder
    ran_on?: SortOrder
    lynxtag?: SortOrder
  }

  export type migrationAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type migrationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    app_name?: SortOrder
    ran_on?: SortOrder
    lynxtag?: SortOrder
  }

  export type migrationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    app_name?: SortOrder
    ran_on?: SortOrder
    lynxtag?: SortOrder
  }

  export type migrationSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type piccolo_userCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    email?: SortOrder
    active?: SortOrder
    admin?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    superuser?: SortOrder
    last_login?: SortOrder
    lynxtag?: SortOrder
  }

  export type piccolo_userAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type piccolo_userMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    email?: SortOrder
    active?: SortOrder
    admin?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    superuser?: SortOrder
    last_login?: SortOrder
    lynxtag?: SortOrder
  }

  export type piccolo_userMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    email?: SortOrder
    active?: SortOrder
    admin?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    superuser?: SortOrder
    last_login?: SortOrder
    lynxtag?: SortOrder
  }

  export type piccolo_userSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type platform_mapCountOrderByAggregateInput = {
    fates_id?: SortOrder
    platform_id?: SortOrder
    lynxtag?: SortOrder
  }

  export type platform_mapAvgOrderByAggregateInput = {
    fates_id?: SortOrder
  }

  export type platform_mapMaxOrderByAggregateInput = {
    fates_id?: SortOrder
    platform_id?: SortOrder
    lynxtag?: SortOrder
  }

  export type platform_mapMinOrderByAggregateInput = {
    fates_id?: SortOrder
    platform_id?: SortOrder
    lynxtag?: SortOrder
  }

  export type platform_mapSumOrderByAggregateInput = {
    fates_id?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type push_notificationsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    token?: SortOrder
  }

  export type push_notificationsAvgOrderByAggregateInput = {
    user_id?: SortOrder
  }

  export type push_notificationsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    token?: SortOrder
  }

  export type push_notificationsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    token?: SortOrder
  }

  export type push_notificationsSumOrderByAggregateInput = {
    user_id?: SortOrder
  }

  export type ReviewsRelationFilter = {
    is?: reviewsWhereInput
    isNot?: reviewsWhereInput
  }

  export type review_votesIdUser_idCompoundUniqueInput = {
    id: string
    user_id: bigint | number
  }

  export type review_votesCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    upvote?: SortOrder
    lynxtag?: SortOrder
  }

  export type review_votesAvgOrderByAggregateInput = {
    user_id?: SortOrder
  }

  export type review_votesMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    upvote?: SortOrder
    lynxtag?: SortOrder
  }

  export type review_votesMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    upvote?: SortOrder
    lynxtag?: SortOrder
  }

  export type review_votesSumOrderByAggregateInput = {
    user_id?: SortOrder
  }

  export type UuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type Review_votesListRelationFilter = {
    every?: review_votesWhereInput
    some?: review_votesWhereInput
    none?: review_votesWhereInput
  }

  export type ReviewsNullableRelationFilter = {
    is?: reviewsWhereInput | null
    isNot?: reviewsWhereInput | null
  }

  export type ReviewsListRelationFilter = {
    every?: reviewsWhereInput
    some?: reviewsWhereInput
    none?: reviewsWhereInput
  }

  export type review_votesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type reviewsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type reviewsCountOrderByAggregateInput = {
    id?: SortOrder
    target_id?: SortOrder
    user_id?: SortOrder
    star_rating?: SortOrder
    review_text?: SortOrder
    flagged?: SortOrder
    epoch?: SortOrder
    target_type?: SortOrder
    parent_id?: SortOrder
    lynxtag?: SortOrder
  }

  export type reviewsAvgOrderByAggregateInput = {
    target_id?: SortOrder
    user_id?: SortOrder
    star_rating?: SortOrder
    epoch?: SortOrder
    target_type?: SortOrder
  }

  export type reviewsMaxOrderByAggregateInput = {
    id?: SortOrder
    target_id?: SortOrder
    user_id?: SortOrder
    star_rating?: SortOrder
    review_text?: SortOrder
    flagged?: SortOrder
    target_type?: SortOrder
    parent_id?: SortOrder
    lynxtag?: SortOrder
  }

  export type reviewsMinOrderByAggregateInput = {
    id?: SortOrder
    target_id?: SortOrder
    user_id?: SortOrder
    star_rating?: SortOrder
    review_text?: SortOrder
    flagged?: SortOrder
    target_type?: SortOrder
    parent_id?: SortOrder
    lynxtag?: SortOrder
  }

  export type reviewsSumOrderByAggregateInput = {
    target_id?: SortOrder
    user_id?: SortOrder
    star_rating?: SortOrder
    epoch?: SortOrder
    target_type?: SortOrder
  }

  export type UuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type ServersRelationFilter = {
    is?: serversWhereInput
    isNot?: serversWhereInput
  }

  export type server_audit_logsCountOrderByAggregateInput = {
    guild_id?: SortOrder
    user_id?: SortOrder
    username?: SortOrder
    user_guild_perms?: SortOrder
    field?: SortOrder
    value?: SortOrder
    action_time?: SortOrder
    action_id?: SortOrder
    lynxtag?: SortOrder
  }

  export type server_audit_logsAvgOrderByAggregateInput = {
    guild_id?: SortOrder
    user_id?: SortOrder
  }

  export type server_audit_logsMaxOrderByAggregateInput = {
    guild_id?: SortOrder
    user_id?: SortOrder
    username?: SortOrder
    user_guild_perms?: SortOrder
    field?: SortOrder
    value?: SortOrder
    action_time?: SortOrder
    action_id?: SortOrder
    lynxtag?: SortOrder
  }

  export type server_audit_logsMinOrderByAggregateInput = {
    guild_id?: SortOrder
    user_id?: SortOrder
    username?: SortOrder
    user_guild_perms?: SortOrder
    field?: SortOrder
    value?: SortOrder
    action_time?: SortOrder
    action_id?: SortOrder
    lynxtag?: SortOrder
  }

  export type server_audit_logsSumOrderByAggregateInput = {
    guild_id?: SortOrder
    user_id?: SortOrder
  }

  export type server_tagsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    owner_guild?: SortOrder
    iconify_data?: SortOrder
    lynxtag?: SortOrder
  }

  export type server_tagsAvgOrderByAggregateInput = {
    owner_guild?: SortOrder
  }

  export type server_tagsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    owner_guild?: SortOrder
    iconify_data?: SortOrder
    lynxtag?: SortOrder
  }

  export type server_tagsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    owner_guild?: SortOrder
    iconify_data?: SortOrder
    lynxtag?: SortOrder
  }

  export type server_tagsSumOrderByAggregateInput = {
    owner_guild?: SortOrder
  }

  export type server_votersCountOrderByAggregateInput = {
    guild_id?: SortOrder
    user_id?: SortOrder
    timestamps?: SortOrder
    lynxtag?: SortOrder
  }

  export type server_votersAvgOrderByAggregateInput = {
    guild_id?: SortOrder
    user_id?: SortOrder
  }

  export type server_votersMaxOrderByAggregateInput = {
    guild_id?: SortOrder
    user_id?: SortOrder
    lynxtag?: SortOrder
  }

  export type server_votersMinOrderByAggregateInput = {
    guild_id?: SortOrder
    user_id?: SortOrder
    lynxtag?: SortOrder
  }

  export type server_votersSumOrderByAggregateInput = {
    guild_id?: SortOrder
    user_id?: SortOrder
  }

  export type Server_audit_logsListRelationFilter = {
    every?: server_audit_logsWhereInput
    some?: server_audit_logsWhereInput
    none?: server_audit_logsWhereInput
  }

  export type server_audit_logsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type serversCountOrderByAggregateInput = {
    guild_id?: SortOrder
    votes?: SortOrder
    webhook?: SortOrder
    description?: SortOrder
    long_description?: SortOrder
    css?: SortOrder
    api_token?: SortOrder
    invite_amount?: SortOrder
    invite_url?: SortOrder
    name_cached?: SortOrder
    long_description_type?: SortOrder
    state?: SortOrder
    created_at?: SortOrder
    avatar_cached?: SortOrder
    invite_channel?: SortOrder
    guild_count?: SortOrder
    banner_card?: SortOrder
    banner_page?: SortOrder
    webhook_secret?: SortOrder
    webhook_type?: SortOrder
    total_votes?: SortOrder
    tags?: SortOrder
    owner_id?: SortOrder
    flags?: SortOrder
    autorole_votes?: SortOrder
    whitelist_form?: SortOrder
    webhook_hmac_only?: SortOrder
    old_state?: SortOrder
    user_whitelist?: SortOrder
    user_blacklist?: SortOrder
    extra_links?: SortOrder
    lynxtag?: SortOrder
  }

  export type serversAvgOrderByAggregateInput = {
    guild_id?: SortOrder
    votes?: SortOrder
    invite_amount?: SortOrder
    long_description_type?: SortOrder
    state?: SortOrder
    invite_channel?: SortOrder
    guild_count?: SortOrder
    webhook_type?: SortOrder
    total_votes?: SortOrder
    owner_id?: SortOrder
    flags?: SortOrder
    autorole_votes?: SortOrder
    old_state?: SortOrder
    user_whitelist?: SortOrder
    user_blacklist?: SortOrder
  }

  export type serversMaxOrderByAggregateInput = {
    guild_id?: SortOrder
    votes?: SortOrder
    webhook?: SortOrder
    description?: SortOrder
    long_description?: SortOrder
    css?: SortOrder
    api_token?: SortOrder
    invite_amount?: SortOrder
    invite_url?: SortOrder
    name_cached?: SortOrder
    long_description_type?: SortOrder
    state?: SortOrder
    created_at?: SortOrder
    avatar_cached?: SortOrder
    invite_channel?: SortOrder
    guild_count?: SortOrder
    banner_card?: SortOrder
    banner_page?: SortOrder
    webhook_secret?: SortOrder
    webhook_type?: SortOrder
    total_votes?: SortOrder
    owner_id?: SortOrder
    whitelist_form?: SortOrder
    webhook_hmac_only?: SortOrder
    old_state?: SortOrder
    lynxtag?: SortOrder
  }

  export type serversMinOrderByAggregateInput = {
    guild_id?: SortOrder
    votes?: SortOrder
    webhook?: SortOrder
    description?: SortOrder
    long_description?: SortOrder
    css?: SortOrder
    api_token?: SortOrder
    invite_amount?: SortOrder
    invite_url?: SortOrder
    name_cached?: SortOrder
    long_description_type?: SortOrder
    state?: SortOrder
    created_at?: SortOrder
    avatar_cached?: SortOrder
    invite_channel?: SortOrder
    guild_count?: SortOrder
    banner_card?: SortOrder
    banner_page?: SortOrder
    webhook_secret?: SortOrder
    webhook_type?: SortOrder
    total_votes?: SortOrder
    owner_id?: SortOrder
    whitelist_form?: SortOrder
    webhook_hmac_only?: SortOrder
    old_state?: SortOrder
    lynxtag?: SortOrder
  }

  export type serversSumOrderByAggregateInput = {
    guild_id?: SortOrder
    votes?: SortOrder
    invite_amount?: SortOrder
    long_description_type?: SortOrder
    state?: SortOrder
    invite_channel?: SortOrder
    guild_count?: SortOrder
    webhook_type?: SortOrder
    total_votes?: SortOrder
    owner_id?: SortOrder
    flags?: SortOrder
    autorole_votes?: SortOrder
    old_state?: SortOrder
    user_whitelist?: SortOrder
    user_blacklist?: SortOrder
  }

  export type sessionsCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    user_id?: SortOrder
    expiry_date?: SortOrder
    max_expiry_date?: SortOrder
    lynxtag?: SortOrder
  }

  export type sessionsAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type sessionsMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    user_id?: SortOrder
    expiry_date?: SortOrder
    max_expiry_date?: SortOrder
    lynxtag?: SortOrder
  }

  export type sessionsMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    user_id?: SortOrder
    expiry_date?: SortOrder
    max_expiry_date?: SortOrder
    lynxtag?: SortOrder
  }

  export type sessionsSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type user_bot_logsCountOrderByAggregateInput = {
    user_id?: SortOrder
    bot_id?: SortOrder
    action_time?: SortOrder
    action?: SortOrder
    context?: SortOrder
    lynxtag?: SortOrder
  }

  export type user_bot_logsAvgOrderByAggregateInput = {
    user_id?: SortOrder
    bot_id?: SortOrder
    action?: SortOrder
  }

  export type user_bot_logsMaxOrderByAggregateInput = {
    user_id?: SortOrder
    bot_id?: SortOrder
    action_time?: SortOrder
    action?: SortOrder
    context?: SortOrder
    lynxtag?: SortOrder
  }

  export type user_bot_logsMinOrderByAggregateInput = {
    user_id?: SortOrder
    bot_id?: SortOrder
    action_time?: SortOrder
    action?: SortOrder
    context?: SortOrder
    lynxtag?: SortOrder
  }

  export type user_bot_logsSumOrderByAggregateInput = {
    user_id?: SortOrder
    bot_id?: SortOrder
    action?: SortOrder
  }

  export type user_connectionsCountOrderByAggregateInput = {
    user_id?: SortOrder
    client_id?: SortOrder
    refresh_token?: SortOrder
    expires_on?: SortOrder
    lynxtag?: SortOrder
  }

  export type user_connectionsAvgOrderByAggregateInput = {
    user_id?: SortOrder
  }

  export type user_connectionsMaxOrderByAggregateInput = {
    user_id?: SortOrder
    client_id?: SortOrder
    refresh_token?: SortOrder
    expires_on?: SortOrder
    lynxtag?: SortOrder
  }

  export type user_connectionsMinOrderByAggregateInput = {
    user_id?: SortOrder
    client_id?: SortOrder
    refresh_token?: SortOrder
    expires_on?: SortOrder
    lynxtag?: SortOrder
  }

  export type user_connectionsSumOrderByAggregateInput = {
    user_id?: SortOrder
  }

  export type user_server_vote_tableCountOrderByAggregateInput = {
    user_id?: SortOrder
    guild_id?: SortOrder
    expires_on?: SortOrder
    lynxtag?: SortOrder
  }

  export type user_server_vote_tableAvgOrderByAggregateInput = {
    user_id?: SortOrder
    guild_id?: SortOrder
  }

  export type user_server_vote_tableMaxOrderByAggregateInput = {
    user_id?: SortOrder
    guild_id?: SortOrder
    expires_on?: SortOrder
    lynxtag?: SortOrder
  }

  export type user_server_vote_tableMinOrderByAggregateInput = {
    user_id?: SortOrder
    guild_id?: SortOrder
    expires_on?: SortOrder
    lynxtag?: SortOrder
  }

  export type user_server_vote_tableSumOrderByAggregateInput = {
    user_id?: SortOrder
    guild_id?: SortOrder
  }

  export type user_vote_tableCountOrderByAggregateInput = {
    user_id?: SortOrder
    bot_id?: SortOrder
    expires_on?: SortOrder
    lynxtag?: SortOrder
  }

  export type user_vote_tableAvgOrderByAggregateInput = {
    user_id?: SortOrder
    bot_id?: SortOrder
  }

  export type user_vote_tableMaxOrderByAggregateInput = {
    user_id?: SortOrder
    bot_id?: SortOrder
    expires_on?: SortOrder
    lynxtag?: SortOrder
  }

  export type user_vote_tableMinOrderByAggregateInput = {
    user_id?: SortOrder
    bot_id?: SortOrder
    expires_on?: SortOrder
    lynxtag?: SortOrder
  }

  export type user_vote_tableSumOrderByAggregateInput = {
    user_id?: SortOrder
    bot_id?: SortOrder
  }

  export type Bot_votersListRelationFilter = {
    every?: bot_votersWhereInput
    some?: bot_votersWhereInput
    none?: bot_votersWhereInput
  }

  export type Extra_dataListRelationFilter = {
    every?: extra_dataWhereInput
    some?: extra_dataWhereInput
    none?: extra_dataWhereInput
  }

  export type Frostpaw_clientsListRelationFilter = {
    every?: frostpaw_clientsWhereInput
    some?: frostpaw_clientsWhereInput
    none?: frostpaw_clientsWhereInput
  }

  export type Leave_of_absenceListRelationFilter = {
    every?: leave_of_absenceWhereInput
    some?: leave_of_absenceWhereInput
    none?: leave_of_absenceWhereInput
  }

  export type Lynx_appsListRelationFilter = {
    every?: lynx_appsWhereInput
    some?: lynx_appsWhereInput
    none?: lynx_appsWhereInput
  }

  export type Lynx_logsListRelationFilter = {
    every?: lynx_logsWhereInput
    some?: lynx_logsWhereInput
    none?: lynx_logsWhereInput
  }

  export type Lynx_ratingsListRelationFilter = {
    every?: lynx_ratingsWhereInput
    some?: lynx_ratingsWhereInput
    none?: lynx_ratingsWhereInput
  }

  export type Push_notificationsListRelationFilter = {
    every?: push_notificationsWhereInput
    some?: push_notificationsWhereInput
    none?: push_notificationsWhereInput
  }

  export type Server_votersListRelationFilter = {
    every?: server_votersWhereInput
    some?: server_votersWhereInput
    none?: server_votersWhereInput
  }

  export type ServersListRelationFilter = {
    every?: serversWhereInput
    some?: serversWhereInput
    none?: serversWhereInput
  }

  export type User_bot_logsListRelationFilter = {
    every?: user_bot_logsWhereInput
    some?: user_bot_logsWhereInput
    none?: user_bot_logsWhereInput
  }

  export type User_connectionsListRelationFilter = {
    every?: user_connectionsWhereInput
    some?: user_connectionsWhereInput
    none?: user_connectionsWhereInput
  }

  export type User_server_vote_tableNullableRelationFilter = {
    is?: user_server_vote_tableWhereInput | null
    isNot?: user_server_vote_tableWhereInput | null
  }

  export type User_vote_tableNullableRelationFilter = {
    is?: user_vote_tableWhereInput | null
    isNot?: user_vote_tableWhereInput | null
  }

  export type bot_votersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type extra_dataOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type frostpaw_clientsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type leave_of_absenceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type lynx_appsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type lynx_logsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type lynx_ratingsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type push_notificationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type server_votersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type serversOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type user_bot_logsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type user_connectionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usersCountOrderByAggregateInput = {
    user_id?: SortOrder
    api_token?: SortOrder
    description?: SortOrder
    badges?: SortOrder
    username?: SortOrder
    user_css?: SortOrder
    state?: SortOrder
    coins?: SortOrder
    id?: SortOrder
    site_lang?: SortOrder
    profile_css?: SortOrder
    vote_reminders?: SortOrder
    vote_reminder_channel?: SortOrder
    staff_verify_code?: SortOrder
    vote_reminders_last_acked?: SortOrder
    vote_reminders_servers?: SortOrder
    vote_reminders_servers_last_acked?: SortOrder
    vote_reminder_servers_channel?: SortOrder
    experiments?: SortOrder
    flags?: SortOrder
    extra_links?: SortOrder
    supabase_id?: SortOrder
    totp_shared_key?: SortOrder
    staff_password?: SortOrder
    lynxtag?: SortOrder
  }

  export type usersAvgOrderByAggregateInput = {
    user_id?: SortOrder
    state?: SortOrder
    coins?: SortOrder
    id?: SortOrder
    vote_reminders?: SortOrder
    vote_reminder_channel?: SortOrder
    vote_reminders_servers?: SortOrder
    vote_reminder_servers_channel?: SortOrder
    experiments?: SortOrder
    flags?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    user_id?: SortOrder
    api_token?: SortOrder
    description?: SortOrder
    username?: SortOrder
    user_css?: SortOrder
    state?: SortOrder
    coins?: SortOrder
    id?: SortOrder
    site_lang?: SortOrder
    profile_css?: SortOrder
    vote_reminder_channel?: SortOrder
    staff_verify_code?: SortOrder
    vote_reminders_last_acked?: SortOrder
    vote_reminders_servers_last_acked?: SortOrder
    vote_reminder_servers_channel?: SortOrder
    supabase_id?: SortOrder
    totp_shared_key?: SortOrder
    staff_password?: SortOrder
    lynxtag?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    user_id?: SortOrder
    api_token?: SortOrder
    description?: SortOrder
    username?: SortOrder
    user_css?: SortOrder
    state?: SortOrder
    coins?: SortOrder
    id?: SortOrder
    site_lang?: SortOrder
    profile_css?: SortOrder
    vote_reminder_channel?: SortOrder
    staff_verify_code?: SortOrder
    vote_reminders_last_acked?: SortOrder
    vote_reminders_servers_last_acked?: SortOrder
    vote_reminder_servers_channel?: SortOrder
    supabase_id?: SortOrder
    totp_shared_key?: SortOrder
    staff_password?: SortOrder
    lynxtag?: SortOrder
  }

  export type usersSumOrderByAggregateInput = {
    user_id?: SortOrder
    state?: SortOrder
    coins?: SortOrder
    id?: SortOrder
    vote_reminders?: SortOrder
    vote_reminder_channel?: SortOrder
    vote_reminders_servers?: SortOrder
    vote_reminder_servers_channel?: SortOrder
    experiments?: SortOrder
    flags?: SortOrder
  }

  export type vanityCountOrderByAggregateInput = {
    type?: SortOrder
    vanity_url?: SortOrder
    redirect?: SortOrder
    lynxtag?: SortOrder
  }

  export type vanityAvgOrderByAggregateInput = {
    type?: SortOrder
    redirect?: SortOrder
  }

  export type vanityMaxOrderByAggregateInput = {
    type?: SortOrder
    vanity_url?: SortOrder
    redirect?: SortOrder
    lynxtag?: SortOrder
  }

  export type vanityMinOrderByAggregateInput = {
    type?: SortOrder
    vanity_url?: SortOrder
    redirect?: SortOrder
    lynxtag?: SortOrder
  }

  export type vanitySumOrderByAggregateInput = {
    type?: SortOrder
    redirect?: SortOrder
  }

  export type ws_eventsCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    ts?: SortOrder
    event?: SortOrder
    lynxtag?: SortOrder
  }

  export type ws_eventsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ws_eventsMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    ts?: SortOrder
    lynxtag?: SortOrder
  }

  export type ws_eventsMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    ts?: SortOrder
    lynxtag?: SortOrder
  }

  export type ws_eventsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type bot_commandsCreategroupsInput = {
    set: string[]
  }

  export type bot_commandsCreateargsInput = {
    set: string[]
  }

  export type bot_commandsCreateexamplesInput = {
    set: string[]
  }

  export type bot_commandsCreatenotesInput = {
    set: string[]
  }

  export type botsCreateNestedOneWithoutBot_commandsInput = {
    create?: XOR<botsCreateWithoutBot_commandsInput, botsUncheckedCreateWithoutBot_commandsInput>
    connectOrCreate?: botsCreateOrConnectWithoutBot_commandsInput
    connect?: botsWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type bot_commandsUpdategroupsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type bot_commandsUpdateargsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type bot_commandsUpdateexamplesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type bot_commandsUpdatenotesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type botsUpdateOneRequiredWithoutBot_commandsNestedInput = {
    create?: XOR<botsCreateWithoutBot_commandsInput, botsUncheckedCreateWithoutBot_commandsInput>
    connectOrCreate?: botsCreateOrConnectWithoutBot_commandsInput
    upsert?: botsUpsertWithoutBot_commandsInput
    connect?: botsWhereUniqueInput
    update?: XOR<XOR<botsUpdateToOneWithWhereWithoutBot_commandsInput, botsUpdateWithoutBot_commandsInput>, botsUncheckedUpdateWithoutBot_commandsInput>
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type botsCreateNestedOneWithoutBot_eventsInput = {
    create?: XOR<botsCreateWithoutBot_eventsInput, botsUncheckedCreateWithoutBot_eventsInput>
    connectOrCreate?: botsCreateOrConnectWithoutBot_eventsInput
    connect?: botsWhereUniqueInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type botsUpdateOneRequiredWithoutBot_eventsNestedInput = {
    create?: XOR<botsCreateWithoutBot_eventsInput, botsUncheckedCreateWithoutBot_eventsInput>
    connectOrCreate?: botsCreateOrConnectWithoutBot_eventsInput
    upsert?: botsUpsertWithoutBot_eventsInput
    connect?: botsWhereUniqueInput
    update?: XOR<XOR<botsUpdateToOneWithWhereWithoutBot_eventsInput, botsUpdateWithoutBot_eventsInput>, botsUncheckedUpdateWithoutBot_eventsInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type bot_tagsCreateNestedManyWithoutBot_list_tagsInput = {
    create?: XOR<bot_tagsCreateWithoutBot_list_tagsInput, bot_tagsUncheckedCreateWithoutBot_list_tagsInput> | bot_tagsCreateWithoutBot_list_tagsInput[] | bot_tagsUncheckedCreateWithoutBot_list_tagsInput[]
    connectOrCreate?: bot_tagsCreateOrConnectWithoutBot_list_tagsInput | bot_tagsCreateOrConnectWithoutBot_list_tagsInput[]
    createMany?: bot_tagsCreateManyBot_list_tagsInputEnvelope
    connect?: bot_tagsWhereUniqueInput | bot_tagsWhereUniqueInput[]
  }

  export type bot_tagsUncheckedCreateNestedManyWithoutBot_list_tagsInput = {
    create?: XOR<bot_tagsCreateWithoutBot_list_tagsInput, bot_tagsUncheckedCreateWithoutBot_list_tagsInput> | bot_tagsCreateWithoutBot_list_tagsInput[] | bot_tagsUncheckedCreateWithoutBot_list_tagsInput[]
    connectOrCreate?: bot_tagsCreateOrConnectWithoutBot_list_tagsInput | bot_tagsCreateOrConnectWithoutBot_list_tagsInput[]
    createMany?: bot_tagsCreateManyBot_list_tagsInputEnvelope
    connect?: bot_tagsWhereUniqueInput | bot_tagsWhereUniqueInput[]
  }

  export type bot_tagsUpdateManyWithoutBot_list_tagsNestedInput = {
    create?: XOR<bot_tagsCreateWithoutBot_list_tagsInput, bot_tagsUncheckedCreateWithoutBot_list_tagsInput> | bot_tagsCreateWithoutBot_list_tagsInput[] | bot_tagsUncheckedCreateWithoutBot_list_tagsInput[]
    connectOrCreate?: bot_tagsCreateOrConnectWithoutBot_list_tagsInput | bot_tagsCreateOrConnectWithoutBot_list_tagsInput[]
    upsert?: bot_tagsUpsertWithWhereUniqueWithoutBot_list_tagsInput | bot_tagsUpsertWithWhereUniqueWithoutBot_list_tagsInput[]
    createMany?: bot_tagsCreateManyBot_list_tagsInputEnvelope
    set?: bot_tagsWhereUniqueInput | bot_tagsWhereUniqueInput[]
    disconnect?: bot_tagsWhereUniqueInput | bot_tagsWhereUniqueInput[]
    delete?: bot_tagsWhereUniqueInput | bot_tagsWhereUniqueInput[]
    connect?: bot_tagsWhereUniqueInput | bot_tagsWhereUniqueInput[]
    update?: bot_tagsUpdateWithWhereUniqueWithoutBot_list_tagsInput | bot_tagsUpdateWithWhereUniqueWithoutBot_list_tagsInput[]
    updateMany?: bot_tagsUpdateManyWithWhereWithoutBot_list_tagsInput | bot_tagsUpdateManyWithWhereWithoutBot_list_tagsInput[]
    deleteMany?: bot_tagsScalarWhereInput | bot_tagsScalarWhereInput[]
  }

  export type bot_tagsUncheckedUpdateManyWithoutBot_list_tagsNestedInput = {
    create?: XOR<bot_tagsCreateWithoutBot_list_tagsInput, bot_tagsUncheckedCreateWithoutBot_list_tagsInput> | bot_tagsCreateWithoutBot_list_tagsInput[] | bot_tagsUncheckedCreateWithoutBot_list_tagsInput[]
    connectOrCreate?: bot_tagsCreateOrConnectWithoutBot_list_tagsInput | bot_tagsCreateOrConnectWithoutBot_list_tagsInput[]
    upsert?: bot_tagsUpsertWithWhereUniqueWithoutBot_list_tagsInput | bot_tagsUpsertWithWhereUniqueWithoutBot_list_tagsInput[]
    createMany?: bot_tagsCreateManyBot_list_tagsInputEnvelope
    set?: bot_tagsWhereUniqueInput | bot_tagsWhereUniqueInput[]
    disconnect?: bot_tagsWhereUniqueInput | bot_tagsWhereUniqueInput[]
    delete?: bot_tagsWhereUniqueInput | bot_tagsWhereUniqueInput[]
    connect?: bot_tagsWhereUniqueInput | bot_tagsWhereUniqueInput[]
    update?: bot_tagsUpdateWithWhereUniqueWithoutBot_list_tagsInput | bot_tagsUpdateWithWhereUniqueWithoutBot_list_tagsInput[]
    updateMany?: bot_tagsUpdateManyWithWhereWithoutBot_list_tagsInput | bot_tagsUpdateManyWithWhereWithoutBot_list_tagsInput[]
    deleteMany?: bot_tagsScalarWhereInput | bot_tagsScalarWhereInput[]
  }

  export type botsCreateNestedOneWithoutBot_ownerInput = {
    create?: XOR<botsCreateWithoutBot_ownerInput, botsUncheckedCreateWithoutBot_ownerInput>
    connectOrCreate?: botsCreateOrConnectWithoutBot_ownerInput
    connect?: botsWhereUniqueInput
  }

  export type botsUpdateOneRequiredWithoutBot_ownerNestedInput = {
    create?: XOR<botsCreateWithoutBot_ownerInput, botsUncheckedCreateWithoutBot_ownerInput>
    connectOrCreate?: botsCreateOrConnectWithoutBot_ownerInput
    upsert?: botsUpsertWithoutBot_ownerInput
    connect?: botsWhereUniqueInput
    update?: XOR<XOR<botsUpdateToOneWithWhereWithoutBot_ownerInput, botsUpdateWithoutBot_ownerInput>, botsUncheckedUpdateWithoutBot_ownerInput>
  }

  export type bot_packsCreatebotsInput = {
    set: bigint[] | number[]
  }

  export type bot_packsUpdatebotsInput = {
    set?: bigint[] | number[]
    push?: bigint | number | bigint[] | number[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type botsCreateNestedOneWithoutBot_promotionsInput = {
    create?: XOR<botsCreateWithoutBot_promotionsInput, botsUncheckedCreateWithoutBot_promotionsInput>
    connectOrCreate?: botsCreateOrConnectWithoutBot_promotionsInput
    connect?: botsWhereUniqueInput
  }

  export type botsUpdateOneWithoutBot_promotionsNestedInput = {
    create?: XOR<botsCreateWithoutBot_promotionsInput, botsUncheckedCreateWithoutBot_promotionsInput>
    connectOrCreate?: botsCreateOrConnectWithoutBot_promotionsInput
    upsert?: botsUpsertWithoutBot_promotionsInput
    disconnect?: botsWhereInput | boolean
    delete?: botsWhereInput | boolean
    connect?: botsWhereUniqueInput
    update?: XOR<XOR<botsUpdateToOneWithWhereWithoutBot_promotionsInput, botsUpdateWithoutBot_promotionsInput>, botsUncheckedUpdateWithoutBot_promotionsInput>
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type botsCreateNestedOneWithoutBot_tagsInput = {
    create?: XOR<botsCreateWithoutBot_tagsInput, botsUncheckedCreateWithoutBot_tagsInput>
    connectOrCreate?: botsCreateOrConnectWithoutBot_tagsInput
    connect?: botsWhereUniqueInput
  }

  export type bot_list_tagsCreateNestedOneWithoutBot_tagsInput = {
    create?: XOR<bot_list_tagsCreateWithoutBot_tagsInput, bot_list_tagsUncheckedCreateWithoutBot_tagsInput>
    connectOrCreate?: bot_list_tagsCreateOrConnectWithoutBot_tagsInput
    connect?: bot_list_tagsWhereUniqueInput
  }

  export type botsUpdateOneRequiredWithoutBot_tagsNestedInput = {
    create?: XOR<botsCreateWithoutBot_tagsInput, botsUncheckedCreateWithoutBot_tagsInput>
    connectOrCreate?: botsCreateOrConnectWithoutBot_tagsInput
    upsert?: botsUpsertWithoutBot_tagsInput
    connect?: botsWhereUniqueInput
    update?: XOR<XOR<botsUpdateToOneWithWhereWithoutBot_tagsInput, botsUpdateWithoutBot_tagsInput>, botsUncheckedUpdateWithoutBot_tagsInput>
  }

  export type bot_list_tagsUpdateOneRequiredWithoutBot_tagsNestedInput = {
    create?: XOR<bot_list_tagsCreateWithoutBot_tagsInput, bot_list_tagsUncheckedCreateWithoutBot_tagsInput>
    connectOrCreate?: bot_list_tagsCreateOrConnectWithoutBot_tagsInput
    upsert?: bot_list_tagsUpsertWithoutBot_tagsInput
    connect?: bot_list_tagsWhereUniqueInput
    update?: XOR<XOR<bot_list_tagsUpdateToOneWithWhereWithoutBot_tagsInput, bot_list_tagsUpdateWithoutBot_tagsInput>, bot_list_tagsUncheckedUpdateWithoutBot_tagsInput>
  }

  export type bot_votersCreatetimestampsInput = {
    set: Date[] | string[]
  }

  export type usersCreateNestedOneWithoutBot_votersInput = {
    create?: XOR<usersCreateWithoutBot_votersInput, usersUncheckedCreateWithoutBot_votersInput>
    connectOrCreate?: usersCreateOrConnectWithoutBot_votersInput
    connect?: usersWhereUniqueInput
  }

  export type bot_votersUpdatetimestampsInput = {
    set?: Date[] | string[]
    push?: Date | string | Date[] | string[]
  }

  export type usersUpdateOneRequiredWithoutBot_votersNestedInput = {
    create?: XOR<usersCreateWithoutBot_votersInput, usersUncheckedCreateWithoutBot_votersInput>
    connectOrCreate?: usersCreateOrConnectWithoutBot_votersInput
    upsert?: usersUpsertWithoutBot_votersInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutBot_votersInput, usersUpdateWithoutBot_votersInput>, usersUncheckedUpdateWithoutBot_votersInput>
  }

  export type botsCreatefeaturesInput = {
    set: string[]
  }

  export type botsCreateshardsInput = {
    set: number[]
  }

  export type botsCreateflagsInput = {
    set: number[]
  }

  export type bot_commandsCreateNestedManyWithoutBotsInput = {
    create?: XOR<bot_commandsCreateWithoutBotsInput, bot_commandsUncheckedCreateWithoutBotsInput> | bot_commandsCreateWithoutBotsInput[] | bot_commandsUncheckedCreateWithoutBotsInput[]
    connectOrCreate?: bot_commandsCreateOrConnectWithoutBotsInput | bot_commandsCreateOrConnectWithoutBotsInput[]
    createMany?: bot_commandsCreateManyBotsInputEnvelope
    connect?: bot_commandsWhereUniqueInput | bot_commandsWhereUniqueInput[]
  }

  export type bot_eventsCreateNestedManyWithoutBotsInput = {
    create?: XOR<bot_eventsCreateWithoutBotsInput, bot_eventsUncheckedCreateWithoutBotsInput> | bot_eventsCreateWithoutBotsInput[] | bot_eventsUncheckedCreateWithoutBotsInput[]
    connectOrCreate?: bot_eventsCreateOrConnectWithoutBotsInput | bot_eventsCreateOrConnectWithoutBotsInput[]
    createMany?: bot_eventsCreateManyBotsInputEnvelope
    connect?: bot_eventsWhereUniqueInput | bot_eventsWhereUniqueInput[]
  }

  export type bot_ownerCreateNestedManyWithoutBotsInput = {
    create?: XOR<bot_ownerCreateWithoutBotsInput, bot_ownerUncheckedCreateWithoutBotsInput> | bot_ownerCreateWithoutBotsInput[] | bot_ownerUncheckedCreateWithoutBotsInput[]
    connectOrCreate?: bot_ownerCreateOrConnectWithoutBotsInput | bot_ownerCreateOrConnectWithoutBotsInput[]
    createMany?: bot_ownerCreateManyBotsInputEnvelope
    connect?: bot_ownerWhereUniqueInput | bot_ownerWhereUniqueInput[]
  }

  export type bot_promotionsCreateNestedManyWithoutBotsInput = {
    create?: XOR<bot_promotionsCreateWithoutBotsInput, bot_promotionsUncheckedCreateWithoutBotsInput> | bot_promotionsCreateWithoutBotsInput[] | bot_promotionsUncheckedCreateWithoutBotsInput[]
    connectOrCreate?: bot_promotionsCreateOrConnectWithoutBotsInput | bot_promotionsCreateOrConnectWithoutBotsInput[]
    createMany?: bot_promotionsCreateManyBotsInputEnvelope
    connect?: bot_promotionsWhereUniqueInput | bot_promotionsWhereUniqueInput[]
  }

  export type bot_tagsCreateNestedManyWithoutBotsInput = {
    create?: XOR<bot_tagsCreateWithoutBotsInput, bot_tagsUncheckedCreateWithoutBotsInput> | bot_tagsCreateWithoutBotsInput[] | bot_tagsUncheckedCreateWithoutBotsInput[]
    connectOrCreate?: bot_tagsCreateOrConnectWithoutBotsInput | bot_tagsCreateOrConnectWithoutBotsInput[]
    createMany?: bot_tagsCreateManyBotsInputEnvelope
    connect?: bot_tagsWhereUniqueInput | bot_tagsWhereUniqueInput[]
  }

  export type bot_commandsUncheckedCreateNestedManyWithoutBotsInput = {
    create?: XOR<bot_commandsCreateWithoutBotsInput, bot_commandsUncheckedCreateWithoutBotsInput> | bot_commandsCreateWithoutBotsInput[] | bot_commandsUncheckedCreateWithoutBotsInput[]
    connectOrCreate?: bot_commandsCreateOrConnectWithoutBotsInput | bot_commandsCreateOrConnectWithoutBotsInput[]
    createMany?: bot_commandsCreateManyBotsInputEnvelope
    connect?: bot_commandsWhereUniqueInput | bot_commandsWhereUniqueInput[]
  }

  export type bot_eventsUncheckedCreateNestedManyWithoutBotsInput = {
    create?: XOR<bot_eventsCreateWithoutBotsInput, bot_eventsUncheckedCreateWithoutBotsInput> | bot_eventsCreateWithoutBotsInput[] | bot_eventsUncheckedCreateWithoutBotsInput[]
    connectOrCreate?: bot_eventsCreateOrConnectWithoutBotsInput | bot_eventsCreateOrConnectWithoutBotsInput[]
    createMany?: bot_eventsCreateManyBotsInputEnvelope
    connect?: bot_eventsWhereUniqueInput | bot_eventsWhereUniqueInput[]
  }

  export type bot_ownerUncheckedCreateNestedManyWithoutBotsInput = {
    create?: XOR<bot_ownerCreateWithoutBotsInput, bot_ownerUncheckedCreateWithoutBotsInput> | bot_ownerCreateWithoutBotsInput[] | bot_ownerUncheckedCreateWithoutBotsInput[]
    connectOrCreate?: bot_ownerCreateOrConnectWithoutBotsInput | bot_ownerCreateOrConnectWithoutBotsInput[]
    createMany?: bot_ownerCreateManyBotsInputEnvelope
    connect?: bot_ownerWhereUniqueInput | bot_ownerWhereUniqueInput[]
  }

  export type bot_promotionsUncheckedCreateNestedManyWithoutBotsInput = {
    create?: XOR<bot_promotionsCreateWithoutBotsInput, bot_promotionsUncheckedCreateWithoutBotsInput> | bot_promotionsCreateWithoutBotsInput[] | bot_promotionsUncheckedCreateWithoutBotsInput[]
    connectOrCreate?: bot_promotionsCreateOrConnectWithoutBotsInput | bot_promotionsCreateOrConnectWithoutBotsInput[]
    createMany?: bot_promotionsCreateManyBotsInputEnvelope
    connect?: bot_promotionsWhereUniqueInput | bot_promotionsWhereUniqueInput[]
  }

  export type bot_tagsUncheckedCreateNestedManyWithoutBotsInput = {
    create?: XOR<bot_tagsCreateWithoutBotsInput, bot_tagsUncheckedCreateWithoutBotsInput> | bot_tagsCreateWithoutBotsInput[] | bot_tagsUncheckedCreateWithoutBotsInput[]
    connectOrCreate?: bot_tagsCreateOrConnectWithoutBotsInput | bot_tagsCreateOrConnectWithoutBotsInput[]
    createMany?: bot_tagsCreateManyBotsInputEnvelope
    connect?: bot_tagsWhereUniqueInput | bot_tagsWhereUniqueInput[]
  }

  export type botsUpdatefeaturesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type botsUpdateshardsInput = {
    set?: number[]
    push?: number | number[]
  }

  export type botsUpdateflagsInput = {
    set?: number[]
    push?: number | number[]
  }

  export type bot_commandsUpdateManyWithoutBotsNestedInput = {
    create?: XOR<bot_commandsCreateWithoutBotsInput, bot_commandsUncheckedCreateWithoutBotsInput> | bot_commandsCreateWithoutBotsInput[] | bot_commandsUncheckedCreateWithoutBotsInput[]
    connectOrCreate?: bot_commandsCreateOrConnectWithoutBotsInput | bot_commandsCreateOrConnectWithoutBotsInput[]
    upsert?: bot_commandsUpsertWithWhereUniqueWithoutBotsInput | bot_commandsUpsertWithWhereUniqueWithoutBotsInput[]
    createMany?: bot_commandsCreateManyBotsInputEnvelope
    set?: bot_commandsWhereUniqueInput | bot_commandsWhereUniqueInput[]
    disconnect?: bot_commandsWhereUniqueInput | bot_commandsWhereUniqueInput[]
    delete?: bot_commandsWhereUniqueInput | bot_commandsWhereUniqueInput[]
    connect?: bot_commandsWhereUniqueInput | bot_commandsWhereUniqueInput[]
    update?: bot_commandsUpdateWithWhereUniqueWithoutBotsInput | bot_commandsUpdateWithWhereUniqueWithoutBotsInput[]
    updateMany?: bot_commandsUpdateManyWithWhereWithoutBotsInput | bot_commandsUpdateManyWithWhereWithoutBotsInput[]
    deleteMany?: bot_commandsScalarWhereInput | bot_commandsScalarWhereInput[]
  }

  export type bot_eventsUpdateManyWithoutBotsNestedInput = {
    create?: XOR<bot_eventsCreateWithoutBotsInput, bot_eventsUncheckedCreateWithoutBotsInput> | bot_eventsCreateWithoutBotsInput[] | bot_eventsUncheckedCreateWithoutBotsInput[]
    connectOrCreate?: bot_eventsCreateOrConnectWithoutBotsInput | bot_eventsCreateOrConnectWithoutBotsInput[]
    upsert?: bot_eventsUpsertWithWhereUniqueWithoutBotsInput | bot_eventsUpsertWithWhereUniqueWithoutBotsInput[]
    createMany?: bot_eventsCreateManyBotsInputEnvelope
    set?: bot_eventsWhereUniqueInput | bot_eventsWhereUniqueInput[]
    disconnect?: bot_eventsWhereUniqueInput | bot_eventsWhereUniqueInput[]
    delete?: bot_eventsWhereUniqueInput | bot_eventsWhereUniqueInput[]
    connect?: bot_eventsWhereUniqueInput | bot_eventsWhereUniqueInput[]
    update?: bot_eventsUpdateWithWhereUniqueWithoutBotsInput | bot_eventsUpdateWithWhereUniqueWithoutBotsInput[]
    updateMany?: bot_eventsUpdateManyWithWhereWithoutBotsInput | bot_eventsUpdateManyWithWhereWithoutBotsInput[]
    deleteMany?: bot_eventsScalarWhereInput | bot_eventsScalarWhereInput[]
  }

  export type bot_ownerUpdateManyWithoutBotsNestedInput = {
    create?: XOR<bot_ownerCreateWithoutBotsInput, bot_ownerUncheckedCreateWithoutBotsInput> | bot_ownerCreateWithoutBotsInput[] | bot_ownerUncheckedCreateWithoutBotsInput[]
    connectOrCreate?: bot_ownerCreateOrConnectWithoutBotsInput | bot_ownerCreateOrConnectWithoutBotsInput[]
    upsert?: bot_ownerUpsertWithWhereUniqueWithoutBotsInput | bot_ownerUpsertWithWhereUniqueWithoutBotsInput[]
    createMany?: bot_ownerCreateManyBotsInputEnvelope
    set?: bot_ownerWhereUniqueInput | bot_ownerWhereUniqueInput[]
    disconnect?: bot_ownerWhereUniqueInput | bot_ownerWhereUniqueInput[]
    delete?: bot_ownerWhereUniqueInput | bot_ownerWhereUniqueInput[]
    connect?: bot_ownerWhereUniqueInput | bot_ownerWhereUniqueInput[]
    update?: bot_ownerUpdateWithWhereUniqueWithoutBotsInput | bot_ownerUpdateWithWhereUniqueWithoutBotsInput[]
    updateMany?: bot_ownerUpdateManyWithWhereWithoutBotsInput | bot_ownerUpdateManyWithWhereWithoutBotsInput[]
    deleteMany?: bot_ownerScalarWhereInput | bot_ownerScalarWhereInput[]
  }

  export type bot_promotionsUpdateManyWithoutBotsNestedInput = {
    create?: XOR<bot_promotionsCreateWithoutBotsInput, bot_promotionsUncheckedCreateWithoutBotsInput> | bot_promotionsCreateWithoutBotsInput[] | bot_promotionsUncheckedCreateWithoutBotsInput[]
    connectOrCreate?: bot_promotionsCreateOrConnectWithoutBotsInput | bot_promotionsCreateOrConnectWithoutBotsInput[]
    upsert?: bot_promotionsUpsertWithWhereUniqueWithoutBotsInput | bot_promotionsUpsertWithWhereUniqueWithoutBotsInput[]
    createMany?: bot_promotionsCreateManyBotsInputEnvelope
    set?: bot_promotionsWhereUniqueInput | bot_promotionsWhereUniqueInput[]
    disconnect?: bot_promotionsWhereUniqueInput | bot_promotionsWhereUniqueInput[]
    delete?: bot_promotionsWhereUniqueInput | bot_promotionsWhereUniqueInput[]
    connect?: bot_promotionsWhereUniqueInput | bot_promotionsWhereUniqueInput[]
    update?: bot_promotionsUpdateWithWhereUniqueWithoutBotsInput | bot_promotionsUpdateWithWhereUniqueWithoutBotsInput[]
    updateMany?: bot_promotionsUpdateManyWithWhereWithoutBotsInput | bot_promotionsUpdateManyWithWhereWithoutBotsInput[]
    deleteMany?: bot_promotionsScalarWhereInput | bot_promotionsScalarWhereInput[]
  }

  export type bot_tagsUpdateManyWithoutBotsNestedInput = {
    create?: XOR<bot_tagsCreateWithoutBotsInput, bot_tagsUncheckedCreateWithoutBotsInput> | bot_tagsCreateWithoutBotsInput[] | bot_tagsUncheckedCreateWithoutBotsInput[]
    connectOrCreate?: bot_tagsCreateOrConnectWithoutBotsInput | bot_tagsCreateOrConnectWithoutBotsInput[]
    upsert?: bot_tagsUpsertWithWhereUniqueWithoutBotsInput | bot_tagsUpsertWithWhereUniqueWithoutBotsInput[]
    createMany?: bot_tagsCreateManyBotsInputEnvelope
    set?: bot_tagsWhereUniqueInput | bot_tagsWhereUniqueInput[]
    disconnect?: bot_tagsWhereUniqueInput | bot_tagsWhereUniqueInput[]
    delete?: bot_tagsWhereUniqueInput | bot_tagsWhereUniqueInput[]
    connect?: bot_tagsWhereUniqueInput | bot_tagsWhereUniqueInput[]
    update?: bot_tagsUpdateWithWhereUniqueWithoutBotsInput | bot_tagsUpdateWithWhereUniqueWithoutBotsInput[]
    updateMany?: bot_tagsUpdateManyWithWhereWithoutBotsInput | bot_tagsUpdateManyWithWhereWithoutBotsInput[]
    deleteMany?: bot_tagsScalarWhereInput | bot_tagsScalarWhereInput[]
  }

  export type bot_commandsUncheckedUpdateManyWithoutBotsNestedInput = {
    create?: XOR<bot_commandsCreateWithoutBotsInput, bot_commandsUncheckedCreateWithoutBotsInput> | bot_commandsCreateWithoutBotsInput[] | bot_commandsUncheckedCreateWithoutBotsInput[]
    connectOrCreate?: bot_commandsCreateOrConnectWithoutBotsInput | bot_commandsCreateOrConnectWithoutBotsInput[]
    upsert?: bot_commandsUpsertWithWhereUniqueWithoutBotsInput | bot_commandsUpsertWithWhereUniqueWithoutBotsInput[]
    createMany?: bot_commandsCreateManyBotsInputEnvelope
    set?: bot_commandsWhereUniqueInput | bot_commandsWhereUniqueInput[]
    disconnect?: bot_commandsWhereUniqueInput | bot_commandsWhereUniqueInput[]
    delete?: bot_commandsWhereUniqueInput | bot_commandsWhereUniqueInput[]
    connect?: bot_commandsWhereUniqueInput | bot_commandsWhereUniqueInput[]
    update?: bot_commandsUpdateWithWhereUniqueWithoutBotsInput | bot_commandsUpdateWithWhereUniqueWithoutBotsInput[]
    updateMany?: bot_commandsUpdateManyWithWhereWithoutBotsInput | bot_commandsUpdateManyWithWhereWithoutBotsInput[]
    deleteMany?: bot_commandsScalarWhereInput | bot_commandsScalarWhereInput[]
  }

  export type bot_eventsUncheckedUpdateManyWithoutBotsNestedInput = {
    create?: XOR<bot_eventsCreateWithoutBotsInput, bot_eventsUncheckedCreateWithoutBotsInput> | bot_eventsCreateWithoutBotsInput[] | bot_eventsUncheckedCreateWithoutBotsInput[]
    connectOrCreate?: bot_eventsCreateOrConnectWithoutBotsInput | bot_eventsCreateOrConnectWithoutBotsInput[]
    upsert?: bot_eventsUpsertWithWhereUniqueWithoutBotsInput | bot_eventsUpsertWithWhereUniqueWithoutBotsInput[]
    createMany?: bot_eventsCreateManyBotsInputEnvelope
    set?: bot_eventsWhereUniqueInput | bot_eventsWhereUniqueInput[]
    disconnect?: bot_eventsWhereUniqueInput | bot_eventsWhereUniqueInput[]
    delete?: bot_eventsWhereUniqueInput | bot_eventsWhereUniqueInput[]
    connect?: bot_eventsWhereUniqueInput | bot_eventsWhereUniqueInput[]
    update?: bot_eventsUpdateWithWhereUniqueWithoutBotsInput | bot_eventsUpdateWithWhereUniqueWithoutBotsInput[]
    updateMany?: bot_eventsUpdateManyWithWhereWithoutBotsInput | bot_eventsUpdateManyWithWhereWithoutBotsInput[]
    deleteMany?: bot_eventsScalarWhereInput | bot_eventsScalarWhereInput[]
  }

  export type bot_ownerUncheckedUpdateManyWithoutBotsNestedInput = {
    create?: XOR<bot_ownerCreateWithoutBotsInput, bot_ownerUncheckedCreateWithoutBotsInput> | bot_ownerCreateWithoutBotsInput[] | bot_ownerUncheckedCreateWithoutBotsInput[]
    connectOrCreate?: bot_ownerCreateOrConnectWithoutBotsInput | bot_ownerCreateOrConnectWithoutBotsInput[]
    upsert?: bot_ownerUpsertWithWhereUniqueWithoutBotsInput | bot_ownerUpsertWithWhereUniqueWithoutBotsInput[]
    createMany?: bot_ownerCreateManyBotsInputEnvelope
    set?: bot_ownerWhereUniqueInput | bot_ownerWhereUniqueInput[]
    disconnect?: bot_ownerWhereUniqueInput | bot_ownerWhereUniqueInput[]
    delete?: bot_ownerWhereUniqueInput | bot_ownerWhereUniqueInput[]
    connect?: bot_ownerWhereUniqueInput | bot_ownerWhereUniqueInput[]
    update?: bot_ownerUpdateWithWhereUniqueWithoutBotsInput | bot_ownerUpdateWithWhereUniqueWithoutBotsInput[]
    updateMany?: bot_ownerUpdateManyWithWhereWithoutBotsInput | bot_ownerUpdateManyWithWhereWithoutBotsInput[]
    deleteMany?: bot_ownerScalarWhereInput | bot_ownerScalarWhereInput[]
  }

  export type bot_promotionsUncheckedUpdateManyWithoutBotsNestedInput = {
    create?: XOR<bot_promotionsCreateWithoutBotsInput, bot_promotionsUncheckedCreateWithoutBotsInput> | bot_promotionsCreateWithoutBotsInput[] | bot_promotionsUncheckedCreateWithoutBotsInput[]
    connectOrCreate?: bot_promotionsCreateOrConnectWithoutBotsInput | bot_promotionsCreateOrConnectWithoutBotsInput[]
    upsert?: bot_promotionsUpsertWithWhereUniqueWithoutBotsInput | bot_promotionsUpsertWithWhereUniqueWithoutBotsInput[]
    createMany?: bot_promotionsCreateManyBotsInputEnvelope
    set?: bot_promotionsWhereUniqueInput | bot_promotionsWhereUniqueInput[]
    disconnect?: bot_promotionsWhereUniqueInput | bot_promotionsWhereUniqueInput[]
    delete?: bot_promotionsWhereUniqueInput | bot_promotionsWhereUniqueInput[]
    connect?: bot_promotionsWhereUniqueInput | bot_promotionsWhereUniqueInput[]
    update?: bot_promotionsUpdateWithWhereUniqueWithoutBotsInput | bot_promotionsUpdateWithWhereUniqueWithoutBotsInput[]
    updateMany?: bot_promotionsUpdateManyWithWhereWithoutBotsInput | bot_promotionsUpdateManyWithWhereWithoutBotsInput[]
    deleteMany?: bot_promotionsScalarWhereInput | bot_promotionsScalarWhereInput[]
  }

  export type bot_tagsUncheckedUpdateManyWithoutBotsNestedInput = {
    create?: XOR<bot_tagsCreateWithoutBotsInput, bot_tagsUncheckedCreateWithoutBotsInput> | bot_tagsCreateWithoutBotsInput[] | bot_tagsUncheckedCreateWithoutBotsInput[]
    connectOrCreate?: bot_tagsCreateOrConnectWithoutBotsInput | bot_tagsCreateOrConnectWithoutBotsInput[]
    upsert?: bot_tagsUpsertWithWhereUniqueWithoutBotsInput | bot_tagsUpsertWithWhereUniqueWithoutBotsInput[]
    createMany?: bot_tagsCreateManyBotsInputEnvelope
    set?: bot_tagsWhereUniqueInput | bot_tagsWhereUniqueInput[]
    disconnect?: bot_tagsWhereUniqueInput | bot_tagsWhereUniqueInput[]
    delete?: bot_tagsWhereUniqueInput | bot_tagsWhereUniqueInput[]
    connect?: bot_tagsWhereUniqueInput | bot_tagsWhereUniqueInput[]
    update?: bot_tagsUpdateWithWhereUniqueWithoutBotsInput | bot_tagsUpdateWithWhereUniqueWithoutBotsInput[]
    updateMany?: bot_tagsUpdateManyWithWhereWithoutBotsInput | bot_tagsUpdateManyWithWhereWithoutBotsInput[]
    deleteMany?: bot_tagsScalarWhereInput | bot_tagsScalarWhereInput[]
  }

  export type usersCreateNestedOneWithoutExtra_dataInput = {
    create?: XOR<usersCreateWithoutExtra_dataInput, usersUncheckedCreateWithoutExtra_dataInput>
    connectOrCreate?: usersCreateOrConnectWithoutExtra_dataInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneWithoutExtra_dataNestedInput = {
    create?: XOR<usersCreateWithoutExtra_dataInput, usersUncheckedCreateWithoutExtra_dataInput>
    connectOrCreate?: usersCreateOrConnectWithoutExtra_dataInput
    upsert?: usersUpsertWithoutExtra_dataInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutExtra_dataInput, usersUpdateWithoutExtra_dataInput>, usersUncheckedUpdateWithoutExtra_dataInput>
  }

  export type usersCreateNestedOneWithoutFrostpaw_clientsInput = {
    create?: XOR<usersCreateWithoutFrostpaw_clientsInput, usersUncheckedCreateWithoutFrostpaw_clientsInput>
    connectOrCreate?: usersCreateOrConnectWithoutFrostpaw_clientsInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutFrostpaw_clientsNestedInput = {
    create?: XOR<usersCreateWithoutFrostpaw_clientsInput, usersUncheckedCreateWithoutFrostpaw_clientsInput>
    connectOrCreate?: usersCreateOrConnectWithoutFrostpaw_clientsInput
    upsert?: usersUpsertWithoutFrostpaw_clientsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutFrostpaw_clientsInput, usersUpdateWithoutFrostpaw_clientsInput>, usersUncheckedUpdateWithoutFrostpaw_clientsInput>
  }

  export type usersCreateNestedOneWithoutLeave_of_absenceInput = {
    create?: XOR<usersCreateWithoutLeave_of_absenceInput, usersUncheckedCreateWithoutLeave_of_absenceInput>
    connectOrCreate?: usersCreateOrConnectWithoutLeave_of_absenceInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneWithoutLeave_of_absenceNestedInput = {
    create?: XOR<usersCreateWithoutLeave_of_absenceInput, usersUncheckedCreateWithoutLeave_of_absenceInput>
    connectOrCreate?: usersCreateOrConnectWithoutLeave_of_absenceInput
    upsert?: usersUpsertWithoutLeave_of_absenceInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutLeave_of_absenceInput, usersUpdateWithoutLeave_of_absenceInput>, usersUncheckedUpdateWithoutLeave_of_absenceInput>
  }

  export type usersCreateNestedOneWithoutLynx_appsInput = {
    create?: XOR<usersCreateWithoutLynx_appsInput, usersUncheckedCreateWithoutLynx_appsInput>
    connectOrCreate?: usersCreateOrConnectWithoutLynx_appsInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneWithoutLynx_appsNestedInput = {
    create?: XOR<usersCreateWithoutLynx_appsInput, usersUncheckedCreateWithoutLynx_appsInput>
    connectOrCreate?: usersCreateOrConnectWithoutLynx_appsInput
    upsert?: usersUpsertWithoutLynx_appsInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutLynx_appsInput, usersUpdateWithoutLynx_appsInput>, usersUncheckedUpdateWithoutLynx_appsInput>
  }

  export type lynx_dataCreatedefault_user_experimentsInput = {
    set: number[]
  }

  export type lynx_dataUpdatedefault_user_experimentsInput = {
    set?: number[]
    push?: number | number[]
  }

  export type usersCreateNestedOneWithoutLynx_logsInput = {
    create?: XOR<usersCreateWithoutLynx_logsInput, usersUncheckedCreateWithoutLynx_logsInput>
    connectOrCreate?: usersCreateOrConnectWithoutLynx_logsInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutLynx_logsNestedInput = {
    create?: XOR<usersCreateWithoutLynx_logsInput, usersUncheckedCreateWithoutLynx_logsInput>
    connectOrCreate?: usersCreateOrConnectWithoutLynx_logsInput
    upsert?: usersUpsertWithoutLynx_logsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutLynx_logsInput, usersUpdateWithoutLynx_logsInput>, usersUncheckedUpdateWithoutLynx_logsInput>
  }

  export type lynx_notificationsCreateacked_usersInput = {
    set: bigint[] | number[]
  }

  export type lynx_notificationsUpdateacked_usersInput = {
    set?: bigint[] | number[]
    push?: bigint | number | bigint[] | number[]
  }

  export type usersCreateNestedOneWithoutLynx_ratingsInput = {
    create?: XOR<usersCreateWithoutLynx_ratingsInput, usersUncheckedCreateWithoutLynx_ratingsInput>
    connectOrCreate?: usersCreateOrConnectWithoutLynx_ratingsInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneWithoutLynx_ratingsNestedInput = {
    create?: XOR<usersCreateWithoutLynx_ratingsInput, usersUncheckedCreateWithoutLynx_ratingsInput>
    connectOrCreate?: usersCreateOrConnectWithoutLynx_ratingsInput
    upsert?: usersUpsertWithoutLynx_ratingsInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutLynx_ratingsInput, usersUpdateWithoutLynx_ratingsInput>, usersUncheckedUpdateWithoutLynx_ratingsInput>
  }

  export type lynx_surveysCreateNestedOneWithoutLynx_survey_responsesInput = {
    create?: XOR<lynx_surveysCreateWithoutLynx_survey_responsesInput, lynx_surveysUncheckedCreateWithoutLynx_survey_responsesInput>
    connectOrCreate?: lynx_surveysCreateOrConnectWithoutLynx_survey_responsesInput
    connect?: lynx_surveysWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutLynx_survey_responsesInput = {
    create?: XOR<usersCreateWithoutLynx_survey_responsesInput, usersUncheckedCreateWithoutLynx_survey_responsesInput>
    connectOrCreate?: usersCreateOrConnectWithoutLynx_survey_responsesInput
    connect?: usersWhereUniqueInput
  }

  export type lynx_surveysUpdateOneRequiredWithoutLynx_survey_responsesNestedInput = {
    create?: XOR<lynx_surveysCreateWithoutLynx_survey_responsesInput, lynx_surveysUncheckedCreateWithoutLynx_survey_responsesInput>
    connectOrCreate?: lynx_surveysCreateOrConnectWithoutLynx_survey_responsesInput
    upsert?: lynx_surveysUpsertWithoutLynx_survey_responsesInput
    connect?: lynx_surveysWhereUniqueInput
    update?: XOR<XOR<lynx_surveysUpdateToOneWithWhereWithoutLynx_survey_responsesInput, lynx_surveysUpdateWithoutLynx_survey_responsesInput>, lynx_surveysUncheckedUpdateWithoutLynx_survey_responsesInput>
  }

  export type usersUpdateOneWithoutLynx_survey_responsesNestedInput = {
    create?: XOR<usersCreateWithoutLynx_survey_responsesInput, usersUncheckedCreateWithoutLynx_survey_responsesInput>
    connectOrCreate?: usersCreateOrConnectWithoutLynx_survey_responsesInput
    upsert?: usersUpsertWithoutLynx_survey_responsesInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutLynx_survey_responsesInput, usersUpdateWithoutLynx_survey_responsesInput>, usersUncheckedUpdateWithoutLynx_survey_responsesInput>
  }

  export type lynx_survey_responsesCreateNestedManyWithoutLynx_surveysInput = {
    create?: XOR<lynx_survey_responsesCreateWithoutLynx_surveysInput, lynx_survey_responsesUncheckedCreateWithoutLynx_surveysInput> | lynx_survey_responsesCreateWithoutLynx_surveysInput[] | lynx_survey_responsesUncheckedCreateWithoutLynx_surveysInput[]
    connectOrCreate?: lynx_survey_responsesCreateOrConnectWithoutLynx_surveysInput | lynx_survey_responsesCreateOrConnectWithoutLynx_surveysInput[]
    createMany?: lynx_survey_responsesCreateManyLynx_surveysInputEnvelope
    connect?: lynx_survey_responsesWhereUniqueInput | lynx_survey_responsesWhereUniqueInput[]
  }

  export type lynx_survey_responsesUncheckedCreateNestedManyWithoutLynx_surveysInput = {
    create?: XOR<lynx_survey_responsesCreateWithoutLynx_surveysInput, lynx_survey_responsesUncheckedCreateWithoutLynx_surveysInput> | lynx_survey_responsesCreateWithoutLynx_surveysInput[] | lynx_survey_responsesUncheckedCreateWithoutLynx_surveysInput[]
    connectOrCreate?: lynx_survey_responsesCreateOrConnectWithoutLynx_surveysInput | lynx_survey_responsesCreateOrConnectWithoutLynx_surveysInput[]
    createMany?: lynx_survey_responsesCreateManyLynx_surveysInputEnvelope
    connect?: lynx_survey_responsesWhereUniqueInput | lynx_survey_responsesWhereUniqueInput[]
  }

  export type lynx_survey_responsesUpdateManyWithoutLynx_surveysNestedInput = {
    create?: XOR<lynx_survey_responsesCreateWithoutLynx_surveysInput, lynx_survey_responsesUncheckedCreateWithoutLynx_surveysInput> | lynx_survey_responsesCreateWithoutLynx_surveysInput[] | lynx_survey_responsesUncheckedCreateWithoutLynx_surveysInput[]
    connectOrCreate?: lynx_survey_responsesCreateOrConnectWithoutLynx_surveysInput | lynx_survey_responsesCreateOrConnectWithoutLynx_surveysInput[]
    upsert?: lynx_survey_responsesUpsertWithWhereUniqueWithoutLynx_surveysInput | lynx_survey_responsesUpsertWithWhereUniqueWithoutLynx_surveysInput[]
    createMany?: lynx_survey_responsesCreateManyLynx_surveysInputEnvelope
    set?: lynx_survey_responsesWhereUniqueInput | lynx_survey_responsesWhereUniqueInput[]
    disconnect?: lynx_survey_responsesWhereUniqueInput | lynx_survey_responsesWhereUniqueInput[]
    delete?: lynx_survey_responsesWhereUniqueInput | lynx_survey_responsesWhereUniqueInput[]
    connect?: lynx_survey_responsesWhereUniqueInput | lynx_survey_responsesWhereUniqueInput[]
    update?: lynx_survey_responsesUpdateWithWhereUniqueWithoutLynx_surveysInput | lynx_survey_responsesUpdateWithWhereUniqueWithoutLynx_surveysInput[]
    updateMany?: lynx_survey_responsesUpdateManyWithWhereWithoutLynx_surveysInput | lynx_survey_responsesUpdateManyWithWhereWithoutLynx_surveysInput[]
    deleteMany?: lynx_survey_responsesScalarWhereInput | lynx_survey_responsesScalarWhereInput[]
  }

  export type lynx_survey_responsesUncheckedUpdateManyWithoutLynx_surveysNestedInput = {
    create?: XOR<lynx_survey_responsesCreateWithoutLynx_surveysInput, lynx_survey_responsesUncheckedCreateWithoutLynx_surveysInput> | lynx_survey_responsesCreateWithoutLynx_surveysInput[] | lynx_survey_responsesUncheckedCreateWithoutLynx_surveysInput[]
    connectOrCreate?: lynx_survey_responsesCreateOrConnectWithoutLynx_surveysInput | lynx_survey_responsesCreateOrConnectWithoutLynx_surveysInput[]
    upsert?: lynx_survey_responsesUpsertWithWhereUniqueWithoutLynx_surveysInput | lynx_survey_responsesUpsertWithWhereUniqueWithoutLynx_surveysInput[]
    createMany?: lynx_survey_responsesCreateManyLynx_surveysInputEnvelope
    set?: lynx_survey_responsesWhereUniqueInput | lynx_survey_responsesWhereUniqueInput[]
    disconnect?: lynx_survey_responsesWhereUniqueInput | lynx_survey_responsesWhereUniqueInput[]
    delete?: lynx_survey_responsesWhereUniqueInput | lynx_survey_responsesWhereUniqueInput[]
    connect?: lynx_survey_responsesWhereUniqueInput | lynx_survey_responsesWhereUniqueInput[]
    update?: lynx_survey_responsesUpdateWithWhereUniqueWithoutLynx_surveysInput | lynx_survey_responsesUpdateWithWhereUniqueWithoutLynx_surveysInput[]
    updateMany?: lynx_survey_responsesUpdateManyWithWhereWithoutLynx_surveysInput | lynx_survey_responsesUpdateManyWithWhereWithoutLynx_surveysInput[]
    deleteMany?: lynx_survey_responsesScalarWhereInput | lynx_survey_responsesScalarWhereInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type usersCreateNestedOneWithoutPush_notificationsInput = {
    create?: XOR<usersCreateWithoutPush_notificationsInput, usersUncheckedCreateWithoutPush_notificationsInput>
    connectOrCreate?: usersCreateOrConnectWithoutPush_notificationsInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutPush_notificationsNestedInput = {
    create?: XOR<usersCreateWithoutPush_notificationsInput, usersUncheckedCreateWithoutPush_notificationsInput>
    connectOrCreate?: usersCreateOrConnectWithoutPush_notificationsInput
    upsert?: usersUpsertWithoutPush_notificationsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutPush_notificationsInput, usersUpdateWithoutPush_notificationsInput>, usersUncheckedUpdateWithoutPush_notificationsInput>
  }

  export type reviewsCreateNestedOneWithoutReview_votesInput = {
    create?: XOR<reviewsCreateWithoutReview_votesInput, reviewsUncheckedCreateWithoutReview_votesInput>
    connectOrCreate?: reviewsCreateOrConnectWithoutReview_votesInput
    connect?: reviewsWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutReview_votesInput = {
    create?: XOR<usersCreateWithoutReview_votesInput, usersUncheckedCreateWithoutReview_votesInput>
    connectOrCreate?: usersCreateOrConnectWithoutReview_votesInput
    connect?: usersWhereUniqueInput
  }

  export type reviewsUpdateOneRequiredWithoutReview_votesNestedInput = {
    create?: XOR<reviewsCreateWithoutReview_votesInput, reviewsUncheckedCreateWithoutReview_votesInput>
    connectOrCreate?: reviewsCreateOrConnectWithoutReview_votesInput
    upsert?: reviewsUpsertWithoutReview_votesInput
    connect?: reviewsWhereUniqueInput
    update?: XOR<XOR<reviewsUpdateToOneWithWhereWithoutReview_votesInput, reviewsUpdateWithoutReview_votesInput>, reviewsUncheckedUpdateWithoutReview_votesInput>
  }

  export type usersUpdateOneRequiredWithoutReview_votesNestedInput = {
    create?: XOR<usersCreateWithoutReview_votesInput, usersUncheckedCreateWithoutReview_votesInput>
    connectOrCreate?: usersCreateOrConnectWithoutReview_votesInput
    upsert?: usersUpsertWithoutReview_votesInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutReview_votesInput, usersUpdateWithoutReview_votesInput>, usersUncheckedUpdateWithoutReview_votesInput>
  }

  export type reviewsCreateepochInput = {
    set: bigint[] | number[]
  }

  export type review_votesCreateNestedManyWithoutReviewsInput = {
    create?: XOR<review_votesCreateWithoutReviewsInput, review_votesUncheckedCreateWithoutReviewsInput> | review_votesCreateWithoutReviewsInput[] | review_votesUncheckedCreateWithoutReviewsInput[]
    connectOrCreate?: review_votesCreateOrConnectWithoutReviewsInput | review_votesCreateOrConnectWithoutReviewsInput[]
    createMany?: review_votesCreateManyReviewsInputEnvelope
    connect?: review_votesWhereUniqueInput | review_votesWhereUniqueInput[]
  }

  export type reviewsCreateNestedOneWithoutOther_reviewsInput = {
    create?: XOR<reviewsCreateWithoutOther_reviewsInput, reviewsUncheckedCreateWithoutOther_reviewsInput>
    connectOrCreate?: reviewsCreateOrConnectWithoutOther_reviewsInput
    connect?: reviewsWhereUniqueInput
  }

  export type reviewsCreateNestedManyWithoutReviewsInput = {
    create?: XOR<reviewsCreateWithoutReviewsInput, reviewsUncheckedCreateWithoutReviewsInput> | reviewsCreateWithoutReviewsInput[] | reviewsUncheckedCreateWithoutReviewsInput[]
    connectOrCreate?: reviewsCreateOrConnectWithoutReviewsInput | reviewsCreateOrConnectWithoutReviewsInput[]
    createMany?: reviewsCreateManyReviewsInputEnvelope
    connect?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
  }

  export type usersCreateNestedOneWithoutReviewsInput = {
    create?: XOR<usersCreateWithoutReviewsInput, usersUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: usersCreateOrConnectWithoutReviewsInput
    connect?: usersWhereUniqueInput
  }

  export type review_votesUncheckedCreateNestedManyWithoutReviewsInput = {
    create?: XOR<review_votesCreateWithoutReviewsInput, review_votesUncheckedCreateWithoutReviewsInput> | review_votesCreateWithoutReviewsInput[] | review_votesUncheckedCreateWithoutReviewsInput[]
    connectOrCreate?: review_votesCreateOrConnectWithoutReviewsInput | review_votesCreateOrConnectWithoutReviewsInput[]
    createMany?: review_votesCreateManyReviewsInputEnvelope
    connect?: review_votesWhereUniqueInput | review_votesWhereUniqueInput[]
  }

  export type reviewsUncheckedCreateNestedManyWithoutReviewsInput = {
    create?: XOR<reviewsCreateWithoutReviewsInput, reviewsUncheckedCreateWithoutReviewsInput> | reviewsCreateWithoutReviewsInput[] | reviewsUncheckedCreateWithoutReviewsInput[]
    connectOrCreate?: reviewsCreateOrConnectWithoutReviewsInput | reviewsCreateOrConnectWithoutReviewsInput[]
    createMany?: reviewsCreateManyReviewsInputEnvelope
    connect?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
  }

  export type reviewsUpdateepochInput = {
    set?: bigint[] | number[]
    push?: bigint | number | bigint[] | number[]
  }

  export type review_votesUpdateManyWithoutReviewsNestedInput = {
    create?: XOR<review_votesCreateWithoutReviewsInput, review_votesUncheckedCreateWithoutReviewsInput> | review_votesCreateWithoutReviewsInput[] | review_votesUncheckedCreateWithoutReviewsInput[]
    connectOrCreate?: review_votesCreateOrConnectWithoutReviewsInput | review_votesCreateOrConnectWithoutReviewsInput[]
    upsert?: review_votesUpsertWithWhereUniqueWithoutReviewsInput | review_votesUpsertWithWhereUniqueWithoutReviewsInput[]
    createMany?: review_votesCreateManyReviewsInputEnvelope
    set?: review_votesWhereUniqueInput | review_votesWhereUniqueInput[]
    disconnect?: review_votesWhereUniqueInput | review_votesWhereUniqueInput[]
    delete?: review_votesWhereUniqueInput | review_votesWhereUniqueInput[]
    connect?: review_votesWhereUniqueInput | review_votesWhereUniqueInput[]
    update?: review_votesUpdateWithWhereUniqueWithoutReviewsInput | review_votesUpdateWithWhereUniqueWithoutReviewsInput[]
    updateMany?: review_votesUpdateManyWithWhereWithoutReviewsInput | review_votesUpdateManyWithWhereWithoutReviewsInput[]
    deleteMany?: review_votesScalarWhereInput | review_votesScalarWhereInput[]
  }

  export type reviewsUpdateOneWithoutOther_reviewsNestedInput = {
    create?: XOR<reviewsCreateWithoutOther_reviewsInput, reviewsUncheckedCreateWithoutOther_reviewsInput>
    connectOrCreate?: reviewsCreateOrConnectWithoutOther_reviewsInput
    upsert?: reviewsUpsertWithoutOther_reviewsInput
    disconnect?: reviewsWhereInput | boolean
    delete?: reviewsWhereInput | boolean
    connect?: reviewsWhereUniqueInput
    update?: XOR<XOR<reviewsUpdateToOneWithWhereWithoutOther_reviewsInput, reviewsUpdateWithoutOther_reviewsInput>, reviewsUncheckedUpdateWithoutOther_reviewsInput>
  }

  export type reviewsUpdateManyWithoutReviewsNestedInput = {
    create?: XOR<reviewsCreateWithoutReviewsInput, reviewsUncheckedCreateWithoutReviewsInput> | reviewsCreateWithoutReviewsInput[] | reviewsUncheckedCreateWithoutReviewsInput[]
    connectOrCreate?: reviewsCreateOrConnectWithoutReviewsInput | reviewsCreateOrConnectWithoutReviewsInput[]
    upsert?: reviewsUpsertWithWhereUniqueWithoutReviewsInput | reviewsUpsertWithWhereUniqueWithoutReviewsInput[]
    createMany?: reviewsCreateManyReviewsInputEnvelope
    set?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    disconnect?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    delete?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    connect?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    update?: reviewsUpdateWithWhereUniqueWithoutReviewsInput | reviewsUpdateWithWhereUniqueWithoutReviewsInput[]
    updateMany?: reviewsUpdateManyWithWhereWithoutReviewsInput | reviewsUpdateManyWithWhereWithoutReviewsInput[]
    deleteMany?: reviewsScalarWhereInput | reviewsScalarWhereInput[]
  }

  export type usersUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<usersCreateWithoutReviewsInput, usersUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: usersCreateOrConnectWithoutReviewsInput
    upsert?: usersUpsertWithoutReviewsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutReviewsInput, usersUpdateWithoutReviewsInput>, usersUncheckedUpdateWithoutReviewsInput>
  }

  export type review_votesUncheckedUpdateManyWithoutReviewsNestedInput = {
    create?: XOR<review_votesCreateWithoutReviewsInput, review_votesUncheckedCreateWithoutReviewsInput> | review_votesCreateWithoutReviewsInput[] | review_votesUncheckedCreateWithoutReviewsInput[]
    connectOrCreate?: review_votesCreateOrConnectWithoutReviewsInput | review_votesCreateOrConnectWithoutReviewsInput[]
    upsert?: review_votesUpsertWithWhereUniqueWithoutReviewsInput | review_votesUpsertWithWhereUniqueWithoutReviewsInput[]
    createMany?: review_votesCreateManyReviewsInputEnvelope
    set?: review_votesWhereUniqueInput | review_votesWhereUniqueInput[]
    disconnect?: review_votesWhereUniqueInput | review_votesWhereUniqueInput[]
    delete?: review_votesWhereUniqueInput | review_votesWhereUniqueInput[]
    connect?: review_votesWhereUniqueInput | review_votesWhereUniqueInput[]
    update?: review_votesUpdateWithWhereUniqueWithoutReviewsInput | review_votesUpdateWithWhereUniqueWithoutReviewsInput[]
    updateMany?: review_votesUpdateManyWithWhereWithoutReviewsInput | review_votesUpdateManyWithWhereWithoutReviewsInput[]
    deleteMany?: review_votesScalarWhereInput | review_votesScalarWhereInput[]
  }

  export type reviewsUncheckedUpdateManyWithoutReviewsNestedInput = {
    create?: XOR<reviewsCreateWithoutReviewsInput, reviewsUncheckedCreateWithoutReviewsInput> | reviewsCreateWithoutReviewsInput[] | reviewsUncheckedCreateWithoutReviewsInput[]
    connectOrCreate?: reviewsCreateOrConnectWithoutReviewsInput | reviewsCreateOrConnectWithoutReviewsInput[]
    upsert?: reviewsUpsertWithWhereUniqueWithoutReviewsInput | reviewsUpsertWithWhereUniqueWithoutReviewsInput[]
    createMany?: reviewsCreateManyReviewsInputEnvelope
    set?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    disconnect?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    delete?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    connect?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    update?: reviewsUpdateWithWhereUniqueWithoutReviewsInput | reviewsUpdateWithWhereUniqueWithoutReviewsInput[]
    updateMany?: reviewsUpdateManyWithWhereWithoutReviewsInput | reviewsUpdateManyWithWhereWithoutReviewsInput[]
    deleteMany?: reviewsScalarWhereInput | reviewsScalarWhereInput[]
  }

  export type serversCreateNestedOneWithoutServer_audit_logsInput = {
    create?: XOR<serversCreateWithoutServer_audit_logsInput, serversUncheckedCreateWithoutServer_audit_logsInput>
    connectOrCreate?: serversCreateOrConnectWithoutServer_audit_logsInput
    connect?: serversWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutServer_audit_logsInput = {
    create?: XOR<usersCreateWithoutServer_audit_logsInput, usersUncheckedCreateWithoutServer_audit_logsInput>
    connectOrCreate?: usersCreateOrConnectWithoutServer_audit_logsInput
    connect?: usersWhereUniqueInput
  }

  export type serversUpdateOneRequiredWithoutServer_audit_logsNestedInput = {
    create?: XOR<serversCreateWithoutServer_audit_logsInput, serversUncheckedCreateWithoutServer_audit_logsInput>
    connectOrCreate?: serversCreateOrConnectWithoutServer_audit_logsInput
    upsert?: serversUpsertWithoutServer_audit_logsInput
    connect?: serversWhereUniqueInput
    update?: XOR<XOR<serversUpdateToOneWithWhereWithoutServer_audit_logsInput, serversUpdateWithoutServer_audit_logsInput>, serversUncheckedUpdateWithoutServer_audit_logsInput>
  }

  export type usersUpdateOneRequiredWithoutServer_audit_logsNestedInput = {
    create?: XOR<usersCreateWithoutServer_audit_logsInput, usersUncheckedCreateWithoutServer_audit_logsInput>
    connectOrCreate?: usersCreateOrConnectWithoutServer_audit_logsInput
    upsert?: usersUpsertWithoutServer_audit_logsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutServer_audit_logsInput, usersUpdateWithoutServer_audit_logsInput>, usersUncheckedUpdateWithoutServer_audit_logsInput>
  }

  export type server_votersCreatetimestampsInput = {
    set: Date[] | string[]
  }

  export type usersCreateNestedOneWithoutServer_votersInput = {
    create?: XOR<usersCreateWithoutServer_votersInput, usersUncheckedCreateWithoutServer_votersInput>
    connectOrCreate?: usersCreateOrConnectWithoutServer_votersInput
    connect?: usersWhereUniqueInput
  }

  export type server_votersUpdatetimestampsInput = {
    set?: Date[] | string[]
    push?: Date | string | Date[] | string[]
  }

  export type usersUpdateOneRequiredWithoutServer_votersNestedInput = {
    create?: XOR<usersCreateWithoutServer_votersInput, usersUncheckedCreateWithoutServer_votersInput>
    connectOrCreate?: usersCreateOrConnectWithoutServer_votersInput
    upsert?: usersUpsertWithoutServer_votersInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutServer_votersInput, usersUpdateWithoutServer_votersInput>, usersUncheckedUpdateWithoutServer_votersInput>
  }

  export type serversCreatetagsInput = {
    set: string[]
  }

  export type serversCreateflagsInput = {
    set: number[]
  }

  export type serversCreateautorole_votesInput = {
    set: bigint[] | number[]
  }

  export type serversCreateuser_whitelistInput = {
    set: bigint[] | number[]
  }

  export type serversCreateuser_blacklistInput = {
    set: bigint[] | number[]
  }

  export type server_audit_logsCreateNestedManyWithoutServersInput = {
    create?: XOR<server_audit_logsCreateWithoutServersInput, server_audit_logsUncheckedCreateWithoutServersInput> | server_audit_logsCreateWithoutServersInput[] | server_audit_logsUncheckedCreateWithoutServersInput[]
    connectOrCreate?: server_audit_logsCreateOrConnectWithoutServersInput | server_audit_logsCreateOrConnectWithoutServersInput[]
    createMany?: server_audit_logsCreateManyServersInputEnvelope
    connect?: server_audit_logsWhereUniqueInput | server_audit_logsWhereUniqueInput[]
  }

  export type usersCreateNestedOneWithoutServersInput = {
    create?: XOR<usersCreateWithoutServersInput, usersUncheckedCreateWithoutServersInput>
    connectOrCreate?: usersCreateOrConnectWithoutServersInput
    connect?: usersWhereUniqueInput
  }

  export type server_audit_logsUncheckedCreateNestedManyWithoutServersInput = {
    create?: XOR<server_audit_logsCreateWithoutServersInput, server_audit_logsUncheckedCreateWithoutServersInput> | server_audit_logsCreateWithoutServersInput[] | server_audit_logsUncheckedCreateWithoutServersInput[]
    connectOrCreate?: server_audit_logsCreateOrConnectWithoutServersInput | server_audit_logsCreateOrConnectWithoutServersInput[]
    createMany?: server_audit_logsCreateManyServersInputEnvelope
    connect?: server_audit_logsWhereUniqueInput | server_audit_logsWhereUniqueInput[]
  }

  export type serversUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type serversUpdateflagsInput = {
    set?: number[]
    push?: number | number[]
  }

  export type serversUpdateautorole_votesInput = {
    set?: bigint[] | number[]
    push?: bigint | number | bigint[] | number[]
  }

  export type serversUpdateuser_whitelistInput = {
    set?: bigint[] | number[]
    push?: bigint | number | bigint[] | number[]
  }

  export type serversUpdateuser_blacklistInput = {
    set?: bigint[] | number[]
    push?: bigint | number | bigint[] | number[]
  }

  export type server_audit_logsUpdateManyWithoutServersNestedInput = {
    create?: XOR<server_audit_logsCreateWithoutServersInput, server_audit_logsUncheckedCreateWithoutServersInput> | server_audit_logsCreateWithoutServersInput[] | server_audit_logsUncheckedCreateWithoutServersInput[]
    connectOrCreate?: server_audit_logsCreateOrConnectWithoutServersInput | server_audit_logsCreateOrConnectWithoutServersInput[]
    upsert?: server_audit_logsUpsertWithWhereUniqueWithoutServersInput | server_audit_logsUpsertWithWhereUniqueWithoutServersInput[]
    createMany?: server_audit_logsCreateManyServersInputEnvelope
    set?: server_audit_logsWhereUniqueInput | server_audit_logsWhereUniqueInput[]
    disconnect?: server_audit_logsWhereUniqueInput | server_audit_logsWhereUniqueInput[]
    delete?: server_audit_logsWhereUniqueInput | server_audit_logsWhereUniqueInput[]
    connect?: server_audit_logsWhereUniqueInput | server_audit_logsWhereUniqueInput[]
    update?: server_audit_logsUpdateWithWhereUniqueWithoutServersInput | server_audit_logsUpdateWithWhereUniqueWithoutServersInput[]
    updateMany?: server_audit_logsUpdateManyWithWhereWithoutServersInput | server_audit_logsUpdateManyWithWhereWithoutServersInput[]
    deleteMany?: server_audit_logsScalarWhereInput | server_audit_logsScalarWhereInput[]
  }

  export type usersUpdateOneRequiredWithoutServersNestedInput = {
    create?: XOR<usersCreateWithoutServersInput, usersUncheckedCreateWithoutServersInput>
    connectOrCreate?: usersCreateOrConnectWithoutServersInput
    upsert?: usersUpsertWithoutServersInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutServersInput, usersUpdateWithoutServersInput>, usersUncheckedUpdateWithoutServersInput>
  }

  export type server_audit_logsUncheckedUpdateManyWithoutServersNestedInput = {
    create?: XOR<server_audit_logsCreateWithoutServersInput, server_audit_logsUncheckedCreateWithoutServersInput> | server_audit_logsCreateWithoutServersInput[] | server_audit_logsUncheckedCreateWithoutServersInput[]
    connectOrCreate?: server_audit_logsCreateOrConnectWithoutServersInput | server_audit_logsCreateOrConnectWithoutServersInput[]
    upsert?: server_audit_logsUpsertWithWhereUniqueWithoutServersInput | server_audit_logsUpsertWithWhereUniqueWithoutServersInput[]
    createMany?: server_audit_logsCreateManyServersInputEnvelope
    set?: server_audit_logsWhereUniqueInput | server_audit_logsWhereUniqueInput[]
    disconnect?: server_audit_logsWhereUniqueInput | server_audit_logsWhereUniqueInput[]
    delete?: server_audit_logsWhereUniqueInput | server_audit_logsWhereUniqueInput[]
    connect?: server_audit_logsWhereUniqueInput | server_audit_logsWhereUniqueInput[]
    update?: server_audit_logsUpdateWithWhereUniqueWithoutServersInput | server_audit_logsUpdateWithWhereUniqueWithoutServersInput[]
    updateMany?: server_audit_logsUpdateManyWithWhereWithoutServersInput | server_audit_logsUpdateManyWithWhereWithoutServersInput[]
    deleteMany?: server_audit_logsScalarWhereInput | server_audit_logsScalarWhereInput[]
  }

  export type usersCreateNestedOneWithoutUser_bot_logsInput = {
    create?: XOR<usersCreateWithoutUser_bot_logsInput, usersUncheckedCreateWithoutUser_bot_logsInput>
    connectOrCreate?: usersCreateOrConnectWithoutUser_bot_logsInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutUser_bot_logsNestedInput = {
    create?: XOR<usersCreateWithoutUser_bot_logsInput, usersUncheckedCreateWithoutUser_bot_logsInput>
    connectOrCreate?: usersCreateOrConnectWithoutUser_bot_logsInput
    upsert?: usersUpsertWithoutUser_bot_logsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutUser_bot_logsInput, usersUpdateWithoutUser_bot_logsInput>, usersUncheckedUpdateWithoutUser_bot_logsInput>
  }

  export type usersCreateNestedOneWithoutUser_connectionsInput = {
    create?: XOR<usersCreateWithoutUser_connectionsInput, usersUncheckedCreateWithoutUser_connectionsInput>
    connectOrCreate?: usersCreateOrConnectWithoutUser_connectionsInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutUser_connectionsNestedInput = {
    create?: XOR<usersCreateWithoutUser_connectionsInput, usersUncheckedCreateWithoutUser_connectionsInput>
    connectOrCreate?: usersCreateOrConnectWithoutUser_connectionsInput
    upsert?: usersUpsertWithoutUser_connectionsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutUser_connectionsInput, usersUpdateWithoutUser_connectionsInput>, usersUncheckedUpdateWithoutUser_connectionsInput>
  }

  export type usersCreateNestedOneWithoutUser_server_vote_tableInput = {
    create?: XOR<usersCreateWithoutUser_server_vote_tableInput, usersUncheckedCreateWithoutUser_server_vote_tableInput>
    connectOrCreate?: usersCreateOrConnectWithoutUser_server_vote_tableInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutUser_server_vote_tableNestedInput = {
    create?: XOR<usersCreateWithoutUser_server_vote_tableInput, usersUncheckedCreateWithoutUser_server_vote_tableInput>
    connectOrCreate?: usersCreateOrConnectWithoutUser_server_vote_tableInput
    upsert?: usersUpsertWithoutUser_server_vote_tableInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutUser_server_vote_tableInput, usersUpdateWithoutUser_server_vote_tableInput>, usersUncheckedUpdateWithoutUser_server_vote_tableInput>
  }

  export type usersCreateNestedOneWithoutUser_vote_tableInput = {
    create?: XOR<usersCreateWithoutUser_vote_tableInput, usersUncheckedCreateWithoutUser_vote_tableInput>
    connectOrCreate?: usersCreateOrConnectWithoutUser_vote_tableInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutUser_vote_tableNestedInput = {
    create?: XOR<usersCreateWithoutUser_vote_tableInput, usersUncheckedCreateWithoutUser_vote_tableInput>
    connectOrCreate?: usersCreateOrConnectWithoutUser_vote_tableInput
    upsert?: usersUpsertWithoutUser_vote_tableInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutUser_vote_tableInput, usersUpdateWithoutUser_vote_tableInput>, usersUncheckedUpdateWithoutUser_vote_tableInput>
  }

  export type usersCreatebadgesInput = {
    set: string[]
  }

  export type usersCreatevote_remindersInput = {
    set: bigint[] | number[]
  }

  export type usersCreatevote_reminders_serversInput = {
    set: bigint[] | number[]
  }

  export type usersCreateexperimentsInput = {
    set: number[]
  }

  export type usersCreateflagsInput = {
    set: number[]
  }

  export type bot_votersCreateNestedManyWithoutUsersInput = {
    create?: XOR<bot_votersCreateWithoutUsersInput, bot_votersUncheckedCreateWithoutUsersInput> | bot_votersCreateWithoutUsersInput[] | bot_votersUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: bot_votersCreateOrConnectWithoutUsersInput | bot_votersCreateOrConnectWithoutUsersInput[]
    createMany?: bot_votersCreateManyUsersInputEnvelope
    connect?: bot_votersWhereUniqueInput | bot_votersWhereUniqueInput[]
  }

  export type extra_dataCreateNestedManyWithoutUsersInput = {
    create?: XOR<extra_dataCreateWithoutUsersInput, extra_dataUncheckedCreateWithoutUsersInput> | extra_dataCreateWithoutUsersInput[] | extra_dataUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: extra_dataCreateOrConnectWithoutUsersInput | extra_dataCreateOrConnectWithoutUsersInput[]
    createMany?: extra_dataCreateManyUsersInputEnvelope
    connect?: extra_dataWhereUniqueInput | extra_dataWhereUniqueInput[]
  }

  export type frostpaw_clientsCreateNestedManyWithoutUsersInput = {
    create?: XOR<frostpaw_clientsCreateWithoutUsersInput, frostpaw_clientsUncheckedCreateWithoutUsersInput> | frostpaw_clientsCreateWithoutUsersInput[] | frostpaw_clientsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: frostpaw_clientsCreateOrConnectWithoutUsersInput | frostpaw_clientsCreateOrConnectWithoutUsersInput[]
    createMany?: frostpaw_clientsCreateManyUsersInputEnvelope
    connect?: frostpaw_clientsWhereUniqueInput | frostpaw_clientsWhereUniqueInput[]
  }

  export type leave_of_absenceCreateNestedManyWithoutUsersInput = {
    create?: XOR<leave_of_absenceCreateWithoutUsersInput, leave_of_absenceUncheckedCreateWithoutUsersInput> | leave_of_absenceCreateWithoutUsersInput[] | leave_of_absenceUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: leave_of_absenceCreateOrConnectWithoutUsersInput | leave_of_absenceCreateOrConnectWithoutUsersInput[]
    createMany?: leave_of_absenceCreateManyUsersInputEnvelope
    connect?: leave_of_absenceWhereUniqueInput | leave_of_absenceWhereUniqueInput[]
  }

  export type lynx_appsCreateNestedManyWithoutUsersInput = {
    create?: XOR<lynx_appsCreateWithoutUsersInput, lynx_appsUncheckedCreateWithoutUsersInput> | lynx_appsCreateWithoutUsersInput[] | lynx_appsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: lynx_appsCreateOrConnectWithoutUsersInput | lynx_appsCreateOrConnectWithoutUsersInput[]
    createMany?: lynx_appsCreateManyUsersInputEnvelope
    connect?: lynx_appsWhereUniqueInput | lynx_appsWhereUniqueInput[]
  }

  export type lynx_logsCreateNestedManyWithoutUsersInput = {
    create?: XOR<lynx_logsCreateWithoutUsersInput, lynx_logsUncheckedCreateWithoutUsersInput> | lynx_logsCreateWithoutUsersInput[] | lynx_logsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: lynx_logsCreateOrConnectWithoutUsersInput | lynx_logsCreateOrConnectWithoutUsersInput[]
    createMany?: lynx_logsCreateManyUsersInputEnvelope
    connect?: lynx_logsWhereUniqueInput | lynx_logsWhereUniqueInput[]
  }

  export type lynx_ratingsCreateNestedManyWithoutUsersInput = {
    create?: XOR<lynx_ratingsCreateWithoutUsersInput, lynx_ratingsUncheckedCreateWithoutUsersInput> | lynx_ratingsCreateWithoutUsersInput[] | lynx_ratingsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: lynx_ratingsCreateOrConnectWithoutUsersInput | lynx_ratingsCreateOrConnectWithoutUsersInput[]
    createMany?: lynx_ratingsCreateManyUsersInputEnvelope
    connect?: lynx_ratingsWhereUniqueInput | lynx_ratingsWhereUniqueInput[]
  }

  export type lynx_survey_responsesCreateNestedManyWithoutUsersInput = {
    create?: XOR<lynx_survey_responsesCreateWithoutUsersInput, lynx_survey_responsesUncheckedCreateWithoutUsersInput> | lynx_survey_responsesCreateWithoutUsersInput[] | lynx_survey_responsesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: lynx_survey_responsesCreateOrConnectWithoutUsersInput | lynx_survey_responsesCreateOrConnectWithoutUsersInput[]
    createMany?: lynx_survey_responsesCreateManyUsersInputEnvelope
    connect?: lynx_survey_responsesWhereUniqueInput | lynx_survey_responsesWhereUniqueInput[]
  }

  export type push_notificationsCreateNestedManyWithoutUsersInput = {
    create?: XOR<push_notificationsCreateWithoutUsersInput, push_notificationsUncheckedCreateWithoutUsersInput> | push_notificationsCreateWithoutUsersInput[] | push_notificationsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: push_notificationsCreateOrConnectWithoutUsersInput | push_notificationsCreateOrConnectWithoutUsersInput[]
    createMany?: push_notificationsCreateManyUsersInputEnvelope
    connect?: push_notificationsWhereUniqueInput | push_notificationsWhereUniqueInput[]
  }

  export type review_votesCreateNestedManyWithoutUsersInput = {
    create?: XOR<review_votesCreateWithoutUsersInput, review_votesUncheckedCreateWithoutUsersInput> | review_votesCreateWithoutUsersInput[] | review_votesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: review_votesCreateOrConnectWithoutUsersInput | review_votesCreateOrConnectWithoutUsersInput[]
    createMany?: review_votesCreateManyUsersInputEnvelope
    connect?: review_votesWhereUniqueInput | review_votesWhereUniqueInput[]
  }

  export type reviewsCreateNestedManyWithoutUsersInput = {
    create?: XOR<reviewsCreateWithoutUsersInput, reviewsUncheckedCreateWithoutUsersInput> | reviewsCreateWithoutUsersInput[] | reviewsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: reviewsCreateOrConnectWithoutUsersInput | reviewsCreateOrConnectWithoutUsersInput[]
    createMany?: reviewsCreateManyUsersInputEnvelope
    connect?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
  }

  export type server_audit_logsCreateNestedManyWithoutUsersInput = {
    create?: XOR<server_audit_logsCreateWithoutUsersInput, server_audit_logsUncheckedCreateWithoutUsersInput> | server_audit_logsCreateWithoutUsersInput[] | server_audit_logsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: server_audit_logsCreateOrConnectWithoutUsersInput | server_audit_logsCreateOrConnectWithoutUsersInput[]
    createMany?: server_audit_logsCreateManyUsersInputEnvelope
    connect?: server_audit_logsWhereUniqueInput | server_audit_logsWhereUniqueInput[]
  }

  export type server_votersCreateNestedManyWithoutUsersInput = {
    create?: XOR<server_votersCreateWithoutUsersInput, server_votersUncheckedCreateWithoutUsersInput> | server_votersCreateWithoutUsersInput[] | server_votersUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: server_votersCreateOrConnectWithoutUsersInput | server_votersCreateOrConnectWithoutUsersInput[]
    createMany?: server_votersCreateManyUsersInputEnvelope
    connect?: server_votersWhereUniqueInput | server_votersWhereUniqueInput[]
  }

  export type serversCreateNestedManyWithoutUsersInput = {
    create?: XOR<serversCreateWithoutUsersInput, serversUncheckedCreateWithoutUsersInput> | serversCreateWithoutUsersInput[] | serversUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: serversCreateOrConnectWithoutUsersInput | serversCreateOrConnectWithoutUsersInput[]
    createMany?: serversCreateManyUsersInputEnvelope
    connect?: serversWhereUniqueInput | serversWhereUniqueInput[]
  }

  export type user_bot_logsCreateNestedManyWithoutUsersInput = {
    create?: XOR<user_bot_logsCreateWithoutUsersInput, user_bot_logsUncheckedCreateWithoutUsersInput> | user_bot_logsCreateWithoutUsersInput[] | user_bot_logsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_bot_logsCreateOrConnectWithoutUsersInput | user_bot_logsCreateOrConnectWithoutUsersInput[]
    createMany?: user_bot_logsCreateManyUsersInputEnvelope
    connect?: user_bot_logsWhereUniqueInput | user_bot_logsWhereUniqueInput[]
  }

  export type user_connectionsCreateNestedManyWithoutUsersInput = {
    create?: XOR<user_connectionsCreateWithoutUsersInput, user_connectionsUncheckedCreateWithoutUsersInput> | user_connectionsCreateWithoutUsersInput[] | user_connectionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_connectionsCreateOrConnectWithoutUsersInput | user_connectionsCreateOrConnectWithoutUsersInput[]
    createMany?: user_connectionsCreateManyUsersInputEnvelope
    connect?: user_connectionsWhereUniqueInput | user_connectionsWhereUniqueInput[]
  }

  export type user_server_vote_tableCreateNestedOneWithoutUsersInput = {
    create?: XOR<user_server_vote_tableCreateWithoutUsersInput, user_server_vote_tableUncheckedCreateWithoutUsersInput>
    connectOrCreate?: user_server_vote_tableCreateOrConnectWithoutUsersInput
    connect?: user_server_vote_tableWhereUniqueInput
  }

  export type user_vote_tableCreateNestedOneWithoutUsersInput = {
    create?: XOR<user_vote_tableCreateWithoutUsersInput, user_vote_tableUncheckedCreateWithoutUsersInput>
    connectOrCreate?: user_vote_tableCreateOrConnectWithoutUsersInput
    connect?: user_vote_tableWhereUniqueInput
  }

  export type bot_votersUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<bot_votersCreateWithoutUsersInput, bot_votersUncheckedCreateWithoutUsersInput> | bot_votersCreateWithoutUsersInput[] | bot_votersUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: bot_votersCreateOrConnectWithoutUsersInput | bot_votersCreateOrConnectWithoutUsersInput[]
    createMany?: bot_votersCreateManyUsersInputEnvelope
    connect?: bot_votersWhereUniqueInput | bot_votersWhereUniqueInput[]
  }

  export type extra_dataUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<extra_dataCreateWithoutUsersInput, extra_dataUncheckedCreateWithoutUsersInput> | extra_dataCreateWithoutUsersInput[] | extra_dataUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: extra_dataCreateOrConnectWithoutUsersInput | extra_dataCreateOrConnectWithoutUsersInput[]
    createMany?: extra_dataCreateManyUsersInputEnvelope
    connect?: extra_dataWhereUniqueInput | extra_dataWhereUniqueInput[]
  }

  export type frostpaw_clientsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<frostpaw_clientsCreateWithoutUsersInput, frostpaw_clientsUncheckedCreateWithoutUsersInput> | frostpaw_clientsCreateWithoutUsersInput[] | frostpaw_clientsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: frostpaw_clientsCreateOrConnectWithoutUsersInput | frostpaw_clientsCreateOrConnectWithoutUsersInput[]
    createMany?: frostpaw_clientsCreateManyUsersInputEnvelope
    connect?: frostpaw_clientsWhereUniqueInput | frostpaw_clientsWhereUniqueInput[]
  }

  export type leave_of_absenceUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<leave_of_absenceCreateWithoutUsersInput, leave_of_absenceUncheckedCreateWithoutUsersInput> | leave_of_absenceCreateWithoutUsersInput[] | leave_of_absenceUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: leave_of_absenceCreateOrConnectWithoutUsersInput | leave_of_absenceCreateOrConnectWithoutUsersInput[]
    createMany?: leave_of_absenceCreateManyUsersInputEnvelope
    connect?: leave_of_absenceWhereUniqueInput | leave_of_absenceWhereUniqueInput[]
  }

  export type lynx_appsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<lynx_appsCreateWithoutUsersInput, lynx_appsUncheckedCreateWithoutUsersInput> | lynx_appsCreateWithoutUsersInput[] | lynx_appsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: lynx_appsCreateOrConnectWithoutUsersInput | lynx_appsCreateOrConnectWithoutUsersInput[]
    createMany?: lynx_appsCreateManyUsersInputEnvelope
    connect?: lynx_appsWhereUniqueInput | lynx_appsWhereUniqueInput[]
  }

  export type lynx_logsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<lynx_logsCreateWithoutUsersInput, lynx_logsUncheckedCreateWithoutUsersInput> | lynx_logsCreateWithoutUsersInput[] | lynx_logsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: lynx_logsCreateOrConnectWithoutUsersInput | lynx_logsCreateOrConnectWithoutUsersInput[]
    createMany?: lynx_logsCreateManyUsersInputEnvelope
    connect?: lynx_logsWhereUniqueInput | lynx_logsWhereUniqueInput[]
  }

  export type lynx_ratingsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<lynx_ratingsCreateWithoutUsersInput, lynx_ratingsUncheckedCreateWithoutUsersInput> | lynx_ratingsCreateWithoutUsersInput[] | lynx_ratingsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: lynx_ratingsCreateOrConnectWithoutUsersInput | lynx_ratingsCreateOrConnectWithoutUsersInput[]
    createMany?: lynx_ratingsCreateManyUsersInputEnvelope
    connect?: lynx_ratingsWhereUniqueInput | lynx_ratingsWhereUniqueInput[]
  }

  export type lynx_survey_responsesUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<lynx_survey_responsesCreateWithoutUsersInput, lynx_survey_responsesUncheckedCreateWithoutUsersInput> | lynx_survey_responsesCreateWithoutUsersInput[] | lynx_survey_responsesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: lynx_survey_responsesCreateOrConnectWithoutUsersInput | lynx_survey_responsesCreateOrConnectWithoutUsersInput[]
    createMany?: lynx_survey_responsesCreateManyUsersInputEnvelope
    connect?: lynx_survey_responsesWhereUniqueInput | lynx_survey_responsesWhereUniqueInput[]
  }

  export type push_notificationsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<push_notificationsCreateWithoutUsersInput, push_notificationsUncheckedCreateWithoutUsersInput> | push_notificationsCreateWithoutUsersInput[] | push_notificationsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: push_notificationsCreateOrConnectWithoutUsersInput | push_notificationsCreateOrConnectWithoutUsersInput[]
    createMany?: push_notificationsCreateManyUsersInputEnvelope
    connect?: push_notificationsWhereUniqueInput | push_notificationsWhereUniqueInput[]
  }

  export type review_votesUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<review_votesCreateWithoutUsersInput, review_votesUncheckedCreateWithoutUsersInput> | review_votesCreateWithoutUsersInput[] | review_votesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: review_votesCreateOrConnectWithoutUsersInput | review_votesCreateOrConnectWithoutUsersInput[]
    createMany?: review_votesCreateManyUsersInputEnvelope
    connect?: review_votesWhereUniqueInput | review_votesWhereUniqueInput[]
  }

  export type reviewsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<reviewsCreateWithoutUsersInput, reviewsUncheckedCreateWithoutUsersInput> | reviewsCreateWithoutUsersInput[] | reviewsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: reviewsCreateOrConnectWithoutUsersInput | reviewsCreateOrConnectWithoutUsersInput[]
    createMany?: reviewsCreateManyUsersInputEnvelope
    connect?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
  }

  export type server_audit_logsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<server_audit_logsCreateWithoutUsersInput, server_audit_logsUncheckedCreateWithoutUsersInput> | server_audit_logsCreateWithoutUsersInput[] | server_audit_logsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: server_audit_logsCreateOrConnectWithoutUsersInput | server_audit_logsCreateOrConnectWithoutUsersInput[]
    createMany?: server_audit_logsCreateManyUsersInputEnvelope
    connect?: server_audit_logsWhereUniqueInput | server_audit_logsWhereUniqueInput[]
  }

  export type server_votersUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<server_votersCreateWithoutUsersInput, server_votersUncheckedCreateWithoutUsersInput> | server_votersCreateWithoutUsersInput[] | server_votersUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: server_votersCreateOrConnectWithoutUsersInput | server_votersCreateOrConnectWithoutUsersInput[]
    createMany?: server_votersCreateManyUsersInputEnvelope
    connect?: server_votersWhereUniqueInput | server_votersWhereUniqueInput[]
  }

  export type serversUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<serversCreateWithoutUsersInput, serversUncheckedCreateWithoutUsersInput> | serversCreateWithoutUsersInput[] | serversUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: serversCreateOrConnectWithoutUsersInput | serversCreateOrConnectWithoutUsersInput[]
    createMany?: serversCreateManyUsersInputEnvelope
    connect?: serversWhereUniqueInput | serversWhereUniqueInput[]
  }

  export type user_bot_logsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<user_bot_logsCreateWithoutUsersInput, user_bot_logsUncheckedCreateWithoutUsersInput> | user_bot_logsCreateWithoutUsersInput[] | user_bot_logsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_bot_logsCreateOrConnectWithoutUsersInput | user_bot_logsCreateOrConnectWithoutUsersInput[]
    createMany?: user_bot_logsCreateManyUsersInputEnvelope
    connect?: user_bot_logsWhereUniqueInput | user_bot_logsWhereUniqueInput[]
  }

  export type user_connectionsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<user_connectionsCreateWithoutUsersInput, user_connectionsUncheckedCreateWithoutUsersInput> | user_connectionsCreateWithoutUsersInput[] | user_connectionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_connectionsCreateOrConnectWithoutUsersInput | user_connectionsCreateOrConnectWithoutUsersInput[]
    createMany?: user_connectionsCreateManyUsersInputEnvelope
    connect?: user_connectionsWhereUniqueInput | user_connectionsWhereUniqueInput[]
  }

  export type user_server_vote_tableUncheckedCreateNestedOneWithoutUsersInput = {
    create?: XOR<user_server_vote_tableCreateWithoutUsersInput, user_server_vote_tableUncheckedCreateWithoutUsersInput>
    connectOrCreate?: user_server_vote_tableCreateOrConnectWithoutUsersInput
    connect?: user_server_vote_tableWhereUniqueInput
  }

  export type user_vote_tableUncheckedCreateNestedOneWithoutUsersInput = {
    create?: XOR<user_vote_tableCreateWithoutUsersInput, user_vote_tableUncheckedCreateWithoutUsersInput>
    connectOrCreate?: user_vote_tableCreateOrConnectWithoutUsersInput
    connect?: user_vote_tableWhereUniqueInput
  }

  export type usersUpdatebadgesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type usersUpdatevote_remindersInput = {
    set?: bigint[] | number[]
    push?: bigint | number | bigint[] | number[]
  }

  export type usersUpdatevote_reminders_serversInput = {
    set?: bigint[] | number[]
    push?: bigint | number | bigint[] | number[]
  }

  export type usersUpdateexperimentsInput = {
    set?: number[]
    push?: number | number[]
  }

  export type usersUpdateflagsInput = {
    set?: number[]
    push?: number | number[]
  }

  export type bot_votersUpdateManyWithoutUsersNestedInput = {
    create?: XOR<bot_votersCreateWithoutUsersInput, bot_votersUncheckedCreateWithoutUsersInput> | bot_votersCreateWithoutUsersInput[] | bot_votersUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: bot_votersCreateOrConnectWithoutUsersInput | bot_votersCreateOrConnectWithoutUsersInput[]
    upsert?: bot_votersUpsertWithWhereUniqueWithoutUsersInput | bot_votersUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: bot_votersCreateManyUsersInputEnvelope
    set?: bot_votersWhereUniqueInput | bot_votersWhereUniqueInput[]
    disconnect?: bot_votersWhereUniqueInput | bot_votersWhereUniqueInput[]
    delete?: bot_votersWhereUniqueInput | bot_votersWhereUniqueInput[]
    connect?: bot_votersWhereUniqueInput | bot_votersWhereUniqueInput[]
    update?: bot_votersUpdateWithWhereUniqueWithoutUsersInput | bot_votersUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: bot_votersUpdateManyWithWhereWithoutUsersInput | bot_votersUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: bot_votersScalarWhereInput | bot_votersScalarWhereInput[]
  }

  export type extra_dataUpdateManyWithoutUsersNestedInput = {
    create?: XOR<extra_dataCreateWithoutUsersInput, extra_dataUncheckedCreateWithoutUsersInput> | extra_dataCreateWithoutUsersInput[] | extra_dataUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: extra_dataCreateOrConnectWithoutUsersInput | extra_dataCreateOrConnectWithoutUsersInput[]
    upsert?: extra_dataUpsertWithWhereUniqueWithoutUsersInput | extra_dataUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: extra_dataCreateManyUsersInputEnvelope
    set?: extra_dataWhereUniqueInput | extra_dataWhereUniqueInput[]
    disconnect?: extra_dataWhereUniqueInput | extra_dataWhereUniqueInput[]
    delete?: extra_dataWhereUniqueInput | extra_dataWhereUniqueInput[]
    connect?: extra_dataWhereUniqueInput | extra_dataWhereUniqueInput[]
    update?: extra_dataUpdateWithWhereUniqueWithoutUsersInput | extra_dataUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: extra_dataUpdateManyWithWhereWithoutUsersInput | extra_dataUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: extra_dataScalarWhereInput | extra_dataScalarWhereInput[]
  }

  export type frostpaw_clientsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<frostpaw_clientsCreateWithoutUsersInput, frostpaw_clientsUncheckedCreateWithoutUsersInput> | frostpaw_clientsCreateWithoutUsersInput[] | frostpaw_clientsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: frostpaw_clientsCreateOrConnectWithoutUsersInput | frostpaw_clientsCreateOrConnectWithoutUsersInput[]
    upsert?: frostpaw_clientsUpsertWithWhereUniqueWithoutUsersInput | frostpaw_clientsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: frostpaw_clientsCreateManyUsersInputEnvelope
    set?: frostpaw_clientsWhereUniqueInput | frostpaw_clientsWhereUniqueInput[]
    disconnect?: frostpaw_clientsWhereUniqueInput | frostpaw_clientsWhereUniqueInput[]
    delete?: frostpaw_clientsWhereUniqueInput | frostpaw_clientsWhereUniqueInput[]
    connect?: frostpaw_clientsWhereUniqueInput | frostpaw_clientsWhereUniqueInput[]
    update?: frostpaw_clientsUpdateWithWhereUniqueWithoutUsersInput | frostpaw_clientsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: frostpaw_clientsUpdateManyWithWhereWithoutUsersInput | frostpaw_clientsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: frostpaw_clientsScalarWhereInput | frostpaw_clientsScalarWhereInput[]
  }

  export type leave_of_absenceUpdateManyWithoutUsersNestedInput = {
    create?: XOR<leave_of_absenceCreateWithoutUsersInput, leave_of_absenceUncheckedCreateWithoutUsersInput> | leave_of_absenceCreateWithoutUsersInput[] | leave_of_absenceUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: leave_of_absenceCreateOrConnectWithoutUsersInput | leave_of_absenceCreateOrConnectWithoutUsersInput[]
    upsert?: leave_of_absenceUpsertWithWhereUniqueWithoutUsersInput | leave_of_absenceUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: leave_of_absenceCreateManyUsersInputEnvelope
    set?: leave_of_absenceWhereUniqueInput | leave_of_absenceWhereUniqueInput[]
    disconnect?: leave_of_absenceWhereUniqueInput | leave_of_absenceWhereUniqueInput[]
    delete?: leave_of_absenceWhereUniqueInput | leave_of_absenceWhereUniqueInput[]
    connect?: leave_of_absenceWhereUniqueInput | leave_of_absenceWhereUniqueInput[]
    update?: leave_of_absenceUpdateWithWhereUniqueWithoutUsersInput | leave_of_absenceUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: leave_of_absenceUpdateManyWithWhereWithoutUsersInput | leave_of_absenceUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: leave_of_absenceScalarWhereInput | leave_of_absenceScalarWhereInput[]
  }

  export type lynx_appsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<lynx_appsCreateWithoutUsersInput, lynx_appsUncheckedCreateWithoutUsersInput> | lynx_appsCreateWithoutUsersInput[] | lynx_appsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: lynx_appsCreateOrConnectWithoutUsersInput | lynx_appsCreateOrConnectWithoutUsersInput[]
    upsert?: lynx_appsUpsertWithWhereUniqueWithoutUsersInput | lynx_appsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: lynx_appsCreateManyUsersInputEnvelope
    set?: lynx_appsWhereUniqueInput | lynx_appsWhereUniqueInput[]
    disconnect?: lynx_appsWhereUniqueInput | lynx_appsWhereUniqueInput[]
    delete?: lynx_appsWhereUniqueInput | lynx_appsWhereUniqueInput[]
    connect?: lynx_appsWhereUniqueInput | lynx_appsWhereUniqueInput[]
    update?: lynx_appsUpdateWithWhereUniqueWithoutUsersInput | lynx_appsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: lynx_appsUpdateManyWithWhereWithoutUsersInput | lynx_appsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: lynx_appsScalarWhereInput | lynx_appsScalarWhereInput[]
  }

  export type lynx_logsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<lynx_logsCreateWithoutUsersInput, lynx_logsUncheckedCreateWithoutUsersInput> | lynx_logsCreateWithoutUsersInput[] | lynx_logsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: lynx_logsCreateOrConnectWithoutUsersInput | lynx_logsCreateOrConnectWithoutUsersInput[]
    upsert?: lynx_logsUpsertWithWhereUniqueWithoutUsersInput | lynx_logsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: lynx_logsCreateManyUsersInputEnvelope
    set?: lynx_logsWhereUniqueInput | lynx_logsWhereUniqueInput[]
    disconnect?: lynx_logsWhereUniqueInput | lynx_logsWhereUniqueInput[]
    delete?: lynx_logsWhereUniqueInput | lynx_logsWhereUniqueInput[]
    connect?: lynx_logsWhereUniqueInput | lynx_logsWhereUniqueInput[]
    update?: lynx_logsUpdateWithWhereUniqueWithoutUsersInput | lynx_logsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: lynx_logsUpdateManyWithWhereWithoutUsersInput | lynx_logsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: lynx_logsScalarWhereInput | lynx_logsScalarWhereInput[]
  }

  export type lynx_ratingsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<lynx_ratingsCreateWithoutUsersInput, lynx_ratingsUncheckedCreateWithoutUsersInput> | lynx_ratingsCreateWithoutUsersInput[] | lynx_ratingsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: lynx_ratingsCreateOrConnectWithoutUsersInput | lynx_ratingsCreateOrConnectWithoutUsersInput[]
    upsert?: lynx_ratingsUpsertWithWhereUniqueWithoutUsersInput | lynx_ratingsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: lynx_ratingsCreateManyUsersInputEnvelope
    set?: lynx_ratingsWhereUniqueInput | lynx_ratingsWhereUniqueInput[]
    disconnect?: lynx_ratingsWhereUniqueInput | lynx_ratingsWhereUniqueInput[]
    delete?: lynx_ratingsWhereUniqueInput | lynx_ratingsWhereUniqueInput[]
    connect?: lynx_ratingsWhereUniqueInput | lynx_ratingsWhereUniqueInput[]
    update?: lynx_ratingsUpdateWithWhereUniqueWithoutUsersInput | lynx_ratingsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: lynx_ratingsUpdateManyWithWhereWithoutUsersInput | lynx_ratingsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: lynx_ratingsScalarWhereInput | lynx_ratingsScalarWhereInput[]
  }

  export type lynx_survey_responsesUpdateManyWithoutUsersNestedInput = {
    create?: XOR<lynx_survey_responsesCreateWithoutUsersInput, lynx_survey_responsesUncheckedCreateWithoutUsersInput> | lynx_survey_responsesCreateWithoutUsersInput[] | lynx_survey_responsesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: lynx_survey_responsesCreateOrConnectWithoutUsersInput | lynx_survey_responsesCreateOrConnectWithoutUsersInput[]
    upsert?: lynx_survey_responsesUpsertWithWhereUniqueWithoutUsersInput | lynx_survey_responsesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: lynx_survey_responsesCreateManyUsersInputEnvelope
    set?: lynx_survey_responsesWhereUniqueInput | lynx_survey_responsesWhereUniqueInput[]
    disconnect?: lynx_survey_responsesWhereUniqueInput | lynx_survey_responsesWhereUniqueInput[]
    delete?: lynx_survey_responsesWhereUniqueInput | lynx_survey_responsesWhereUniqueInput[]
    connect?: lynx_survey_responsesWhereUniqueInput | lynx_survey_responsesWhereUniqueInput[]
    update?: lynx_survey_responsesUpdateWithWhereUniqueWithoutUsersInput | lynx_survey_responsesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: lynx_survey_responsesUpdateManyWithWhereWithoutUsersInput | lynx_survey_responsesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: lynx_survey_responsesScalarWhereInput | lynx_survey_responsesScalarWhereInput[]
  }

  export type push_notificationsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<push_notificationsCreateWithoutUsersInput, push_notificationsUncheckedCreateWithoutUsersInput> | push_notificationsCreateWithoutUsersInput[] | push_notificationsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: push_notificationsCreateOrConnectWithoutUsersInput | push_notificationsCreateOrConnectWithoutUsersInput[]
    upsert?: push_notificationsUpsertWithWhereUniqueWithoutUsersInput | push_notificationsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: push_notificationsCreateManyUsersInputEnvelope
    set?: push_notificationsWhereUniqueInput | push_notificationsWhereUniqueInput[]
    disconnect?: push_notificationsWhereUniqueInput | push_notificationsWhereUniqueInput[]
    delete?: push_notificationsWhereUniqueInput | push_notificationsWhereUniqueInput[]
    connect?: push_notificationsWhereUniqueInput | push_notificationsWhereUniqueInput[]
    update?: push_notificationsUpdateWithWhereUniqueWithoutUsersInput | push_notificationsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: push_notificationsUpdateManyWithWhereWithoutUsersInput | push_notificationsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: push_notificationsScalarWhereInput | push_notificationsScalarWhereInput[]
  }

  export type review_votesUpdateManyWithoutUsersNestedInput = {
    create?: XOR<review_votesCreateWithoutUsersInput, review_votesUncheckedCreateWithoutUsersInput> | review_votesCreateWithoutUsersInput[] | review_votesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: review_votesCreateOrConnectWithoutUsersInput | review_votesCreateOrConnectWithoutUsersInput[]
    upsert?: review_votesUpsertWithWhereUniqueWithoutUsersInput | review_votesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: review_votesCreateManyUsersInputEnvelope
    set?: review_votesWhereUniqueInput | review_votesWhereUniqueInput[]
    disconnect?: review_votesWhereUniqueInput | review_votesWhereUniqueInput[]
    delete?: review_votesWhereUniqueInput | review_votesWhereUniqueInput[]
    connect?: review_votesWhereUniqueInput | review_votesWhereUniqueInput[]
    update?: review_votesUpdateWithWhereUniqueWithoutUsersInput | review_votesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: review_votesUpdateManyWithWhereWithoutUsersInput | review_votesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: review_votesScalarWhereInput | review_votesScalarWhereInput[]
  }

  export type reviewsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<reviewsCreateWithoutUsersInput, reviewsUncheckedCreateWithoutUsersInput> | reviewsCreateWithoutUsersInput[] | reviewsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: reviewsCreateOrConnectWithoutUsersInput | reviewsCreateOrConnectWithoutUsersInput[]
    upsert?: reviewsUpsertWithWhereUniqueWithoutUsersInput | reviewsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: reviewsCreateManyUsersInputEnvelope
    set?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    disconnect?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    delete?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    connect?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    update?: reviewsUpdateWithWhereUniqueWithoutUsersInput | reviewsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: reviewsUpdateManyWithWhereWithoutUsersInput | reviewsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: reviewsScalarWhereInput | reviewsScalarWhereInput[]
  }

  export type server_audit_logsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<server_audit_logsCreateWithoutUsersInput, server_audit_logsUncheckedCreateWithoutUsersInput> | server_audit_logsCreateWithoutUsersInput[] | server_audit_logsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: server_audit_logsCreateOrConnectWithoutUsersInput | server_audit_logsCreateOrConnectWithoutUsersInput[]
    upsert?: server_audit_logsUpsertWithWhereUniqueWithoutUsersInput | server_audit_logsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: server_audit_logsCreateManyUsersInputEnvelope
    set?: server_audit_logsWhereUniqueInput | server_audit_logsWhereUniqueInput[]
    disconnect?: server_audit_logsWhereUniqueInput | server_audit_logsWhereUniqueInput[]
    delete?: server_audit_logsWhereUniqueInput | server_audit_logsWhereUniqueInput[]
    connect?: server_audit_logsWhereUniqueInput | server_audit_logsWhereUniqueInput[]
    update?: server_audit_logsUpdateWithWhereUniqueWithoutUsersInput | server_audit_logsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: server_audit_logsUpdateManyWithWhereWithoutUsersInput | server_audit_logsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: server_audit_logsScalarWhereInput | server_audit_logsScalarWhereInput[]
  }

  export type server_votersUpdateManyWithoutUsersNestedInput = {
    create?: XOR<server_votersCreateWithoutUsersInput, server_votersUncheckedCreateWithoutUsersInput> | server_votersCreateWithoutUsersInput[] | server_votersUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: server_votersCreateOrConnectWithoutUsersInput | server_votersCreateOrConnectWithoutUsersInput[]
    upsert?: server_votersUpsertWithWhereUniqueWithoutUsersInput | server_votersUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: server_votersCreateManyUsersInputEnvelope
    set?: server_votersWhereUniqueInput | server_votersWhereUniqueInput[]
    disconnect?: server_votersWhereUniqueInput | server_votersWhereUniqueInput[]
    delete?: server_votersWhereUniqueInput | server_votersWhereUniqueInput[]
    connect?: server_votersWhereUniqueInput | server_votersWhereUniqueInput[]
    update?: server_votersUpdateWithWhereUniqueWithoutUsersInput | server_votersUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: server_votersUpdateManyWithWhereWithoutUsersInput | server_votersUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: server_votersScalarWhereInput | server_votersScalarWhereInput[]
  }

  export type serversUpdateManyWithoutUsersNestedInput = {
    create?: XOR<serversCreateWithoutUsersInput, serversUncheckedCreateWithoutUsersInput> | serversCreateWithoutUsersInput[] | serversUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: serversCreateOrConnectWithoutUsersInput | serversCreateOrConnectWithoutUsersInput[]
    upsert?: serversUpsertWithWhereUniqueWithoutUsersInput | serversUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: serversCreateManyUsersInputEnvelope
    set?: serversWhereUniqueInput | serversWhereUniqueInput[]
    disconnect?: serversWhereUniqueInput | serversWhereUniqueInput[]
    delete?: serversWhereUniqueInput | serversWhereUniqueInput[]
    connect?: serversWhereUniqueInput | serversWhereUniqueInput[]
    update?: serversUpdateWithWhereUniqueWithoutUsersInput | serversUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: serversUpdateManyWithWhereWithoutUsersInput | serversUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: serversScalarWhereInput | serversScalarWhereInput[]
  }

  export type user_bot_logsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<user_bot_logsCreateWithoutUsersInput, user_bot_logsUncheckedCreateWithoutUsersInput> | user_bot_logsCreateWithoutUsersInput[] | user_bot_logsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_bot_logsCreateOrConnectWithoutUsersInput | user_bot_logsCreateOrConnectWithoutUsersInput[]
    upsert?: user_bot_logsUpsertWithWhereUniqueWithoutUsersInput | user_bot_logsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: user_bot_logsCreateManyUsersInputEnvelope
    set?: user_bot_logsWhereUniqueInput | user_bot_logsWhereUniqueInput[]
    disconnect?: user_bot_logsWhereUniqueInput | user_bot_logsWhereUniqueInput[]
    delete?: user_bot_logsWhereUniqueInput | user_bot_logsWhereUniqueInput[]
    connect?: user_bot_logsWhereUniqueInput | user_bot_logsWhereUniqueInput[]
    update?: user_bot_logsUpdateWithWhereUniqueWithoutUsersInput | user_bot_logsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: user_bot_logsUpdateManyWithWhereWithoutUsersInput | user_bot_logsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: user_bot_logsScalarWhereInput | user_bot_logsScalarWhereInput[]
  }

  export type user_connectionsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<user_connectionsCreateWithoutUsersInput, user_connectionsUncheckedCreateWithoutUsersInput> | user_connectionsCreateWithoutUsersInput[] | user_connectionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_connectionsCreateOrConnectWithoutUsersInput | user_connectionsCreateOrConnectWithoutUsersInput[]
    upsert?: user_connectionsUpsertWithWhereUniqueWithoutUsersInput | user_connectionsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: user_connectionsCreateManyUsersInputEnvelope
    set?: user_connectionsWhereUniqueInput | user_connectionsWhereUniqueInput[]
    disconnect?: user_connectionsWhereUniqueInput | user_connectionsWhereUniqueInput[]
    delete?: user_connectionsWhereUniqueInput | user_connectionsWhereUniqueInput[]
    connect?: user_connectionsWhereUniqueInput | user_connectionsWhereUniqueInput[]
    update?: user_connectionsUpdateWithWhereUniqueWithoutUsersInput | user_connectionsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: user_connectionsUpdateManyWithWhereWithoutUsersInput | user_connectionsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: user_connectionsScalarWhereInput | user_connectionsScalarWhereInput[]
  }

  export type user_server_vote_tableUpdateOneWithoutUsersNestedInput = {
    create?: XOR<user_server_vote_tableCreateWithoutUsersInput, user_server_vote_tableUncheckedCreateWithoutUsersInput>
    connectOrCreate?: user_server_vote_tableCreateOrConnectWithoutUsersInput
    upsert?: user_server_vote_tableUpsertWithoutUsersInput
    disconnect?: user_server_vote_tableWhereInput | boolean
    delete?: user_server_vote_tableWhereInput | boolean
    connect?: user_server_vote_tableWhereUniqueInput
    update?: XOR<XOR<user_server_vote_tableUpdateToOneWithWhereWithoutUsersInput, user_server_vote_tableUpdateWithoutUsersInput>, user_server_vote_tableUncheckedUpdateWithoutUsersInput>
  }

  export type user_vote_tableUpdateOneWithoutUsersNestedInput = {
    create?: XOR<user_vote_tableCreateWithoutUsersInput, user_vote_tableUncheckedCreateWithoutUsersInput>
    connectOrCreate?: user_vote_tableCreateOrConnectWithoutUsersInput
    upsert?: user_vote_tableUpsertWithoutUsersInput
    disconnect?: user_vote_tableWhereInput | boolean
    delete?: user_vote_tableWhereInput | boolean
    connect?: user_vote_tableWhereUniqueInput
    update?: XOR<XOR<user_vote_tableUpdateToOneWithWhereWithoutUsersInput, user_vote_tableUpdateWithoutUsersInput>, user_vote_tableUncheckedUpdateWithoutUsersInput>
  }

  export type bot_votersUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<bot_votersCreateWithoutUsersInput, bot_votersUncheckedCreateWithoutUsersInput> | bot_votersCreateWithoutUsersInput[] | bot_votersUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: bot_votersCreateOrConnectWithoutUsersInput | bot_votersCreateOrConnectWithoutUsersInput[]
    upsert?: bot_votersUpsertWithWhereUniqueWithoutUsersInput | bot_votersUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: bot_votersCreateManyUsersInputEnvelope
    set?: bot_votersWhereUniqueInput | bot_votersWhereUniqueInput[]
    disconnect?: bot_votersWhereUniqueInput | bot_votersWhereUniqueInput[]
    delete?: bot_votersWhereUniqueInput | bot_votersWhereUniqueInput[]
    connect?: bot_votersWhereUniqueInput | bot_votersWhereUniqueInput[]
    update?: bot_votersUpdateWithWhereUniqueWithoutUsersInput | bot_votersUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: bot_votersUpdateManyWithWhereWithoutUsersInput | bot_votersUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: bot_votersScalarWhereInput | bot_votersScalarWhereInput[]
  }

  export type extra_dataUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<extra_dataCreateWithoutUsersInput, extra_dataUncheckedCreateWithoutUsersInput> | extra_dataCreateWithoutUsersInput[] | extra_dataUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: extra_dataCreateOrConnectWithoutUsersInput | extra_dataCreateOrConnectWithoutUsersInput[]
    upsert?: extra_dataUpsertWithWhereUniqueWithoutUsersInput | extra_dataUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: extra_dataCreateManyUsersInputEnvelope
    set?: extra_dataWhereUniqueInput | extra_dataWhereUniqueInput[]
    disconnect?: extra_dataWhereUniqueInput | extra_dataWhereUniqueInput[]
    delete?: extra_dataWhereUniqueInput | extra_dataWhereUniqueInput[]
    connect?: extra_dataWhereUniqueInput | extra_dataWhereUniqueInput[]
    update?: extra_dataUpdateWithWhereUniqueWithoutUsersInput | extra_dataUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: extra_dataUpdateManyWithWhereWithoutUsersInput | extra_dataUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: extra_dataScalarWhereInput | extra_dataScalarWhereInput[]
  }

  export type frostpaw_clientsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<frostpaw_clientsCreateWithoutUsersInput, frostpaw_clientsUncheckedCreateWithoutUsersInput> | frostpaw_clientsCreateWithoutUsersInput[] | frostpaw_clientsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: frostpaw_clientsCreateOrConnectWithoutUsersInput | frostpaw_clientsCreateOrConnectWithoutUsersInput[]
    upsert?: frostpaw_clientsUpsertWithWhereUniqueWithoutUsersInput | frostpaw_clientsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: frostpaw_clientsCreateManyUsersInputEnvelope
    set?: frostpaw_clientsWhereUniqueInput | frostpaw_clientsWhereUniqueInput[]
    disconnect?: frostpaw_clientsWhereUniqueInput | frostpaw_clientsWhereUniqueInput[]
    delete?: frostpaw_clientsWhereUniqueInput | frostpaw_clientsWhereUniqueInput[]
    connect?: frostpaw_clientsWhereUniqueInput | frostpaw_clientsWhereUniqueInput[]
    update?: frostpaw_clientsUpdateWithWhereUniqueWithoutUsersInput | frostpaw_clientsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: frostpaw_clientsUpdateManyWithWhereWithoutUsersInput | frostpaw_clientsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: frostpaw_clientsScalarWhereInput | frostpaw_clientsScalarWhereInput[]
  }

  export type leave_of_absenceUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<leave_of_absenceCreateWithoutUsersInput, leave_of_absenceUncheckedCreateWithoutUsersInput> | leave_of_absenceCreateWithoutUsersInput[] | leave_of_absenceUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: leave_of_absenceCreateOrConnectWithoutUsersInput | leave_of_absenceCreateOrConnectWithoutUsersInput[]
    upsert?: leave_of_absenceUpsertWithWhereUniqueWithoutUsersInput | leave_of_absenceUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: leave_of_absenceCreateManyUsersInputEnvelope
    set?: leave_of_absenceWhereUniqueInput | leave_of_absenceWhereUniqueInput[]
    disconnect?: leave_of_absenceWhereUniqueInput | leave_of_absenceWhereUniqueInput[]
    delete?: leave_of_absenceWhereUniqueInput | leave_of_absenceWhereUniqueInput[]
    connect?: leave_of_absenceWhereUniqueInput | leave_of_absenceWhereUniqueInput[]
    update?: leave_of_absenceUpdateWithWhereUniqueWithoutUsersInput | leave_of_absenceUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: leave_of_absenceUpdateManyWithWhereWithoutUsersInput | leave_of_absenceUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: leave_of_absenceScalarWhereInput | leave_of_absenceScalarWhereInput[]
  }

  export type lynx_appsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<lynx_appsCreateWithoutUsersInput, lynx_appsUncheckedCreateWithoutUsersInput> | lynx_appsCreateWithoutUsersInput[] | lynx_appsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: lynx_appsCreateOrConnectWithoutUsersInput | lynx_appsCreateOrConnectWithoutUsersInput[]
    upsert?: lynx_appsUpsertWithWhereUniqueWithoutUsersInput | lynx_appsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: lynx_appsCreateManyUsersInputEnvelope
    set?: lynx_appsWhereUniqueInput | lynx_appsWhereUniqueInput[]
    disconnect?: lynx_appsWhereUniqueInput | lynx_appsWhereUniqueInput[]
    delete?: lynx_appsWhereUniqueInput | lynx_appsWhereUniqueInput[]
    connect?: lynx_appsWhereUniqueInput | lynx_appsWhereUniqueInput[]
    update?: lynx_appsUpdateWithWhereUniqueWithoutUsersInput | lynx_appsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: lynx_appsUpdateManyWithWhereWithoutUsersInput | lynx_appsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: lynx_appsScalarWhereInput | lynx_appsScalarWhereInput[]
  }

  export type lynx_logsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<lynx_logsCreateWithoutUsersInput, lynx_logsUncheckedCreateWithoutUsersInput> | lynx_logsCreateWithoutUsersInput[] | lynx_logsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: lynx_logsCreateOrConnectWithoutUsersInput | lynx_logsCreateOrConnectWithoutUsersInput[]
    upsert?: lynx_logsUpsertWithWhereUniqueWithoutUsersInput | lynx_logsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: lynx_logsCreateManyUsersInputEnvelope
    set?: lynx_logsWhereUniqueInput | lynx_logsWhereUniqueInput[]
    disconnect?: lynx_logsWhereUniqueInput | lynx_logsWhereUniqueInput[]
    delete?: lynx_logsWhereUniqueInput | lynx_logsWhereUniqueInput[]
    connect?: lynx_logsWhereUniqueInput | lynx_logsWhereUniqueInput[]
    update?: lynx_logsUpdateWithWhereUniqueWithoutUsersInput | lynx_logsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: lynx_logsUpdateManyWithWhereWithoutUsersInput | lynx_logsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: lynx_logsScalarWhereInput | lynx_logsScalarWhereInput[]
  }

  export type lynx_ratingsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<lynx_ratingsCreateWithoutUsersInput, lynx_ratingsUncheckedCreateWithoutUsersInput> | lynx_ratingsCreateWithoutUsersInput[] | lynx_ratingsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: lynx_ratingsCreateOrConnectWithoutUsersInput | lynx_ratingsCreateOrConnectWithoutUsersInput[]
    upsert?: lynx_ratingsUpsertWithWhereUniqueWithoutUsersInput | lynx_ratingsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: lynx_ratingsCreateManyUsersInputEnvelope
    set?: lynx_ratingsWhereUniqueInput | lynx_ratingsWhereUniqueInput[]
    disconnect?: lynx_ratingsWhereUniqueInput | lynx_ratingsWhereUniqueInput[]
    delete?: lynx_ratingsWhereUniqueInput | lynx_ratingsWhereUniqueInput[]
    connect?: lynx_ratingsWhereUniqueInput | lynx_ratingsWhereUniqueInput[]
    update?: lynx_ratingsUpdateWithWhereUniqueWithoutUsersInput | lynx_ratingsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: lynx_ratingsUpdateManyWithWhereWithoutUsersInput | lynx_ratingsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: lynx_ratingsScalarWhereInput | lynx_ratingsScalarWhereInput[]
  }

  export type lynx_survey_responsesUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<lynx_survey_responsesCreateWithoutUsersInput, lynx_survey_responsesUncheckedCreateWithoutUsersInput> | lynx_survey_responsesCreateWithoutUsersInput[] | lynx_survey_responsesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: lynx_survey_responsesCreateOrConnectWithoutUsersInput | lynx_survey_responsesCreateOrConnectWithoutUsersInput[]
    upsert?: lynx_survey_responsesUpsertWithWhereUniqueWithoutUsersInput | lynx_survey_responsesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: lynx_survey_responsesCreateManyUsersInputEnvelope
    set?: lynx_survey_responsesWhereUniqueInput | lynx_survey_responsesWhereUniqueInput[]
    disconnect?: lynx_survey_responsesWhereUniqueInput | lynx_survey_responsesWhereUniqueInput[]
    delete?: lynx_survey_responsesWhereUniqueInput | lynx_survey_responsesWhereUniqueInput[]
    connect?: lynx_survey_responsesWhereUniqueInput | lynx_survey_responsesWhereUniqueInput[]
    update?: lynx_survey_responsesUpdateWithWhereUniqueWithoutUsersInput | lynx_survey_responsesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: lynx_survey_responsesUpdateManyWithWhereWithoutUsersInput | lynx_survey_responsesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: lynx_survey_responsesScalarWhereInput | lynx_survey_responsesScalarWhereInput[]
  }

  export type push_notificationsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<push_notificationsCreateWithoutUsersInput, push_notificationsUncheckedCreateWithoutUsersInput> | push_notificationsCreateWithoutUsersInput[] | push_notificationsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: push_notificationsCreateOrConnectWithoutUsersInput | push_notificationsCreateOrConnectWithoutUsersInput[]
    upsert?: push_notificationsUpsertWithWhereUniqueWithoutUsersInput | push_notificationsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: push_notificationsCreateManyUsersInputEnvelope
    set?: push_notificationsWhereUniqueInput | push_notificationsWhereUniqueInput[]
    disconnect?: push_notificationsWhereUniqueInput | push_notificationsWhereUniqueInput[]
    delete?: push_notificationsWhereUniqueInput | push_notificationsWhereUniqueInput[]
    connect?: push_notificationsWhereUniqueInput | push_notificationsWhereUniqueInput[]
    update?: push_notificationsUpdateWithWhereUniqueWithoutUsersInput | push_notificationsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: push_notificationsUpdateManyWithWhereWithoutUsersInput | push_notificationsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: push_notificationsScalarWhereInput | push_notificationsScalarWhereInput[]
  }

  export type review_votesUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<review_votesCreateWithoutUsersInput, review_votesUncheckedCreateWithoutUsersInput> | review_votesCreateWithoutUsersInput[] | review_votesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: review_votesCreateOrConnectWithoutUsersInput | review_votesCreateOrConnectWithoutUsersInput[]
    upsert?: review_votesUpsertWithWhereUniqueWithoutUsersInput | review_votesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: review_votesCreateManyUsersInputEnvelope
    set?: review_votesWhereUniqueInput | review_votesWhereUniqueInput[]
    disconnect?: review_votesWhereUniqueInput | review_votesWhereUniqueInput[]
    delete?: review_votesWhereUniqueInput | review_votesWhereUniqueInput[]
    connect?: review_votesWhereUniqueInput | review_votesWhereUniqueInput[]
    update?: review_votesUpdateWithWhereUniqueWithoutUsersInput | review_votesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: review_votesUpdateManyWithWhereWithoutUsersInput | review_votesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: review_votesScalarWhereInput | review_votesScalarWhereInput[]
  }

  export type reviewsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<reviewsCreateWithoutUsersInput, reviewsUncheckedCreateWithoutUsersInput> | reviewsCreateWithoutUsersInput[] | reviewsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: reviewsCreateOrConnectWithoutUsersInput | reviewsCreateOrConnectWithoutUsersInput[]
    upsert?: reviewsUpsertWithWhereUniqueWithoutUsersInput | reviewsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: reviewsCreateManyUsersInputEnvelope
    set?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    disconnect?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    delete?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    connect?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    update?: reviewsUpdateWithWhereUniqueWithoutUsersInput | reviewsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: reviewsUpdateManyWithWhereWithoutUsersInput | reviewsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: reviewsScalarWhereInput | reviewsScalarWhereInput[]
  }

  export type server_audit_logsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<server_audit_logsCreateWithoutUsersInput, server_audit_logsUncheckedCreateWithoutUsersInput> | server_audit_logsCreateWithoutUsersInput[] | server_audit_logsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: server_audit_logsCreateOrConnectWithoutUsersInput | server_audit_logsCreateOrConnectWithoutUsersInput[]
    upsert?: server_audit_logsUpsertWithWhereUniqueWithoutUsersInput | server_audit_logsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: server_audit_logsCreateManyUsersInputEnvelope
    set?: server_audit_logsWhereUniqueInput | server_audit_logsWhereUniqueInput[]
    disconnect?: server_audit_logsWhereUniqueInput | server_audit_logsWhereUniqueInput[]
    delete?: server_audit_logsWhereUniqueInput | server_audit_logsWhereUniqueInput[]
    connect?: server_audit_logsWhereUniqueInput | server_audit_logsWhereUniqueInput[]
    update?: server_audit_logsUpdateWithWhereUniqueWithoutUsersInput | server_audit_logsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: server_audit_logsUpdateManyWithWhereWithoutUsersInput | server_audit_logsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: server_audit_logsScalarWhereInput | server_audit_logsScalarWhereInput[]
  }

  export type server_votersUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<server_votersCreateWithoutUsersInput, server_votersUncheckedCreateWithoutUsersInput> | server_votersCreateWithoutUsersInput[] | server_votersUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: server_votersCreateOrConnectWithoutUsersInput | server_votersCreateOrConnectWithoutUsersInput[]
    upsert?: server_votersUpsertWithWhereUniqueWithoutUsersInput | server_votersUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: server_votersCreateManyUsersInputEnvelope
    set?: server_votersWhereUniqueInput | server_votersWhereUniqueInput[]
    disconnect?: server_votersWhereUniqueInput | server_votersWhereUniqueInput[]
    delete?: server_votersWhereUniqueInput | server_votersWhereUniqueInput[]
    connect?: server_votersWhereUniqueInput | server_votersWhereUniqueInput[]
    update?: server_votersUpdateWithWhereUniqueWithoutUsersInput | server_votersUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: server_votersUpdateManyWithWhereWithoutUsersInput | server_votersUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: server_votersScalarWhereInput | server_votersScalarWhereInput[]
  }

  export type serversUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<serversCreateWithoutUsersInput, serversUncheckedCreateWithoutUsersInput> | serversCreateWithoutUsersInput[] | serversUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: serversCreateOrConnectWithoutUsersInput | serversCreateOrConnectWithoutUsersInput[]
    upsert?: serversUpsertWithWhereUniqueWithoutUsersInput | serversUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: serversCreateManyUsersInputEnvelope
    set?: serversWhereUniqueInput | serversWhereUniqueInput[]
    disconnect?: serversWhereUniqueInput | serversWhereUniqueInput[]
    delete?: serversWhereUniqueInput | serversWhereUniqueInput[]
    connect?: serversWhereUniqueInput | serversWhereUniqueInput[]
    update?: serversUpdateWithWhereUniqueWithoutUsersInput | serversUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: serversUpdateManyWithWhereWithoutUsersInput | serversUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: serversScalarWhereInput | serversScalarWhereInput[]
  }

  export type user_bot_logsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<user_bot_logsCreateWithoutUsersInput, user_bot_logsUncheckedCreateWithoutUsersInput> | user_bot_logsCreateWithoutUsersInput[] | user_bot_logsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_bot_logsCreateOrConnectWithoutUsersInput | user_bot_logsCreateOrConnectWithoutUsersInput[]
    upsert?: user_bot_logsUpsertWithWhereUniqueWithoutUsersInput | user_bot_logsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: user_bot_logsCreateManyUsersInputEnvelope
    set?: user_bot_logsWhereUniqueInput | user_bot_logsWhereUniqueInput[]
    disconnect?: user_bot_logsWhereUniqueInput | user_bot_logsWhereUniqueInput[]
    delete?: user_bot_logsWhereUniqueInput | user_bot_logsWhereUniqueInput[]
    connect?: user_bot_logsWhereUniqueInput | user_bot_logsWhereUniqueInput[]
    update?: user_bot_logsUpdateWithWhereUniqueWithoutUsersInput | user_bot_logsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: user_bot_logsUpdateManyWithWhereWithoutUsersInput | user_bot_logsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: user_bot_logsScalarWhereInput | user_bot_logsScalarWhereInput[]
  }

  export type user_connectionsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<user_connectionsCreateWithoutUsersInput, user_connectionsUncheckedCreateWithoutUsersInput> | user_connectionsCreateWithoutUsersInput[] | user_connectionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_connectionsCreateOrConnectWithoutUsersInput | user_connectionsCreateOrConnectWithoutUsersInput[]
    upsert?: user_connectionsUpsertWithWhereUniqueWithoutUsersInput | user_connectionsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: user_connectionsCreateManyUsersInputEnvelope
    set?: user_connectionsWhereUniqueInput | user_connectionsWhereUniqueInput[]
    disconnect?: user_connectionsWhereUniqueInput | user_connectionsWhereUniqueInput[]
    delete?: user_connectionsWhereUniqueInput | user_connectionsWhereUniqueInput[]
    connect?: user_connectionsWhereUniqueInput | user_connectionsWhereUniqueInput[]
    update?: user_connectionsUpdateWithWhereUniqueWithoutUsersInput | user_connectionsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: user_connectionsUpdateManyWithWhereWithoutUsersInput | user_connectionsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: user_connectionsScalarWhereInput | user_connectionsScalarWhereInput[]
  }

  export type user_server_vote_tableUncheckedUpdateOneWithoutUsersNestedInput = {
    create?: XOR<user_server_vote_tableCreateWithoutUsersInput, user_server_vote_tableUncheckedCreateWithoutUsersInput>
    connectOrCreate?: user_server_vote_tableCreateOrConnectWithoutUsersInput
    upsert?: user_server_vote_tableUpsertWithoutUsersInput
    disconnect?: user_server_vote_tableWhereInput | boolean
    delete?: user_server_vote_tableWhereInput | boolean
    connect?: user_server_vote_tableWhereUniqueInput
    update?: XOR<XOR<user_server_vote_tableUpdateToOneWithWhereWithoutUsersInput, user_server_vote_tableUpdateWithoutUsersInput>, user_server_vote_tableUncheckedUpdateWithoutUsersInput>
  }

  export type user_vote_tableUncheckedUpdateOneWithoutUsersNestedInput = {
    create?: XOR<user_vote_tableCreateWithoutUsersInput, user_vote_tableUncheckedCreateWithoutUsersInput>
    connectOrCreate?: user_vote_tableCreateOrConnectWithoutUsersInput
    upsert?: user_vote_tableUpsertWithoutUsersInput
    disconnect?: user_vote_tableWhereInput | boolean
    delete?: user_vote_tableWhereInput | boolean
    connect?: user_vote_tableWhereUniqueInput
    update?: XOR<XOR<user_vote_tableUpdateToOneWithWhereWithoutUsersInput, user_vote_tableUpdateWithoutUsersInput>, user_vote_tableUncheckedUpdateWithoutUsersInput>
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedUuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type NestedUuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type botsCreateWithoutBot_commandsInput = {
    bot_id: bigint | number
    votes?: bigint | number | null
    guild_count?: bigint | number | null
    shard_count?: bigint | number | null
    bot_library?: string | null
    webhook?: string | null
    description: string
    long_description: string
    prefix?: string | null
    api_token?: string | null
    banner_card?: string | null
    created_at?: Date | string
    invite?: string
    features?: botsCreatefeaturesInput | string[]
    invite_amount?: number | null
    user_count?: bigint | number | null
    css?: string | null
    shards?: botsCreateshardsInput | number[]
    username_cached?: string
    state?: number
    long_description_type: number
    verifier?: bigint | number | null
    last_stats_post?: Date | string
    webhook_secret?: string | null
    webhook_type?: number | null
    di_text?: string | null
    id: bigint | number
    banner_page?: string | null
    total_votes?: bigint | number | null
    client_id?: bigint | number | null
    flags?: botsCreateflagsInput | number[]
    uptime_checks_total?: number | null
    uptime_checks_failed?: number | null
    page_style?: number
    webhook_hmac_only?: boolean | null
    last_updated_at?: Date | string
    avatar_cached?: string
    disc_cached?: string
    extra_links?: JsonNullValueInput | InputJsonValue
    lynxtag?: string
    bot_events?: bot_eventsCreateNestedManyWithoutBotsInput
    bot_owner?: bot_ownerCreateNestedManyWithoutBotsInput
    bot_promotions?: bot_promotionsCreateNestedManyWithoutBotsInput
    bot_tags?: bot_tagsCreateNestedManyWithoutBotsInput
  }

  export type botsUncheckedCreateWithoutBot_commandsInput = {
    bot_id: bigint | number
    votes?: bigint | number | null
    guild_count?: bigint | number | null
    shard_count?: bigint | number | null
    bot_library?: string | null
    webhook?: string | null
    description: string
    long_description: string
    prefix?: string | null
    api_token?: string | null
    banner_card?: string | null
    created_at?: Date | string
    invite?: string
    features?: botsCreatefeaturesInput | string[]
    invite_amount?: number | null
    user_count?: bigint | number | null
    css?: string | null
    shards?: botsCreateshardsInput | number[]
    username_cached?: string
    state?: number
    long_description_type: number
    verifier?: bigint | number | null
    last_stats_post?: Date | string
    webhook_secret?: string | null
    webhook_type?: number | null
    di_text?: string | null
    id: bigint | number
    banner_page?: string | null
    total_votes?: bigint | number | null
    client_id?: bigint | number | null
    flags?: botsCreateflagsInput | number[]
    uptime_checks_total?: number | null
    uptime_checks_failed?: number | null
    page_style?: number
    webhook_hmac_only?: boolean | null
    last_updated_at?: Date | string
    avatar_cached?: string
    disc_cached?: string
    extra_links?: JsonNullValueInput | InputJsonValue
    lynxtag?: string
    bot_events?: bot_eventsUncheckedCreateNestedManyWithoutBotsInput
    bot_owner?: bot_ownerUncheckedCreateNestedManyWithoutBotsInput
    bot_promotions?: bot_promotionsUncheckedCreateNestedManyWithoutBotsInput
    bot_tags?: bot_tagsUncheckedCreateNestedManyWithoutBotsInput
  }

  export type botsCreateOrConnectWithoutBot_commandsInput = {
    where: botsWhereUniqueInput
    create: XOR<botsCreateWithoutBot_commandsInput, botsUncheckedCreateWithoutBot_commandsInput>
  }

  export type botsUpsertWithoutBot_commandsInput = {
    update: XOR<botsUpdateWithoutBot_commandsInput, botsUncheckedUpdateWithoutBot_commandsInput>
    create: XOR<botsCreateWithoutBot_commandsInput, botsUncheckedCreateWithoutBot_commandsInput>
    where?: botsWhereInput
  }

  export type botsUpdateToOneWithWhereWithoutBot_commandsInput = {
    where?: botsWhereInput
    data: XOR<botsUpdateWithoutBot_commandsInput, botsUncheckedUpdateWithoutBot_commandsInput>
  }

  export type botsUpdateWithoutBot_commandsInput = {
    bot_id?: BigIntFieldUpdateOperationsInput | bigint | number
    votes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    guild_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    shard_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    bot_library?: NullableStringFieldUpdateOperationsInput | string | null
    webhook?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    long_description?: StringFieldUpdateOperationsInput | string
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    api_token?: NullableStringFieldUpdateOperationsInput | string | null
    banner_card?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    invite?: StringFieldUpdateOperationsInput | string
    features?: botsUpdatefeaturesInput | string[]
    invite_amount?: NullableIntFieldUpdateOperationsInput | number | null
    user_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    css?: NullableStringFieldUpdateOperationsInput | string | null
    shards?: botsUpdateshardsInput | number[]
    username_cached?: StringFieldUpdateOperationsInput | string
    state?: IntFieldUpdateOperationsInput | number
    long_description_type?: IntFieldUpdateOperationsInput | number
    verifier?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    last_stats_post?: DateTimeFieldUpdateOperationsInput | Date | string
    webhook_secret?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_type?: NullableIntFieldUpdateOperationsInput | number | null
    di_text?: NullableStringFieldUpdateOperationsInput | string | null
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    banner_page?: NullableStringFieldUpdateOperationsInput | string | null
    total_votes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    client_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    flags?: botsUpdateflagsInput | number[]
    uptime_checks_total?: NullableIntFieldUpdateOperationsInput | number | null
    uptime_checks_failed?: NullableIntFieldUpdateOperationsInput | number | null
    page_style?: IntFieldUpdateOperationsInput | number
    webhook_hmac_only?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar_cached?: StringFieldUpdateOperationsInput | string
    disc_cached?: StringFieldUpdateOperationsInput | string
    extra_links?: JsonNullValueInput | InputJsonValue
    lynxtag?: StringFieldUpdateOperationsInput | string
    bot_events?: bot_eventsUpdateManyWithoutBotsNestedInput
    bot_owner?: bot_ownerUpdateManyWithoutBotsNestedInput
    bot_promotions?: bot_promotionsUpdateManyWithoutBotsNestedInput
    bot_tags?: bot_tagsUpdateManyWithoutBotsNestedInput
  }

  export type botsUncheckedUpdateWithoutBot_commandsInput = {
    bot_id?: BigIntFieldUpdateOperationsInput | bigint | number
    votes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    guild_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    shard_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    bot_library?: NullableStringFieldUpdateOperationsInput | string | null
    webhook?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    long_description?: StringFieldUpdateOperationsInput | string
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    api_token?: NullableStringFieldUpdateOperationsInput | string | null
    banner_card?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    invite?: StringFieldUpdateOperationsInput | string
    features?: botsUpdatefeaturesInput | string[]
    invite_amount?: NullableIntFieldUpdateOperationsInput | number | null
    user_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    css?: NullableStringFieldUpdateOperationsInput | string | null
    shards?: botsUpdateshardsInput | number[]
    username_cached?: StringFieldUpdateOperationsInput | string
    state?: IntFieldUpdateOperationsInput | number
    long_description_type?: IntFieldUpdateOperationsInput | number
    verifier?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    last_stats_post?: DateTimeFieldUpdateOperationsInput | Date | string
    webhook_secret?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_type?: NullableIntFieldUpdateOperationsInput | number | null
    di_text?: NullableStringFieldUpdateOperationsInput | string | null
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    banner_page?: NullableStringFieldUpdateOperationsInput | string | null
    total_votes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    client_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    flags?: botsUpdateflagsInput | number[]
    uptime_checks_total?: NullableIntFieldUpdateOperationsInput | number | null
    uptime_checks_failed?: NullableIntFieldUpdateOperationsInput | number | null
    page_style?: IntFieldUpdateOperationsInput | number
    webhook_hmac_only?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar_cached?: StringFieldUpdateOperationsInput | string
    disc_cached?: StringFieldUpdateOperationsInput | string
    extra_links?: JsonNullValueInput | InputJsonValue
    lynxtag?: StringFieldUpdateOperationsInput | string
    bot_events?: bot_eventsUncheckedUpdateManyWithoutBotsNestedInput
    bot_owner?: bot_ownerUncheckedUpdateManyWithoutBotsNestedInput
    bot_promotions?: bot_promotionsUncheckedUpdateManyWithoutBotsNestedInput
    bot_tags?: bot_tagsUncheckedUpdateManyWithoutBotsNestedInput
  }

  export type botsCreateWithoutBot_eventsInput = {
    bot_id: bigint | number
    votes?: bigint | number | null
    guild_count?: bigint | number | null
    shard_count?: bigint | number | null
    bot_library?: string | null
    webhook?: string | null
    description: string
    long_description: string
    prefix?: string | null
    api_token?: string | null
    banner_card?: string | null
    created_at?: Date | string
    invite?: string
    features?: botsCreatefeaturesInput | string[]
    invite_amount?: number | null
    user_count?: bigint | number | null
    css?: string | null
    shards?: botsCreateshardsInput | number[]
    username_cached?: string
    state?: number
    long_description_type: number
    verifier?: bigint | number | null
    last_stats_post?: Date | string
    webhook_secret?: string | null
    webhook_type?: number | null
    di_text?: string | null
    id: bigint | number
    banner_page?: string | null
    total_votes?: bigint | number | null
    client_id?: bigint | number | null
    flags?: botsCreateflagsInput | number[]
    uptime_checks_total?: number | null
    uptime_checks_failed?: number | null
    page_style?: number
    webhook_hmac_only?: boolean | null
    last_updated_at?: Date | string
    avatar_cached?: string
    disc_cached?: string
    extra_links?: JsonNullValueInput | InputJsonValue
    lynxtag?: string
    bot_commands?: bot_commandsCreateNestedManyWithoutBotsInput
    bot_owner?: bot_ownerCreateNestedManyWithoutBotsInput
    bot_promotions?: bot_promotionsCreateNestedManyWithoutBotsInput
    bot_tags?: bot_tagsCreateNestedManyWithoutBotsInput
  }

  export type botsUncheckedCreateWithoutBot_eventsInput = {
    bot_id: bigint | number
    votes?: bigint | number | null
    guild_count?: bigint | number | null
    shard_count?: bigint | number | null
    bot_library?: string | null
    webhook?: string | null
    description: string
    long_description: string
    prefix?: string | null
    api_token?: string | null
    banner_card?: string | null
    created_at?: Date | string
    invite?: string
    features?: botsCreatefeaturesInput | string[]
    invite_amount?: number | null
    user_count?: bigint | number | null
    css?: string | null
    shards?: botsCreateshardsInput | number[]
    username_cached?: string
    state?: number
    long_description_type: number
    verifier?: bigint | number | null
    last_stats_post?: Date | string
    webhook_secret?: string | null
    webhook_type?: number | null
    di_text?: string | null
    id: bigint | number
    banner_page?: string | null
    total_votes?: bigint | number | null
    client_id?: bigint | number | null
    flags?: botsCreateflagsInput | number[]
    uptime_checks_total?: number | null
    uptime_checks_failed?: number | null
    page_style?: number
    webhook_hmac_only?: boolean | null
    last_updated_at?: Date | string
    avatar_cached?: string
    disc_cached?: string
    extra_links?: JsonNullValueInput | InputJsonValue
    lynxtag?: string
    bot_commands?: bot_commandsUncheckedCreateNestedManyWithoutBotsInput
    bot_owner?: bot_ownerUncheckedCreateNestedManyWithoutBotsInput
    bot_promotions?: bot_promotionsUncheckedCreateNestedManyWithoutBotsInput
    bot_tags?: bot_tagsUncheckedCreateNestedManyWithoutBotsInput
  }

  export type botsCreateOrConnectWithoutBot_eventsInput = {
    where: botsWhereUniqueInput
    create: XOR<botsCreateWithoutBot_eventsInput, botsUncheckedCreateWithoutBot_eventsInput>
  }

  export type botsUpsertWithoutBot_eventsInput = {
    update: XOR<botsUpdateWithoutBot_eventsInput, botsUncheckedUpdateWithoutBot_eventsInput>
    create: XOR<botsCreateWithoutBot_eventsInput, botsUncheckedCreateWithoutBot_eventsInput>
    where?: botsWhereInput
  }

  export type botsUpdateToOneWithWhereWithoutBot_eventsInput = {
    where?: botsWhereInput
    data: XOR<botsUpdateWithoutBot_eventsInput, botsUncheckedUpdateWithoutBot_eventsInput>
  }

  export type botsUpdateWithoutBot_eventsInput = {
    bot_id?: BigIntFieldUpdateOperationsInput | bigint | number
    votes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    guild_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    shard_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    bot_library?: NullableStringFieldUpdateOperationsInput | string | null
    webhook?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    long_description?: StringFieldUpdateOperationsInput | string
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    api_token?: NullableStringFieldUpdateOperationsInput | string | null
    banner_card?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    invite?: StringFieldUpdateOperationsInput | string
    features?: botsUpdatefeaturesInput | string[]
    invite_amount?: NullableIntFieldUpdateOperationsInput | number | null
    user_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    css?: NullableStringFieldUpdateOperationsInput | string | null
    shards?: botsUpdateshardsInput | number[]
    username_cached?: StringFieldUpdateOperationsInput | string
    state?: IntFieldUpdateOperationsInput | number
    long_description_type?: IntFieldUpdateOperationsInput | number
    verifier?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    last_stats_post?: DateTimeFieldUpdateOperationsInput | Date | string
    webhook_secret?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_type?: NullableIntFieldUpdateOperationsInput | number | null
    di_text?: NullableStringFieldUpdateOperationsInput | string | null
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    banner_page?: NullableStringFieldUpdateOperationsInput | string | null
    total_votes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    client_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    flags?: botsUpdateflagsInput | number[]
    uptime_checks_total?: NullableIntFieldUpdateOperationsInput | number | null
    uptime_checks_failed?: NullableIntFieldUpdateOperationsInput | number | null
    page_style?: IntFieldUpdateOperationsInput | number
    webhook_hmac_only?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar_cached?: StringFieldUpdateOperationsInput | string
    disc_cached?: StringFieldUpdateOperationsInput | string
    extra_links?: JsonNullValueInput | InputJsonValue
    lynxtag?: StringFieldUpdateOperationsInput | string
    bot_commands?: bot_commandsUpdateManyWithoutBotsNestedInput
    bot_owner?: bot_ownerUpdateManyWithoutBotsNestedInput
    bot_promotions?: bot_promotionsUpdateManyWithoutBotsNestedInput
    bot_tags?: bot_tagsUpdateManyWithoutBotsNestedInput
  }

  export type botsUncheckedUpdateWithoutBot_eventsInput = {
    bot_id?: BigIntFieldUpdateOperationsInput | bigint | number
    votes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    guild_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    shard_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    bot_library?: NullableStringFieldUpdateOperationsInput | string | null
    webhook?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    long_description?: StringFieldUpdateOperationsInput | string
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    api_token?: NullableStringFieldUpdateOperationsInput | string | null
    banner_card?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    invite?: StringFieldUpdateOperationsInput | string
    features?: botsUpdatefeaturesInput | string[]
    invite_amount?: NullableIntFieldUpdateOperationsInput | number | null
    user_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    css?: NullableStringFieldUpdateOperationsInput | string | null
    shards?: botsUpdateshardsInput | number[]
    username_cached?: StringFieldUpdateOperationsInput | string
    state?: IntFieldUpdateOperationsInput | number
    long_description_type?: IntFieldUpdateOperationsInput | number
    verifier?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    last_stats_post?: DateTimeFieldUpdateOperationsInput | Date | string
    webhook_secret?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_type?: NullableIntFieldUpdateOperationsInput | number | null
    di_text?: NullableStringFieldUpdateOperationsInput | string | null
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    banner_page?: NullableStringFieldUpdateOperationsInput | string | null
    total_votes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    client_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    flags?: botsUpdateflagsInput | number[]
    uptime_checks_total?: NullableIntFieldUpdateOperationsInput | number | null
    uptime_checks_failed?: NullableIntFieldUpdateOperationsInput | number | null
    page_style?: IntFieldUpdateOperationsInput | number
    webhook_hmac_only?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar_cached?: StringFieldUpdateOperationsInput | string
    disc_cached?: StringFieldUpdateOperationsInput | string
    extra_links?: JsonNullValueInput | InputJsonValue
    lynxtag?: StringFieldUpdateOperationsInput | string
    bot_commands?: bot_commandsUncheckedUpdateManyWithoutBotsNestedInput
    bot_owner?: bot_ownerUncheckedUpdateManyWithoutBotsNestedInput
    bot_promotions?: bot_promotionsUncheckedUpdateManyWithoutBotsNestedInput
    bot_tags?: bot_tagsUncheckedUpdateManyWithoutBotsNestedInput
  }

  export type bot_tagsCreateWithoutBot_list_tagsInput = {
    id?: number
    lynxtag?: string
    bots: botsCreateNestedOneWithoutBot_tagsInput
  }

  export type bot_tagsUncheckedCreateWithoutBot_list_tagsInput = {
    bot_id: bigint | number
    id?: number
    lynxtag?: string
  }

  export type bot_tagsCreateOrConnectWithoutBot_list_tagsInput = {
    where: bot_tagsWhereUniqueInput
    create: XOR<bot_tagsCreateWithoutBot_list_tagsInput, bot_tagsUncheckedCreateWithoutBot_list_tagsInput>
  }

  export type bot_tagsCreateManyBot_list_tagsInputEnvelope = {
    data: bot_tagsCreateManyBot_list_tagsInput | bot_tagsCreateManyBot_list_tagsInput[]
    skipDuplicates?: boolean
  }

  export type bot_tagsUpsertWithWhereUniqueWithoutBot_list_tagsInput = {
    where: bot_tagsWhereUniqueInput
    update: XOR<bot_tagsUpdateWithoutBot_list_tagsInput, bot_tagsUncheckedUpdateWithoutBot_list_tagsInput>
    create: XOR<bot_tagsCreateWithoutBot_list_tagsInput, bot_tagsUncheckedCreateWithoutBot_list_tagsInput>
  }

  export type bot_tagsUpdateWithWhereUniqueWithoutBot_list_tagsInput = {
    where: bot_tagsWhereUniqueInput
    data: XOR<bot_tagsUpdateWithoutBot_list_tagsInput, bot_tagsUncheckedUpdateWithoutBot_list_tagsInput>
  }

  export type bot_tagsUpdateManyWithWhereWithoutBot_list_tagsInput = {
    where: bot_tagsScalarWhereInput
    data: XOR<bot_tagsUpdateManyMutationInput, bot_tagsUncheckedUpdateManyWithoutBot_list_tagsInput>
  }

  export type bot_tagsScalarWhereInput = {
    AND?: bot_tagsScalarWhereInput | bot_tagsScalarWhereInput[]
    OR?: bot_tagsScalarWhereInput[]
    NOT?: bot_tagsScalarWhereInput | bot_tagsScalarWhereInput[]
    bot_id?: BigIntFilter<"bot_tags"> | bigint | number
    tag?: StringFilter<"bot_tags"> | string
    id?: IntFilter<"bot_tags"> | number
    lynxtag?: UuidFilter<"bot_tags"> | string
  }

  export type botsCreateWithoutBot_ownerInput = {
    bot_id: bigint | number
    votes?: bigint | number | null
    guild_count?: bigint | number | null
    shard_count?: bigint | number | null
    bot_library?: string | null
    webhook?: string | null
    description: string
    long_description: string
    prefix?: string | null
    api_token?: string | null
    banner_card?: string | null
    created_at?: Date | string
    invite?: string
    features?: botsCreatefeaturesInput | string[]
    invite_amount?: number | null
    user_count?: bigint | number | null
    css?: string | null
    shards?: botsCreateshardsInput | number[]
    username_cached?: string
    state?: number
    long_description_type: number
    verifier?: bigint | number | null
    last_stats_post?: Date | string
    webhook_secret?: string | null
    webhook_type?: number | null
    di_text?: string | null
    id: bigint | number
    banner_page?: string | null
    total_votes?: bigint | number | null
    client_id?: bigint | number | null
    flags?: botsCreateflagsInput | number[]
    uptime_checks_total?: number | null
    uptime_checks_failed?: number | null
    page_style?: number
    webhook_hmac_only?: boolean | null
    last_updated_at?: Date | string
    avatar_cached?: string
    disc_cached?: string
    extra_links?: JsonNullValueInput | InputJsonValue
    lynxtag?: string
    bot_commands?: bot_commandsCreateNestedManyWithoutBotsInput
    bot_events?: bot_eventsCreateNestedManyWithoutBotsInput
    bot_promotions?: bot_promotionsCreateNestedManyWithoutBotsInput
    bot_tags?: bot_tagsCreateNestedManyWithoutBotsInput
  }

  export type botsUncheckedCreateWithoutBot_ownerInput = {
    bot_id: bigint | number
    votes?: bigint | number | null
    guild_count?: bigint | number | null
    shard_count?: bigint | number | null
    bot_library?: string | null
    webhook?: string | null
    description: string
    long_description: string
    prefix?: string | null
    api_token?: string | null
    banner_card?: string | null
    created_at?: Date | string
    invite?: string
    features?: botsCreatefeaturesInput | string[]
    invite_amount?: number | null
    user_count?: bigint | number | null
    css?: string | null
    shards?: botsCreateshardsInput | number[]
    username_cached?: string
    state?: number
    long_description_type: number
    verifier?: bigint | number | null
    last_stats_post?: Date | string
    webhook_secret?: string | null
    webhook_type?: number | null
    di_text?: string | null
    id: bigint | number
    banner_page?: string | null
    total_votes?: bigint | number | null
    client_id?: bigint | number | null
    flags?: botsCreateflagsInput | number[]
    uptime_checks_total?: number | null
    uptime_checks_failed?: number | null
    page_style?: number
    webhook_hmac_only?: boolean | null
    last_updated_at?: Date | string
    avatar_cached?: string
    disc_cached?: string
    extra_links?: JsonNullValueInput | InputJsonValue
    lynxtag?: string
    bot_commands?: bot_commandsUncheckedCreateNestedManyWithoutBotsInput
    bot_events?: bot_eventsUncheckedCreateNestedManyWithoutBotsInput
    bot_promotions?: bot_promotionsUncheckedCreateNestedManyWithoutBotsInput
    bot_tags?: bot_tagsUncheckedCreateNestedManyWithoutBotsInput
  }

  export type botsCreateOrConnectWithoutBot_ownerInput = {
    where: botsWhereUniqueInput
    create: XOR<botsCreateWithoutBot_ownerInput, botsUncheckedCreateWithoutBot_ownerInput>
  }

  export type botsUpsertWithoutBot_ownerInput = {
    update: XOR<botsUpdateWithoutBot_ownerInput, botsUncheckedUpdateWithoutBot_ownerInput>
    create: XOR<botsCreateWithoutBot_ownerInput, botsUncheckedCreateWithoutBot_ownerInput>
    where?: botsWhereInput
  }

  export type botsUpdateToOneWithWhereWithoutBot_ownerInput = {
    where?: botsWhereInput
    data: XOR<botsUpdateWithoutBot_ownerInput, botsUncheckedUpdateWithoutBot_ownerInput>
  }

  export type botsUpdateWithoutBot_ownerInput = {
    bot_id?: BigIntFieldUpdateOperationsInput | bigint | number
    votes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    guild_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    shard_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    bot_library?: NullableStringFieldUpdateOperationsInput | string | null
    webhook?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    long_description?: StringFieldUpdateOperationsInput | string
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    api_token?: NullableStringFieldUpdateOperationsInput | string | null
    banner_card?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    invite?: StringFieldUpdateOperationsInput | string
    features?: botsUpdatefeaturesInput | string[]
    invite_amount?: NullableIntFieldUpdateOperationsInput | number | null
    user_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    css?: NullableStringFieldUpdateOperationsInput | string | null
    shards?: botsUpdateshardsInput | number[]
    username_cached?: StringFieldUpdateOperationsInput | string
    state?: IntFieldUpdateOperationsInput | number
    long_description_type?: IntFieldUpdateOperationsInput | number
    verifier?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    last_stats_post?: DateTimeFieldUpdateOperationsInput | Date | string
    webhook_secret?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_type?: NullableIntFieldUpdateOperationsInput | number | null
    di_text?: NullableStringFieldUpdateOperationsInput | string | null
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    banner_page?: NullableStringFieldUpdateOperationsInput | string | null
    total_votes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    client_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    flags?: botsUpdateflagsInput | number[]
    uptime_checks_total?: NullableIntFieldUpdateOperationsInput | number | null
    uptime_checks_failed?: NullableIntFieldUpdateOperationsInput | number | null
    page_style?: IntFieldUpdateOperationsInput | number
    webhook_hmac_only?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar_cached?: StringFieldUpdateOperationsInput | string
    disc_cached?: StringFieldUpdateOperationsInput | string
    extra_links?: JsonNullValueInput | InputJsonValue
    lynxtag?: StringFieldUpdateOperationsInput | string
    bot_commands?: bot_commandsUpdateManyWithoutBotsNestedInput
    bot_events?: bot_eventsUpdateManyWithoutBotsNestedInput
    bot_promotions?: bot_promotionsUpdateManyWithoutBotsNestedInput
    bot_tags?: bot_tagsUpdateManyWithoutBotsNestedInput
  }

  export type botsUncheckedUpdateWithoutBot_ownerInput = {
    bot_id?: BigIntFieldUpdateOperationsInput | bigint | number
    votes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    guild_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    shard_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    bot_library?: NullableStringFieldUpdateOperationsInput | string | null
    webhook?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    long_description?: StringFieldUpdateOperationsInput | string
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    api_token?: NullableStringFieldUpdateOperationsInput | string | null
    banner_card?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    invite?: StringFieldUpdateOperationsInput | string
    features?: botsUpdatefeaturesInput | string[]
    invite_amount?: NullableIntFieldUpdateOperationsInput | number | null
    user_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    css?: NullableStringFieldUpdateOperationsInput | string | null
    shards?: botsUpdateshardsInput | number[]
    username_cached?: StringFieldUpdateOperationsInput | string
    state?: IntFieldUpdateOperationsInput | number
    long_description_type?: IntFieldUpdateOperationsInput | number
    verifier?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    last_stats_post?: DateTimeFieldUpdateOperationsInput | Date | string
    webhook_secret?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_type?: NullableIntFieldUpdateOperationsInput | number | null
    di_text?: NullableStringFieldUpdateOperationsInput | string | null
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    banner_page?: NullableStringFieldUpdateOperationsInput | string | null
    total_votes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    client_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    flags?: botsUpdateflagsInput | number[]
    uptime_checks_total?: NullableIntFieldUpdateOperationsInput | number | null
    uptime_checks_failed?: NullableIntFieldUpdateOperationsInput | number | null
    page_style?: IntFieldUpdateOperationsInput | number
    webhook_hmac_only?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar_cached?: StringFieldUpdateOperationsInput | string
    disc_cached?: StringFieldUpdateOperationsInput | string
    extra_links?: JsonNullValueInput | InputJsonValue
    lynxtag?: StringFieldUpdateOperationsInput | string
    bot_commands?: bot_commandsUncheckedUpdateManyWithoutBotsNestedInput
    bot_events?: bot_eventsUncheckedUpdateManyWithoutBotsNestedInput
    bot_promotions?: bot_promotionsUncheckedUpdateManyWithoutBotsNestedInput
    bot_tags?: bot_tagsUncheckedUpdateManyWithoutBotsNestedInput
  }

  export type botsCreateWithoutBot_promotionsInput = {
    bot_id: bigint | number
    votes?: bigint | number | null
    guild_count?: bigint | number | null
    shard_count?: bigint | number | null
    bot_library?: string | null
    webhook?: string | null
    description: string
    long_description: string
    prefix?: string | null
    api_token?: string | null
    banner_card?: string | null
    created_at?: Date | string
    invite?: string
    features?: botsCreatefeaturesInput | string[]
    invite_amount?: number | null
    user_count?: bigint | number | null
    css?: string | null
    shards?: botsCreateshardsInput | number[]
    username_cached?: string
    state?: number
    long_description_type: number
    verifier?: bigint | number | null
    last_stats_post?: Date | string
    webhook_secret?: string | null
    webhook_type?: number | null
    di_text?: string | null
    id: bigint | number
    banner_page?: string | null
    total_votes?: bigint | number | null
    client_id?: bigint | number | null
    flags?: botsCreateflagsInput | number[]
    uptime_checks_total?: number | null
    uptime_checks_failed?: number | null
    page_style?: number
    webhook_hmac_only?: boolean | null
    last_updated_at?: Date | string
    avatar_cached?: string
    disc_cached?: string
    extra_links?: JsonNullValueInput | InputJsonValue
    lynxtag?: string
    bot_commands?: bot_commandsCreateNestedManyWithoutBotsInput
    bot_events?: bot_eventsCreateNestedManyWithoutBotsInput
    bot_owner?: bot_ownerCreateNestedManyWithoutBotsInput
    bot_tags?: bot_tagsCreateNestedManyWithoutBotsInput
  }

  export type botsUncheckedCreateWithoutBot_promotionsInput = {
    bot_id: bigint | number
    votes?: bigint | number | null
    guild_count?: bigint | number | null
    shard_count?: bigint | number | null
    bot_library?: string | null
    webhook?: string | null
    description: string
    long_description: string
    prefix?: string | null
    api_token?: string | null
    banner_card?: string | null
    created_at?: Date | string
    invite?: string
    features?: botsCreatefeaturesInput | string[]
    invite_amount?: number | null
    user_count?: bigint | number | null
    css?: string | null
    shards?: botsCreateshardsInput | number[]
    username_cached?: string
    state?: number
    long_description_type: number
    verifier?: bigint | number | null
    last_stats_post?: Date | string
    webhook_secret?: string | null
    webhook_type?: number | null
    di_text?: string | null
    id: bigint | number
    banner_page?: string | null
    total_votes?: bigint | number | null
    client_id?: bigint | number | null
    flags?: botsCreateflagsInput | number[]
    uptime_checks_total?: number | null
    uptime_checks_failed?: number | null
    page_style?: number
    webhook_hmac_only?: boolean | null
    last_updated_at?: Date | string
    avatar_cached?: string
    disc_cached?: string
    extra_links?: JsonNullValueInput | InputJsonValue
    lynxtag?: string
    bot_commands?: bot_commandsUncheckedCreateNestedManyWithoutBotsInput
    bot_events?: bot_eventsUncheckedCreateNestedManyWithoutBotsInput
    bot_owner?: bot_ownerUncheckedCreateNestedManyWithoutBotsInput
    bot_tags?: bot_tagsUncheckedCreateNestedManyWithoutBotsInput
  }

  export type botsCreateOrConnectWithoutBot_promotionsInput = {
    where: botsWhereUniqueInput
    create: XOR<botsCreateWithoutBot_promotionsInput, botsUncheckedCreateWithoutBot_promotionsInput>
  }

  export type botsUpsertWithoutBot_promotionsInput = {
    update: XOR<botsUpdateWithoutBot_promotionsInput, botsUncheckedUpdateWithoutBot_promotionsInput>
    create: XOR<botsCreateWithoutBot_promotionsInput, botsUncheckedCreateWithoutBot_promotionsInput>
    where?: botsWhereInput
  }

  export type botsUpdateToOneWithWhereWithoutBot_promotionsInput = {
    where?: botsWhereInput
    data: XOR<botsUpdateWithoutBot_promotionsInput, botsUncheckedUpdateWithoutBot_promotionsInput>
  }

  export type botsUpdateWithoutBot_promotionsInput = {
    bot_id?: BigIntFieldUpdateOperationsInput | bigint | number
    votes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    guild_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    shard_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    bot_library?: NullableStringFieldUpdateOperationsInput | string | null
    webhook?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    long_description?: StringFieldUpdateOperationsInput | string
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    api_token?: NullableStringFieldUpdateOperationsInput | string | null
    banner_card?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    invite?: StringFieldUpdateOperationsInput | string
    features?: botsUpdatefeaturesInput | string[]
    invite_amount?: NullableIntFieldUpdateOperationsInput | number | null
    user_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    css?: NullableStringFieldUpdateOperationsInput | string | null
    shards?: botsUpdateshardsInput | number[]
    username_cached?: StringFieldUpdateOperationsInput | string
    state?: IntFieldUpdateOperationsInput | number
    long_description_type?: IntFieldUpdateOperationsInput | number
    verifier?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    last_stats_post?: DateTimeFieldUpdateOperationsInput | Date | string
    webhook_secret?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_type?: NullableIntFieldUpdateOperationsInput | number | null
    di_text?: NullableStringFieldUpdateOperationsInput | string | null
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    banner_page?: NullableStringFieldUpdateOperationsInput | string | null
    total_votes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    client_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    flags?: botsUpdateflagsInput | number[]
    uptime_checks_total?: NullableIntFieldUpdateOperationsInput | number | null
    uptime_checks_failed?: NullableIntFieldUpdateOperationsInput | number | null
    page_style?: IntFieldUpdateOperationsInput | number
    webhook_hmac_only?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar_cached?: StringFieldUpdateOperationsInput | string
    disc_cached?: StringFieldUpdateOperationsInput | string
    extra_links?: JsonNullValueInput | InputJsonValue
    lynxtag?: StringFieldUpdateOperationsInput | string
    bot_commands?: bot_commandsUpdateManyWithoutBotsNestedInput
    bot_events?: bot_eventsUpdateManyWithoutBotsNestedInput
    bot_owner?: bot_ownerUpdateManyWithoutBotsNestedInput
    bot_tags?: bot_tagsUpdateManyWithoutBotsNestedInput
  }

  export type botsUncheckedUpdateWithoutBot_promotionsInput = {
    bot_id?: BigIntFieldUpdateOperationsInput | bigint | number
    votes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    guild_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    shard_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    bot_library?: NullableStringFieldUpdateOperationsInput | string | null
    webhook?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    long_description?: StringFieldUpdateOperationsInput | string
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    api_token?: NullableStringFieldUpdateOperationsInput | string | null
    banner_card?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    invite?: StringFieldUpdateOperationsInput | string
    features?: botsUpdatefeaturesInput | string[]
    invite_amount?: NullableIntFieldUpdateOperationsInput | number | null
    user_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    css?: NullableStringFieldUpdateOperationsInput | string | null
    shards?: botsUpdateshardsInput | number[]
    username_cached?: StringFieldUpdateOperationsInput | string
    state?: IntFieldUpdateOperationsInput | number
    long_description_type?: IntFieldUpdateOperationsInput | number
    verifier?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    last_stats_post?: DateTimeFieldUpdateOperationsInput | Date | string
    webhook_secret?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_type?: NullableIntFieldUpdateOperationsInput | number | null
    di_text?: NullableStringFieldUpdateOperationsInput | string | null
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    banner_page?: NullableStringFieldUpdateOperationsInput | string | null
    total_votes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    client_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    flags?: botsUpdateflagsInput | number[]
    uptime_checks_total?: NullableIntFieldUpdateOperationsInput | number | null
    uptime_checks_failed?: NullableIntFieldUpdateOperationsInput | number | null
    page_style?: IntFieldUpdateOperationsInput | number
    webhook_hmac_only?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar_cached?: StringFieldUpdateOperationsInput | string
    disc_cached?: StringFieldUpdateOperationsInput | string
    extra_links?: JsonNullValueInput | InputJsonValue
    lynxtag?: StringFieldUpdateOperationsInput | string
    bot_commands?: bot_commandsUncheckedUpdateManyWithoutBotsNestedInput
    bot_events?: bot_eventsUncheckedUpdateManyWithoutBotsNestedInput
    bot_owner?: bot_ownerUncheckedUpdateManyWithoutBotsNestedInput
    bot_tags?: bot_tagsUncheckedUpdateManyWithoutBotsNestedInput
  }

  export type botsCreateWithoutBot_tagsInput = {
    bot_id: bigint | number
    votes?: bigint | number | null
    guild_count?: bigint | number | null
    shard_count?: bigint | number | null
    bot_library?: string | null
    webhook?: string | null
    description: string
    long_description: string
    prefix?: string | null
    api_token?: string | null
    banner_card?: string | null
    created_at?: Date | string
    invite?: string
    features?: botsCreatefeaturesInput | string[]
    invite_amount?: number | null
    user_count?: bigint | number | null
    css?: string | null
    shards?: botsCreateshardsInput | number[]
    username_cached?: string
    state?: number
    long_description_type: number
    verifier?: bigint | number | null
    last_stats_post?: Date | string
    webhook_secret?: string | null
    webhook_type?: number | null
    di_text?: string | null
    id: bigint | number
    banner_page?: string | null
    total_votes?: bigint | number | null
    client_id?: bigint | number | null
    flags?: botsCreateflagsInput | number[]
    uptime_checks_total?: number | null
    uptime_checks_failed?: number | null
    page_style?: number
    webhook_hmac_only?: boolean | null
    last_updated_at?: Date | string
    avatar_cached?: string
    disc_cached?: string
    extra_links?: JsonNullValueInput | InputJsonValue
    lynxtag?: string
    bot_commands?: bot_commandsCreateNestedManyWithoutBotsInput
    bot_events?: bot_eventsCreateNestedManyWithoutBotsInput
    bot_owner?: bot_ownerCreateNestedManyWithoutBotsInput
    bot_promotions?: bot_promotionsCreateNestedManyWithoutBotsInput
  }

  export type botsUncheckedCreateWithoutBot_tagsInput = {
    bot_id: bigint | number
    votes?: bigint | number | null
    guild_count?: bigint | number | null
    shard_count?: bigint | number | null
    bot_library?: string | null
    webhook?: string | null
    description: string
    long_description: string
    prefix?: string | null
    api_token?: string | null
    banner_card?: string | null
    created_at?: Date | string
    invite?: string
    features?: botsCreatefeaturesInput | string[]
    invite_amount?: number | null
    user_count?: bigint | number | null
    css?: string | null
    shards?: botsCreateshardsInput | number[]
    username_cached?: string
    state?: number
    long_description_type: number
    verifier?: bigint | number | null
    last_stats_post?: Date | string
    webhook_secret?: string | null
    webhook_type?: number | null
    di_text?: string | null
    id: bigint | number
    banner_page?: string | null
    total_votes?: bigint | number | null
    client_id?: bigint | number | null
    flags?: botsCreateflagsInput | number[]
    uptime_checks_total?: number | null
    uptime_checks_failed?: number | null
    page_style?: number
    webhook_hmac_only?: boolean | null
    last_updated_at?: Date | string
    avatar_cached?: string
    disc_cached?: string
    extra_links?: JsonNullValueInput | InputJsonValue
    lynxtag?: string
    bot_commands?: bot_commandsUncheckedCreateNestedManyWithoutBotsInput
    bot_events?: bot_eventsUncheckedCreateNestedManyWithoutBotsInput
    bot_owner?: bot_ownerUncheckedCreateNestedManyWithoutBotsInput
    bot_promotions?: bot_promotionsUncheckedCreateNestedManyWithoutBotsInput
  }

  export type botsCreateOrConnectWithoutBot_tagsInput = {
    where: botsWhereUniqueInput
    create: XOR<botsCreateWithoutBot_tagsInput, botsUncheckedCreateWithoutBot_tagsInput>
  }

  export type bot_list_tagsCreateWithoutBot_tagsInput = {
    id: string
    icon: string
    lynxtag?: string
  }

  export type bot_list_tagsUncheckedCreateWithoutBot_tagsInput = {
    id: string
    icon: string
    lynxtag?: string
  }

  export type bot_list_tagsCreateOrConnectWithoutBot_tagsInput = {
    where: bot_list_tagsWhereUniqueInput
    create: XOR<bot_list_tagsCreateWithoutBot_tagsInput, bot_list_tagsUncheckedCreateWithoutBot_tagsInput>
  }

  export type botsUpsertWithoutBot_tagsInput = {
    update: XOR<botsUpdateWithoutBot_tagsInput, botsUncheckedUpdateWithoutBot_tagsInput>
    create: XOR<botsCreateWithoutBot_tagsInput, botsUncheckedCreateWithoutBot_tagsInput>
    where?: botsWhereInput
  }

  export type botsUpdateToOneWithWhereWithoutBot_tagsInput = {
    where?: botsWhereInput
    data: XOR<botsUpdateWithoutBot_tagsInput, botsUncheckedUpdateWithoutBot_tagsInput>
  }

  export type botsUpdateWithoutBot_tagsInput = {
    bot_id?: BigIntFieldUpdateOperationsInput | bigint | number
    votes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    guild_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    shard_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    bot_library?: NullableStringFieldUpdateOperationsInput | string | null
    webhook?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    long_description?: StringFieldUpdateOperationsInput | string
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    api_token?: NullableStringFieldUpdateOperationsInput | string | null
    banner_card?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    invite?: StringFieldUpdateOperationsInput | string
    features?: botsUpdatefeaturesInput | string[]
    invite_amount?: NullableIntFieldUpdateOperationsInput | number | null
    user_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    css?: NullableStringFieldUpdateOperationsInput | string | null
    shards?: botsUpdateshardsInput | number[]
    username_cached?: StringFieldUpdateOperationsInput | string
    state?: IntFieldUpdateOperationsInput | number
    long_description_type?: IntFieldUpdateOperationsInput | number
    verifier?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    last_stats_post?: DateTimeFieldUpdateOperationsInput | Date | string
    webhook_secret?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_type?: NullableIntFieldUpdateOperationsInput | number | null
    di_text?: NullableStringFieldUpdateOperationsInput | string | null
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    banner_page?: NullableStringFieldUpdateOperationsInput | string | null
    total_votes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    client_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    flags?: botsUpdateflagsInput | number[]
    uptime_checks_total?: NullableIntFieldUpdateOperationsInput | number | null
    uptime_checks_failed?: NullableIntFieldUpdateOperationsInput | number | null
    page_style?: IntFieldUpdateOperationsInput | number
    webhook_hmac_only?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar_cached?: StringFieldUpdateOperationsInput | string
    disc_cached?: StringFieldUpdateOperationsInput | string
    extra_links?: JsonNullValueInput | InputJsonValue
    lynxtag?: StringFieldUpdateOperationsInput | string
    bot_commands?: bot_commandsUpdateManyWithoutBotsNestedInput
    bot_events?: bot_eventsUpdateManyWithoutBotsNestedInput
    bot_owner?: bot_ownerUpdateManyWithoutBotsNestedInput
    bot_promotions?: bot_promotionsUpdateManyWithoutBotsNestedInput
  }

  export type botsUncheckedUpdateWithoutBot_tagsInput = {
    bot_id?: BigIntFieldUpdateOperationsInput | bigint | number
    votes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    guild_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    shard_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    bot_library?: NullableStringFieldUpdateOperationsInput | string | null
    webhook?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    long_description?: StringFieldUpdateOperationsInput | string
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    api_token?: NullableStringFieldUpdateOperationsInput | string | null
    banner_card?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    invite?: StringFieldUpdateOperationsInput | string
    features?: botsUpdatefeaturesInput | string[]
    invite_amount?: NullableIntFieldUpdateOperationsInput | number | null
    user_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    css?: NullableStringFieldUpdateOperationsInput | string | null
    shards?: botsUpdateshardsInput | number[]
    username_cached?: StringFieldUpdateOperationsInput | string
    state?: IntFieldUpdateOperationsInput | number
    long_description_type?: IntFieldUpdateOperationsInput | number
    verifier?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    last_stats_post?: DateTimeFieldUpdateOperationsInput | Date | string
    webhook_secret?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_type?: NullableIntFieldUpdateOperationsInput | number | null
    di_text?: NullableStringFieldUpdateOperationsInput | string | null
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    banner_page?: NullableStringFieldUpdateOperationsInput | string | null
    total_votes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    client_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    flags?: botsUpdateflagsInput | number[]
    uptime_checks_total?: NullableIntFieldUpdateOperationsInput | number | null
    uptime_checks_failed?: NullableIntFieldUpdateOperationsInput | number | null
    page_style?: IntFieldUpdateOperationsInput | number
    webhook_hmac_only?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar_cached?: StringFieldUpdateOperationsInput | string
    disc_cached?: StringFieldUpdateOperationsInput | string
    extra_links?: JsonNullValueInput | InputJsonValue
    lynxtag?: StringFieldUpdateOperationsInput | string
    bot_commands?: bot_commandsUncheckedUpdateManyWithoutBotsNestedInput
    bot_events?: bot_eventsUncheckedUpdateManyWithoutBotsNestedInput
    bot_owner?: bot_ownerUncheckedUpdateManyWithoutBotsNestedInput
    bot_promotions?: bot_promotionsUncheckedUpdateManyWithoutBotsNestedInput
  }

  export type bot_list_tagsUpsertWithoutBot_tagsInput = {
    update: XOR<bot_list_tagsUpdateWithoutBot_tagsInput, bot_list_tagsUncheckedUpdateWithoutBot_tagsInput>
    create: XOR<bot_list_tagsCreateWithoutBot_tagsInput, bot_list_tagsUncheckedCreateWithoutBot_tagsInput>
    where?: bot_list_tagsWhereInput
  }

  export type bot_list_tagsUpdateToOneWithWhereWithoutBot_tagsInput = {
    where?: bot_list_tagsWhereInput
    data: XOR<bot_list_tagsUpdateWithoutBot_tagsInput, bot_list_tagsUncheckedUpdateWithoutBot_tagsInput>
  }

  export type bot_list_tagsUpdateWithoutBot_tagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type bot_list_tagsUncheckedUpdateWithoutBot_tagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type usersCreateWithoutBot_votersInput = {
    user_id: bigint | number
    api_token: string
    description?: string | null
    badges?: usersCreatebadgesInput | string[]
    username?: string | null
    user_css?: string | null
    state?: number
    coins?: number | null
    id: bigint | number
    site_lang?: string | null
    profile_css?: string
    vote_reminders?: usersCreatevote_remindersInput | bigint[] | number[]
    vote_reminder_channel?: bigint | number | null
    staff_verify_code?: string | null
    vote_reminders_last_acked?: Date | string
    vote_reminders_servers?: usersCreatevote_reminders_serversInput | bigint[] | number[]
    vote_reminders_servers_last_acked?: Date | string
    vote_reminder_servers_channel?: bigint | number | null
    experiments?: usersCreateexperimentsInput | number[]
    flags?: usersCreateflagsInput | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    supabase_id?: string | null
    totp_shared_key?: string | null
    staff_password?: string | null
    lynxtag?: string
    extra_data?: extra_dataCreateNestedManyWithoutUsersInput
    frostpaw_clients?: frostpaw_clientsCreateNestedManyWithoutUsersInput
    leave_of_absence?: leave_of_absenceCreateNestedManyWithoutUsersInput
    lynx_apps?: lynx_appsCreateNestedManyWithoutUsersInput
    lynx_logs?: lynx_logsCreateNestedManyWithoutUsersInput
    lynx_ratings?: lynx_ratingsCreateNestedManyWithoutUsersInput
    lynx_survey_responses?: lynx_survey_responsesCreateNestedManyWithoutUsersInput
    push_notifications?: push_notificationsCreateNestedManyWithoutUsersInput
    review_votes?: review_votesCreateNestedManyWithoutUsersInput
    reviews?: reviewsCreateNestedManyWithoutUsersInput
    server_audit_logs?: server_audit_logsCreateNestedManyWithoutUsersInput
    server_voters?: server_votersCreateNestedManyWithoutUsersInput
    servers?: serversCreateNestedManyWithoutUsersInput
    user_bot_logs?: user_bot_logsCreateNestedManyWithoutUsersInput
    user_connections?: user_connectionsCreateNestedManyWithoutUsersInput
    user_server_vote_table?: user_server_vote_tableCreateNestedOneWithoutUsersInput
    user_vote_table?: user_vote_tableCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutBot_votersInput = {
    user_id: bigint | number
    api_token: string
    description?: string | null
    badges?: usersCreatebadgesInput | string[]
    username?: string | null
    user_css?: string | null
    state?: number
    coins?: number | null
    id: bigint | number
    site_lang?: string | null
    profile_css?: string
    vote_reminders?: usersCreatevote_remindersInput | bigint[] | number[]
    vote_reminder_channel?: bigint | number | null
    staff_verify_code?: string | null
    vote_reminders_last_acked?: Date | string
    vote_reminders_servers?: usersCreatevote_reminders_serversInput | bigint[] | number[]
    vote_reminders_servers_last_acked?: Date | string
    vote_reminder_servers_channel?: bigint | number | null
    experiments?: usersCreateexperimentsInput | number[]
    flags?: usersCreateflagsInput | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    supabase_id?: string | null
    totp_shared_key?: string | null
    staff_password?: string | null
    lynxtag?: string
    extra_data?: extra_dataUncheckedCreateNestedManyWithoutUsersInput
    frostpaw_clients?: frostpaw_clientsUncheckedCreateNestedManyWithoutUsersInput
    leave_of_absence?: leave_of_absenceUncheckedCreateNestedManyWithoutUsersInput
    lynx_apps?: lynx_appsUncheckedCreateNestedManyWithoutUsersInput
    lynx_logs?: lynx_logsUncheckedCreateNestedManyWithoutUsersInput
    lynx_ratings?: lynx_ratingsUncheckedCreateNestedManyWithoutUsersInput
    lynx_survey_responses?: lynx_survey_responsesUncheckedCreateNestedManyWithoutUsersInput
    push_notifications?: push_notificationsUncheckedCreateNestedManyWithoutUsersInput
    review_votes?: review_votesUncheckedCreateNestedManyWithoutUsersInput
    reviews?: reviewsUncheckedCreateNestedManyWithoutUsersInput
    server_audit_logs?: server_audit_logsUncheckedCreateNestedManyWithoutUsersInput
    server_voters?: server_votersUncheckedCreateNestedManyWithoutUsersInput
    servers?: serversUncheckedCreateNestedManyWithoutUsersInput
    user_bot_logs?: user_bot_logsUncheckedCreateNestedManyWithoutUsersInput
    user_connections?: user_connectionsUncheckedCreateNestedManyWithoutUsersInput
    user_server_vote_table?: user_server_vote_tableUncheckedCreateNestedOneWithoutUsersInput
    user_vote_table?: user_vote_tableUncheckedCreateNestedOneWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutBot_votersInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutBot_votersInput, usersUncheckedCreateWithoutBot_votersInput>
  }

  export type usersUpsertWithoutBot_votersInput = {
    update: XOR<usersUpdateWithoutBot_votersInput, usersUncheckedUpdateWithoutBot_votersInput>
    create: XOR<usersCreateWithoutBot_votersInput, usersUncheckedCreateWithoutBot_votersInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutBot_votersInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutBot_votersInput, usersUncheckedUpdateWithoutBot_votersInput>
  }

  export type usersUpdateWithoutBot_votersInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    api_token?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    badges?: usersUpdatebadgesInput | string[]
    username?: NullableStringFieldUpdateOperationsInput | string | null
    user_css?: NullableStringFieldUpdateOperationsInput | string | null
    state?: IntFieldUpdateOperationsInput | number
    coins?: NullableIntFieldUpdateOperationsInput | number | null
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    site_lang?: NullableStringFieldUpdateOperationsInput | string | null
    profile_css?: StringFieldUpdateOperationsInput | string
    vote_reminders?: usersUpdatevote_remindersInput | bigint[] | number[]
    vote_reminder_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    staff_verify_code?: NullableStringFieldUpdateOperationsInput | string | null
    vote_reminders_last_acked?: DateTimeFieldUpdateOperationsInput | Date | string
    vote_reminders_servers?: usersUpdatevote_reminders_serversInput | bigint[] | number[]
    vote_reminders_servers_last_acked?: DateTimeFieldUpdateOperationsInput | Date | string
    vote_reminder_servers_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    experiments?: usersUpdateexperimentsInput | number[]
    flags?: usersUpdateflagsInput | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    totp_shared_key?: NullableStringFieldUpdateOperationsInput | string | null
    staff_password?: NullableStringFieldUpdateOperationsInput | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
    extra_data?: extra_dataUpdateManyWithoutUsersNestedInput
    frostpaw_clients?: frostpaw_clientsUpdateManyWithoutUsersNestedInput
    leave_of_absence?: leave_of_absenceUpdateManyWithoutUsersNestedInput
    lynx_apps?: lynx_appsUpdateManyWithoutUsersNestedInput
    lynx_logs?: lynx_logsUpdateManyWithoutUsersNestedInput
    lynx_ratings?: lynx_ratingsUpdateManyWithoutUsersNestedInput
    lynx_survey_responses?: lynx_survey_responsesUpdateManyWithoutUsersNestedInput
    push_notifications?: push_notificationsUpdateManyWithoutUsersNestedInput
    review_votes?: review_votesUpdateManyWithoutUsersNestedInput
    reviews?: reviewsUpdateManyWithoutUsersNestedInput
    server_audit_logs?: server_audit_logsUpdateManyWithoutUsersNestedInput
    server_voters?: server_votersUpdateManyWithoutUsersNestedInput
    servers?: serversUpdateManyWithoutUsersNestedInput
    user_bot_logs?: user_bot_logsUpdateManyWithoutUsersNestedInput
    user_connections?: user_connectionsUpdateManyWithoutUsersNestedInput
    user_server_vote_table?: user_server_vote_tableUpdateOneWithoutUsersNestedInput
    user_vote_table?: user_vote_tableUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutBot_votersInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    api_token?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    badges?: usersUpdatebadgesInput | string[]
    username?: NullableStringFieldUpdateOperationsInput | string | null
    user_css?: NullableStringFieldUpdateOperationsInput | string | null
    state?: IntFieldUpdateOperationsInput | number
    coins?: NullableIntFieldUpdateOperationsInput | number | null
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    site_lang?: NullableStringFieldUpdateOperationsInput | string | null
    profile_css?: StringFieldUpdateOperationsInput | string
    vote_reminders?: usersUpdatevote_remindersInput | bigint[] | number[]
    vote_reminder_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    staff_verify_code?: NullableStringFieldUpdateOperationsInput | string | null
    vote_reminders_last_acked?: DateTimeFieldUpdateOperationsInput | Date | string
    vote_reminders_servers?: usersUpdatevote_reminders_serversInput | bigint[] | number[]
    vote_reminders_servers_last_acked?: DateTimeFieldUpdateOperationsInput | Date | string
    vote_reminder_servers_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    experiments?: usersUpdateexperimentsInput | number[]
    flags?: usersUpdateflagsInput | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    totp_shared_key?: NullableStringFieldUpdateOperationsInput | string | null
    staff_password?: NullableStringFieldUpdateOperationsInput | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
    extra_data?: extra_dataUncheckedUpdateManyWithoutUsersNestedInput
    frostpaw_clients?: frostpaw_clientsUncheckedUpdateManyWithoutUsersNestedInput
    leave_of_absence?: leave_of_absenceUncheckedUpdateManyWithoutUsersNestedInput
    lynx_apps?: lynx_appsUncheckedUpdateManyWithoutUsersNestedInput
    lynx_logs?: lynx_logsUncheckedUpdateManyWithoutUsersNestedInput
    lynx_ratings?: lynx_ratingsUncheckedUpdateManyWithoutUsersNestedInput
    lynx_survey_responses?: lynx_survey_responsesUncheckedUpdateManyWithoutUsersNestedInput
    push_notifications?: push_notificationsUncheckedUpdateManyWithoutUsersNestedInput
    review_votes?: review_votesUncheckedUpdateManyWithoutUsersNestedInput
    reviews?: reviewsUncheckedUpdateManyWithoutUsersNestedInput
    server_audit_logs?: server_audit_logsUncheckedUpdateManyWithoutUsersNestedInput
    server_voters?: server_votersUncheckedUpdateManyWithoutUsersNestedInput
    servers?: serversUncheckedUpdateManyWithoutUsersNestedInput
    user_bot_logs?: user_bot_logsUncheckedUpdateManyWithoutUsersNestedInput
    user_connections?: user_connectionsUncheckedUpdateManyWithoutUsersNestedInput
    user_server_vote_table?: user_server_vote_tableUncheckedUpdateOneWithoutUsersNestedInput
    user_vote_table?: user_vote_tableUncheckedUpdateOneWithoutUsersNestedInput
  }

  export type bot_commandsCreateWithoutBotsInput = {
    id?: string
    cmd_type: number
    groups?: bot_commandsCreategroupsInput | string[]
    name: string
    vote_locked?: boolean
    description: string
    args?: bot_commandsCreateargsInput | string[]
    examples?: bot_commandsCreateexamplesInput | string[]
    premium_only?: boolean
    notes?: bot_commandsCreatenotesInput | string[]
    doc_link?: string | null
    nsfw?: boolean | null
    lynxtag?: string
  }

  export type bot_commandsUncheckedCreateWithoutBotsInput = {
    id?: string
    cmd_type: number
    groups?: bot_commandsCreategroupsInput | string[]
    name: string
    vote_locked?: boolean
    description: string
    args?: bot_commandsCreateargsInput | string[]
    examples?: bot_commandsCreateexamplesInput | string[]
    premium_only?: boolean
    notes?: bot_commandsCreatenotesInput | string[]
    doc_link?: string | null
    nsfw?: boolean | null
    lynxtag?: string
  }

  export type bot_commandsCreateOrConnectWithoutBotsInput = {
    where: bot_commandsWhereUniqueInput
    create: XOR<bot_commandsCreateWithoutBotsInput, bot_commandsUncheckedCreateWithoutBotsInput>
  }

  export type bot_commandsCreateManyBotsInputEnvelope = {
    data: bot_commandsCreateManyBotsInput | bot_commandsCreateManyBotsInput[]
    skipDuplicates?: boolean
  }

  export type bot_eventsCreateWithoutBotsInput = {
    event_type: number
    ts?: Date | string
    reason: string
    css?: string
    id?: string
    lynxtag?: string
  }

  export type bot_eventsUncheckedCreateWithoutBotsInput = {
    event_type: number
    ts?: Date | string
    reason: string
    css?: string
    id?: string
    lynxtag?: string
  }

  export type bot_eventsCreateOrConnectWithoutBotsInput = {
    where: bot_eventsWhereUniqueInput
    create: XOR<bot_eventsCreateWithoutBotsInput, bot_eventsUncheckedCreateWithoutBotsInput>
  }

  export type bot_eventsCreateManyBotsInputEnvelope = {
    data: bot_eventsCreateManyBotsInput | bot_eventsCreateManyBotsInput[]
    skipDuplicates?: boolean
  }

  export type bot_ownerCreateWithoutBotsInput = {
    owner: bigint | number
    main?: boolean | null
    id?: number
    lynxtag?: string
  }

  export type bot_ownerUncheckedCreateWithoutBotsInput = {
    owner: bigint | number
    main?: boolean | null
    id?: number
    lynxtag?: string
  }

  export type bot_ownerCreateOrConnectWithoutBotsInput = {
    where: bot_ownerWhereUniqueInput
    create: XOR<bot_ownerCreateWithoutBotsInput, bot_ownerUncheckedCreateWithoutBotsInput>
  }

  export type bot_ownerCreateManyBotsInputEnvelope = {
    data: bot_ownerCreateManyBotsInput | bot_ownerCreateManyBotsInput[]
    skipDuplicates?: boolean
  }

  export type bot_promotionsCreateWithoutBotsInput = {
    id?: string
    title?: string | null
    info?: string | null
    css?: string | null
    type?: number | null
    lynxtag?: string
  }

  export type bot_promotionsUncheckedCreateWithoutBotsInput = {
    id?: string
    title?: string | null
    info?: string | null
    css?: string | null
    type?: number | null
    lynxtag?: string
  }

  export type bot_promotionsCreateOrConnectWithoutBotsInput = {
    where: bot_promotionsWhereUniqueInput
    create: XOR<bot_promotionsCreateWithoutBotsInput, bot_promotionsUncheckedCreateWithoutBotsInput>
  }

  export type bot_promotionsCreateManyBotsInputEnvelope = {
    data: bot_promotionsCreateManyBotsInput | bot_promotionsCreateManyBotsInput[]
    skipDuplicates?: boolean
  }

  export type bot_tagsCreateWithoutBotsInput = {
    id?: number
    lynxtag?: string
    bot_list_tags: bot_list_tagsCreateNestedOneWithoutBot_tagsInput
  }

  export type bot_tagsUncheckedCreateWithoutBotsInput = {
    tag: string
    id?: number
    lynxtag?: string
  }

  export type bot_tagsCreateOrConnectWithoutBotsInput = {
    where: bot_tagsWhereUniqueInput
    create: XOR<bot_tagsCreateWithoutBotsInput, bot_tagsUncheckedCreateWithoutBotsInput>
  }

  export type bot_tagsCreateManyBotsInputEnvelope = {
    data: bot_tagsCreateManyBotsInput | bot_tagsCreateManyBotsInput[]
    skipDuplicates?: boolean
  }

  export type bot_commandsUpsertWithWhereUniqueWithoutBotsInput = {
    where: bot_commandsWhereUniqueInput
    update: XOR<bot_commandsUpdateWithoutBotsInput, bot_commandsUncheckedUpdateWithoutBotsInput>
    create: XOR<bot_commandsCreateWithoutBotsInput, bot_commandsUncheckedCreateWithoutBotsInput>
  }

  export type bot_commandsUpdateWithWhereUniqueWithoutBotsInput = {
    where: bot_commandsWhereUniqueInput
    data: XOR<bot_commandsUpdateWithoutBotsInput, bot_commandsUncheckedUpdateWithoutBotsInput>
  }

  export type bot_commandsUpdateManyWithWhereWithoutBotsInput = {
    where: bot_commandsScalarWhereInput
    data: XOR<bot_commandsUpdateManyMutationInput, bot_commandsUncheckedUpdateManyWithoutBotsInput>
  }

  export type bot_commandsScalarWhereInput = {
    AND?: bot_commandsScalarWhereInput | bot_commandsScalarWhereInput[]
    OR?: bot_commandsScalarWhereInput[]
    NOT?: bot_commandsScalarWhereInput | bot_commandsScalarWhereInput[]
    id?: UuidFilter<"bot_commands"> | string
    bot_id?: BigIntFilter<"bot_commands"> | bigint | number
    cmd_type?: IntFilter<"bot_commands"> | number
    groups?: StringNullableListFilter<"bot_commands">
    name?: StringFilter<"bot_commands"> | string
    vote_locked?: BoolFilter<"bot_commands"> | boolean
    description?: StringFilter<"bot_commands"> | string
    args?: StringNullableListFilter<"bot_commands">
    examples?: StringNullableListFilter<"bot_commands">
    premium_only?: BoolFilter<"bot_commands"> | boolean
    notes?: StringNullableListFilter<"bot_commands">
    doc_link?: StringNullableFilter<"bot_commands"> | string | null
    nsfw?: BoolNullableFilter<"bot_commands"> | boolean | null
    lynxtag?: UuidFilter<"bot_commands"> | string
  }

  export type bot_eventsUpsertWithWhereUniqueWithoutBotsInput = {
    where: bot_eventsWhereUniqueInput
    update: XOR<bot_eventsUpdateWithoutBotsInput, bot_eventsUncheckedUpdateWithoutBotsInput>
    create: XOR<bot_eventsCreateWithoutBotsInput, bot_eventsUncheckedCreateWithoutBotsInput>
  }

  export type bot_eventsUpdateWithWhereUniqueWithoutBotsInput = {
    where: bot_eventsWhereUniqueInput
    data: XOR<bot_eventsUpdateWithoutBotsInput, bot_eventsUncheckedUpdateWithoutBotsInput>
  }

  export type bot_eventsUpdateManyWithWhereWithoutBotsInput = {
    where: bot_eventsScalarWhereInput
    data: XOR<bot_eventsUpdateManyMutationInput, bot_eventsUncheckedUpdateManyWithoutBotsInput>
  }

  export type bot_eventsScalarWhereInput = {
    AND?: bot_eventsScalarWhereInput | bot_eventsScalarWhereInput[]
    OR?: bot_eventsScalarWhereInput[]
    NOT?: bot_eventsScalarWhereInput | bot_eventsScalarWhereInput[]
    bot_id?: BigIntFilter<"bot_events"> | bigint | number
    event_type?: IntFilter<"bot_events"> | number
    ts?: DateTimeFilter<"bot_events"> | Date | string
    reason?: StringFilter<"bot_events"> | string
    css?: StringFilter<"bot_events"> | string
    id?: UuidFilter<"bot_events"> | string
    lynxtag?: UuidFilter<"bot_events"> | string
  }

  export type bot_ownerUpsertWithWhereUniqueWithoutBotsInput = {
    where: bot_ownerWhereUniqueInput
    update: XOR<bot_ownerUpdateWithoutBotsInput, bot_ownerUncheckedUpdateWithoutBotsInput>
    create: XOR<bot_ownerCreateWithoutBotsInput, bot_ownerUncheckedCreateWithoutBotsInput>
  }

  export type bot_ownerUpdateWithWhereUniqueWithoutBotsInput = {
    where: bot_ownerWhereUniqueInput
    data: XOR<bot_ownerUpdateWithoutBotsInput, bot_ownerUncheckedUpdateWithoutBotsInput>
  }

  export type bot_ownerUpdateManyWithWhereWithoutBotsInput = {
    where: bot_ownerScalarWhereInput
    data: XOR<bot_ownerUpdateManyMutationInput, bot_ownerUncheckedUpdateManyWithoutBotsInput>
  }

  export type bot_ownerScalarWhereInput = {
    AND?: bot_ownerScalarWhereInput | bot_ownerScalarWhereInput[]
    OR?: bot_ownerScalarWhereInput[]
    NOT?: bot_ownerScalarWhereInput | bot_ownerScalarWhereInput[]
    bot_id?: BigIntFilter<"bot_owner"> | bigint | number
    owner?: BigIntFilter<"bot_owner"> | bigint | number
    main?: BoolNullableFilter<"bot_owner"> | boolean | null
    id?: IntFilter<"bot_owner"> | number
    lynxtag?: UuidFilter<"bot_owner"> | string
  }

  export type bot_promotionsUpsertWithWhereUniqueWithoutBotsInput = {
    where: bot_promotionsWhereUniqueInput
    update: XOR<bot_promotionsUpdateWithoutBotsInput, bot_promotionsUncheckedUpdateWithoutBotsInput>
    create: XOR<bot_promotionsCreateWithoutBotsInput, bot_promotionsUncheckedCreateWithoutBotsInput>
  }

  export type bot_promotionsUpdateWithWhereUniqueWithoutBotsInput = {
    where: bot_promotionsWhereUniqueInput
    data: XOR<bot_promotionsUpdateWithoutBotsInput, bot_promotionsUncheckedUpdateWithoutBotsInput>
  }

  export type bot_promotionsUpdateManyWithWhereWithoutBotsInput = {
    where: bot_promotionsScalarWhereInput
    data: XOR<bot_promotionsUpdateManyMutationInput, bot_promotionsUncheckedUpdateManyWithoutBotsInput>
  }

  export type bot_promotionsScalarWhereInput = {
    AND?: bot_promotionsScalarWhereInput | bot_promotionsScalarWhereInput[]
    OR?: bot_promotionsScalarWhereInput[]
    NOT?: bot_promotionsScalarWhereInput | bot_promotionsScalarWhereInput[]
    id?: UuidFilter<"bot_promotions"> | string
    bot_id?: BigIntNullableFilter<"bot_promotions"> | bigint | number | null
    title?: StringNullableFilter<"bot_promotions"> | string | null
    info?: StringNullableFilter<"bot_promotions"> | string | null
    css?: StringNullableFilter<"bot_promotions"> | string | null
    type?: IntNullableFilter<"bot_promotions"> | number | null
    lynxtag?: UuidFilter<"bot_promotions"> | string
  }

  export type bot_tagsUpsertWithWhereUniqueWithoutBotsInput = {
    where: bot_tagsWhereUniqueInput
    update: XOR<bot_tagsUpdateWithoutBotsInput, bot_tagsUncheckedUpdateWithoutBotsInput>
    create: XOR<bot_tagsCreateWithoutBotsInput, bot_tagsUncheckedCreateWithoutBotsInput>
  }

  export type bot_tagsUpdateWithWhereUniqueWithoutBotsInput = {
    where: bot_tagsWhereUniqueInput
    data: XOR<bot_tagsUpdateWithoutBotsInput, bot_tagsUncheckedUpdateWithoutBotsInput>
  }

  export type bot_tagsUpdateManyWithWhereWithoutBotsInput = {
    where: bot_tagsScalarWhereInput
    data: XOR<bot_tagsUpdateManyMutationInput, bot_tagsUncheckedUpdateManyWithoutBotsInput>
  }

  export type usersCreateWithoutExtra_dataInput = {
    user_id: bigint | number
    api_token: string
    description?: string | null
    badges?: usersCreatebadgesInput | string[]
    username?: string | null
    user_css?: string | null
    state?: number
    coins?: number | null
    id: bigint | number
    site_lang?: string | null
    profile_css?: string
    vote_reminders?: usersCreatevote_remindersInput | bigint[] | number[]
    vote_reminder_channel?: bigint | number | null
    staff_verify_code?: string | null
    vote_reminders_last_acked?: Date | string
    vote_reminders_servers?: usersCreatevote_reminders_serversInput | bigint[] | number[]
    vote_reminders_servers_last_acked?: Date | string
    vote_reminder_servers_channel?: bigint | number | null
    experiments?: usersCreateexperimentsInput | number[]
    flags?: usersCreateflagsInput | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    supabase_id?: string | null
    totp_shared_key?: string | null
    staff_password?: string | null
    lynxtag?: string
    bot_voters?: bot_votersCreateNestedManyWithoutUsersInput
    frostpaw_clients?: frostpaw_clientsCreateNestedManyWithoutUsersInput
    leave_of_absence?: leave_of_absenceCreateNestedManyWithoutUsersInput
    lynx_apps?: lynx_appsCreateNestedManyWithoutUsersInput
    lynx_logs?: lynx_logsCreateNestedManyWithoutUsersInput
    lynx_ratings?: lynx_ratingsCreateNestedManyWithoutUsersInput
    lynx_survey_responses?: lynx_survey_responsesCreateNestedManyWithoutUsersInput
    push_notifications?: push_notificationsCreateNestedManyWithoutUsersInput
    review_votes?: review_votesCreateNestedManyWithoutUsersInput
    reviews?: reviewsCreateNestedManyWithoutUsersInput
    server_audit_logs?: server_audit_logsCreateNestedManyWithoutUsersInput
    server_voters?: server_votersCreateNestedManyWithoutUsersInput
    servers?: serversCreateNestedManyWithoutUsersInput
    user_bot_logs?: user_bot_logsCreateNestedManyWithoutUsersInput
    user_connections?: user_connectionsCreateNestedManyWithoutUsersInput
    user_server_vote_table?: user_server_vote_tableCreateNestedOneWithoutUsersInput
    user_vote_table?: user_vote_tableCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutExtra_dataInput = {
    user_id: bigint | number
    api_token: string
    description?: string | null
    badges?: usersCreatebadgesInput | string[]
    username?: string | null
    user_css?: string | null
    state?: number
    coins?: number | null
    id: bigint | number
    site_lang?: string | null
    profile_css?: string
    vote_reminders?: usersCreatevote_remindersInput | bigint[] | number[]
    vote_reminder_channel?: bigint | number | null
    staff_verify_code?: string | null
    vote_reminders_last_acked?: Date | string
    vote_reminders_servers?: usersCreatevote_reminders_serversInput | bigint[] | number[]
    vote_reminders_servers_last_acked?: Date | string
    vote_reminder_servers_channel?: bigint | number | null
    experiments?: usersCreateexperimentsInput | number[]
    flags?: usersCreateflagsInput | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    supabase_id?: string | null
    totp_shared_key?: string | null
    staff_password?: string | null
    lynxtag?: string
    bot_voters?: bot_votersUncheckedCreateNestedManyWithoutUsersInput
    frostpaw_clients?: frostpaw_clientsUncheckedCreateNestedManyWithoutUsersInput
    leave_of_absence?: leave_of_absenceUncheckedCreateNestedManyWithoutUsersInput
    lynx_apps?: lynx_appsUncheckedCreateNestedManyWithoutUsersInput
    lynx_logs?: lynx_logsUncheckedCreateNestedManyWithoutUsersInput
    lynx_ratings?: lynx_ratingsUncheckedCreateNestedManyWithoutUsersInput
    lynx_survey_responses?: lynx_survey_responsesUncheckedCreateNestedManyWithoutUsersInput
    push_notifications?: push_notificationsUncheckedCreateNestedManyWithoutUsersInput
    review_votes?: review_votesUncheckedCreateNestedManyWithoutUsersInput
    reviews?: reviewsUncheckedCreateNestedManyWithoutUsersInput
    server_audit_logs?: server_audit_logsUncheckedCreateNestedManyWithoutUsersInput
    server_voters?: server_votersUncheckedCreateNestedManyWithoutUsersInput
    servers?: serversUncheckedCreateNestedManyWithoutUsersInput
    user_bot_logs?: user_bot_logsUncheckedCreateNestedManyWithoutUsersInput
    user_connections?: user_connectionsUncheckedCreateNestedManyWithoutUsersInput
    user_server_vote_table?: user_server_vote_tableUncheckedCreateNestedOneWithoutUsersInput
    user_vote_table?: user_vote_tableUncheckedCreateNestedOneWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutExtra_dataInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutExtra_dataInput, usersUncheckedCreateWithoutExtra_dataInput>
  }

  export type usersUpsertWithoutExtra_dataInput = {
    update: XOR<usersUpdateWithoutExtra_dataInput, usersUncheckedUpdateWithoutExtra_dataInput>
    create: XOR<usersCreateWithoutExtra_dataInput, usersUncheckedCreateWithoutExtra_dataInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutExtra_dataInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutExtra_dataInput, usersUncheckedUpdateWithoutExtra_dataInput>
  }

  export type usersUpdateWithoutExtra_dataInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    api_token?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    badges?: usersUpdatebadgesInput | string[]
    username?: NullableStringFieldUpdateOperationsInput | string | null
    user_css?: NullableStringFieldUpdateOperationsInput | string | null
    state?: IntFieldUpdateOperationsInput | number
    coins?: NullableIntFieldUpdateOperationsInput | number | null
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    site_lang?: NullableStringFieldUpdateOperationsInput | string | null
    profile_css?: StringFieldUpdateOperationsInput | string
    vote_reminders?: usersUpdatevote_remindersInput | bigint[] | number[]
    vote_reminder_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    staff_verify_code?: NullableStringFieldUpdateOperationsInput | string | null
    vote_reminders_last_acked?: DateTimeFieldUpdateOperationsInput | Date | string
    vote_reminders_servers?: usersUpdatevote_reminders_serversInput | bigint[] | number[]
    vote_reminders_servers_last_acked?: DateTimeFieldUpdateOperationsInput | Date | string
    vote_reminder_servers_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    experiments?: usersUpdateexperimentsInput | number[]
    flags?: usersUpdateflagsInput | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    totp_shared_key?: NullableStringFieldUpdateOperationsInput | string | null
    staff_password?: NullableStringFieldUpdateOperationsInput | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
    bot_voters?: bot_votersUpdateManyWithoutUsersNestedInput
    frostpaw_clients?: frostpaw_clientsUpdateManyWithoutUsersNestedInput
    leave_of_absence?: leave_of_absenceUpdateManyWithoutUsersNestedInput
    lynx_apps?: lynx_appsUpdateManyWithoutUsersNestedInput
    lynx_logs?: lynx_logsUpdateManyWithoutUsersNestedInput
    lynx_ratings?: lynx_ratingsUpdateManyWithoutUsersNestedInput
    lynx_survey_responses?: lynx_survey_responsesUpdateManyWithoutUsersNestedInput
    push_notifications?: push_notificationsUpdateManyWithoutUsersNestedInput
    review_votes?: review_votesUpdateManyWithoutUsersNestedInput
    reviews?: reviewsUpdateManyWithoutUsersNestedInput
    server_audit_logs?: server_audit_logsUpdateManyWithoutUsersNestedInput
    server_voters?: server_votersUpdateManyWithoutUsersNestedInput
    servers?: serversUpdateManyWithoutUsersNestedInput
    user_bot_logs?: user_bot_logsUpdateManyWithoutUsersNestedInput
    user_connections?: user_connectionsUpdateManyWithoutUsersNestedInput
    user_server_vote_table?: user_server_vote_tableUpdateOneWithoutUsersNestedInput
    user_vote_table?: user_vote_tableUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutExtra_dataInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    api_token?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    badges?: usersUpdatebadgesInput | string[]
    username?: NullableStringFieldUpdateOperationsInput | string | null
    user_css?: NullableStringFieldUpdateOperationsInput | string | null
    state?: IntFieldUpdateOperationsInput | number
    coins?: NullableIntFieldUpdateOperationsInput | number | null
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    site_lang?: NullableStringFieldUpdateOperationsInput | string | null
    profile_css?: StringFieldUpdateOperationsInput | string
    vote_reminders?: usersUpdatevote_remindersInput | bigint[] | number[]
    vote_reminder_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    staff_verify_code?: NullableStringFieldUpdateOperationsInput | string | null
    vote_reminders_last_acked?: DateTimeFieldUpdateOperationsInput | Date | string
    vote_reminders_servers?: usersUpdatevote_reminders_serversInput | bigint[] | number[]
    vote_reminders_servers_last_acked?: DateTimeFieldUpdateOperationsInput | Date | string
    vote_reminder_servers_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    experiments?: usersUpdateexperimentsInput | number[]
    flags?: usersUpdateflagsInput | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    totp_shared_key?: NullableStringFieldUpdateOperationsInput | string | null
    staff_password?: NullableStringFieldUpdateOperationsInput | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
    bot_voters?: bot_votersUncheckedUpdateManyWithoutUsersNestedInput
    frostpaw_clients?: frostpaw_clientsUncheckedUpdateManyWithoutUsersNestedInput
    leave_of_absence?: leave_of_absenceUncheckedUpdateManyWithoutUsersNestedInput
    lynx_apps?: lynx_appsUncheckedUpdateManyWithoutUsersNestedInput
    lynx_logs?: lynx_logsUncheckedUpdateManyWithoutUsersNestedInput
    lynx_ratings?: lynx_ratingsUncheckedUpdateManyWithoutUsersNestedInput
    lynx_survey_responses?: lynx_survey_responsesUncheckedUpdateManyWithoutUsersNestedInput
    push_notifications?: push_notificationsUncheckedUpdateManyWithoutUsersNestedInput
    review_votes?: review_votesUncheckedUpdateManyWithoutUsersNestedInput
    reviews?: reviewsUncheckedUpdateManyWithoutUsersNestedInput
    server_audit_logs?: server_audit_logsUncheckedUpdateManyWithoutUsersNestedInput
    server_voters?: server_votersUncheckedUpdateManyWithoutUsersNestedInput
    servers?: serversUncheckedUpdateManyWithoutUsersNestedInput
    user_bot_logs?: user_bot_logsUncheckedUpdateManyWithoutUsersNestedInput
    user_connections?: user_connectionsUncheckedUpdateManyWithoutUsersNestedInput
    user_server_vote_table?: user_server_vote_tableUncheckedUpdateOneWithoutUsersNestedInput
    user_vote_table?: user_vote_tableUncheckedUpdateOneWithoutUsersNestedInput
  }

  export type usersCreateWithoutFrostpaw_clientsInput = {
    user_id: bigint | number
    api_token: string
    description?: string | null
    badges?: usersCreatebadgesInput | string[]
    username?: string | null
    user_css?: string | null
    state?: number
    coins?: number | null
    id: bigint | number
    site_lang?: string | null
    profile_css?: string
    vote_reminders?: usersCreatevote_remindersInput | bigint[] | number[]
    vote_reminder_channel?: bigint | number | null
    staff_verify_code?: string | null
    vote_reminders_last_acked?: Date | string
    vote_reminders_servers?: usersCreatevote_reminders_serversInput | bigint[] | number[]
    vote_reminders_servers_last_acked?: Date | string
    vote_reminder_servers_channel?: bigint | number | null
    experiments?: usersCreateexperimentsInput | number[]
    flags?: usersCreateflagsInput | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    supabase_id?: string | null
    totp_shared_key?: string | null
    staff_password?: string | null
    lynxtag?: string
    bot_voters?: bot_votersCreateNestedManyWithoutUsersInput
    extra_data?: extra_dataCreateNestedManyWithoutUsersInput
    leave_of_absence?: leave_of_absenceCreateNestedManyWithoutUsersInput
    lynx_apps?: lynx_appsCreateNestedManyWithoutUsersInput
    lynx_logs?: lynx_logsCreateNestedManyWithoutUsersInput
    lynx_ratings?: lynx_ratingsCreateNestedManyWithoutUsersInput
    lynx_survey_responses?: lynx_survey_responsesCreateNestedManyWithoutUsersInput
    push_notifications?: push_notificationsCreateNestedManyWithoutUsersInput
    review_votes?: review_votesCreateNestedManyWithoutUsersInput
    reviews?: reviewsCreateNestedManyWithoutUsersInput
    server_audit_logs?: server_audit_logsCreateNestedManyWithoutUsersInput
    server_voters?: server_votersCreateNestedManyWithoutUsersInput
    servers?: serversCreateNestedManyWithoutUsersInput
    user_bot_logs?: user_bot_logsCreateNestedManyWithoutUsersInput
    user_connections?: user_connectionsCreateNestedManyWithoutUsersInput
    user_server_vote_table?: user_server_vote_tableCreateNestedOneWithoutUsersInput
    user_vote_table?: user_vote_tableCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutFrostpaw_clientsInput = {
    user_id: bigint | number
    api_token: string
    description?: string | null
    badges?: usersCreatebadgesInput | string[]
    username?: string | null
    user_css?: string | null
    state?: number
    coins?: number | null
    id: bigint | number
    site_lang?: string | null
    profile_css?: string
    vote_reminders?: usersCreatevote_remindersInput | bigint[] | number[]
    vote_reminder_channel?: bigint | number | null
    staff_verify_code?: string | null
    vote_reminders_last_acked?: Date | string
    vote_reminders_servers?: usersCreatevote_reminders_serversInput | bigint[] | number[]
    vote_reminders_servers_last_acked?: Date | string
    vote_reminder_servers_channel?: bigint | number | null
    experiments?: usersCreateexperimentsInput | number[]
    flags?: usersCreateflagsInput | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    supabase_id?: string | null
    totp_shared_key?: string | null
    staff_password?: string | null
    lynxtag?: string
    bot_voters?: bot_votersUncheckedCreateNestedManyWithoutUsersInput
    extra_data?: extra_dataUncheckedCreateNestedManyWithoutUsersInput
    leave_of_absence?: leave_of_absenceUncheckedCreateNestedManyWithoutUsersInput
    lynx_apps?: lynx_appsUncheckedCreateNestedManyWithoutUsersInput
    lynx_logs?: lynx_logsUncheckedCreateNestedManyWithoutUsersInput
    lynx_ratings?: lynx_ratingsUncheckedCreateNestedManyWithoutUsersInput
    lynx_survey_responses?: lynx_survey_responsesUncheckedCreateNestedManyWithoutUsersInput
    push_notifications?: push_notificationsUncheckedCreateNestedManyWithoutUsersInput
    review_votes?: review_votesUncheckedCreateNestedManyWithoutUsersInput
    reviews?: reviewsUncheckedCreateNestedManyWithoutUsersInput
    server_audit_logs?: server_audit_logsUncheckedCreateNestedManyWithoutUsersInput
    server_voters?: server_votersUncheckedCreateNestedManyWithoutUsersInput
    servers?: serversUncheckedCreateNestedManyWithoutUsersInput
    user_bot_logs?: user_bot_logsUncheckedCreateNestedManyWithoutUsersInput
    user_connections?: user_connectionsUncheckedCreateNestedManyWithoutUsersInput
    user_server_vote_table?: user_server_vote_tableUncheckedCreateNestedOneWithoutUsersInput
    user_vote_table?: user_vote_tableUncheckedCreateNestedOneWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutFrostpaw_clientsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutFrostpaw_clientsInput, usersUncheckedCreateWithoutFrostpaw_clientsInput>
  }

  export type usersUpsertWithoutFrostpaw_clientsInput = {
    update: XOR<usersUpdateWithoutFrostpaw_clientsInput, usersUncheckedUpdateWithoutFrostpaw_clientsInput>
    create: XOR<usersCreateWithoutFrostpaw_clientsInput, usersUncheckedCreateWithoutFrostpaw_clientsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutFrostpaw_clientsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutFrostpaw_clientsInput, usersUncheckedUpdateWithoutFrostpaw_clientsInput>
  }

  export type usersUpdateWithoutFrostpaw_clientsInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    api_token?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    badges?: usersUpdatebadgesInput | string[]
    username?: NullableStringFieldUpdateOperationsInput | string | null
    user_css?: NullableStringFieldUpdateOperationsInput | string | null
    state?: IntFieldUpdateOperationsInput | number
    coins?: NullableIntFieldUpdateOperationsInput | number | null
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    site_lang?: NullableStringFieldUpdateOperationsInput | string | null
    profile_css?: StringFieldUpdateOperationsInput | string
    vote_reminders?: usersUpdatevote_remindersInput | bigint[] | number[]
    vote_reminder_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    staff_verify_code?: NullableStringFieldUpdateOperationsInput | string | null
    vote_reminders_last_acked?: DateTimeFieldUpdateOperationsInput | Date | string
    vote_reminders_servers?: usersUpdatevote_reminders_serversInput | bigint[] | number[]
    vote_reminders_servers_last_acked?: DateTimeFieldUpdateOperationsInput | Date | string
    vote_reminder_servers_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    experiments?: usersUpdateexperimentsInput | number[]
    flags?: usersUpdateflagsInput | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    totp_shared_key?: NullableStringFieldUpdateOperationsInput | string | null
    staff_password?: NullableStringFieldUpdateOperationsInput | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
    bot_voters?: bot_votersUpdateManyWithoutUsersNestedInput
    extra_data?: extra_dataUpdateManyWithoutUsersNestedInput
    leave_of_absence?: leave_of_absenceUpdateManyWithoutUsersNestedInput
    lynx_apps?: lynx_appsUpdateManyWithoutUsersNestedInput
    lynx_logs?: lynx_logsUpdateManyWithoutUsersNestedInput
    lynx_ratings?: lynx_ratingsUpdateManyWithoutUsersNestedInput
    lynx_survey_responses?: lynx_survey_responsesUpdateManyWithoutUsersNestedInput
    push_notifications?: push_notificationsUpdateManyWithoutUsersNestedInput
    review_votes?: review_votesUpdateManyWithoutUsersNestedInput
    reviews?: reviewsUpdateManyWithoutUsersNestedInput
    server_audit_logs?: server_audit_logsUpdateManyWithoutUsersNestedInput
    server_voters?: server_votersUpdateManyWithoutUsersNestedInput
    servers?: serversUpdateManyWithoutUsersNestedInput
    user_bot_logs?: user_bot_logsUpdateManyWithoutUsersNestedInput
    user_connections?: user_connectionsUpdateManyWithoutUsersNestedInput
    user_server_vote_table?: user_server_vote_tableUpdateOneWithoutUsersNestedInput
    user_vote_table?: user_vote_tableUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutFrostpaw_clientsInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    api_token?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    badges?: usersUpdatebadgesInput | string[]
    username?: NullableStringFieldUpdateOperationsInput | string | null
    user_css?: NullableStringFieldUpdateOperationsInput | string | null
    state?: IntFieldUpdateOperationsInput | number
    coins?: NullableIntFieldUpdateOperationsInput | number | null
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    site_lang?: NullableStringFieldUpdateOperationsInput | string | null
    profile_css?: StringFieldUpdateOperationsInput | string
    vote_reminders?: usersUpdatevote_remindersInput | bigint[] | number[]
    vote_reminder_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    staff_verify_code?: NullableStringFieldUpdateOperationsInput | string | null
    vote_reminders_last_acked?: DateTimeFieldUpdateOperationsInput | Date | string
    vote_reminders_servers?: usersUpdatevote_reminders_serversInput | bigint[] | number[]
    vote_reminders_servers_last_acked?: DateTimeFieldUpdateOperationsInput | Date | string
    vote_reminder_servers_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    experiments?: usersUpdateexperimentsInput | number[]
    flags?: usersUpdateflagsInput | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    totp_shared_key?: NullableStringFieldUpdateOperationsInput | string | null
    staff_password?: NullableStringFieldUpdateOperationsInput | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
    bot_voters?: bot_votersUncheckedUpdateManyWithoutUsersNestedInput
    extra_data?: extra_dataUncheckedUpdateManyWithoutUsersNestedInput
    leave_of_absence?: leave_of_absenceUncheckedUpdateManyWithoutUsersNestedInput
    lynx_apps?: lynx_appsUncheckedUpdateManyWithoutUsersNestedInput
    lynx_logs?: lynx_logsUncheckedUpdateManyWithoutUsersNestedInput
    lynx_ratings?: lynx_ratingsUncheckedUpdateManyWithoutUsersNestedInput
    lynx_survey_responses?: lynx_survey_responsesUncheckedUpdateManyWithoutUsersNestedInput
    push_notifications?: push_notificationsUncheckedUpdateManyWithoutUsersNestedInput
    review_votes?: review_votesUncheckedUpdateManyWithoutUsersNestedInput
    reviews?: reviewsUncheckedUpdateManyWithoutUsersNestedInput
    server_audit_logs?: server_audit_logsUncheckedUpdateManyWithoutUsersNestedInput
    server_voters?: server_votersUncheckedUpdateManyWithoutUsersNestedInput
    servers?: serversUncheckedUpdateManyWithoutUsersNestedInput
    user_bot_logs?: user_bot_logsUncheckedUpdateManyWithoutUsersNestedInput
    user_connections?: user_connectionsUncheckedUpdateManyWithoutUsersNestedInput
    user_server_vote_table?: user_server_vote_tableUncheckedUpdateOneWithoutUsersNestedInput
    user_vote_table?: user_vote_tableUncheckedUpdateOneWithoutUsersNestedInput
  }

  export type usersCreateWithoutLeave_of_absenceInput = {
    user_id: bigint | number
    api_token: string
    description?: string | null
    badges?: usersCreatebadgesInput | string[]
    username?: string | null
    user_css?: string | null
    state?: number
    coins?: number | null
    id: bigint | number
    site_lang?: string | null
    profile_css?: string
    vote_reminders?: usersCreatevote_remindersInput | bigint[] | number[]
    vote_reminder_channel?: bigint | number | null
    staff_verify_code?: string | null
    vote_reminders_last_acked?: Date | string
    vote_reminders_servers?: usersCreatevote_reminders_serversInput | bigint[] | number[]
    vote_reminders_servers_last_acked?: Date | string
    vote_reminder_servers_channel?: bigint | number | null
    experiments?: usersCreateexperimentsInput | number[]
    flags?: usersCreateflagsInput | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    supabase_id?: string | null
    totp_shared_key?: string | null
    staff_password?: string | null
    lynxtag?: string
    bot_voters?: bot_votersCreateNestedManyWithoutUsersInput
    extra_data?: extra_dataCreateNestedManyWithoutUsersInput
    frostpaw_clients?: frostpaw_clientsCreateNestedManyWithoutUsersInput
    lynx_apps?: lynx_appsCreateNestedManyWithoutUsersInput
    lynx_logs?: lynx_logsCreateNestedManyWithoutUsersInput
    lynx_ratings?: lynx_ratingsCreateNestedManyWithoutUsersInput
    lynx_survey_responses?: lynx_survey_responsesCreateNestedManyWithoutUsersInput
    push_notifications?: push_notificationsCreateNestedManyWithoutUsersInput
    review_votes?: review_votesCreateNestedManyWithoutUsersInput
    reviews?: reviewsCreateNestedManyWithoutUsersInput
    server_audit_logs?: server_audit_logsCreateNestedManyWithoutUsersInput
    server_voters?: server_votersCreateNestedManyWithoutUsersInput
    servers?: serversCreateNestedManyWithoutUsersInput
    user_bot_logs?: user_bot_logsCreateNestedManyWithoutUsersInput
    user_connections?: user_connectionsCreateNestedManyWithoutUsersInput
    user_server_vote_table?: user_server_vote_tableCreateNestedOneWithoutUsersInput
    user_vote_table?: user_vote_tableCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutLeave_of_absenceInput = {
    user_id: bigint | number
    api_token: string
    description?: string | null
    badges?: usersCreatebadgesInput | string[]
    username?: string | null
    user_css?: string | null
    state?: number
    coins?: number | null
    id: bigint | number
    site_lang?: string | null
    profile_css?: string
    vote_reminders?: usersCreatevote_remindersInput | bigint[] | number[]
    vote_reminder_channel?: bigint | number | null
    staff_verify_code?: string | null
    vote_reminders_last_acked?: Date | string
    vote_reminders_servers?: usersCreatevote_reminders_serversInput | bigint[] | number[]
    vote_reminders_servers_last_acked?: Date | string
    vote_reminder_servers_channel?: bigint | number | null
    experiments?: usersCreateexperimentsInput | number[]
    flags?: usersCreateflagsInput | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    supabase_id?: string | null
    totp_shared_key?: string | null
    staff_password?: string | null
    lynxtag?: string
    bot_voters?: bot_votersUncheckedCreateNestedManyWithoutUsersInput
    extra_data?: extra_dataUncheckedCreateNestedManyWithoutUsersInput
    frostpaw_clients?: frostpaw_clientsUncheckedCreateNestedManyWithoutUsersInput
    lynx_apps?: lynx_appsUncheckedCreateNestedManyWithoutUsersInput
    lynx_logs?: lynx_logsUncheckedCreateNestedManyWithoutUsersInput
    lynx_ratings?: lynx_ratingsUncheckedCreateNestedManyWithoutUsersInput
    lynx_survey_responses?: lynx_survey_responsesUncheckedCreateNestedManyWithoutUsersInput
    push_notifications?: push_notificationsUncheckedCreateNestedManyWithoutUsersInput
    review_votes?: review_votesUncheckedCreateNestedManyWithoutUsersInput
    reviews?: reviewsUncheckedCreateNestedManyWithoutUsersInput
    server_audit_logs?: server_audit_logsUncheckedCreateNestedManyWithoutUsersInput
    server_voters?: server_votersUncheckedCreateNestedManyWithoutUsersInput
    servers?: serversUncheckedCreateNestedManyWithoutUsersInput
    user_bot_logs?: user_bot_logsUncheckedCreateNestedManyWithoutUsersInput
    user_connections?: user_connectionsUncheckedCreateNestedManyWithoutUsersInput
    user_server_vote_table?: user_server_vote_tableUncheckedCreateNestedOneWithoutUsersInput
    user_vote_table?: user_vote_tableUncheckedCreateNestedOneWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutLeave_of_absenceInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutLeave_of_absenceInput, usersUncheckedCreateWithoutLeave_of_absenceInput>
  }

  export type usersUpsertWithoutLeave_of_absenceInput = {
    update: XOR<usersUpdateWithoutLeave_of_absenceInput, usersUncheckedUpdateWithoutLeave_of_absenceInput>
    create: XOR<usersCreateWithoutLeave_of_absenceInput, usersUncheckedCreateWithoutLeave_of_absenceInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutLeave_of_absenceInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutLeave_of_absenceInput, usersUncheckedUpdateWithoutLeave_of_absenceInput>
  }

  export type usersUpdateWithoutLeave_of_absenceInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    api_token?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    badges?: usersUpdatebadgesInput | string[]
    username?: NullableStringFieldUpdateOperationsInput | string | null
    user_css?: NullableStringFieldUpdateOperationsInput | string | null
    state?: IntFieldUpdateOperationsInput | number
    coins?: NullableIntFieldUpdateOperationsInput | number | null
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    site_lang?: NullableStringFieldUpdateOperationsInput | string | null
    profile_css?: StringFieldUpdateOperationsInput | string
    vote_reminders?: usersUpdatevote_remindersInput | bigint[] | number[]
    vote_reminder_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    staff_verify_code?: NullableStringFieldUpdateOperationsInput | string | null
    vote_reminders_last_acked?: DateTimeFieldUpdateOperationsInput | Date | string
    vote_reminders_servers?: usersUpdatevote_reminders_serversInput | bigint[] | number[]
    vote_reminders_servers_last_acked?: DateTimeFieldUpdateOperationsInput | Date | string
    vote_reminder_servers_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    experiments?: usersUpdateexperimentsInput | number[]
    flags?: usersUpdateflagsInput | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    totp_shared_key?: NullableStringFieldUpdateOperationsInput | string | null
    staff_password?: NullableStringFieldUpdateOperationsInput | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
    bot_voters?: bot_votersUpdateManyWithoutUsersNestedInput
    extra_data?: extra_dataUpdateManyWithoutUsersNestedInput
    frostpaw_clients?: frostpaw_clientsUpdateManyWithoutUsersNestedInput
    lynx_apps?: lynx_appsUpdateManyWithoutUsersNestedInput
    lynx_logs?: lynx_logsUpdateManyWithoutUsersNestedInput
    lynx_ratings?: lynx_ratingsUpdateManyWithoutUsersNestedInput
    lynx_survey_responses?: lynx_survey_responsesUpdateManyWithoutUsersNestedInput
    push_notifications?: push_notificationsUpdateManyWithoutUsersNestedInput
    review_votes?: review_votesUpdateManyWithoutUsersNestedInput
    reviews?: reviewsUpdateManyWithoutUsersNestedInput
    server_audit_logs?: server_audit_logsUpdateManyWithoutUsersNestedInput
    server_voters?: server_votersUpdateManyWithoutUsersNestedInput
    servers?: serversUpdateManyWithoutUsersNestedInput
    user_bot_logs?: user_bot_logsUpdateManyWithoutUsersNestedInput
    user_connections?: user_connectionsUpdateManyWithoutUsersNestedInput
    user_server_vote_table?: user_server_vote_tableUpdateOneWithoutUsersNestedInput
    user_vote_table?: user_vote_tableUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutLeave_of_absenceInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    api_token?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    badges?: usersUpdatebadgesInput | string[]
    username?: NullableStringFieldUpdateOperationsInput | string | null
    user_css?: NullableStringFieldUpdateOperationsInput | string | null
    state?: IntFieldUpdateOperationsInput | number
    coins?: NullableIntFieldUpdateOperationsInput | number | null
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    site_lang?: NullableStringFieldUpdateOperationsInput | string | null
    profile_css?: StringFieldUpdateOperationsInput | string
    vote_reminders?: usersUpdatevote_remindersInput | bigint[] | number[]
    vote_reminder_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    staff_verify_code?: NullableStringFieldUpdateOperationsInput | string | null
    vote_reminders_last_acked?: DateTimeFieldUpdateOperationsInput | Date | string
    vote_reminders_servers?: usersUpdatevote_reminders_serversInput | bigint[] | number[]
    vote_reminders_servers_last_acked?: DateTimeFieldUpdateOperationsInput | Date | string
    vote_reminder_servers_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    experiments?: usersUpdateexperimentsInput | number[]
    flags?: usersUpdateflagsInput | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    totp_shared_key?: NullableStringFieldUpdateOperationsInput | string | null
    staff_password?: NullableStringFieldUpdateOperationsInput | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
    bot_voters?: bot_votersUncheckedUpdateManyWithoutUsersNestedInput
    extra_data?: extra_dataUncheckedUpdateManyWithoutUsersNestedInput
    frostpaw_clients?: frostpaw_clientsUncheckedUpdateManyWithoutUsersNestedInput
    lynx_apps?: lynx_appsUncheckedUpdateManyWithoutUsersNestedInput
    lynx_logs?: lynx_logsUncheckedUpdateManyWithoutUsersNestedInput
    lynx_ratings?: lynx_ratingsUncheckedUpdateManyWithoutUsersNestedInput
    lynx_survey_responses?: lynx_survey_responsesUncheckedUpdateManyWithoutUsersNestedInput
    push_notifications?: push_notificationsUncheckedUpdateManyWithoutUsersNestedInput
    review_votes?: review_votesUncheckedUpdateManyWithoutUsersNestedInput
    reviews?: reviewsUncheckedUpdateManyWithoutUsersNestedInput
    server_audit_logs?: server_audit_logsUncheckedUpdateManyWithoutUsersNestedInput
    server_voters?: server_votersUncheckedUpdateManyWithoutUsersNestedInput
    servers?: serversUncheckedUpdateManyWithoutUsersNestedInput
    user_bot_logs?: user_bot_logsUncheckedUpdateManyWithoutUsersNestedInput
    user_connections?: user_connectionsUncheckedUpdateManyWithoutUsersNestedInput
    user_server_vote_table?: user_server_vote_tableUncheckedUpdateOneWithoutUsersNestedInput
    user_vote_table?: user_vote_tableUncheckedUpdateOneWithoutUsersNestedInput
  }

  export type usersCreateWithoutLynx_appsInput = {
    user_id: bigint | number
    api_token: string
    description?: string | null
    badges?: usersCreatebadgesInput | string[]
    username?: string | null
    user_css?: string | null
    state?: number
    coins?: number | null
    id: bigint | number
    site_lang?: string | null
    profile_css?: string
    vote_reminders?: usersCreatevote_remindersInput | bigint[] | number[]
    vote_reminder_channel?: bigint | number | null
    staff_verify_code?: string | null
    vote_reminders_last_acked?: Date | string
    vote_reminders_servers?: usersCreatevote_reminders_serversInput | bigint[] | number[]
    vote_reminders_servers_last_acked?: Date | string
    vote_reminder_servers_channel?: bigint | number | null
    experiments?: usersCreateexperimentsInput | number[]
    flags?: usersCreateflagsInput | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    supabase_id?: string | null
    totp_shared_key?: string | null
    staff_password?: string | null
    lynxtag?: string
    bot_voters?: bot_votersCreateNestedManyWithoutUsersInput
    extra_data?: extra_dataCreateNestedManyWithoutUsersInput
    frostpaw_clients?: frostpaw_clientsCreateNestedManyWithoutUsersInput
    leave_of_absence?: leave_of_absenceCreateNestedManyWithoutUsersInput
    lynx_logs?: lynx_logsCreateNestedManyWithoutUsersInput
    lynx_ratings?: lynx_ratingsCreateNestedManyWithoutUsersInput
    lynx_survey_responses?: lynx_survey_responsesCreateNestedManyWithoutUsersInput
    push_notifications?: push_notificationsCreateNestedManyWithoutUsersInput
    review_votes?: review_votesCreateNestedManyWithoutUsersInput
    reviews?: reviewsCreateNestedManyWithoutUsersInput
    server_audit_logs?: server_audit_logsCreateNestedManyWithoutUsersInput
    server_voters?: server_votersCreateNestedManyWithoutUsersInput
    servers?: serversCreateNestedManyWithoutUsersInput
    user_bot_logs?: user_bot_logsCreateNestedManyWithoutUsersInput
    user_connections?: user_connectionsCreateNestedManyWithoutUsersInput
    user_server_vote_table?: user_server_vote_tableCreateNestedOneWithoutUsersInput
    user_vote_table?: user_vote_tableCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutLynx_appsInput = {
    user_id: bigint | number
    api_token: string
    description?: string | null
    badges?: usersCreatebadgesInput | string[]
    username?: string | null
    user_css?: string | null
    state?: number
    coins?: number | null
    id: bigint | number
    site_lang?: string | null
    profile_css?: string
    vote_reminders?: usersCreatevote_remindersInput | bigint[] | number[]
    vote_reminder_channel?: bigint | number | null
    staff_verify_code?: string | null
    vote_reminders_last_acked?: Date | string
    vote_reminders_servers?: usersCreatevote_reminders_serversInput | bigint[] | number[]
    vote_reminders_servers_last_acked?: Date | string
    vote_reminder_servers_channel?: bigint | number | null
    experiments?: usersCreateexperimentsInput | number[]
    flags?: usersCreateflagsInput | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    supabase_id?: string | null
    totp_shared_key?: string | null
    staff_password?: string | null
    lynxtag?: string
    bot_voters?: bot_votersUncheckedCreateNestedManyWithoutUsersInput
    extra_data?: extra_dataUncheckedCreateNestedManyWithoutUsersInput
    frostpaw_clients?: frostpaw_clientsUncheckedCreateNestedManyWithoutUsersInput
    leave_of_absence?: leave_of_absenceUncheckedCreateNestedManyWithoutUsersInput
    lynx_logs?: lynx_logsUncheckedCreateNestedManyWithoutUsersInput
    lynx_ratings?: lynx_ratingsUncheckedCreateNestedManyWithoutUsersInput
    lynx_survey_responses?: lynx_survey_responsesUncheckedCreateNestedManyWithoutUsersInput
    push_notifications?: push_notificationsUncheckedCreateNestedManyWithoutUsersInput
    review_votes?: review_votesUncheckedCreateNestedManyWithoutUsersInput
    reviews?: reviewsUncheckedCreateNestedManyWithoutUsersInput
    server_audit_logs?: server_audit_logsUncheckedCreateNestedManyWithoutUsersInput
    server_voters?: server_votersUncheckedCreateNestedManyWithoutUsersInput
    servers?: serversUncheckedCreateNestedManyWithoutUsersInput
    user_bot_logs?: user_bot_logsUncheckedCreateNestedManyWithoutUsersInput
    user_connections?: user_connectionsUncheckedCreateNestedManyWithoutUsersInput
    user_server_vote_table?: user_server_vote_tableUncheckedCreateNestedOneWithoutUsersInput
    user_vote_table?: user_vote_tableUncheckedCreateNestedOneWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutLynx_appsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutLynx_appsInput, usersUncheckedCreateWithoutLynx_appsInput>
  }

  export type usersUpsertWithoutLynx_appsInput = {
    update: XOR<usersUpdateWithoutLynx_appsInput, usersUncheckedUpdateWithoutLynx_appsInput>
    create: XOR<usersCreateWithoutLynx_appsInput, usersUncheckedCreateWithoutLynx_appsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutLynx_appsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutLynx_appsInput, usersUncheckedUpdateWithoutLynx_appsInput>
  }

  export type usersUpdateWithoutLynx_appsInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    api_token?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    badges?: usersUpdatebadgesInput | string[]
    username?: NullableStringFieldUpdateOperationsInput | string | null
    user_css?: NullableStringFieldUpdateOperationsInput | string | null
    state?: IntFieldUpdateOperationsInput | number
    coins?: NullableIntFieldUpdateOperationsInput | number | null
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    site_lang?: NullableStringFieldUpdateOperationsInput | string | null
    profile_css?: StringFieldUpdateOperationsInput | string
    vote_reminders?: usersUpdatevote_remindersInput | bigint[] | number[]
    vote_reminder_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    staff_verify_code?: NullableStringFieldUpdateOperationsInput | string | null
    vote_reminders_last_acked?: DateTimeFieldUpdateOperationsInput | Date | string
    vote_reminders_servers?: usersUpdatevote_reminders_serversInput | bigint[] | number[]
    vote_reminders_servers_last_acked?: DateTimeFieldUpdateOperationsInput | Date | string
    vote_reminder_servers_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    experiments?: usersUpdateexperimentsInput | number[]
    flags?: usersUpdateflagsInput | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    totp_shared_key?: NullableStringFieldUpdateOperationsInput | string | null
    staff_password?: NullableStringFieldUpdateOperationsInput | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
    bot_voters?: bot_votersUpdateManyWithoutUsersNestedInput
    extra_data?: extra_dataUpdateManyWithoutUsersNestedInput
    frostpaw_clients?: frostpaw_clientsUpdateManyWithoutUsersNestedInput
    leave_of_absence?: leave_of_absenceUpdateManyWithoutUsersNestedInput
    lynx_logs?: lynx_logsUpdateManyWithoutUsersNestedInput
    lynx_ratings?: lynx_ratingsUpdateManyWithoutUsersNestedInput
    lynx_survey_responses?: lynx_survey_responsesUpdateManyWithoutUsersNestedInput
    push_notifications?: push_notificationsUpdateManyWithoutUsersNestedInput
    review_votes?: review_votesUpdateManyWithoutUsersNestedInput
    reviews?: reviewsUpdateManyWithoutUsersNestedInput
    server_audit_logs?: server_audit_logsUpdateManyWithoutUsersNestedInput
    server_voters?: server_votersUpdateManyWithoutUsersNestedInput
    servers?: serversUpdateManyWithoutUsersNestedInput
    user_bot_logs?: user_bot_logsUpdateManyWithoutUsersNestedInput
    user_connections?: user_connectionsUpdateManyWithoutUsersNestedInput
    user_server_vote_table?: user_server_vote_tableUpdateOneWithoutUsersNestedInput
    user_vote_table?: user_vote_tableUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutLynx_appsInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    api_token?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    badges?: usersUpdatebadgesInput | string[]
    username?: NullableStringFieldUpdateOperationsInput | string | null
    user_css?: NullableStringFieldUpdateOperationsInput | string | null
    state?: IntFieldUpdateOperationsInput | number
    coins?: NullableIntFieldUpdateOperationsInput | number | null
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    site_lang?: NullableStringFieldUpdateOperationsInput | string | null
    profile_css?: StringFieldUpdateOperationsInput | string
    vote_reminders?: usersUpdatevote_remindersInput | bigint[] | number[]
    vote_reminder_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    staff_verify_code?: NullableStringFieldUpdateOperationsInput | string | null
    vote_reminders_last_acked?: DateTimeFieldUpdateOperationsInput | Date | string
    vote_reminders_servers?: usersUpdatevote_reminders_serversInput | bigint[] | number[]
    vote_reminders_servers_last_acked?: DateTimeFieldUpdateOperationsInput | Date | string
    vote_reminder_servers_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    experiments?: usersUpdateexperimentsInput | number[]
    flags?: usersUpdateflagsInput | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    totp_shared_key?: NullableStringFieldUpdateOperationsInput | string | null
    staff_password?: NullableStringFieldUpdateOperationsInput | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
    bot_voters?: bot_votersUncheckedUpdateManyWithoutUsersNestedInput
    extra_data?: extra_dataUncheckedUpdateManyWithoutUsersNestedInput
    frostpaw_clients?: frostpaw_clientsUncheckedUpdateManyWithoutUsersNestedInput
    leave_of_absence?: leave_of_absenceUncheckedUpdateManyWithoutUsersNestedInput
    lynx_logs?: lynx_logsUncheckedUpdateManyWithoutUsersNestedInput
    lynx_ratings?: lynx_ratingsUncheckedUpdateManyWithoutUsersNestedInput
    lynx_survey_responses?: lynx_survey_responsesUncheckedUpdateManyWithoutUsersNestedInput
    push_notifications?: push_notificationsUncheckedUpdateManyWithoutUsersNestedInput
    review_votes?: review_votesUncheckedUpdateManyWithoutUsersNestedInput
    reviews?: reviewsUncheckedUpdateManyWithoutUsersNestedInput
    server_audit_logs?: server_audit_logsUncheckedUpdateManyWithoutUsersNestedInput
    server_voters?: server_votersUncheckedUpdateManyWithoutUsersNestedInput
    servers?: serversUncheckedUpdateManyWithoutUsersNestedInput
    user_bot_logs?: user_bot_logsUncheckedUpdateManyWithoutUsersNestedInput
    user_connections?: user_connectionsUncheckedUpdateManyWithoutUsersNestedInput
    user_server_vote_table?: user_server_vote_tableUncheckedUpdateOneWithoutUsersNestedInput
    user_vote_table?: user_vote_tableUncheckedUpdateOneWithoutUsersNestedInput
  }

  export type usersCreateWithoutLynx_logsInput = {
    user_id: bigint | number
    api_token: string
    description?: string | null
    badges?: usersCreatebadgesInput | string[]
    username?: string | null
    user_css?: string | null
    state?: number
    coins?: number | null
    id: bigint | number
    site_lang?: string | null
    profile_css?: string
    vote_reminders?: usersCreatevote_remindersInput | bigint[] | number[]
    vote_reminder_channel?: bigint | number | null
    staff_verify_code?: string | null
    vote_reminders_last_acked?: Date | string
    vote_reminders_servers?: usersCreatevote_reminders_serversInput | bigint[] | number[]
    vote_reminders_servers_last_acked?: Date | string
    vote_reminder_servers_channel?: bigint | number | null
    experiments?: usersCreateexperimentsInput | number[]
    flags?: usersCreateflagsInput | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    supabase_id?: string | null
    totp_shared_key?: string | null
    staff_password?: string | null
    lynxtag?: string
    bot_voters?: bot_votersCreateNestedManyWithoutUsersInput
    extra_data?: extra_dataCreateNestedManyWithoutUsersInput
    frostpaw_clients?: frostpaw_clientsCreateNestedManyWithoutUsersInput
    leave_of_absence?: leave_of_absenceCreateNestedManyWithoutUsersInput
    lynx_apps?: lynx_appsCreateNestedManyWithoutUsersInput
    lynx_ratings?: lynx_ratingsCreateNestedManyWithoutUsersInput
    lynx_survey_responses?: lynx_survey_responsesCreateNestedManyWithoutUsersInput
    push_notifications?: push_notificationsCreateNestedManyWithoutUsersInput
    review_votes?: review_votesCreateNestedManyWithoutUsersInput
    reviews?: reviewsCreateNestedManyWithoutUsersInput
    server_audit_logs?: server_audit_logsCreateNestedManyWithoutUsersInput
    server_voters?: server_votersCreateNestedManyWithoutUsersInput
    servers?: serversCreateNestedManyWithoutUsersInput
    user_bot_logs?: user_bot_logsCreateNestedManyWithoutUsersInput
    user_connections?: user_connectionsCreateNestedManyWithoutUsersInput
    user_server_vote_table?: user_server_vote_tableCreateNestedOneWithoutUsersInput
    user_vote_table?: user_vote_tableCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutLynx_logsInput = {
    user_id: bigint | number
    api_token: string
    description?: string | null
    badges?: usersCreatebadgesInput | string[]
    username?: string | null
    user_css?: string | null
    state?: number
    coins?: number | null
    id: bigint | number
    site_lang?: string | null
    profile_css?: string
    vote_reminders?: usersCreatevote_remindersInput | bigint[] | number[]
    vote_reminder_channel?: bigint | number | null
    staff_verify_code?: string | null
    vote_reminders_last_acked?: Date | string
    vote_reminders_servers?: usersCreatevote_reminders_serversInput | bigint[] | number[]
    vote_reminders_servers_last_acked?: Date | string
    vote_reminder_servers_channel?: bigint | number | null
    experiments?: usersCreateexperimentsInput | number[]
    flags?: usersCreateflagsInput | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    supabase_id?: string | null
    totp_shared_key?: string | null
    staff_password?: string | null
    lynxtag?: string
    bot_voters?: bot_votersUncheckedCreateNestedManyWithoutUsersInput
    extra_data?: extra_dataUncheckedCreateNestedManyWithoutUsersInput
    frostpaw_clients?: frostpaw_clientsUncheckedCreateNestedManyWithoutUsersInput
    leave_of_absence?: leave_of_absenceUncheckedCreateNestedManyWithoutUsersInput
    lynx_apps?: lynx_appsUncheckedCreateNestedManyWithoutUsersInput
    lynx_ratings?: lynx_ratingsUncheckedCreateNestedManyWithoutUsersInput
    lynx_survey_responses?: lynx_survey_responsesUncheckedCreateNestedManyWithoutUsersInput
    push_notifications?: push_notificationsUncheckedCreateNestedManyWithoutUsersInput
    review_votes?: review_votesUncheckedCreateNestedManyWithoutUsersInput
    reviews?: reviewsUncheckedCreateNestedManyWithoutUsersInput
    server_audit_logs?: server_audit_logsUncheckedCreateNestedManyWithoutUsersInput
    server_voters?: server_votersUncheckedCreateNestedManyWithoutUsersInput
    servers?: serversUncheckedCreateNestedManyWithoutUsersInput
    user_bot_logs?: user_bot_logsUncheckedCreateNestedManyWithoutUsersInput
    user_connections?: user_connectionsUncheckedCreateNestedManyWithoutUsersInput
    user_server_vote_table?: user_server_vote_tableUncheckedCreateNestedOneWithoutUsersInput
    user_vote_table?: user_vote_tableUncheckedCreateNestedOneWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutLynx_logsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutLynx_logsInput, usersUncheckedCreateWithoutLynx_logsInput>
  }

  export type usersUpsertWithoutLynx_logsInput = {
    update: XOR<usersUpdateWithoutLynx_logsInput, usersUncheckedUpdateWithoutLynx_logsInput>
    create: XOR<usersCreateWithoutLynx_logsInput, usersUncheckedCreateWithoutLynx_logsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutLynx_logsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutLynx_logsInput, usersUncheckedUpdateWithoutLynx_logsInput>
  }

  export type usersUpdateWithoutLynx_logsInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    api_token?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    badges?: usersUpdatebadgesInput | string[]
    username?: NullableStringFieldUpdateOperationsInput | string | null
    user_css?: NullableStringFieldUpdateOperationsInput | string | null
    state?: IntFieldUpdateOperationsInput | number
    coins?: NullableIntFieldUpdateOperationsInput | number | null
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    site_lang?: NullableStringFieldUpdateOperationsInput | string | null
    profile_css?: StringFieldUpdateOperationsInput | string
    vote_reminders?: usersUpdatevote_remindersInput | bigint[] | number[]
    vote_reminder_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    staff_verify_code?: NullableStringFieldUpdateOperationsInput | string | null
    vote_reminders_last_acked?: DateTimeFieldUpdateOperationsInput | Date | string
    vote_reminders_servers?: usersUpdatevote_reminders_serversInput | bigint[] | number[]
    vote_reminders_servers_last_acked?: DateTimeFieldUpdateOperationsInput | Date | string
    vote_reminder_servers_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    experiments?: usersUpdateexperimentsInput | number[]
    flags?: usersUpdateflagsInput | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    totp_shared_key?: NullableStringFieldUpdateOperationsInput | string | null
    staff_password?: NullableStringFieldUpdateOperationsInput | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
    bot_voters?: bot_votersUpdateManyWithoutUsersNestedInput
    extra_data?: extra_dataUpdateManyWithoutUsersNestedInput
    frostpaw_clients?: frostpaw_clientsUpdateManyWithoutUsersNestedInput
    leave_of_absence?: leave_of_absenceUpdateManyWithoutUsersNestedInput
    lynx_apps?: lynx_appsUpdateManyWithoutUsersNestedInput
    lynx_ratings?: lynx_ratingsUpdateManyWithoutUsersNestedInput
    lynx_survey_responses?: lynx_survey_responsesUpdateManyWithoutUsersNestedInput
    push_notifications?: push_notificationsUpdateManyWithoutUsersNestedInput
    review_votes?: review_votesUpdateManyWithoutUsersNestedInput
    reviews?: reviewsUpdateManyWithoutUsersNestedInput
    server_audit_logs?: server_audit_logsUpdateManyWithoutUsersNestedInput
    server_voters?: server_votersUpdateManyWithoutUsersNestedInput
    servers?: serversUpdateManyWithoutUsersNestedInput
    user_bot_logs?: user_bot_logsUpdateManyWithoutUsersNestedInput
    user_connections?: user_connectionsUpdateManyWithoutUsersNestedInput
    user_server_vote_table?: user_server_vote_tableUpdateOneWithoutUsersNestedInput
    user_vote_table?: user_vote_tableUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutLynx_logsInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    api_token?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    badges?: usersUpdatebadgesInput | string[]
    username?: NullableStringFieldUpdateOperationsInput | string | null
    user_css?: NullableStringFieldUpdateOperationsInput | string | null
    state?: IntFieldUpdateOperationsInput | number
    coins?: NullableIntFieldUpdateOperationsInput | number | null
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    site_lang?: NullableStringFieldUpdateOperationsInput | string | null
    profile_css?: StringFieldUpdateOperationsInput | string
    vote_reminders?: usersUpdatevote_remindersInput | bigint[] | number[]
    vote_reminder_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    staff_verify_code?: NullableStringFieldUpdateOperationsInput | string | null
    vote_reminders_last_acked?: DateTimeFieldUpdateOperationsInput | Date | string
    vote_reminders_servers?: usersUpdatevote_reminders_serversInput | bigint[] | number[]
    vote_reminders_servers_last_acked?: DateTimeFieldUpdateOperationsInput | Date | string
    vote_reminder_servers_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    experiments?: usersUpdateexperimentsInput | number[]
    flags?: usersUpdateflagsInput | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    totp_shared_key?: NullableStringFieldUpdateOperationsInput | string | null
    staff_password?: NullableStringFieldUpdateOperationsInput | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
    bot_voters?: bot_votersUncheckedUpdateManyWithoutUsersNestedInput
    extra_data?: extra_dataUncheckedUpdateManyWithoutUsersNestedInput
    frostpaw_clients?: frostpaw_clientsUncheckedUpdateManyWithoutUsersNestedInput
    leave_of_absence?: leave_of_absenceUncheckedUpdateManyWithoutUsersNestedInput
    lynx_apps?: lynx_appsUncheckedUpdateManyWithoutUsersNestedInput
    lynx_ratings?: lynx_ratingsUncheckedUpdateManyWithoutUsersNestedInput
    lynx_survey_responses?: lynx_survey_responsesUncheckedUpdateManyWithoutUsersNestedInput
    push_notifications?: push_notificationsUncheckedUpdateManyWithoutUsersNestedInput
    review_votes?: review_votesUncheckedUpdateManyWithoutUsersNestedInput
    reviews?: reviewsUncheckedUpdateManyWithoutUsersNestedInput
    server_audit_logs?: server_audit_logsUncheckedUpdateManyWithoutUsersNestedInput
    server_voters?: server_votersUncheckedUpdateManyWithoutUsersNestedInput
    servers?: serversUncheckedUpdateManyWithoutUsersNestedInput
    user_bot_logs?: user_bot_logsUncheckedUpdateManyWithoutUsersNestedInput
    user_connections?: user_connectionsUncheckedUpdateManyWithoutUsersNestedInput
    user_server_vote_table?: user_server_vote_tableUncheckedUpdateOneWithoutUsersNestedInput
    user_vote_table?: user_vote_tableUncheckedUpdateOneWithoutUsersNestedInput
  }

  export type usersCreateWithoutLynx_ratingsInput = {
    user_id: bigint | number
    api_token: string
    description?: string | null
    badges?: usersCreatebadgesInput | string[]
    username?: string | null
    user_css?: string | null
    state?: number
    coins?: number | null
    id: bigint | number
    site_lang?: string | null
    profile_css?: string
    vote_reminders?: usersCreatevote_remindersInput | bigint[] | number[]
    vote_reminder_channel?: bigint | number | null
    staff_verify_code?: string | null
    vote_reminders_last_acked?: Date | string
    vote_reminders_servers?: usersCreatevote_reminders_serversInput | bigint[] | number[]
    vote_reminders_servers_last_acked?: Date | string
    vote_reminder_servers_channel?: bigint | number | null
    experiments?: usersCreateexperimentsInput | number[]
    flags?: usersCreateflagsInput | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    supabase_id?: string | null
    totp_shared_key?: string | null
    staff_password?: string | null
    lynxtag?: string
    bot_voters?: bot_votersCreateNestedManyWithoutUsersInput
    extra_data?: extra_dataCreateNestedManyWithoutUsersInput
    frostpaw_clients?: frostpaw_clientsCreateNestedManyWithoutUsersInput
    leave_of_absence?: leave_of_absenceCreateNestedManyWithoutUsersInput
    lynx_apps?: lynx_appsCreateNestedManyWithoutUsersInput
    lynx_logs?: lynx_logsCreateNestedManyWithoutUsersInput
    lynx_survey_responses?: lynx_survey_responsesCreateNestedManyWithoutUsersInput
    push_notifications?: push_notificationsCreateNestedManyWithoutUsersInput
    review_votes?: review_votesCreateNestedManyWithoutUsersInput
    reviews?: reviewsCreateNestedManyWithoutUsersInput
    server_audit_logs?: server_audit_logsCreateNestedManyWithoutUsersInput
    server_voters?: server_votersCreateNestedManyWithoutUsersInput
    servers?: serversCreateNestedManyWithoutUsersInput
    user_bot_logs?: user_bot_logsCreateNestedManyWithoutUsersInput
    user_connections?: user_connectionsCreateNestedManyWithoutUsersInput
    user_server_vote_table?: user_server_vote_tableCreateNestedOneWithoutUsersInput
    user_vote_table?: user_vote_tableCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutLynx_ratingsInput = {
    user_id: bigint | number
    api_token: string
    description?: string | null
    badges?: usersCreatebadgesInput | string[]
    username?: string | null
    user_css?: string | null
    state?: number
    coins?: number | null
    id: bigint | number
    site_lang?: string | null
    profile_css?: string
    vote_reminders?: usersCreatevote_remindersInput | bigint[] | number[]
    vote_reminder_channel?: bigint | number | null
    staff_verify_code?: string | null
    vote_reminders_last_acked?: Date | string
    vote_reminders_servers?: usersCreatevote_reminders_serversInput | bigint[] | number[]
    vote_reminders_servers_last_acked?: Date | string
    vote_reminder_servers_channel?: bigint | number | null
    experiments?: usersCreateexperimentsInput | number[]
    flags?: usersCreateflagsInput | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    supabase_id?: string | null
    totp_shared_key?: string | null
    staff_password?: string | null
    lynxtag?: string
    bot_voters?: bot_votersUncheckedCreateNestedManyWithoutUsersInput
    extra_data?: extra_dataUncheckedCreateNestedManyWithoutUsersInput
    frostpaw_clients?: frostpaw_clientsUncheckedCreateNestedManyWithoutUsersInput
    leave_of_absence?: leave_of_absenceUncheckedCreateNestedManyWithoutUsersInput
    lynx_apps?: lynx_appsUncheckedCreateNestedManyWithoutUsersInput
    lynx_logs?: lynx_logsUncheckedCreateNestedManyWithoutUsersInput
    lynx_survey_responses?: lynx_survey_responsesUncheckedCreateNestedManyWithoutUsersInput
    push_notifications?: push_notificationsUncheckedCreateNestedManyWithoutUsersInput
    review_votes?: review_votesUncheckedCreateNestedManyWithoutUsersInput
    reviews?: reviewsUncheckedCreateNestedManyWithoutUsersInput
    server_audit_logs?: server_audit_logsUncheckedCreateNestedManyWithoutUsersInput
    server_voters?: server_votersUncheckedCreateNestedManyWithoutUsersInput
    servers?: serversUncheckedCreateNestedManyWithoutUsersInput
    user_bot_logs?: user_bot_logsUncheckedCreateNestedManyWithoutUsersInput
    user_connections?: user_connectionsUncheckedCreateNestedManyWithoutUsersInput
    user_server_vote_table?: user_server_vote_tableUncheckedCreateNestedOneWithoutUsersInput
    user_vote_table?: user_vote_tableUncheckedCreateNestedOneWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutLynx_ratingsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutLynx_ratingsInput, usersUncheckedCreateWithoutLynx_ratingsInput>
  }

  export type usersUpsertWithoutLynx_ratingsInput = {
    update: XOR<usersUpdateWithoutLynx_ratingsInput, usersUncheckedUpdateWithoutLynx_ratingsInput>
    create: XOR<usersCreateWithoutLynx_ratingsInput, usersUncheckedCreateWithoutLynx_ratingsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutLynx_ratingsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutLynx_ratingsInput, usersUncheckedUpdateWithoutLynx_ratingsInput>
  }

  export type usersUpdateWithoutLynx_ratingsInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    api_token?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    badges?: usersUpdatebadgesInput | string[]
    username?: NullableStringFieldUpdateOperationsInput | string | null
    user_css?: NullableStringFieldUpdateOperationsInput | string | null
    state?: IntFieldUpdateOperationsInput | number
    coins?: NullableIntFieldUpdateOperationsInput | number | null
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    site_lang?: NullableStringFieldUpdateOperationsInput | string | null
    profile_css?: StringFieldUpdateOperationsInput | string
    vote_reminders?: usersUpdatevote_remindersInput | bigint[] | number[]
    vote_reminder_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    staff_verify_code?: NullableStringFieldUpdateOperationsInput | string | null
    vote_reminders_last_acked?: DateTimeFieldUpdateOperationsInput | Date | string
    vote_reminders_servers?: usersUpdatevote_reminders_serversInput | bigint[] | number[]
    vote_reminders_servers_last_acked?: DateTimeFieldUpdateOperationsInput | Date | string
    vote_reminder_servers_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    experiments?: usersUpdateexperimentsInput | number[]
    flags?: usersUpdateflagsInput | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    totp_shared_key?: NullableStringFieldUpdateOperationsInput | string | null
    staff_password?: NullableStringFieldUpdateOperationsInput | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
    bot_voters?: bot_votersUpdateManyWithoutUsersNestedInput
    extra_data?: extra_dataUpdateManyWithoutUsersNestedInput
    frostpaw_clients?: frostpaw_clientsUpdateManyWithoutUsersNestedInput
    leave_of_absence?: leave_of_absenceUpdateManyWithoutUsersNestedInput
    lynx_apps?: lynx_appsUpdateManyWithoutUsersNestedInput
    lynx_logs?: lynx_logsUpdateManyWithoutUsersNestedInput
    lynx_survey_responses?: lynx_survey_responsesUpdateManyWithoutUsersNestedInput
    push_notifications?: push_notificationsUpdateManyWithoutUsersNestedInput
    review_votes?: review_votesUpdateManyWithoutUsersNestedInput
    reviews?: reviewsUpdateManyWithoutUsersNestedInput
    server_audit_logs?: server_audit_logsUpdateManyWithoutUsersNestedInput
    server_voters?: server_votersUpdateManyWithoutUsersNestedInput
    servers?: serversUpdateManyWithoutUsersNestedInput
    user_bot_logs?: user_bot_logsUpdateManyWithoutUsersNestedInput
    user_connections?: user_connectionsUpdateManyWithoutUsersNestedInput
    user_server_vote_table?: user_server_vote_tableUpdateOneWithoutUsersNestedInput
    user_vote_table?: user_vote_tableUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutLynx_ratingsInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    api_token?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    badges?: usersUpdatebadgesInput | string[]
    username?: NullableStringFieldUpdateOperationsInput | string | null
    user_css?: NullableStringFieldUpdateOperationsInput | string | null
    state?: IntFieldUpdateOperationsInput | number
    coins?: NullableIntFieldUpdateOperationsInput | number | null
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    site_lang?: NullableStringFieldUpdateOperationsInput | string | null
    profile_css?: StringFieldUpdateOperationsInput | string
    vote_reminders?: usersUpdatevote_remindersInput | bigint[] | number[]
    vote_reminder_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    staff_verify_code?: NullableStringFieldUpdateOperationsInput | string | null
    vote_reminders_last_acked?: DateTimeFieldUpdateOperationsInput | Date | string
    vote_reminders_servers?: usersUpdatevote_reminders_serversInput | bigint[] | number[]
    vote_reminders_servers_last_acked?: DateTimeFieldUpdateOperationsInput | Date | string
    vote_reminder_servers_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    experiments?: usersUpdateexperimentsInput | number[]
    flags?: usersUpdateflagsInput | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    totp_shared_key?: NullableStringFieldUpdateOperationsInput | string | null
    staff_password?: NullableStringFieldUpdateOperationsInput | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
    bot_voters?: bot_votersUncheckedUpdateManyWithoutUsersNestedInput
    extra_data?: extra_dataUncheckedUpdateManyWithoutUsersNestedInput
    frostpaw_clients?: frostpaw_clientsUncheckedUpdateManyWithoutUsersNestedInput
    leave_of_absence?: leave_of_absenceUncheckedUpdateManyWithoutUsersNestedInput
    lynx_apps?: lynx_appsUncheckedUpdateManyWithoutUsersNestedInput
    lynx_logs?: lynx_logsUncheckedUpdateManyWithoutUsersNestedInput
    lynx_survey_responses?: lynx_survey_responsesUncheckedUpdateManyWithoutUsersNestedInput
    push_notifications?: push_notificationsUncheckedUpdateManyWithoutUsersNestedInput
    review_votes?: review_votesUncheckedUpdateManyWithoutUsersNestedInput
    reviews?: reviewsUncheckedUpdateManyWithoutUsersNestedInput
    server_audit_logs?: server_audit_logsUncheckedUpdateManyWithoutUsersNestedInput
    server_voters?: server_votersUncheckedUpdateManyWithoutUsersNestedInput
    servers?: serversUncheckedUpdateManyWithoutUsersNestedInput
    user_bot_logs?: user_bot_logsUncheckedUpdateManyWithoutUsersNestedInput
    user_connections?: user_connectionsUncheckedUpdateManyWithoutUsersNestedInput
    user_server_vote_table?: user_server_vote_tableUncheckedUpdateOneWithoutUsersNestedInput
    user_vote_table?: user_vote_tableUncheckedUpdateOneWithoutUsersNestedInput
  }

  export type lynx_surveysCreateWithoutLynx_survey_responsesInput = {
    id?: string
    title: string
    questions: JsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    lynxtag?: string
  }

  export type lynx_surveysUncheckedCreateWithoutLynx_survey_responsesInput = {
    id?: string
    title: string
    questions: JsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    lynxtag?: string
  }

  export type lynx_surveysCreateOrConnectWithoutLynx_survey_responsesInput = {
    where: lynx_surveysWhereUniqueInput
    create: XOR<lynx_surveysCreateWithoutLynx_survey_responsesInput, lynx_surveysUncheckedCreateWithoutLynx_survey_responsesInput>
  }

  export type usersCreateWithoutLynx_survey_responsesInput = {
    user_id: bigint | number
    api_token: string
    description?: string | null
    badges?: usersCreatebadgesInput | string[]
    username?: string | null
    user_css?: string | null
    state?: number
    coins?: number | null
    id: bigint | number
    site_lang?: string | null
    profile_css?: string
    vote_reminders?: usersCreatevote_remindersInput | bigint[] | number[]
    vote_reminder_channel?: bigint | number | null
    staff_verify_code?: string | null
    vote_reminders_last_acked?: Date | string
    vote_reminders_servers?: usersCreatevote_reminders_serversInput | bigint[] | number[]
    vote_reminders_servers_last_acked?: Date | string
    vote_reminder_servers_channel?: bigint | number | null
    experiments?: usersCreateexperimentsInput | number[]
    flags?: usersCreateflagsInput | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    supabase_id?: string | null
    totp_shared_key?: string | null
    staff_password?: string | null
    lynxtag?: string
    bot_voters?: bot_votersCreateNestedManyWithoutUsersInput
    extra_data?: extra_dataCreateNestedManyWithoutUsersInput
    frostpaw_clients?: frostpaw_clientsCreateNestedManyWithoutUsersInput
    leave_of_absence?: leave_of_absenceCreateNestedManyWithoutUsersInput
    lynx_apps?: lynx_appsCreateNestedManyWithoutUsersInput
    lynx_logs?: lynx_logsCreateNestedManyWithoutUsersInput
    lynx_ratings?: lynx_ratingsCreateNestedManyWithoutUsersInput
    push_notifications?: push_notificationsCreateNestedManyWithoutUsersInput
    review_votes?: review_votesCreateNestedManyWithoutUsersInput
    reviews?: reviewsCreateNestedManyWithoutUsersInput
    server_audit_logs?: server_audit_logsCreateNestedManyWithoutUsersInput
    server_voters?: server_votersCreateNestedManyWithoutUsersInput
    servers?: serversCreateNestedManyWithoutUsersInput
    user_bot_logs?: user_bot_logsCreateNestedManyWithoutUsersInput
    user_connections?: user_connectionsCreateNestedManyWithoutUsersInput
    user_server_vote_table?: user_server_vote_tableCreateNestedOneWithoutUsersInput
    user_vote_table?: user_vote_tableCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutLynx_survey_responsesInput = {
    user_id: bigint | number
    api_token: string
    description?: string | null
    badges?: usersCreatebadgesInput | string[]
    username?: string | null
    user_css?: string | null
    state?: number
    coins?: number | null
    id: bigint | number
    site_lang?: string | null
    profile_css?: string
    vote_reminders?: usersCreatevote_remindersInput | bigint[] | number[]
    vote_reminder_channel?: bigint | number | null
    staff_verify_code?: string | null
    vote_reminders_last_acked?: Date | string
    vote_reminders_servers?: usersCreatevote_reminders_serversInput | bigint[] | number[]
    vote_reminders_servers_last_acked?: Date | string
    vote_reminder_servers_channel?: bigint | number | null
    experiments?: usersCreateexperimentsInput | number[]
    flags?: usersCreateflagsInput | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    supabase_id?: string | null
    totp_shared_key?: string | null
    staff_password?: string | null
    lynxtag?: string
    bot_voters?: bot_votersUncheckedCreateNestedManyWithoutUsersInput
    extra_data?: extra_dataUncheckedCreateNestedManyWithoutUsersInput
    frostpaw_clients?: frostpaw_clientsUncheckedCreateNestedManyWithoutUsersInput
    leave_of_absence?: leave_of_absenceUncheckedCreateNestedManyWithoutUsersInput
    lynx_apps?: lynx_appsUncheckedCreateNestedManyWithoutUsersInput
    lynx_logs?: lynx_logsUncheckedCreateNestedManyWithoutUsersInput
    lynx_ratings?: lynx_ratingsUncheckedCreateNestedManyWithoutUsersInput
    push_notifications?: push_notificationsUncheckedCreateNestedManyWithoutUsersInput
    review_votes?: review_votesUncheckedCreateNestedManyWithoutUsersInput
    reviews?: reviewsUncheckedCreateNestedManyWithoutUsersInput
    server_audit_logs?: server_audit_logsUncheckedCreateNestedManyWithoutUsersInput
    server_voters?: server_votersUncheckedCreateNestedManyWithoutUsersInput
    servers?: serversUncheckedCreateNestedManyWithoutUsersInput
    user_bot_logs?: user_bot_logsUncheckedCreateNestedManyWithoutUsersInput
    user_connections?: user_connectionsUncheckedCreateNestedManyWithoutUsersInput
    user_server_vote_table?: user_server_vote_tableUncheckedCreateNestedOneWithoutUsersInput
    user_vote_table?: user_vote_tableUncheckedCreateNestedOneWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutLynx_survey_responsesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutLynx_survey_responsesInput, usersUncheckedCreateWithoutLynx_survey_responsesInput>
  }

  export type lynx_surveysUpsertWithoutLynx_survey_responsesInput = {
    update: XOR<lynx_surveysUpdateWithoutLynx_survey_responsesInput, lynx_surveysUncheckedUpdateWithoutLynx_survey_responsesInput>
    create: XOR<lynx_surveysCreateWithoutLynx_survey_responsesInput, lynx_surveysUncheckedCreateWithoutLynx_survey_responsesInput>
    where?: lynx_surveysWhereInput
  }

  export type lynx_surveysUpdateToOneWithWhereWithoutLynx_survey_responsesInput = {
    where?: lynx_surveysWhereInput
    data: XOR<lynx_surveysUpdateWithoutLynx_survey_responsesInput, lynx_surveysUncheckedUpdateWithoutLynx_survey_responsesInput>
  }

  export type lynx_surveysUpdateWithoutLynx_survey_responsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    questions?: JsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type lynx_surveysUncheckedUpdateWithoutLynx_survey_responsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    questions?: JsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type usersUpsertWithoutLynx_survey_responsesInput = {
    update: XOR<usersUpdateWithoutLynx_survey_responsesInput, usersUncheckedUpdateWithoutLynx_survey_responsesInput>
    create: XOR<usersCreateWithoutLynx_survey_responsesInput, usersUncheckedCreateWithoutLynx_survey_responsesInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutLynx_survey_responsesInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutLynx_survey_responsesInput, usersUncheckedUpdateWithoutLynx_survey_responsesInput>
  }

  export type usersUpdateWithoutLynx_survey_responsesInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    api_token?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    badges?: usersUpdatebadgesInput | string[]
    username?: NullableStringFieldUpdateOperationsInput | string | null
    user_css?: NullableStringFieldUpdateOperationsInput | string | null
    state?: IntFieldUpdateOperationsInput | number
    coins?: NullableIntFieldUpdateOperationsInput | number | null
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    site_lang?: NullableStringFieldUpdateOperationsInput | string | null
    profile_css?: StringFieldUpdateOperationsInput | string
    vote_reminders?: usersUpdatevote_remindersInput | bigint[] | number[]
    vote_reminder_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    staff_verify_code?: NullableStringFieldUpdateOperationsInput | string | null
    vote_reminders_last_acked?: DateTimeFieldUpdateOperationsInput | Date | string
    vote_reminders_servers?: usersUpdatevote_reminders_serversInput | bigint[] | number[]
    vote_reminders_servers_last_acked?: DateTimeFieldUpdateOperationsInput | Date | string
    vote_reminder_servers_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    experiments?: usersUpdateexperimentsInput | number[]
    flags?: usersUpdateflagsInput | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    totp_shared_key?: NullableStringFieldUpdateOperationsInput | string | null
    staff_password?: NullableStringFieldUpdateOperationsInput | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
    bot_voters?: bot_votersUpdateManyWithoutUsersNestedInput
    extra_data?: extra_dataUpdateManyWithoutUsersNestedInput
    frostpaw_clients?: frostpaw_clientsUpdateManyWithoutUsersNestedInput
    leave_of_absence?: leave_of_absenceUpdateManyWithoutUsersNestedInput
    lynx_apps?: lynx_appsUpdateManyWithoutUsersNestedInput
    lynx_logs?: lynx_logsUpdateManyWithoutUsersNestedInput
    lynx_ratings?: lynx_ratingsUpdateManyWithoutUsersNestedInput
    push_notifications?: push_notificationsUpdateManyWithoutUsersNestedInput
    review_votes?: review_votesUpdateManyWithoutUsersNestedInput
    reviews?: reviewsUpdateManyWithoutUsersNestedInput
    server_audit_logs?: server_audit_logsUpdateManyWithoutUsersNestedInput
    server_voters?: server_votersUpdateManyWithoutUsersNestedInput
    servers?: serversUpdateManyWithoutUsersNestedInput
    user_bot_logs?: user_bot_logsUpdateManyWithoutUsersNestedInput
    user_connections?: user_connectionsUpdateManyWithoutUsersNestedInput
    user_server_vote_table?: user_server_vote_tableUpdateOneWithoutUsersNestedInput
    user_vote_table?: user_vote_tableUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutLynx_survey_responsesInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    api_token?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    badges?: usersUpdatebadgesInput | string[]
    username?: NullableStringFieldUpdateOperationsInput | string | null
    user_css?: NullableStringFieldUpdateOperationsInput | string | null
    state?: IntFieldUpdateOperationsInput | number
    coins?: NullableIntFieldUpdateOperationsInput | number | null
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    site_lang?: NullableStringFieldUpdateOperationsInput | string | null
    profile_css?: StringFieldUpdateOperationsInput | string
    vote_reminders?: usersUpdatevote_remindersInput | bigint[] | number[]
    vote_reminder_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    staff_verify_code?: NullableStringFieldUpdateOperationsInput | string | null
    vote_reminders_last_acked?: DateTimeFieldUpdateOperationsInput | Date | string
    vote_reminders_servers?: usersUpdatevote_reminders_serversInput | bigint[] | number[]
    vote_reminders_servers_last_acked?: DateTimeFieldUpdateOperationsInput | Date | string
    vote_reminder_servers_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    experiments?: usersUpdateexperimentsInput | number[]
    flags?: usersUpdateflagsInput | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    totp_shared_key?: NullableStringFieldUpdateOperationsInput | string | null
    staff_password?: NullableStringFieldUpdateOperationsInput | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
    bot_voters?: bot_votersUncheckedUpdateManyWithoutUsersNestedInput
    extra_data?: extra_dataUncheckedUpdateManyWithoutUsersNestedInput
    frostpaw_clients?: frostpaw_clientsUncheckedUpdateManyWithoutUsersNestedInput
    leave_of_absence?: leave_of_absenceUncheckedUpdateManyWithoutUsersNestedInput
    lynx_apps?: lynx_appsUncheckedUpdateManyWithoutUsersNestedInput
    lynx_logs?: lynx_logsUncheckedUpdateManyWithoutUsersNestedInput
    lynx_ratings?: lynx_ratingsUncheckedUpdateManyWithoutUsersNestedInput
    push_notifications?: push_notificationsUncheckedUpdateManyWithoutUsersNestedInput
    review_votes?: review_votesUncheckedUpdateManyWithoutUsersNestedInput
    reviews?: reviewsUncheckedUpdateManyWithoutUsersNestedInput
    server_audit_logs?: server_audit_logsUncheckedUpdateManyWithoutUsersNestedInput
    server_voters?: server_votersUncheckedUpdateManyWithoutUsersNestedInput
    servers?: serversUncheckedUpdateManyWithoutUsersNestedInput
    user_bot_logs?: user_bot_logsUncheckedUpdateManyWithoutUsersNestedInput
    user_connections?: user_connectionsUncheckedUpdateManyWithoutUsersNestedInput
    user_server_vote_table?: user_server_vote_tableUncheckedUpdateOneWithoutUsersNestedInput
    user_vote_table?: user_vote_tableUncheckedUpdateOneWithoutUsersNestedInput
  }

  export type lynx_survey_responsesCreateWithoutLynx_surveysInput = {
    id?: string
    questions: JsonNullValueInput | InputJsonValue
    answers: JsonNullValueInput | InputJsonValue
    username_cached: string
    lynxtag?: string
    users?: usersCreateNestedOneWithoutLynx_survey_responsesInput
  }

  export type lynx_survey_responsesUncheckedCreateWithoutLynx_surveysInput = {
    id?: string
    questions: JsonNullValueInput | InputJsonValue
    answers: JsonNullValueInput | InputJsonValue
    username_cached: string
    user_id?: bigint | number | null
    lynxtag?: string
  }

  export type lynx_survey_responsesCreateOrConnectWithoutLynx_surveysInput = {
    where: lynx_survey_responsesWhereUniqueInput
    create: XOR<lynx_survey_responsesCreateWithoutLynx_surveysInput, lynx_survey_responsesUncheckedCreateWithoutLynx_surveysInput>
  }

  export type lynx_survey_responsesCreateManyLynx_surveysInputEnvelope = {
    data: lynx_survey_responsesCreateManyLynx_surveysInput | lynx_survey_responsesCreateManyLynx_surveysInput[]
    skipDuplicates?: boolean
  }

  export type lynx_survey_responsesUpsertWithWhereUniqueWithoutLynx_surveysInput = {
    where: lynx_survey_responsesWhereUniqueInput
    update: XOR<lynx_survey_responsesUpdateWithoutLynx_surveysInput, lynx_survey_responsesUncheckedUpdateWithoutLynx_surveysInput>
    create: XOR<lynx_survey_responsesCreateWithoutLynx_surveysInput, lynx_survey_responsesUncheckedCreateWithoutLynx_surveysInput>
  }

  export type lynx_survey_responsesUpdateWithWhereUniqueWithoutLynx_surveysInput = {
    where: lynx_survey_responsesWhereUniqueInput
    data: XOR<lynx_survey_responsesUpdateWithoutLynx_surveysInput, lynx_survey_responsesUncheckedUpdateWithoutLynx_surveysInput>
  }

  export type lynx_survey_responsesUpdateManyWithWhereWithoutLynx_surveysInput = {
    where: lynx_survey_responsesScalarWhereInput
    data: XOR<lynx_survey_responsesUpdateManyMutationInput, lynx_survey_responsesUncheckedUpdateManyWithoutLynx_surveysInput>
  }

  export type lynx_survey_responsesScalarWhereInput = {
    AND?: lynx_survey_responsesScalarWhereInput | lynx_survey_responsesScalarWhereInput[]
    OR?: lynx_survey_responsesScalarWhereInput[]
    NOT?: lynx_survey_responsesScalarWhereInput | lynx_survey_responsesScalarWhereInput[]
    id?: UuidFilter<"lynx_survey_responses"> | string
    questions?: JsonFilter<"lynx_survey_responses">
    answers?: JsonFilter<"lynx_survey_responses">
    username_cached?: StringFilter<"lynx_survey_responses"> | string
    user_id?: BigIntNullableFilter<"lynx_survey_responses"> | bigint | number | null
    survey_id?: UuidFilter<"lynx_survey_responses"> | string
    lynxtag?: UuidFilter<"lynx_survey_responses"> | string
  }

  export type usersCreateWithoutPush_notificationsInput = {
    user_id: bigint | number
    api_token: string
    description?: string | null
    badges?: usersCreatebadgesInput | string[]
    username?: string | null
    user_css?: string | null
    state?: number
    coins?: number | null
    id: bigint | number
    site_lang?: string | null
    profile_css?: string
    vote_reminders?: usersCreatevote_remindersInput | bigint[] | number[]
    vote_reminder_channel?: bigint | number | null
    staff_verify_code?: string | null
    vote_reminders_last_acked?: Date | string
    vote_reminders_servers?: usersCreatevote_reminders_serversInput | bigint[] | number[]
    vote_reminders_servers_last_acked?: Date | string
    vote_reminder_servers_channel?: bigint | number | null
    experiments?: usersCreateexperimentsInput | number[]
    flags?: usersCreateflagsInput | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    supabase_id?: string | null
    totp_shared_key?: string | null
    staff_password?: string | null
    lynxtag?: string
    bot_voters?: bot_votersCreateNestedManyWithoutUsersInput
    extra_data?: extra_dataCreateNestedManyWithoutUsersInput
    frostpaw_clients?: frostpaw_clientsCreateNestedManyWithoutUsersInput
    leave_of_absence?: leave_of_absenceCreateNestedManyWithoutUsersInput
    lynx_apps?: lynx_appsCreateNestedManyWithoutUsersInput
    lynx_logs?: lynx_logsCreateNestedManyWithoutUsersInput
    lynx_ratings?: lynx_ratingsCreateNestedManyWithoutUsersInput
    lynx_survey_responses?: lynx_survey_responsesCreateNestedManyWithoutUsersInput
    review_votes?: review_votesCreateNestedManyWithoutUsersInput
    reviews?: reviewsCreateNestedManyWithoutUsersInput
    server_audit_logs?: server_audit_logsCreateNestedManyWithoutUsersInput
    server_voters?: server_votersCreateNestedManyWithoutUsersInput
    servers?: serversCreateNestedManyWithoutUsersInput
    user_bot_logs?: user_bot_logsCreateNestedManyWithoutUsersInput
    user_connections?: user_connectionsCreateNestedManyWithoutUsersInput
    user_server_vote_table?: user_server_vote_tableCreateNestedOneWithoutUsersInput
    user_vote_table?: user_vote_tableCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutPush_notificationsInput = {
    user_id: bigint | number
    api_token: string
    description?: string | null
    badges?: usersCreatebadgesInput | string[]
    username?: string | null
    user_css?: string | null
    state?: number
    coins?: number | null
    id: bigint | number
    site_lang?: string | null
    profile_css?: string
    vote_reminders?: usersCreatevote_remindersInput | bigint[] | number[]
    vote_reminder_channel?: bigint | number | null
    staff_verify_code?: string | null
    vote_reminders_last_acked?: Date | string
    vote_reminders_servers?: usersCreatevote_reminders_serversInput | bigint[] | number[]
    vote_reminders_servers_last_acked?: Date | string
    vote_reminder_servers_channel?: bigint | number | null
    experiments?: usersCreateexperimentsInput | number[]
    flags?: usersCreateflagsInput | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    supabase_id?: string | null
    totp_shared_key?: string | null
    staff_password?: string | null
    lynxtag?: string
    bot_voters?: bot_votersUncheckedCreateNestedManyWithoutUsersInput
    extra_data?: extra_dataUncheckedCreateNestedManyWithoutUsersInput
    frostpaw_clients?: frostpaw_clientsUncheckedCreateNestedManyWithoutUsersInput
    leave_of_absence?: leave_of_absenceUncheckedCreateNestedManyWithoutUsersInput
    lynx_apps?: lynx_appsUncheckedCreateNestedManyWithoutUsersInput
    lynx_logs?: lynx_logsUncheckedCreateNestedManyWithoutUsersInput
    lynx_ratings?: lynx_ratingsUncheckedCreateNestedManyWithoutUsersInput
    lynx_survey_responses?: lynx_survey_responsesUncheckedCreateNestedManyWithoutUsersInput
    review_votes?: review_votesUncheckedCreateNestedManyWithoutUsersInput
    reviews?: reviewsUncheckedCreateNestedManyWithoutUsersInput
    server_audit_logs?: server_audit_logsUncheckedCreateNestedManyWithoutUsersInput
    server_voters?: server_votersUncheckedCreateNestedManyWithoutUsersInput
    servers?: serversUncheckedCreateNestedManyWithoutUsersInput
    user_bot_logs?: user_bot_logsUncheckedCreateNestedManyWithoutUsersInput
    user_connections?: user_connectionsUncheckedCreateNestedManyWithoutUsersInput
    user_server_vote_table?: user_server_vote_tableUncheckedCreateNestedOneWithoutUsersInput
    user_vote_table?: user_vote_tableUncheckedCreateNestedOneWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutPush_notificationsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutPush_notificationsInput, usersUncheckedCreateWithoutPush_notificationsInput>
  }

  export type usersUpsertWithoutPush_notificationsInput = {
    update: XOR<usersUpdateWithoutPush_notificationsInput, usersUncheckedUpdateWithoutPush_notificationsInput>
    create: XOR<usersCreateWithoutPush_notificationsInput, usersUncheckedCreateWithoutPush_notificationsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutPush_notificationsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutPush_notificationsInput, usersUncheckedUpdateWithoutPush_notificationsInput>
  }

  export type usersUpdateWithoutPush_notificationsInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    api_token?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    badges?: usersUpdatebadgesInput | string[]
    username?: NullableStringFieldUpdateOperationsInput | string | null
    user_css?: NullableStringFieldUpdateOperationsInput | string | null
    state?: IntFieldUpdateOperationsInput | number
    coins?: NullableIntFieldUpdateOperationsInput | number | null
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    site_lang?: NullableStringFieldUpdateOperationsInput | string | null
    profile_css?: StringFieldUpdateOperationsInput | string
    vote_reminders?: usersUpdatevote_remindersInput | bigint[] | number[]
    vote_reminder_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    staff_verify_code?: NullableStringFieldUpdateOperationsInput | string | null
    vote_reminders_last_acked?: DateTimeFieldUpdateOperationsInput | Date | string
    vote_reminders_servers?: usersUpdatevote_reminders_serversInput | bigint[] | number[]
    vote_reminders_servers_last_acked?: DateTimeFieldUpdateOperationsInput | Date | string
    vote_reminder_servers_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    experiments?: usersUpdateexperimentsInput | number[]
    flags?: usersUpdateflagsInput | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    totp_shared_key?: NullableStringFieldUpdateOperationsInput | string | null
    staff_password?: NullableStringFieldUpdateOperationsInput | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
    bot_voters?: bot_votersUpdateManyWithoutUsersNestedInput
    extra_data?: extra_dataUpdateManyWithoutUsersNestedInput
    frostpaw_clients?: frostpaw_clientsUpdateManyWithoutUsersNestedInput
    leave_of_absence?: leave_of_absenceUpdateManyWithoutUsersNestedInput
    lynx_apps?: lynx_appsUpdateManyWithoutUsersNestedInput
    lynx_logs?: lynx_logsUpdateManyWithoutUsersNestedInput
    lynx_ratings?: lynx_ratingsUpdateManyWithoutUsersNestedInput
    lynx_survey_responses?: lynx_survey_responsesUpdateManyWithoutUsersNestedInput
    review_votes?: review_votesUpdateManyWithoutUsersNestedInput
    reviews?: reviewsUpdateManyWithoutUsersNestedInput
    server_audit_logs?: server_audit_logsUpdateManyWithoutUsersNestedInput
    server_voters?: server_votersUpdateManyWithoutUsersNestedInput
    servers?: serversUpdateManyWithoutUsersNestedInput
    user_bot_logs?: user_bot_logsUpdateManyWithoutUsersNestedInput
    user_connections?: user_connectionsUpdateManyWithoutUsersNestedInput
    user_server_vote_table?: user_server_vote_tableUpdateOneWithoutUsersNestedInput
    user_vote_table?: user_vote_tableUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutPush_notificationsInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    api_token?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    badges?: usersUpdatebadgesInput | string[]
    username?: NullableStringFieldUpdateOperationsInput | string | null
    user_css?: NullableStringFieldUpdateOperationsInput | string | null
    state?: IntFieldUpdateOperationsInput | number
    coins?: NullableIntFieldUpdateOperationsInput | number | null
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    site_lang?: NullableStringFieldUpdateOperationsInput | string | null
    profile_css?: StringFieldUpdateOperationsInput | string
    vote_reminders?: usersUpdatevote_remindersInput | bigint[] | number[]
    vote_reminder_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    staff_verify_code?: NullableStringFieldUpdateOperationsInput | string | null
    vote_reminders_last_acked?: DateTimeFieldUpdateOperationsInput | Date | string
    vote_reminders_servers?: usersUpdatevote_reminders_serversInput | bigint[] | number[]
    vote_reminders_servers_last_acked?: DateTimeFieldUpdateOperationsInput | Date | string
    vote_reminder_servers_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    experiments?: usersUpdateexperimentsInput | number[]
    flags?: usersUpdateflagsInput | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    totp_shared_key?: NullableStringFieldUpdateOperationsInput | string | null
    staff_password?: NullableStringFieldUpdateOperationsInput | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
    bot_voters?: bot_votersUncheckedUpdateManyWithoutUsersNestedInput
    extra_data?: extra_dataUncheckedUpdateManyWithoutUsersNestedInput
    frostpaw_clients?: frostpaw_clientsUncheckedUpdateManyWithoutUsersNestedInput
    leave_of_absence?: leave_of_absenceUncheckedUpdateManyWithoutUsersNestedInput
    lynx_apps?: lynx_appsUncheckedUpdateManyWithoutUsersNestedInput
    lynx_logs?: lynx_logsUncheckedUpdateManyWithoutUsersNestedInput
    lynx_ratings?: lynx_ratingsUncheckedUpdateManyWithoutUsersNestedInput
    lynx_survey_responses?: lynx_survey_responsesUncheckedUpdateManyWithoutUsersNestedInput
    review_votes?: review_votesUncheckedUpdateManyWithoutUsersNestedInput
    reviews?: reviewsUncheckedUpdateManyWithoutUsersNestedInput
    server_audit_logs?: server_audit_logsUncheckedUpdateManyWithoutUsersNestedInput
    server_voters?: server_votersUncheckedUpdateManyWithoutUsersNestedInput
    servers?: serversUncheckedUpdateManyWithoutUsersNestedInput
    user_bot_logs?: user_bot_logsUncheckedUpdateManyWithoutUsersNestedInput
    user_connections?: user_connectionsUncheckedUpdateManyWithoutUsersNestedInput
    user_server_vote_table?: user_server_vote_tableUncheckedUpdateOneWithoutUsersNestedInput
    user_vote_table?: user_vote_tableUncheckedUpdateOneWithoutUsersNestedInput
  }

  export type reviewsCreateWithoutReview_votesInput = {
    id?: string
    target_id: bigint | number
    star_rating?: Decimal | DecimalJsLike | number | string
    review_text: string
    flagged?: boolean
    epoch?: reviewsCreateepochInput | bigint[] | number[]
    target_type?: number | null
    lynxtag?: string
    reviews?: reviewsCreateNestedOneWithoutOther_reviewsInput
    other_reviews?: reviewsCreateNestedManyWithoutReviewsInput
    users: usersCreateNestedOneWithoutReviewsInput
  }

  export type reviewsUncheckedCreateWithoutReview_votesInput = {
    id?: string
    target_id: bigint | number
    user_id: bigint | number
    star_rating?: Decimal | DecimalJsLike | number | string
    review_text: string
    flagged?: boolean
    epoch?: reviewsCreateepochInput | bigint[] | number[]
    target_type?: number | null
    parent_id?: string | null
    lynxtag?: string
    other_reviews?: reviewsUncheckedCreateNestedManyWithoutReviewsInput
  }

  export type reviewsCreateOrConnectWithoutReview_votesInput = {
    where: reviewsWhereUniqueInput
    create: XOR<reviewsCreateWithoutReview_votesInput, reviewsUncheckedCreateWithoutReview_votesInput>
  }

  export type usersCreateWithoutReview_votesInput = {
    user_id: bigint | number
    api_token: string
    description?: string | null
    badges?: usersCreatebadgesInput | string[]
    username?: string | null
    user_css?: string | null
    state?: number
    coins?: number | null
    id: bigint | number
    site_lang?: string | null
    profile_css?: string
    vote_reminders?: usersCreatevote_remindersInput | bigint[] | number[]
    vote_reminder_channel?: bigint | number | null
    staff_verify_code?: string | null
    vote_reminders_last_acked?: Date | string
    vote_reminders_servers?: usersCreatevote_reminders_serversInput | bigint[] | number[]
    vote_reminders_servers_last_acked?: Date | string
    vote_reminder_servers_channel?: bigint | number | null
    experiments?: usersCreateexperimentsInput | number[]
    flags?: usersCreateflagsInput | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    supabase_id?: string | null
    totp_shared_key?: string | null
    staff_password?: string | null
    lynxtag?: string
    bot_voters?: bot_votersCreateNestedManyWithoutUsersInput
    extra_data?: extra_dataCreateNestedManyWithoutUsersInput
    frostpaw_clients?: frostpaw_clientsCreateNestedManyWithoutUsersInput
    leave_of_absence?: leave_of_absenceCreateNestedManyWithoutUsersInput
    lynx_apps?: lynx_appsCreateNestedManyWithoutUsersInput
    lynx_logs?: lynx_logsCreateNestedManyWithoutUsersInput
    lynx_ratings?: lynx_ratingsCreateNestedManyWithoutUsersInput
    lynx_survey_responses?: lynx_survey_responsesCreateNestedManyWithoutUsersInput
    push_notifications?: push_notificationsCreateNestedManyWithoutUsersInput
    reviews?: reviewsCreateNestedManyWithoutUsersInput
    server_audit_logs?: server_audit_logsCreateNestedManyWithoutUsersInput
    server_voters?: server_votersCreateNestedManyWithoutUsersInput
    servers?: serversCreateNestedManyWithoutUsersInput
    user_bot_logs?: user_bot_logsCreateNestedManyWithoutUsersInput
    user_connections?: user_connectionsCreateNestedManyWithoutUsersInput
    user_server_vote_table?: user_server_vote_tableCreateNestedOneWithoutUsersInput
    user_vote_table?: user_vote_tableCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutReview_votesInput = {
    user_id: bigint | number
    api_token: string
    description?: string | null
    badges?: usersCreatebadgesInput | string[]
    username?: string | null
    user_css?: string | null
    state?: number
    coins?: number | null
    id: bigint | number
    site_lang?: string | null
    profile_css?: string
    vote_reminders?: usersCreatevote_remindersInput | bigint[] | number[]
    vote_reminder_channel?: bigint | number | null
    staff_verify_code?: string | null
    vote_reminders_last_acked?: Date | string
    vote_reminders_servers?: usersCreatevote_reminders_serversInput | bigint[] | number[]
    vote_reminders_servers_last_acked?: Date | string
    vote_reminder_servers_channel?: bigint | number | null
    experiments?: usersCreateexperimentsInput | number[]
    flags?: usersCreateflagsInput | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    supabase_id?: string | null
    totp_shared_key?: string | null
    staff_password?: string | null
    lynxtag?: string
    bot_voters?: bot_votersUncheckedCreateNestedManyWithoutUsersInput
    extra_data?: extra_dataUncheckedCreateNestedManyWithoutUsersInput
    frostpaw_clients?: frostpaw_clientsUncheckedCreateNestedManyWithoutUsersInput
    leave_of_absence?: leave_of_absenceUncheckedCreateNestedManyWithoutUsersInput
    lynx_apps?: lynx_appsUncheckedCreateNestedManyWithoutUsersInput
    lynx_logs?: lynx_logsUncheckedCreateNestedManyWithoutUsersInput
    lynx_ratings?: lynx_ratingsUncheckedCreateNestedManyWithoutUsersInput
    lynx_survey_responses?: lynx_survey_responsesUncheckedCreateNestedManyWithoutUsersInput
    push_notifications?: push_notificationsUncheckedCreateNestedManyWithoutUsersInput
    reviews?: reviewsUncheckedCreateNestedManyWithoutUsersInput
    server_audit_logs?: server_audit_logsUncheckedCreateNestedManyWithoutUsersInput
    server_voters?: server_votersUncheckedCreateNestedManyWithoutUsersInput
    servers?: serversUncheckedCreateNestedManyWithoutUsersInput
    user_bot_logs?: user_bot_logsUncheckedCreateNestedManyWithoutUsersInput
    user_connections?: user_connectionsUncheckedCreateNestedManyWithoutUsersInput
    user_server_vote_table?: user_server_vote_tableUncheckedCreateNestedOneWithoutUsersInput
    user_vote_table?: user_vote_tableUncheckedCreateNestedOneWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutReview_votesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutReview_votesInput, usersUncheckedCreateWithoutReview_votesInput>
  }

  export type reviewsUpsertWithoutReview_votesInput = {
    update: XOR<reviewsUpdateWithoutReview_votesInput, reviewsUncheckedUpdateWithoutReview_votesInput>
    create: XOR<reviewsCreateWithoutReview_votesInput, reviewsUncheckedCreateWithoutReview_votesInput>
    where?: reviewsWhereInput
  }

  export type reviewsUpdateToOneWithWhereWithoutReview_votesInput = {
    where?: reviewsWhereInput
    data: XOR<reviewsUpdateWithoutReview_votesInput, reviewsUncheckedUpdateWithoutReview_votesInput>
  }

  export type reviewsUpdateWithoutReview_votesInput = {
    id?: StringFieldUpdateOperationsInput | string
    target_id?: BigIntFieldUpdateOperationsInput | bigint | number
    star_rating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    review_text?: StringFieldUpdateOperationsInput | string
    flagged?: BoolFieldUpdateOperationsInput | boolean
    epoch?: reviewsUpdateepochInput | bigint[] | number[]
    target_type?: NullableIntFieldUpdateOperationsInput | number | null
    lynxtag?: StringFieldUpdateOperationsInput | string
    reviews?: reviewsUpdateOneWithoutOther_reviewsNestedInput
    other_reviews?: reviewsUpdateManyWithoutReviewsNestedInput
    users?: usersUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type reviewsUncheckedUpdateWithoutReview_votesInput = {
    id?: StringFieldUpdateOperationsInput | string
    target_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    star_rating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    review_text?: StringFieldUpdateOperationsInput | string
    flagged?: BoolFieldUpdateOperationsInput | boolean
    epoch?: reviewsUpdateepochInput | bigint[] | number[]
    target_type?: NullableIntFieldUpdateOperationsInput | number | null
    parent_id?: NullableStringFieldUpdateOperationsInput | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
    other_reviews?: reviewsUncheckedUpdateManyWithoutReviewsNestedInput
  }

  export type usersUpsertWithoutReview_votesInput = {
    update: XOR<usersUpdateWithoutReview_votesInput, usersUncheckedUpdateWithoutReview_votesInput>
    create: XOR<usersCreateWithoutReview_votesInput, usersUncheckedCreateWithoutReview_votesInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutReview_votesInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutReview_votesInput, usersUncheckedUpdateWithoutReview_votesInput>
  }

  export type usersUpdateWithoutReview_votesInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    api_token?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    badges?: usersUpdatebadgesInput | string[]
    username?: NullableStringFieldUpdateOperationsInput | string | null
    user_css?: NullableStringFieldUpdateOperationsInput | string | null
    state?: IntFieldUpdateOperationsInput | number
    coins?: NullableIntFieldUpdateOperationsInput | number | null
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    site_lang?: NullableStringFieldUpdateOperationsInput | string | null
    profile_css?: StringFieldUpdateOperationsInput | string
    vote_reminders?: usersUpdatevote_remindersInput | bigint[] | number[]
    vote_reminder_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    staff_verify_code?: NullableStringFieldUpdateOperationsInput | string | null
    vote_reminders_last_acked?: DateTimeFieldUpdateOperationsInput | Date | string
    vote_reminders_servers?: usersUpdatevote_reminders_serversInput | bigint[] | number[]
    vote_reminders_servers_last_acked?: DateTimeFieldUpdateOperationsInput | Date | string
    vote_reminder_servers_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    experiments?: usersUpdateexperimentsInput | number[]
    flags?: usersUpdateflagsInput | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    totp_shared_key?: NullableStringFieldUpdateOperationsInput | string | null
    staff_password?: NullableStringFieldUpdateOperationsInput | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
    bot_voters?: bot_votersUpdateManyWithoutUsersNestedInput
    extra_data?: extra_dataUpdateManyWithoutUsersNestedInput
    frostpaw_clients?: frostpaw_clientsUpdateManyWithoutUsersNestedInput
    leave_of_absence?: leave_of_absenceUpdateManyWithoutUsersNestedInput
    lynx_apps?: lynx_appsUpdateManyWithoutUsersNestedInput
    lynx_logs?: lynx_logsUpdateManyWithoutUsersNestedInput
    lynx_ratings?: lynx_ratingsUpdateManyWithoutUsersNestedInput
    lynx_survey_responses?: lynx_survey_responsesUpdateManyWithoutUsersNestedInput
    push_notifications?: push_notificationsUpdateManyWithoutUsersNestedInput
    reviews?: reviewsUpdateManyWithoutUsersNestedInput
    server_audit_logs?: server_audit_logsUpdateManyWithoutUsersNestedInput
    server_voters?: server_votersUpdateManyWithoutUsersNestedInput
    servers?: serversUpdateManyWithoutUsersNestedInput
    user_bot_logs?: user_bot_logsUpdateManyWithoutUsersNestedInput
    user_connections?: user_connectionsUpdateManyWithoutUsersNestedInput
    user_server_vote_table?: user_server_vote_tableUpdateOneWithoutUsersNestedInput
    user_vote_table?: user_vote_tableUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutReview_votesInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    api_token?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    badges?: usersUpdatebadgesInput | string[]
    username?: NullableStringFieldUpdateOperationsInput | string | null
    user_css?: NullableStringFieldUpdateOperationsInput | string | null
    state?: IntFieldUpdateOperationsInput | number
    coins?: NullableIntFieldUpdateOperationsInput | number | null
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    site_lang?: NullableStringFieldUpdateOperationsInput | string | null
    profile_css?: StringFieldUpdateOperationsInput | string
    vote_reminders?: usersUpdatevote_remindersInput | bigint[] | number[]
    vote_reminder_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    staff_verify_code?: NullableStringFieldUpdateOperationsInput | string | null
    vote_reminders_last_acked?: DateTimeFieldUpdateOperationsInput | Date | string
    vote_reminders_servers?: usersUpdatevote_reminders_serversInput | bigint[] | number[]
    vote_reminders_servers_last_acked?: DateTimeFieldUpdateOperationsInput | Date | string
    vote_reminder_servers_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    experiments?: usersUpdateexperimentsInput | number[]
    flags?: usersUpdateflagsInput | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    totp_shared_key?: NullableStringFieldUpdateOperationsInput | string | null
    staff_password?: NullableStringFieldUpdateOperationsInput | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
    bot_voters?: bot_votersUncheckedUpdateManyWithoutUsersNestedInput
    extra_data?: extra_dataUncheckedUpdateManyWithoutUsersNestedInput
    frostpaw_clients?: frostpaw_clientsUncheckedUpdateManyWithoutUsersNestedInput
    leave_of_absence?: leave_of_absenceUncheckedUpdateManyWithoutUsersNestedInput
    lynx_apps?: lynx_appsUncheckedUpdateManyWithoutUsersNestedInput
    lynx_logs?: lynx_logsUncheckedUpdateManyWithoutUsersNestedInput
    lynx_ratings?: lynx_ratingsUncheckedUpdateManyWithoutUsersNestedInput
    lynx_survey_responses?: lynx_survey_responsesUncheckedUpdateManyWithoutUsersNestedInput
    push_notifications?: push_notificationsUncheckedUpdateManyWithoutUsersNestedInput
    reviews?: reviewsUncheckedUpdateManyWithoutUsersNestedInput
    server_audit_logs?: server_audit_logsUncheckedUpdateManyWithoutUsersNestedInput
    server_voters?: server_votersUncheckedUpdateManyWithoutUsersNestedInput
    servers?: serversUncheckedUpdateManyWithoutUsersNestedInput
    user_bot_logs?: user_bot_logsUncheckedUpdateManyWithoutUsersNestedInput
    user_connections?: user_connectionsUncheckedUpdateManyWithoutUsersNestedInput
    user_server_vote_table?: user_server_vote_tableUncheckedUpdateOneWithoutUsersNestedInput
    user_vote_table?: user_vote_tableUncheckedUpdateOneWithoutUsersNestedInput
  }

  export type review_votesCreateWithoutReviewsInput = {
    upvote: boolean
    lynxtag?: string
    users: usersCreateNestedOneWithoutReview_votesInput
  }

  export type review_votesUncheckedCreateWithoutReviewsInput = {
    user_id: bigint | number
    upvote: boolean
    lynxtag?: string
  }

  export type review_votesCreateOrConnectWithoutReviewsInput = {
    where: review_votesWhereUniqueInput
    create: XOR<review_votesCreateWithoutReviewsInput, review_votesUncheckedCreateWithoutReviewsInput>
  }

  export type review_votesCreateManyReviewsInputEnvelope = {
    data: review_votesCreateManyReviewsInput | review_votesCreateManyReviewsInput[]
    skipDuplicates?: boolean
  }

  export type reviewsCreateWithoutOther_reviewsInput = {
    id?: string
    target_id: bigint | number
    star_rating?: Decimal | DecimalJsLike | number | string
    review_text: string
    flagged?: boolean
    epoch?: reviewsCreateepochInput | bigint[] | number[]
    target_type?: number | null
    lynxtag?: string
    review_votes?: review_votesCreateNestedManyWithoutReviewsInput
    reviews?: reviewsCreateNestedOneWithoutOther_reviewsInput
    users: usersCreateNestedOneWithoutReviewsInput
  }

  export type reviewsUncheckedCreateWithoutOther_reviewsInput = {
    id?: string
    target_id: bigint | number
    user_id: bigint | number
    star_rating?: Decimal | DecimalJsLike | number | string
    review_text: string
    flagged?: boolean
    epoch?: reviewsCreateepochInput | bigint[] | number[]
    target_type?: number | null
    parent_id?: string | null
    lynxtag?: string
    review_votes?: review_votesUncheckedCreateNestedManyWithoutReviewsInput
  }

  export type reviewsCreateOrConnectWithoutOther_reviewsInput = {
    where: reviewsWhereUniqueInput
    create: XOR<reviewsCreateWithoutOther_reviewsInput, reviewsUncheckedCreateWithoutOther_reviewsInput>
  }

  export type reviewsCreateWithoutReviewsInput = {
    id?: string
    target_id: bigint | number
    star_rating?: Decimal | DecimalJsLike | number | string
    review_text: string
    flagged?: boolean
    epoch?: reviewsCreateepochInput | bigint[] | number[]
    target_type?: number | null
    lynxtag?: string
    review_votes?: review_votesCreateNestedManyWithoutReviewsInput
    other_reviews?: reviewsCreateNestedManyWithoutReviewsInput
    users: usersCreateNestedOneWithoutReviewsInput
  }

  export type reviewsUncheckedCreateWithoutReviewsInput = {
    id?: string
    target_id: bigint | number
    user_id: bigint | number
    star_rating?: Decimal | DecimalJsLike | number | string
    review_text: string
    flagged?: boolean
    epoch?: reviewsCreateepochInput | bigint[] | number[]
    target_type?: number | null
    lynxtag?: string
    review_votes?: review_votesUncheckedCreateNestedManyWithoutReviewsInput
    other_reviews?: reviewsUncheckedCreateNestedManyWithoutReviewsInput
  }

  export type reviewsCreateOrConnectWithoutReviewsInput = {
    where: reviewsWhereUniqueInput
    create: XOR<reviewsCreateWithoutReviewsInput, reviewsUncheckedCreateWithoutReviewsInput>
  }

  export type reviewsCreateManyReviewsInputEnvelope = {
    data: reviewsCreateManyReviewsInput | reviewsCreateManyReviewsInput[]
    skipDuplicates?: boolean
  }

  export type usersCreateWithoutReviewsInput = {
    user_id: bigint | number
    api_token: string
    description?: string | null
    badges?: usersCreatebadgesInput | string[]
    username?: string | null
    user_css?: string | null
    state?: number
    coins?: number | null
    id: bigint | number
    site_lang?: string | null
    profile_css?: string
    vote_reminders?: usersCreatevote_remindersInput | bigint[] | number[]
    vote_reminder_channel?: bigint | number | null
    staff_verify_code?: string | null
    vote_reminders_last_acked?: Date | string
    vote_reminders_servers?: usersCreatevote_reminders_serversInput | bigint[] | number[]
    vote_reminders_servers_last_acked?: Date | string
    vote_reminder_servers_channel?: bigint | number | null
    experiments?: usersCreateexperimentsInput | number[]
    flags?: usersCreateflagsInput | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    supabase_id?: string | null
    totp_shared_key?: string | null
    staff_password?: string | null
    lynxtag?: string
    bot_voters?: bot_votersCreateNestedManyWithoutUsersInput
    extra_data?: extra_dataCreateNestedManyWithoutUsersInput
    frostpaw_clients?: frostpaw_clientsCreateNestedManyWithoutUsersInput
    leave_of_absence?: leave_of_absenceCreateNestedManyWithoutUsersInput
    lynx_apps?: lynx_appsCreateNestedManyWithoutUsersInput
    lynx_logs?: lynx_logsCreateNestedManyWithoutUsersInput
    lynx_ratings?: lynx_ratingsCreateNestedManyWithoutUsersInput
    lynx_survey_responses?: lynx_survey_responsesCreateNestedManyWithoutUsersInput
    push_notifications?: push_notificationsCreateNestedManyWithoutUsersInput
    review_votes?: review_votesCreateNestedManyWithoutUsersInput
    server_audit_logs?: server_audit_logsCreateNestedManyWithoutUsersInput
    server_voters?: server_votersCreateNestedManyWithoutUsersInput
    servers?: serversCreateNestedManyWithoutUsersInput
    user_bot_logs?: user_bot_logsCreateNestedManyWithoutUsersInput
    user_connections?: user_connectionsCreateNestedManyWithoutUsersInput
    user_server_vote_table?: user_server_vote_tableCreateNestedOneWithoutUsersInput
    user_vote_table?: user_vote_tableCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutReviewsInput = {
    user_id: bigint | number
    api_token: string
    description?: string | null
    badges?: usersCreatebadgesInput | string[]
    username?: string | null
    user_css?: string | null
    state?: number
    coins?: number | null
    id: bigint | number
    site_lang?: string | null
    profile_css?: string
    vote_reminders?: usersCreatevote_remindersInput | bigint[] | number[]
    vote_reminder_channel?: bigint | number | null
    staff_verify_code?: string | null
    vote_reminders_last_acked?: Date | string
    vote_reminders_servers?: usersCreatevote_reminders_serversInput | bigint[] | number[]
    vote_reminders_servers_last_acked?: Date | string
    vote_reminder_servers_channel?: bigint | number | null
    experiments?: usersCreateexperimentsInput | number[]
    flags?: usersCreateflagsInput | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    supabase_id?: string | null
    totp_shared_key?: string | null
    staff_password?: string | null
    lynxtag?: string
    bot_voters?: bot_votersUncheckedCreateNestedManyWithoutUsersInput
    extra_data?: extra_dataUncheckedCreateNestedManyWithoutUsersInput
    frostpaw_clients?: frostpaw_clientsUncheckedCreateNestedManyWithoutUsersInput
    leave_of_absence?: leave_of_absenceUncheckedCreateNestedManyWithoutUsersInput
    lynx_apps?: lynx_appsUncheckedCreateNestedManyWithoutUsersInput
    lynx_logs?: lynx_logsUncheckedCreateNestedManyWithoutUsersInput
    lynx_ratings?: lynx_ratingsUncheckedCreateNestedManyWithoutUsersInput
    lynx_survey_responses?: lynx_survey_responsesUncheckedCreateNestedManyWithoutUsersInput
    push_notifications?: push_notificationsUncheckedCreateNestedManyWithoutUsersInput
    review_votes?: review_votesUncheckedCreateNestedManyWithoutUsersInput
    server_audit_logs?: server_audit_logsUncheckedCreateNestedManyWithoutUsersInput
    server_voters?: server_votersUncheckedCreateNestedManyWithoutUsersInput
    servers?: serversUncheckedCreateNestedManyWithoutUsersInput
    user_bot_logs?: user_bot_logsUncheckedCreateNestedManyWithoutUsersInput
    user_connections?: user_connectionsUncheckedCreateNestedManyWithoutUsersInput
    user_server_vote_table?: user_server_vote_tableUncheckedCreateNestedOneWithoutUsersInput
    user_vote_table?: user_vote_tableUncheckedCreateNestedOneWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutReviewsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutReviewsInput, usersUncheckedCreateWithoutReviewsInput>
  }

  export type review_votesUpsertWithWhereUniqueWithoutReviewsInput = {
    where: review_votesWhereUniqueInput
    update: XOR<review_votesUpdateWithoutReviewsInput, review_votesUncheckedUpdateWithoutReviewsInput>
    create: XOR<review_votesCreateWithoutReviewsInput, review_votesUncheckedCreateWithoutReviewsInput>
  }

  export type review_votesUpdateWithWhereUniqueWithoutReviewsInput = {
    where: review_votesWhereUniqueInput
    data: XOR<review_votesUpdateWithoutReviewsInput, review_votesUncheckedUpdateWithoutReviewsInput>
  }

  export type review_votesUpdateManyWithWhereWithoutReviewsInput = {
    where: review_votesScalarWhereInput
    data: XOR<review_votesUpdateManyMutationInput, review_votesUncheckedUpdateManyWithoutReviewsInput>
  }

  export type review_votesScalarWhereInput = {
    AND?: review_votesScalarWhereInput | review_votesScalarWhereInput[]
    OR?: review_votesScalarWhereInput[]
    NOT?: review_votesScalarWhereInput | review_votesScalarWhereInput[]
    id?: UuidFilter<"review_votes"> | string
    user_id?: BigIntFilter<"review_votes"> | bigint | number
    upvote?: BoolFilter<"review_votes"> | boolean
    lynxtag?: UuidFilter<"review_votes"> | string
  }

  export type reviewsUpsertWithoutOther_reviewsInput = {
    update: XOR<reviewsUpdateWithoutOther_reviewsInput, reviewsUncheckedUpdateWithoutOther_reviewsInput>
    create: XOR<reviewsCreateWithoutOther_reviewsInput, reviewsUncheckedCreateWithoutOther_reviewsInput>
    where?: reviewsWhereInput
  }

  export type reviewsUpdateToOneWithWhereWithoutOther_reviewsInput = {
    where?: reviewsWhereInput
    data: XOR<reviewsUpdateWithoutOther_reviewsInput, reviewsUncheckedUpdateWithoutOther_reviewsInput>
  }

  export type reviewsUpdateWithoutOther_reviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    target_id?: BigIntFieldUpdateOperationsInput | bigint | number
    star_rating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    review_text?: StringFieldUpdateOperationsInput | string
    flagged?: BoolFieldUpdateOperationsInput | boolean
    epoch?: reviewsUpdateepochInput | bigint[] | number[]
    target_type?: NullableIntFieldUpdateOperationsInput | number | null
    lynxtag?: StringFieldUpdateOperationsInput | string
    review_votes?: review_votesUpdateManyWithoutReviewsNestedInput
    reviews?: reviewsUpdateOneWithoutOther_reviewsNestedInput
    users?: usersUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type reviewsUncheckedUpdateWithoutOther_reviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    target_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    star_rating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    review_text?: StringFieldUpdateOperationsInput | string
    flagged?: BoolFieldUpdateOperationsInput | boolean
    epoch?: reviewsUpdateepochInput | bigint[] | number[]
    target_type?: NullableIntFieldUpdateOperationsInput | number | null
    parent_id?: NullableStringFieldUpdateOperationsInput | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
    review_votes?: review_votesUncheckedUpdateManyWithoutReviewsNestedInput
  }

  export type reviewsUpsertWithWhereUniqueWithoutReviewsInput = {
    where: reviewsWhereUniqueInput
    update: XOR<reviewsUpdateWithoutReviewsInput, reviewsUncheckedUpdateWithoutReviewsInput>
    create: XOR<reviewsCreateWithoutReviewsInput, reviewsUncheckedCreateWithoutReviewsInput>
  }

  export type reviewsUpdateWithWhereUniqueWithoutReviewsInput = {
    where: reviewsWhereUniqueInput
    data: XOR<reviewsUpdateWithoutReviewsInput, reviewsUncheckedUpdateWithoutReviewsInput>
  }

  export type reviewsUpdateManyWithWhereWithoutReviewsInput = {
    where: reviewsScalarWhereInput
    data: XOR<reviewsUpdateManyMutationInput, reviewsUncheckedUpdateManyWithoutReviewsInput>
  }

  export type reviewsScalarWhereInput = {
    AND?: reviewsScalarWhereInput | reviewsScalarWhereInput[]
    OR?: reviewsScalarWhereInput[]
    NOT?: reviewsScalarWhereInput | reviewsScalarWhereInput[]
    id?: UuidFilter<"reviews"> | string
    target_id?: BigIntFilter<"reviews"> | bigint | number
    user_id?: BigIntFilter<"reviews"> | bigint | number
    star_rating?: DecimalFilter<"reviews"> | Decimal | DecimalJsLike | number | string
    review_text?: StringFilter<"reviews"> | string
    flagged?: BoolFilter<"reviews"> | boolean
    epoch?: BigIntNullableListFilter<"reviews">
    target_type?: IntNullableFilter<"reviews"> | number | null
    parent_id?: UuidNullableFilter<"reviews"> | string | null
    lynxtag?: UuidFilter<"reviews"> | string
  }

  export type usersUpsertWithoutReviewsInput = {
    update: XOR<usersUpdateWithoutReviewsInput, usersUncheckedUpdateWithoutReviewsInput>
    create: XOR<usersCreateWithoutReviewsInput, usersUncheckedCreateWithoutReviewsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutReviewsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutReviewsInput, usersUncheckedUpdateWithoutReviewsInput>
  }

  export type usersUpdateWithoutReviewsInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    api_token?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    badges?: usersUpdatebadgesInput | string[]
    username?: NullableStringFieldUpdateOperationsInput | string | null
    user_css?: NullableStringFieldUpdateOperationsInput | string | null
    state?: IntFieldUpdateOperationsInput | number
    coins?: NullableIntFieldUpdateOperationsInput | number | null
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    site_lang?: NullableStringFieldUpdateOperationsInput | string | null
    profile_css?: StringFieldUpdateOperationsInput | string
    vote_reminders?: usersUpdatevote_remindersInput | bigint[] | number[]
    vote_reminder_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    staff_verify_code?: NullableStringFieldUpdateOperationsInput | string | null
    vote_reminders_last_acked?: DateTimeFieldUpdateOperationsInput | Date | string
    vote_reminders_servers?: usersUpdatevote_reminders_serversInput | bigint[] | number[]
    vote_reminders_servers_last_acked?: DateTimeFieldUpdateOperationsInput | Date | string
    vote_reminder_servers_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    experiments?: usersUpdateexperimentsInput | number[]
    flags?: usersUpdateflagsInput | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    totp_shared_key?: NullableStringFieldUpdateOperationsInput | string | null
    staff_password?: NullableStringFieldUpdateOperationsInput | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
    bot_voters?: bot_votersUpdateManyWithoutUsersNestedInput
    extra_data?: extra_dataUpdateManyWithoutUsersNestedInput
    frostpaw_clients?: frostpaw_clientsUpdateManyWithoutUsersNestedInput
    leave_of_absence?: leave_of_absenceUpdateManyWithoutUsersNestedInput
    lynx_apps?: lynx_appsUpdateManyWithoutUsersNestedInput
    lynx_logs?: lynx_logsUpdateManyWithoutUsersNestedInput
    lynx_ratings?: lynx_ratingsUpdateManyWithoutUsersNestedInput
    lynx_survey_responses?: lynx_survey_responsesUpdateManyWithoutUsersNestedInput
    push_notifications?: push_notificationsUpdateManyWithoutUsersNestedInput
    review_votes?: review_votesUpdateManyWithoutUsersNestedInput
    server_audit_logs?: server_audit_logsUpdateManyWithoutUsersNestedInput
    server_voters?: server_votersUpdateManyWithoutUsersNestedInput
    servers?: serversUpdateManyWithoutUsersNestedInput
    user_bot_logs?: user_bot_logsUpdateManyWithoutUsersNestedInput
    user_connections?: user_connectionsUpdateManyWithoutUsersNestedInput
    user_server_vote_table?: user_server_vote_tableUpdateOneWithoutUsersNestedInput
    user_vote_table?: user_vote_tableUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutReviewsInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    api_token?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    badges?: usersUpdatebadgesInput | string[]
    username?: NullableStringFieldUpdateOperationsInput | string | null
    user_css?: NullableStringFieldUpdateOperationsInput | string | null
    state?: IntFieldUpdateOperationsInput | number
    coins?: NullableIntFieldUpdateOperationsInput | number | null
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    site_lang?: NullableStringFieldUpdateOperationsInput | string | null
    profile_css?: StringFieldUpdateOperationsInput | string
    vote_reminders?: usersUpdatevote_remindersInput | bigint[] | number[]
    vote_reminder_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    staff_verify_code?: NullableStringFieldUpdateOperationsInput | string | null
    vote_reminders_last_acked?: DateTimeFieldUpdateOperationsInput | Date | string
    vote_reminders_servers?: usersUpdatevote_reminders_serversInput | bigint[] | number[]
    vote_reminders_servers_last_acked?: DateTimeFieldUpdateOperationsInput | Date | string
    vote_reminder_servers_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    experiments?: usersUpdateexperimentsInput | number[]
    flags?: usersUpdateflagsInput | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    totp_shared_key?: NullableStringFieldUpdateOperationsInput | string | null
    staff_password?: NullableStringFieldUpdateOperationsInput | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
    bot_voters?: bot_votersUncheckedUpdateManyWithoutUsersNestedInput
    extra_data?: extra_dataUncheckedUpdateManyWithoutUsersNestedInput
    frostpaw_clients?: frostpaw_clientsUncheckedUpdateManyWithoutUsersNestedInput
    leave_of_absence?: leave_of_absenceUncheckedUpdateManyWithoutUsersNestedInput
    lynx_apps?: lynx_appsUncheckedUpdateManyWithoutUsersNestedInput
    lynx_logs?: lynx_logsUncheckedUpdateManyWithoutUsersNestedInput
    lynx_ratings?: lynx_ratingsUncheckedUpdateManyWithoutUsersNestedInput
    lynx_survey_responses?: lynx_survey_responsesUncheckedUpdateManyWithoutUsersNestedInput
    push_notifications?: push_notificationsUncheckedUpdateManyWithoutUsersNestedInput
    review_votes?: review_votesUncheckedUpdateManyWithoutUsersNestedInput
    server_audit_logs?: server_audit_logsUncheckedUpdateManyWithoutUsersNestedInput
    server_voters?: server_votersUncheckedUpdateManyWithoutUsersNestedInput
    servers?: serversUncheckedUpdateManyWithoutUsersNestedInput
    user_bot_logs?: user_bot_logsUncheckedUpdateManyWithoutUsersNestedInput
    user_connections?: user_connectionsUncheckedUpdateManyWithoutUsersNestedInput
    user_server_vote_table?: user_server_vote_tableUncheckedUpdateOneWithoutUsersNestedInput
    user_vote_table?: user_vote_tableUncheckedUpdateOneWithoutUsersNestedInput
  }

  export type serversCreateWithoutServer_audit_logsInput = {
    guild_id: bigint | number
    votes?: bigint | number | null
    webhook?: string | null
    description?: string
    long_description?: string
    css?: string | null
    api_token: string
    invite_amount?: number | null
    invite_url?: string | null
    name_cached: string
    long_description_type?: number | null
    state?: number
    created_at?: Date | string
    avatar_cached?: string | null
    invite_channel?: bigint | number | null
    guild_count?: bigint | number | null
    banner_card?: string | null
    banner_page?: string | null
    webhook_secret?: string | null
    webhook_type?: number | null
    total_votes?: bigint | number | null
    tags?: serversCreatetagsInput | string[]
    flags?: serversCreateflagsInput | number[]
    autorole_votes?: serversCreateautorole_votesInput | bigint[] | number[]
    whitelist_form?: string | null
    webhook_hmac_only?: boolean | null
    old_state?: number
    user_whitelist?: serversCreateuser_whitelistInput | bigint[] | number[]
    user_blacklist?: serversCreateuser_blacklistInput | bigint[] | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    lynxtag?: string
    users: usersCreateNestedOneWithoutServersInput
  }

  export type serversUncheckedCreateWithoutServer_audit_logsInput = {
    guild_id: bigint | number
    votes?: bigint | number | null
    webhook?: string | null
    description?: string
    long_description?: string
    css?: string | null
    api_token: string
    invite_amount?: number | null
    invite_url?: string | null
    name_cached: string
    long_description_type?: number | null
    state?: number
    created_at?: Date | string
    avatar_cached?: string | null
    invite_channel?: bigint | number | null
    guild_count?: bigint | number | null
    banner_card?: string | null
    banner_page?: string | null
    webhook_secret?: string | null
    webhook_type?: number | null
    total_votes?: bigint | number | null
    tags?: serversCreatetagsInput | string[]
    owner_id: bigint | number
    flags?: serversCreateflagsInput | number[]
    autorole_votes?: serversCreateautorole_votesInput | bigint[] | number[]
    whitelist_form?: string | null
    webhook_hmac_only?: boolean | null
    old_state?: number
    user_whitelist?: serversCreateuser_whitelistInput | bigint[] | number[]
    user_blacklist?: serversCreateuser_blacklistInput | bigint[] | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    lynxtag?: string
  }

  export type serversCreateOrConnectWithoutServer_audit_logsInput = {
    where: serversWhereUniqueInput
    create: XOR<serversCreateWithoutServer_audit_logsInput, serversUncheckedCreateWithoutServer_audit_logsInput>
  }

  export type usersCreateWithoutServer_audit_logsInput = {
    user_id: bigint | number
    api_token: string
    description?: string | null
    badges?: usersCreatebadgesInput | string[]
    username?: string | null
    user_css?: string | null
    state?: number
    coins?: number | null
    id: bigint | number
    site_lang?: string | null
    profile_css?: string
    vote_reminders?: usersCreatevote_remindersInput | bigint[] | number[]
    vote_reminder_channel?: bigint | number | null
    staff_verify_code?: string | null
    vote_reminders_last_acked?: Date | string
    vote_reminders_servers?: usersCreatevote_reminders_serversInput | bigint[] | number[]
    vote_reminders_servers_last_acked?: Date | string
    vote_reminder_servers_channel?: bigint | number | null
    experiments?: usersCreateexperimentsInput | number[]
    flags?: usersCreateflagsInput | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    supabase_id?: string | null
    totp_shared_key?: string | null
    staff_password?: string | null
    lynxtag?: string
    bot_voters?: bot_votersCreateNestedManyWithoutUsersInput
    extra_data?: extra_dataCreateNestedManyWithoutUsersInput
    frostpaw_clients?: frostpaw_clientsCreateNestedManyWithoutUsersInput
    leave_of_absence?: leave_of_absenceCreateNestedManyWithoutUsersInput
    lynx_apps?: lynx_appsCreateNestedManyWithoutUsersInput
    lynx_logs?: lynx_logsCreateNestedManyWithoutUsersInput
    lynx_ratings?: lynx_ratingsCreateNestedManyWithoutUsersInput
    lynx_survey_responses?: lynx_survey_responsesCreateNestedManyWithoutUsersInput
    push_notifications?: push_notificationsCreateNestedManyWithoutUsersInput
    review_votes?: review_votesCreateNestedManyWithoutUsersInput
    reviews?: reviewsCreateNestedManyWithoutUsersInput
    server_voters?: server_votersCreateNestedManyWithoutUsersInput
    servers?: serversCreateNestedManyWithoutUsersInput
    user_bot_logs?: user_bot_logsCreateNestedManyWithoutUsersInput
    user_connections?: user_connectionsCreateNestedManyWithoutUsersInput
    user_server_vote_table?: user_server_vote_tableCreateNestedOneWithoutUsersInput
    user_vote_table?: user_vote_tableCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutServer_audit_logsInput = {
    user_id: bigint | number
    api_token: string
    description?: string | null
    badges?: usersCreatebadgesInput | string[]
    username?: string | null
    user_css?: string | null
    state?: number
    coins?: number | null
    id: bigint | number
    site_lang?: string | null
    profile_css?: string
    vote_reminders?: usersCreatevote_remindersInput | bigint[] | number[]
    vote_reminder_channel?: bigint | number | null
    staff_verify_code?: string | null
    vote_reminders_last_acked?: Date | string
    vote_reminders_servers?: usersCreatevote_reminders_serversInput | bigint[] | number[]
    vote_reminders_servers_last_acked?: Date | string
    vote_reminder_servers_channel?: bigint | number | null
    experiments?: usersCreateexperimentsInput | number[]
    flags?: usersCreateflagsInput | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    supabase_id?: string | null
    totp_shared_key?: string | null
    staff_password?: string | null
    lynxtag?: string
    bot_voters?: bot_votersUncheckedCreateNestedManyWithoutUsersInput
    extra_data?: extra_dataUncheckedCreateNestedManyWithoutUsersInput
    frostpaw_clients?: frostpaw_clientsUncheckedCreateNestedManyWithoutUsersInput
    leave_of_absence?: leave_of_absenceUncheckedCreateNestedManyWithoutUsersInput
    lynx_apps?: lynx_appsUncheckedCreateNestedManyWithoutUsersInput
    lynx_logs?: lynx_logsUncheckedCreateNestedManyWithoutUsersInput
    lynx_ratings?: lynx_ratingsUncheckedCreateNestedManyWithoutUsersInput
    lynx_survey_responses?: lynx_survey_responsesUncheckedCreateNestedManyWithoutUsersInput
    push_notifications?: push_notificationsUncheckedCreateNestedManyWithoutUsersInput
    review_votes?: review_votesUncheckedCreateNestedManyWithoutUsersInput
    reviews?: reviewsUncheckedCreateNestedManyWithoutUsersInput
    server_voters?: server_votersUncheckedCreateNestedManyWithoutUsersInput
    servers?: serversUncheckedCreateNestedManyWithoutUsersInput
    user_bot_logs?: user_bot_logsUncheckedCreateNestedManyWithoutUsersInput
    user_connections?: user_connectionsUncheckedCreateNestedManyWithoutUsersInput
    user_server_vote_table?: user_server_vote_tableUncheckedCreateNestedOneWithoutUsersInput
    user_vote_table?: user_vote_tableUncheckedCreateNestedOneWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutServer_audit_logsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutServer_audit_logsInput, usersUncheckedCreateWithoutServer_audit_logsInput>
  }

  export type serversUpsertWithoutServer_audit_logsInput = {
    update: XOR<serversUpdateWithoutServer_audit_logsInput, serversUncheckedUpdateWithoutServer_audit_logsInput>
    create: XOR<serversCreateWithoutServer_audit_logsInput, serversUncheckedCreateWithoutServer_audit_logsInput>
    where?: serversWhereInput
  }

  export type serversUpdateToOneWithWhereWithoutServer_audit_logsInput = {
    where?: serversWhereInput
    data: XOR<serversUpdateWithoutServer_audit_logsInput, serversUncheckedUpdateWithoutServer_audit_logsInput>
  }

  export type serversUpdateWithoutServer_audit_logsInput = {
    guild_id?: BigIntFieldUpdateOperationsInput | bigint | number
    votes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    webhook?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    long_description?: StringFieldUpdateOperationsInput | string
    css?: NullableStringFieldUpdateOperationsInput | string | null
    api_token?: StringFieldUpdateOperationsInput | string
    invite_amount?: NullableIntFieldUpdateOperationsInput | number | null
    invite_url?: NullableStringFieldUpdateOperationsInput | string | null
    name_cached?: StringFieldUpdateOperationsInput | string
    long_description_type?: NullableIntFieldUpdateOperationsInput | number | null
    state?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar_cached?: NullableStringFieldUpdateOperationsInput | string | null
    invite_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    guild_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    banner_card?: NullableStringFieldUpdateOperationsInput | string | null
    banner_page?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_secret?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_type?: NullableIntFieldUpdateOperationsInput | number | null
    total_votes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    tags?: serversUpdatetagsInput | string[]
    flags?: serversUpdateflagsInput | number[]
    autorole_votes?: serversUpdateautorole_votesInput | bigint[] | number[]
    whitelist_form?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_hmac_only?: NullableBoolFieldUpdateOperationsInput | boolean | null
    old_state?: IntFieldUpdateOperationsInput | number
    user_whitelist?: serversUpdateuser_whitelistInput | bigint[] | number[]
    user_blacklist?: serversUpdateuser_blacklistInput | bigint[] | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    lynxtag?: StringFieldUpdateOperationsInput | string
    users?: usersUpdateOneRequiredWithoutServersNestedInput
  }

  export type serversUncheckedUpdateWithoutServer_audit_logsInput = {
    guild_id?: BigIntFieldUpdateOperationsInput | bigint | number
    votes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    webhook?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    long_description?: StringFieldUpdateOperationsInput | string
    css?: NullableStringFieldUpdateOperationsInput | string | null
    api_token?: StringFieldUpdateOperationsInput | string
    invite_amount?: NullableIntFieldUpdateOperationsInput | number | null
    invite_url?: NullableStringFieldUpdateOperationsInput | string | null
    name_cached?: StringFieldUpdateOperationsInput | string
    long_description_type?: NullableIntFieldUpdateOperationsInput | number | null
    state?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar_cached?: NullableStringFieldUpdateOperationsInput | string | null
    invite_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    guild_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    banner_card?: NullableStringFieldUpdateOperationsInput | string | null
    banner_page?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_secret?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_type?: NullableIntFieldUpdateOperationsInput | number | null
    total_votes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    tags?: serversUpdatetagsInput | string[]
    owner_id?: BigIntFieldUpdateOperationsInput | bigint | number
    flags?: serversUpdateflagsInput | number[]
    autorole_votes?: serversUpdateautorole_votesInput | bigint[] | number[]
    whitelist_form?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_hmac_only?: NullableBoolFieldUpdateOperationsInput | boolean | null
    old_state?: IntFieldUpdateOperationsInput | number
    user_whitelist?: serversUpdateuser_whitelistInput | bigint[] | number[]
    user_blacklist?: serversUpdateuser_blacklistInput | bigint[] | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type usersUpsertWithoutServer_audit_logsInput = {
    update: XOR<usersUpdateWithoutServer_audit_logsInput, usersUncheckedUpdateWithoutServer_audit_logsInput>
    create: XOR<usersCreateWithoutServer_audit_logsInput, usersUncheckedCreateWithoutServer_audit_logsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutServer_audit_logsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutServer_audit_logsInput, usersUncheckedUpdateWithoutServer_audit_logsInput>
  }

  export type usersUpdateWithoutServer_audit_logsInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    api_token?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    badges?: usersUpdatebadgesInput | string[]
    username?: NullableStringFieldUpdateOperationsInput | string | null
    user_css?: NullableStringFieldUpdateOperationsInput | string | null
    state?: IntFieldUpdateOperationsInput | number
    coins?: NullableIntFieldUpdateOperationsInput | number | null
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    site_lang?: NullableStringFieldUpdateOperationsInput | string | null
    profile_css?: StringFieldUpdateOperationsInput | string
    vote_reminders?: usersUpdatevote_remindersInput | bigint[] | number[]
    vote_reminder_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    staff_verify_code?: NullableStringFieldUpdateOperationsInput | string | null
    vote_reminders_last_acked?: DateTimeFieldUpdateOperationsInput | Date | string
    vote_reminders_servers?: usersUpdatevote_reminders_serversInput | bigint[] | number[]
    vote_reminders_servers_last_acked?: DateTimeFieldUpdateOperationsInput | Date | string
    vote_reminder_servers_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    experiments?: usersUpdateexperimentsInput | number[]
    flags?: usersUpdateflagsInput | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    totp_shared_key?: NullableStringFieldUpdateOperationsInput | string | null
    staff_password?: NullableStringFieldUpdateOperationsInput | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
    bot_voters?: bot_votersUpdateManyWithoutUsersNestedInput
    extra_data?: extra_dataUpdateManyWithoutUsersNestedInput
    frostpaw_clients?: frostpaw_clientsUpdateManyWithoutUsersNestedInput
    leave_of_absence?: leave_of_absenceUpdateManyWithoutUsersNestedInput
    lynx_apps?: lynx_appsUpdateManyWithoutUsersNestedInput
    lynx_logs?: lynx_logsUpdateManyWithoutUsersNestedInput
    lynx_ratings?: lynx_ratingsUpdateManyWithoutUsersNestedInput
    lynx_survey_responses?: lynx_survey_responsesUpdateManyWithoutUsersNestedInput
    push_notifications?: push_notificationsUpdateManyWithoutUsersNestedInput
    review_votes?: review_votesUpdateManyWithoutUsersNestedInput
    reviews?: reviewsUpdateManyWithoutUsersNestedInput
    server_voters?: server_votersUpdateManyWithoutUsersNestedInput
    servers?: serversUpdateManyWithoutUsersNestedInput
    user_bot_logs?: user_bot_logsUpdateManyWithoutUsersNestedInput
    user_connections?: user_connectionsUpdateManyWithoutUsersNestedInput
    user_server_vote_table?: user_server_vote_tableUpdateOneWithoutUsersNestedInput
    user_vote_table?: user_vote_tableUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutServer_audit_logsInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    api_token?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    badges?: usersUpdatebadgesInput | string[]
    username?: NullableStringFieldUpdateOperationsInput | string | null
    user_css?: NullableStringFieldUpdateOperationsInput | string | null
    state?: IntFieldUpdateOperationsInput | number
    coins?: NullableIntFieldUpdateOperationsInput | number | null
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    site_lang?: NullableStringFieldUpdateOperationsInput | string | null
    profile_css?: StringFieldUpdateOperationsInput | string
    vote_reminders?: usersUpdatevote_remindersInput | bigint[] | number[]
    vote_reminder_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    staff_verify_code?: NullableStringFieldUpdateOperationsInput | string | null
    vote_reminders_last_acked?: DateTimeFieldUpdateOperationsInput | Date | string
    vote_reminders_servers?: usersUpdatevote_reminders_serversInput | bigint[] | number[]
    vote_reminders_servers_last_acked?: DateTimeFieldUpdateOperationsInput | Date | string
    vote_reminder_servers_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    experiments?: usersUpdateexperimentsInput | number[]
    flags?: usersUpdateflagsInput | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    totp_shared_key?: NullableStringFieldUpdateOperationsInput | string | null
    staff_password?: NullableStringFieldUpdateOperationsInput | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
    bot_voters?: bot_votersUncheckedUpdateManyWithoutUsersNestedInput
    extra_data?: extra_dataUncheckedUpdateManyWithoutUsersNestedInput
    frostpaw_clients?: frostpaw_clientsUncheckedUpdateManyWithoutUsersNestedInput
    leave_of_absence?: leave_of_absenceUncheckedUpdateManyWithoutUsersNestedInput
    lynx_apps?: lynx_appsUncheckedUpdateManyWithoutUsersNestedInput
    lynx_logs?: lynx_logsUncheckedUpdateManyWithoutUsersNestedInput
    lynx_ratings?: lynx_ratingsUncheckedUpdateManyWithoutUsersNestedInput
    lynx_survey_responses?: lynx_survey_responsesUncheckedUpdateManyWithoutUsersNestedInput
    push_notifications?: push_notificationsUncheckedUpdateManyWithoutUsersNestedInput
    review_votes?: review_votesUncheckedUpdateManyWithoutUsersNestedInput
    reviews?: reviewsUncheckedUpdateManyWithoutUsersNestedInput
    server_voters?: server_votersUncheckedUpdateManyWithoutUsersNestedInput
    servers?: serversUncheckedUpdateManyWithoutUsersNestedInput
    user_bot_logs?: user_bot_logsUncheckedUpdateManyWithoutUsersNestedInput
    user_connections?: user_connectionsUncheckedUpdateManyWithoutUsersNestedInput
    user_server_vote_table?: user_server_vote_tableUncheckedUpdateOneWithoutUsersNestedInput
    user_vote_table?: user_vote_tableUncheckedUpdateOneWithoutUsersNestedInput
  }

  export type usersCreateWithoutServer_votersInput = {
    user_id: bigint | number
    api_token: string
    description?: string | null
    badges?: usersCreatebadgesInput | string[]
    username?: string | null
    user_css?: string | null
    state?: number
    coins?: number | null
    id: bigint | number
    site_lang?: string | null
    profile_css?: string
    vote_reminders?: usersCreatevote_remindersInput | bigint[] | number[]
    vote_reminder_channel?: bigint | number | null
    staff_verify_code?: string | null
    vote_reminders_last_acked?: Date | string
    vote_reminders_servers?: usersCreatevote_reminders_serversInput | bigint[] | number[]
    vote_reminders_servers_last_acked?: Date | string
    vote_reminder_servers_channel?: bigint | number | null
    experiments?: usersCreateexperimentsInput | number[]
    flags?: usersCreateflagsInput | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    supabase_id?: string | null
    totp_shared_key?: string | null
    staff_password?: string | null
    lynxtag?: string
    bot_voters?: bot_votersCreateNestedManyWithoutUsersInput
    extra_data?: extra_dataCreateNestedManyWithoutUsersInput
    frostpaw_clients?: frostpaw_clientsCreateNestedManyWithoutUsersInput
    leave_of_absence?: leave_of_absenceCreateNestedManyWithoutUsersInput
    lynx_apps?: lynx_appsCreateNestedManyWithoutUsersInput
    lynx_logs?: lynx_logsCreateNestedManyWithoutUsersInput
    lynx_ratings?: lynx_ratingsCreateNestedManyWithoutUsersInput
    lynx_survey_responses?: lynx_survey_responsesCreateNestedManyWithoutUsersInput
    push_notifications?: push_notificationsCreateNestedManyWithoutUsersInput
    review_votes?: review_votesCreateNestedManyWithoutUsersInput
    reviews?: reviewsCreateNestedManyWithoutUsersInput
    server_audit_logs?: server_audit_logsCreateNestedManyWithoutUsersInput
    servers?: serversCreateNestedManyWithoutUsersInput
    user_bot_logs?: user_bot_logsCreateNestedManyWithoutUsersInput
    user_connections?: user_connectionsCreateNestedManyWithoutUsersInput
    user_server_vote_table?: user_server_vote_tableCreateNestedOneWithoutUsersInput
    user_vote_table?: user_vote_tableCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutServer_votersInput = {
    user_id: bigint | number
    api_token: string
    description?: string | null
    badges?: usersCreatebadgesInput | string[]
    username?: string | null
    user_css?: string | null
    state?: number
    coins?: number | null
    id: bigint | number
    site_lang?: string | null
    profile_css?: string
    vote_reminders?: usersCreatevote_remindersInput | bigint[] | number[]
    vote_reminder_channel?: bigint | number | null
    staff_verify_code?: string | null
    vote_reminders_last_acked?: Date | string
    vote_reminders_servers?: usersCreatevote_reminders_serversInput | bigint[] | number[]
    vote_reminders_servers_last_acked?: Date | string
    vote_reminder_servers_channel?: bigint | number | null
    experiments?: usersCreateexperimentsInput | number[]
    flags?: usersCreateflagsInput | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    supabase_id?: string | null
    totp_shared_key?: string | null
    staff_password?: string | null
    lynxtag?: string
    bot_voters?: bot_votersUncheckedCreateNestedManyWithoutUsersInput
    extra_data?: extra_dataUncheckedCreateNestedManyWithoutUsersInput
    frostpaw_clients?: frostpaw_clientsUncheckedCreateNestedManyWithoutUsersInput
    leave_of_absence?: leave_of_absenceUncheckedCreateNestedManyWithoutUsersInput
    lynx_apps?: lynx_appsUncheckedCreateNestedManyWithoutUsersInput
    lynx_logs?: lynx_logsUncheckedCreateNestedManyWithoutUsersInput
    lynx_ratings?: lynx_ratingsUncheckedCreateNestedManyWithoutUsersInput
    lynx_survey_responses?: lynx_survey_responsesUncheckedCreateNestedManyWithoutUsersInput
    push_notifications?: push_notificationsUncheckedCreateNestedManyWithoutUsersInput
    review_votes?: review_votesUncheckedCreateNestedManyWithoutUsersInput
    reviews?: reviewsUncheckedCreateNestedManyWithoutUsersInput
    server_audit_logs?: server_audit_logsUncheckedCreateNestedManyWithoutUsersInput
    servers?: serversUncheckedCreateNestedManyWithoutUsersInput
    user_bot_logs?: user_bot_logsUncheckedCreateNestedManyWithoutUsersInput
    user_connections?: user_connectionsUncheckedCreateNestedManyWithoutUsersInput
    user_server_vote_table?: user_server_vote_tableUncheckedCreateNestedOneWithoutUsersInput
    user_vote_table?: user_vote_tableUncheckedCreateNestedOneWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutServer_votersInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutServer_votersInput, usersUncheckedCreateWithoutServer_votersInput>
  }

  export type usersUpsertWithoutServer_votersInput = {
    update: XOR<usersUpdateWithoutServer_votersInput, usersUncheckedUpdateWithoutServer_votersInput>
    create: XOR<usersCreateWithoutServer_votersInput, usersUncheckedCreateWithoutServer_votersInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutServer_votersInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutServer_votersInput, usersUncheckedUpdateWithoutServer_votersInput>
  }

  export type usersUpdateWithoutServer_votersInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    api_token?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    badges?: usersUpdatebadgesInput | string[]
    username?: NullableStringFieldUpdateOperationsInput | string | null
    user_css?: NullableStringFieldUpdateOperationsInput | string | null
    state?: IntFieldUpdateOperationsInput | number
    coins?: NullableIntFieldUpdateOperationsInput | number | null
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    site_lang?: NullableStringFieldUpdateOperationsInput | string | null
    profile_css?: StringFieldUpdateOperationsInput | string
    vote_reminders?: usersUpdatevote_remindersInput | bigint[] | number[]
    vote_reminder_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    staff_verify_code?: NullableStringFieldUpdateOperationsInput | string | null
    vote_reminders_last_acked?: DateTimeFieldUpdateOperationsInput | Date | string
    vote_reminders_servers?: usersUpdatevote_reminders_serversInput | bigint[] | number[]
    vote_reminders_servers_last_acked?: DateTimeFieldUpdateOperationsInput | Date | string
    vote_reminder_servers_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    experiments?: usersUpdateexperimentsInput | number[]
    flags?: usersUpdateflagsInput | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    totp_shared_key?: NullableStringFieldUpdateOperationsInput | string | null
    staff_password?: NullableStringFieldUpdateOperationsInput | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
    bot_voters?: bot_votersUpdateManyWithoutUsersNestedInput
    extra_data?: extra_dataUpdateManyWithoutUsersNestedInput
    frostpaw_clients?: frostpaw_clientsUpdateManyWithoutUsersNestedInput
    leave_of_absence?: leave_of_absenceUpdateManyWithoutUsersNestedInput
    lynx_apps?: lynx_appsUpdateManyWithoutUsersNestedInput
    lynx_logs?: lynx_logsUpdateManyWithoutUsersNestedInput
    lynx_ratings?: lynx_ratingsUpdateManyWithoutUsersNestedInput
    lynx_survey_responses?: lynx_survey_responsesUpdateManyWithoutUsersNestedInput
    push_notifications?: push_notificationsUpdateManyWithoutUsersNestedInput
    review_votes?: review_votesUpdateManyWithoutUsersNestedInput
    reviews?: reviewsUpdateManyWithoutUsersNestedInput
    server_audit_logs?: server_audit_logsUpdateManyWithoutUsersNestedInput
    servers?: serversUpdateManyWithoutUsersNestedInput
    user_bot_logs?: user_bot_logsUpdateManyWithoutUsersNestedInput
    user_connections?: user_connectionsUpdateManyWithoutUsersNestedInput
    user_server_vote_table?: user_server_vote_tableUpdateOneWithoutUsersNestedInput
    user_vote_table?: user_vote_tableUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutServer_votersInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    api_token?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    badges?: usersUpdatebadgesInput | string[]
    username?: NullableStringFieldUpdateOperationsInput | string | null
    user_css?: NullableStringFieldUpdateOperationsInput | string | null
    state?: IntFieldUpdateOperationsInput | number
    coins?: NullableIntFieldUpdateOperationsInput | number | null
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    site_lang?: NullableStringFieldUpdateOperationsInput | string | null
    profile_css?: StringFieldUpdateOperationsInput | string
    vote_reminders?: usersUpdatevote_remindersInput | bigint[] | number[]
    vote_reminder_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    staff_verify_code?: NullableStringFieldUpdateOperationsInput | string | null
    vote_reminders_last_acked?: DateTimeFieldUpdateOperationsInput | Date | string
    vote_reminders_servers?: usersUpdatevote_reminders_serversInput | bigint[] | number[]
    vote_reminders_servers_last_acked?: DateTimeFieldUpdateOperationsInput | Date | string
    vote_reminder_servers_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    experiments?: usersUpdateexperimentsInput | number[]
    flags?: usersUpdateflagsInput | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    totp_shared_key?: NullableStringFieldUpdateOperationsInput | string | null
    staff_password?: NullableStringFieldUpdateOperationsInput | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
    bot_voters?: bot_votersUncheckedUpdateManyWithoutUsersNestedInput
    extra_data?: extra_dataUncheckedUpdateManyWithoutUsersNestedInput
    frostpaw_clients?: frostpaw_clientsUncheckedUpdateManyWithoutUsersNestedInput
    leave_of_absence?: leave_of_absenceUncheckedUpdateManyWithoutUsersNestedInput
    lynx_apps?: lynx_appsUncheckedUpdateManyWithoutUsersNestedInput
    lynx_logs?: lynx_logsUncheckedUpdateManyWithoutUsersNestedInput
    lynx_ratings?: lynx_ratingsUncheckedUpdateManyWithoutUsersNestedInput
    lynx_survey_responses?: lynx_survey_responsesUncheckedUpdateManyWithoutUsersNestedInput
    push_notifications?: push_notificationsUncheckedUpdateManyWithoutUsersNestedInput
    review_votes?: review_votesUncheckedUpdateManyWithoutUsersNestedInput
    reviews?: reviewsUncheckedUpdateManyWithoutUsersNestedInput
    server_audit_logs?: server_audit_logsUncheckedUpdateManyWithoutUsersNestedInput
    servers?: serversUncheckedUpdateManyWithoutUsersNestedInput
    user_bot_logs?: user_bot_logsUncheckedUpdateManyWithoutUsersNestedInput
    user_connections?: user_connectionsUncheckedUpdateManyWithoutUsersNestedInput
    user_server_vote_table?: user_server_vote_tableUncheckedUpdateOneWithoutUsersNestedInput
    user_vote_table?: user_vote_tableUncheckedUpdateOneWithoutUsersNestedInput
  }

  export type server_audit_logsCreateWithoutServersInput = {
    username: string
    user_guild_perms: string
    field: string
    value: string
    action_time?: Date | string
    action_id?: string
    lynxtag?: string
    users: usersCreateNestedOneWithoutServer_audit_logsInput
  }

  export type server_audit_logsUncheckedCreateWithoutServersInput = {
    user_id: bigint | number
    username: string
    user_guild_perms: string
    field: string
    value: string
    action_time?: Date | string
    action_id?: string
    lynxtag?: string
  }

  export type server_audit_logsCreateOrConnectWithoutServersInput = {
    where: server_audit_logsWhereUniqueInput
    create: XOR<server_audit_logsCreateWithoutServersInput, server_audit_logsUncheckedCreateWithoutServersInput>
  }

  export type server_audit_logsCreateManyServersInputEnvelope = {
    data: server_audit_logsCreateManyServersInput | server_audit_logsCreateManyServersInput[]
    skipDuplicates?: boolean
  }

  export type usersCreateWithoutServersInput = {
    user_id: bigint | number
    api_token: string
    description?: string | null
    badges?: usersCreatebadgesInput | string[]
    username?: string | null
    user_css?: string | null
    state?: number
    coins?: number | null
    id: bigint | number
    site_lang?: string | null
    profile_css?: string
    vote_reminders?: usersCreatevote_remindersInput | bigint[] | number[]
    vote_reminder_channel?: bigint | number | null
    staff_verify_code?: string | null
    vote_reminders_last_acked?: Date | string
    vote_reminders_servers?: usersCreatevote_reminders_serversInput | bigint[] | number[]
    vote_reminders_servers_last_acked?: Date | string
    vote_reminder_servers_channel?: bigint | number | null
    experiments?: usersCreateexperimentsInput | number[]
    flags?: usersCreateflagsInput | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    supabase_id?: string | null
    totp_shared_key?: string | null
    staff_password?: string | null
    lynxtag?: string
    bot_voters?: bot_votersCreateNestedManyWithoutUsersInput
    extra_data?: extra_dataCreateNestedManyWithoutUsersInput
    frostpaw_clients?: frostpaw_clientsCreateNestedManyWithoutUsersInput
    leave_of_absence?: leave_of_absenceCreateNestedManyWithoutUsersInput
    lynx_apps?: lynx_appsCreateNestedManyWithoutUsersInput
    lynx_logs?: lynx_logsCreateNestedManyWithoutUsersInput
    lynx_ratings?: lynx_ratingsCreateNestedManyWithoutUsersInput
    lynx_survey_responses?: lynx_survey_responsesCreateNestedManyWithoutUsersInput
    push_notifications?: push_notificationsCreateNestedManyWithoutUsersInput
    review_votes?: review_votesCreateNestedManyWithoutUsersInput
    reviews?: reviewsCreateNestedManyWithoutUsersInput
    server_audit_logs?: server_audit_logsCreateNestedManyWithoutUsersInput
    server_voters?: server_votersCreateNestedManyWithoutUsersInput
    user_bot_logs?: user_bot_logsCreateNestedManyWithoutUsersInput
    user_connections?: user_connectionsCreateNestedManyWithoutUsersInput
    user_server_vote_table?: user_server_vote_tableCreateNestedOneWithoutUsersInput
    user_vote_table?: user_vote_tableCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutServersInput = {
    user_id: bigint | number
    api_token: string
    description?: string | null
    badges?: usersCreatebadgesInput | string[]
    username?: string | null
    user_css?: string | null
    state?: number
    coins?: number | null
    id: bigint | number
    site_lang?: string | null
    profile_css?: string
    vote_reminders?: usersCreatevote_remindersInput | bigint[] | number[]
    vote_reminder_channel?: bigint | number | null
    staff_verify_code?: string | null
    vote_reminders_last_acked?: Date | string
    vote_reminders_servers?: usersCreatevote_reminders_serversInput | bigint[] | number[]
    vote_reminders_servers_last_acked?: Date | string
    vote_reminder_servers_channel?: bigint | number | null
    experiments?: usersCreateexperimentsInput | number[]
    flags?: usersCreateflagsInput | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    supabase_id?: string | null
    totp_shared_key?: string | null
    staff_password?: string | null
    lynxtag?: string
    bot_voters?: bot_votersUncheckedCreateNestedManyWithoutUsersInput
    extra_data?: extra_dataUncheckedCreateNestedManyWithoutUsersInput
    frostpaw_clients?: frostpaw_clientsUncheckedCreateNestedManyWithoutUsersInput
    leave_of_absence?: leave_of_absenceUncheckedCreateNestedManyWithoutUsersInput
    lynx_apps?: lynx_appsUncheckedCreateNestedManyWithoutUsersInput
    lynx_logs?: lynx_logsUncheckedCreateNestedManyWithoutUsersInput
    lynx_ratings?: lynx_ratingsUncheckedCreateNestedManyWithoutUsersInput
    lynx_survey_responses?: lynx_survey_responsesUncheckedCreateNestedManyWithoutUsersInput
    push_notifications?: push_notificationsUncheckedCreateNestedManyWithoutUsersInput
    review_votes?: review_votesUncheckedCreateNestedManyWithoutUsersInput
    reviews?: reviewsUncheckedCreateNestedManyWithoutUsersInput
    server_audit_logs?: server_audit_logsUncheckedCreateNestedManyWithoutUsersInput
    server_voters?: server_votersUncheckedCreateNestedManyWithoutUsersInput
    user_bot_logs?: user_bot_logsUncheckedCreateNestedManyWithoutUsersInput
    user_connections?: user_connectionsUncheckedCreateNestedManyWithoutUsersInput
    user_server_vote_table?: user_server_vote_tableUncheckedCreateNestedOneWithoutUsersInput
    user_vote_table?: user_vote_tableUncheckedCreateNestedOneWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutServersInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutServersInput, usersUncheckedCreateWithoutServersInput>
  }

  export type server_audit_logsUpsertWithWhereUniqueWithoutServersInput = {
    where: server_audit_logsWhereUniqueInput
    update: XOR<server_audit_logsUpdateWithoutServersInput, server_audit_logsUncheckedUpdateWithoutServersInput>
    create: XOR<server_audit_logsCreateWithoutServersInput, server_audit_logsUncheckedCreateWithoutServersInput>
  }

  export type server_audit_logsUpdateWithWhereUniqueWithoutServersInput = {
    where: server_audit_logsWhereUniqueInput
    data: XOR<server_audit_logsUpdateWithoutServersInput, server_audit_logsUncheckedUpdateWithoutServersInput>
  }

  export type server_audit_logsUpdateManyWithWhereWithoutServersInput = {
    where: server_audit_logsScalarWhereInput
    data: XOR<server_audit_logsUpdateManyMutationInput, server_audit_logsUncheckedUpdateManyWithoutServersInput>
  }

  export type server_audit_logsScalarWhereInput = {
    AND?: server_audit_logsScalarWhereInput | server_audit_logsScalarWhereInput[]
    OR?: server_audit_logsScalarWhereInput[]
    NOT?: server_audit_logsScalarWhereInput | server_audit_logsScalarWhereInput[]
    guild_id?: BigIntFilter<"server_audit_logs"> | bigint | number
    user_id?: BigIntFilter<"server_audit_logs"> | bigint | number
    username?: StringFilter<"server_audit_logs"> | string
    user_guild_perms?: StringFilter<"server_audit_logs"> | string
    field?: StringFilter<"server_audit_logs"> | string
    value?: StringFilter<"server_audit_logs"> | string
    action_time?: DateTimeFilter<"server_audit_logs"> | Date | string
    action_id?: UuidFilter<"server_audit_logs"> | string
    lynxtag?: UuidFilter<"server_audit_logs"> | string
  }

  export type usersUpsertWithoutServersInput = {
    update: XOR<usersUpdateWithoutServersInput, usersUncheckedUpdateWithoutServersInput>
    create: XOR<usersCreateWithoutServersInput, usersUncheckedCreateWithoutServersInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutServersInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutServersInput, usersUncheckedUpdateWithoutServersInput>
  }

  export type usersUpdateWithoutServersInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    api_token?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    badges?: usersUpdatebadgesInput | string[]
    username?: NullableStringFieldUpdateOperationsInput | string | null
    user_css?: NullableStringFieldUpdateOperationsInput | string | null
    state?: IntFieldUpdateOperationsInput | number
    coins?: NullableIntFieldUpdateOperationsInput | number | null
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    site_lang?: NullableStringFieldUpdateOperationsInput | string | null
    profile_css?: StringFieldUpdateOperationsInput | string
    vote_reminders?: usersUpdatevote_remindersInput | bigint[] | number[]
    vote_reminder_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    staff_verify_code?: NullableStringFieldUpdateOperationsInput | string | null
    vote_reminders_last_acked?: DateTimeFieldUpdateOperationsInput | Date | string
    vote_reminders_servers?: usersUpdatevote_reminders_serversInput | bigint[] | number[]
    vote_reminders_servers_last_acked?: DateTimeFieldUpdateOperationsInput | Date | string
    vote_reminder_servers_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    experiments?: usersUpdateexperimentsInput | number[]
    flags?: usersUpdateflagsInput | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    totp_shared_key?: NullableStringFieldUpdateOperationsInput | string | null
    staff_password?: NullableStringFieldUpdateOperationsInput | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
    bot_voters?: bot_votersUpdateManyWithoutUsersNestedInput
    extra_data?: extra_dataUpdateManyWithoutUsersNestedInput
    frostpaw_clients?: frostpaw_clientsUpdateManyWithoutUsersNestedInput
    leave_of_absence?: leave_of_absenceUpdateManyWithoutUsersNestedInput
    lynx_apps?: lynx_appsUpdateManyWithoutUsersNestedInput
    lynx_logs?: lynx_logsUpdateManyWithoutUsersNestedInput
    lynx_ratings?: lynx_ratingsUpdateManyWithoutUsersNestedInput
    lynx_survey_responses?: lynx_survey_responsesUpdateManyWithoutUsersNestedInput
    push_notifications?: push_notificationsUpdateManyWithoutUsersNestedInput
    review_votes?: review_votesUpdateManyWithoutUsersNestedInput
    reviews?: reviewsUpdateManyWithoutUsersNestedInput
    server_audit_logs?: server_audit_logsUpdateManyWithoutUsersNestedInput
    server_voters?: server_votersUpdateManyWithoutUsersNestedInput
    user_bot_logs?: user_bot_logsUpdateManyWithoutUsersNestedInput
    user_connections?: user_connectionsUpdateManyWithoutUsersNestedInput
    user_server_vote_table?: user_server_vote_tableUpdateOneWithoutUsersNestedInput
    user_vote_table?: user_vote_tableUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutServersInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    api_token?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    badges?: usersUpdatebadgesInput | string[]
    username?: NullableStringFieldUpdateOperationsInput | string | null
    user_css?: NullableStringFieldUpdateOperationsInput | string | null
    state?: IntFieldUpdateOperationsInput | number
    coins?: NullableIntFieldUpdateOperationsInput | number | null
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    site_lang?: NullableStringFieldUpdateOperationsInput | string | null
    profile_css?: StringFieldUpdateOperationsInput | string
    vote_reminders?: usersUpdatevote_remindersInput | bigint[] | number[]
    vote_reminder_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    staff_verify_code?: NullableStringFieldUpdateOperationsInput | string | null
    vote_reminders_last_acked?: DateTimeFieldUpdateOperationsInput | Date | string
    vote_reminders_servers?: usersUpdatevote_reminders_serversInput | bigint[] | number[]
    vote_reminders_servers_last_acked?: DateTimeFieldUpdateOperationsInput | Date | string
    vote_reminder_servers_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    experiments?: usersUpdateexperimentsInput | number[]
    flags?: usersUpdateflagsInput | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    totp_shared_key?: NullableStringFieldUpdateOperationsInput | string | null
    staff_password?: NullableStringFieldUpdateOperationsInput | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
    bot_voters?: bot_votersUncheckedUpdateManyWithoutUsersNestedInput
    extra_data?: extra_dataUncheckedUpdateManyWithoutUsersNestedInput
    frostpaw_clients?: frostpaw_clientsUncheckedUpdateManyWithoutUsersNestedInput
    leave_of_absence?: leave_of_absenceUncheckedUpdateManyWithoutUsersNestedInput
    lynx_apps?: lynx_appsUncheckedUpdateManyWithoutUsersNestedInput
    lynx_logs?: lynx_logsUncheckedUpdateManyWithoutUsersNestedInput
    lynx_ratings?: lynx_ratingsUncheckedUpdateManyWithoutUsersNestedInput
    lynx_survey_responses?: lynx_survey_responsesUncheckedUpdateManyWithoutUsersNestedInput
    push_notifications?: push_notificationsUncheckedUpdateManyWithoutUsersNestedInput
    review_votes?: review_votesUncheckedUpdateManyWithoutUsersNestedInput
    reviews?: reviewsUncheckedUpdateManyWithoutUsersNestedInput
    server_audit_logs?: server_audit_logsUncheckedUpdateManyWithoutUsersNestedInput
    server_voters?: server_votersUncheckedUpdateManyWithoutUsersNestedInput
    user_bot_logs?: user_bot_logsUncheckedUpdateManyWithoutUsersNestedInput
    user_connections?: user_connectionsUncheckedUpdateManyWithoutUsersNestedInput
    user_server_vote_table?: user_server_vote_tableUncheckedUpdateOneWithoutUsersNestedInput
    user_vote_table?: user_vote_tableUncheckedUpdateOneWithoutUsersNestedInput
  }

  export type usersCreateWithoutUser_bot_logsInput = {
    user_id: bigint | number
    api_token: string
    description?: string | null
    badges?: usersCreatebadgesInput | string[]
    username?: string | null
    user_css?: string | null
    state?: number
    coins?: number | null
    id: bigint | number
    site_lang?: string | null
    profile_css?: string
    vote_reminders?: usersCreatevote_remindersInput | bigint[] | number[]
    vote_reminder_channel?: bigint | number | null
    staff_verify_code?: string | null
    vote_reminders_last_acked?: Date | string
    vote_reminders_servers?: usersCreatevote_reminders_serversInput | bigint[] | number[]
    vote_reminders_servers_last_acked?: Date | string
    vote_reminder_servers_channel?: bigint | number | null
    experiments?: usersCreateexperimentsInput | number[]
    flags?: usersCreateflagsInput | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    supabase_id?: string | null
    totp_shared_key?: string | null
    staff_password?: string | null
    lynxtag?: string
    bot_voters?: bot_votersCreateNestedManyWithoutUsersInput
    extra_data?: extra_dataCreateNestedManyWithoutUsersInput
    frostpaw_clients?: frostpaw_clientsCreateNestedManyWithoutUsersInput
    leave_of_absence?: leave_of_absenceCreateNestedManyWithoutUsersInput
    lynx_apps?: lynx_appsCreateNestedManyWithoutUsersInput
    lynx_logs?: lynx_logsCreateNestedManyWithoutUsersInput
    lynx_ratings?: lynx_ratingsCreateNestedManyWithoutUsersInput
    lynx_survey_responses?: lynx_survey_responsesCreateNestedManyWithoutUsersInput
    push_notifications?: push_notificationsCreateNestedManyWithoutUsersInput
    review_votes?: review_votesCreateNestedManyWithoutUsersInput
    reviews?: reviewsCreateNestedManyWithoutUsersInput
    server_audit_logs?: server_audit_logsCreateNestedManyWithoutUsersInput
    server_voters?: server_votersCreateNestedManyWithoutUsersInput
    servers?: serversCreateNestedManyWithoutUsersInput
    user_connections?: user_connectionsCreateNestedManyWithoutUsersInput
    user_server_vote_table?: user_server_vote_tableCreateNestedOneWithoutUsersInput
    user_vote_table?: user_vote_tableCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutUser_bot_logsInput = {
    user_id: bigint | number
    api_token: string
    description?: string | null
    badges?: usersCreatebadgesInput | string[]
    username?: string | null
    user_css?: string | null
    state?: number
    coins?: number | null
    id: bigint | number
    site_lang?: string | null
    profile_css?: string
    vote_reminders?: usersCreatevote_remindersInput | bigint[] | number[]
    vote_reminder_channel?: bigint | number | null
    staff_verify_code?: string | null
    vote_reminders_last_acked?: Date | string
    vote_reminders_servers?: usersCreatevote_reminders_serversInput | bigint[] | number[]
    vote_reminders_servers_last_acked?: Date | string
    vote_reminder_servers_channel?: bigint | number | null
    experiments?: usersCreateexperimentsInput | number[]
    flags?: usersCreateflagsInput | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    supabase_id?: string | null
    totp_shared_key?: string | null
    staff_password?: string | null
    lynxtag?: string
    bot_voters?: bot_votersUncheckedCreateNestedManyWithoutUsersInput
    extra_data?: extra_dataUncheckedCreateNestedManyWithoutUsersInput
    frostpaw_clients?: frostpaw_clientsUncheckedCreateNestedManyWithoutUsersInput
    leave_of_absence?: leave_of_absenceUncheckedCreateNestedManyWithoutUsersInput
    lynx_apps?: lynx_appsUncheckedCreateNestedManyWithoutUsersInput
    lynx_logs?: lynx_logsUncheckedCreateNestedManyWithoutUsersInput
    lynx_ratings?: lynx_ratingsUncheckedCreateNestedManyWithoutUsersInput
    lynx_survey_responses?: lynx_survey_responsesUncheckedCreateNestedManyWithoutUsersInput
    push_notifications?: push_notificationsUncheckedCreateNestedManyWithoutUsersInput
    review_votes?: review_votesUncheckedCreateNestedManyWithoutUsersInput
    reviews?: reviewsUncheckedCreateNestedManyWithoutUsersInput
    server_audit_logs?: server_audit_logsUncheckedCreateNestedManyWithoutUsersInput
    server_voters?: server_votersUncheckedCreateNestedManyWithoutUsersInput
    servers?: serversUncheckedCreateNestedManyWithoutUsersInput
    user_connections?: user_connectionsUncheckedCreateNestedManyWithoutUsersInput
    user_server_vote_table?: user_server_vote_tableUncheckedCreateNestedOneWithoutUsersInput
    user_vote_table?: user_vote_tableUncheckedCreateNestedOneWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutUser_bot_logsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutUser_bot_logsInput, usersUncheckedCreateWithoutUser_bot_logsInput>
  }

  export type usersUpsertWithoutUser_bot_logsInput = {
    update: XOR<usersUpdateWithoutUser_bot_logsInput, usersUncheckedUpdateWithoutUser_bot_logsInput>
    create: XOR<usersCreateWithoutUser_bot_logsInput, usersUncheckedCreateWithoutUser_bot_logsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutUser_bot_logsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutUser_bot_logsInput, usersUncheckedUpdateWithoutUser_bot_logsInput>
  }

  export type usersUpdateWithoutUser_bot_logsInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    api_token?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    badges?: usersUpdatebadgesInput | string[]
    username?: NullableStringFieldUpdateOperationsInput | string | null
    user_css?: NullableStringFieldUpdateOperationsInput | string | null
    state?: IntFieldUpdateOperationsInput | number
    coins?: NullableIntFieldUpdateOperationsInput | number | null
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    site_lang?: NullableStringFieldUpdateOperationsInput | string | null
    profile_css?: StringFieldUpdateOperationsInput | string
    vote_reminders?: usersUpdatevote_remindersInput | bigint[] | number[]
    vote_reminder_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    staff_verify_code?: NullableStringFieldUpdateOperationsInput | string | null
    vote_reminders_last_acked?: DateTimeFieldUpdateOperationsInput | Date | string
    vote_reminders_servers?: usersUpdatevote_reminders_serversInput | bigint[] | number[]
    vote_reminders_servers_last_acked?: DateTimeFieldUpdateOperationsInput | Date | string
    vote_reminder_servers_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    experiments?: usersUpdateexperimentsInput | number[]
    flags?: usersUpdateflagsInput | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    totp_shared_key?: NullableStringFieldUpdateOperationsInput | string | null
    staff_password?: NullableStringFieldUpdateOperationsInput | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
    bot_voters?: bot_votersUpdateManyWithoutUsersNestedInput
    extra_data?: extra_dataUpdateManyWithoutUsersNestedInput
    frostpaw_clients?: frostpaw_clientsUpdateManyWithoutUsersNestedInput
    leave_of_absence?: leave_of_absenceUpdateManyWithoutUsersNestedInput
    lynx_apps?: lynx_appsUpdateManyWithoutUsersNestedInput
    lynx_logs?: lynx_logsUpdateManyWithoutUsersNestedInput
    lynx_ratings?: lynx_ratingsUpdateManyWithoutUsersNestedInput
    lynx_survey_responses?: lynx_survey_responsesUpdateManyWithoutUsersNestedInput
    push_notifications?: push_notificationsUpdateManyWithoutUsersNestedInput
    review_votes?: review_votesUpdateManyWithoutUsersNestedInput
    reviews?: reviewsUpdateManyWithoutUsersNestedInput
    server_audit_logs?: server_audit_logsUpdateManyWithoutUsersNestedInput
    server_voters?: server_votersUpdateManyWithoutUsersNestedInput
    servers?: serversUpdateManyWithoutUsersNestedInput
    user_connections?: user_connectionsUpdateManyWithoutUsersNestedInput
    user_server_vote_table?: user_server_vote_tableUpdateOneWithoutUsersNestedInput
    user_vote_table?: user_vote_tableUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutUser_bot_logsInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    api_token?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    badges?: usersUpdatebadgesInput | string[]
    username?: NullableStringFieldUpdateOperationsInput | string | null
    user_css?: NullableStringFieldUpdateOperationsInput | string | null
    state?: IntFieldUpdateOperationsInput | number
    coins?: NullableIntFieldUpdateOperationsInput | number | null
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    site_lang?: NullableStringFieldUpdateOperationsInput | string | null
    profile_css?: StringFieldUpdateOperationsInput | string
    vote_reminders?: usersUpdatevote_remindersInput | bigint[] | number[]
    vote_reminder_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    staff_verify_code?: NullableStringFieldUpdateOperationsInput | string | null
    vote_reminders_last_acked?: DateTimeFieldUpdateOperationsInput | Date | string
    vote_reminders_servers?: usersUpdatevote_reminders_serversInput | bigint[] | number[]
    vote_reminders_servers_last_acked?: DateTimeFieldUpdateOperationsInput | Date | string
    vote_reminder_servers_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    experiments?: usersUpdateexperimentsInput | number[]
    flags?: usersUpdateflagsInput | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    totp_shared_key?: NullableStringFieldUpdateOperationsInput | string | null
    staff_password?: NullableStringFieldUpdateOperationsInput | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
    bot_voters?: bot_votersUncheckedUpdateManyWithoutUsersNestedInput
    extra_data?: extra_dataUncheckedUpdateManyWithoutUsersNestedInput
    frostpaw_clients?: frostpaw_clientsUncheckedUpdateManyWithoutUsersNestedInput
    leave_of_absence?: leave_of_absenceUncheckedUpdateManyWithoutUsersNestedInput
    lynx_apps?: lynx_appsUncheckedUpdateManyWithoutUsersNestedInput
    lynx_logs?: lynx_logsUncheckedUpdateManyWithoutUsersNestedInput
    lynx_ratings?: lynx_ratingsUncheckedUpdateManyWithoutUsersNestedInput
    lynx_survey_responses?: lynx_survey_responsesUncheckedUpdateManyWithoutUsersNestedInput
    push_notifications?: push_notificationsUncheckedUpdateManyWithoutUsersNestedInput
    review_votes?: review_votesUncheckedUpdateManyWithoutUsersNestedInput
    reviews?: reviewsUncheckedUpdateManyWithoutUsersNestedInput
    server_audit_logs?: server_audit_logsUncheckedUpdateManyWithoutUsersNestedInput
    server_voters?: server_votersUncheckedUpdateManyWithoutUsersNestedInput
    servers?: serversUncheckedUpdateManyWithoutUsersNestedInput
    user_connections?: user_connectionsUncheckedUpdateManyWithoutUsersNestedInput
    user_server_vote_table?: user_server_vote_tableUncheckedUpdateOneWithoutUsersNestedInput
    user_vote_table?: user_vote_tableUncheckedUpdateOneWithoutUsersNestedInput
  }

  export type usersCreateWithoutUser_connectionsInput = {
    user_id: bigint | number
    api_token: string
    description?: string | null
    badges?: usersCreatebadgesInput | string[]
    username?: string | null
    user_css?: string | null
    state?: number
    coins?: number | null
    id: bigint | number
    site_lang?: string | null
    profile_css?: string
    vote_reminders?: usersCreatevote_remindersInput | bigint[] | number[]
    vote_reminder_channel?: bigint | number | null
    staff_verify_code?: string | null
    vote_reminders_last_acked?: Date | string
    vote_reminders_servers?: usersCreatevote_reminders_serversInput | bigint[] | number[]
    vote_reminders_servers_last_acked?: Date | string
    vote_reminder_servers_channel?: bigint | number | null
    experiments?: usersCreateexperimentsInput | number[]
    flags?: usersCreateflagsInput | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    supabase_id?: string | null
    totp_shared_key?: string | null
    staff_password?: string | null
    lynxtag?: string
    bot_voters?: bot_votersCreateNestedManyWithoutUsersInput
    extra_data?: extra_dataCreateNestedManyWithoutUsersInput
    frostpaw_clients?: frostpaw_clientsCreateNestedManyWithoutUsersInput
    leave_of_absence?: leave_of_absenceCreateNestedManyWithoutUsersInput
    lynx_apps?: lynx_appsCreateNestedManyWithoutUsersInput
    lynx_logs?: lynx_logsCreateNestedManyWithoutUsersInput
    lynx_ratings?: lynx_ratingsCreateNestedManyWithoutUsersInput
    lynx_survey_responses?: lynx_survey_responsesCreateNestedManyWithoutUsersInput
    push_notifications?: push_notificationsCreateNestedManyWithoutUsersInput
    review_votes?: review_votesCreateNestedManyWithoutUsersInput
    reviews?: reviewsCreateNestedManyWithoutUsersInput
    server_audit_logs?: server_audit_logsCreateNestedManyWithoutUsersInput
    server_voters?: server_votersCreateNestedManyWithoutUsersInput
    servers?: serversCreateNestedManyWithoutUsersInput
    user_bot_logs?: user_bot_logsCreateNestedManyWithoutUsersInput
    user_server_vote_table?: user_server_vote_tableCreateNestedOneWithoutUsersInput
    user_vote_table?: user_vote_tableCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutUser_connectionsInput = {
    user_id: bigint | number
    api_token: string
    description?: string | null
    badges?: usersCreatebadgesInput | string[]
    username?: string | null
    user_css?: string | null
    state?: number
    coins?: number | null
    id: bigint | number
    site_lang?: string | null
    profile_css?: string
    vote_reminders?: usersCreatevote_remindersInput | bigint[] | number[]
    vote_reminder_channel?: bigint | number | null
    staff_verify_code?: string | null
    vote_reminders_last_acked?: Date | string
    vote_reminders_servers?: usersCreatevote_reminders_serversInput | bigint[] | number[]
    vote_reminders_servers_last_acked?: Date | string
    vote_reminder_servers_channel?: bigint | number | null
    experiments?: usersCreateexperimentsInput | number[]
    flags?: usersCreateflagsInput | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    supabase_id?: string | null
    totp_shared_key?: string | null
    staff_password?: string | null
    lynxtag?: string
    bot_voters?: bot_votersUncheckedCreateNestedManyWithoutUsersInput
    extra_data?: extra_dataUncheckedCreateNestedManyWithoutUsersInput
    frostpaw_clients?: frostpaw_clientsUncheckedCreateNestedManyWithoutUsersInput
    leave_of_absence?: leave_of_absenceUncheckedCreateNestedManyWithoutUsersInput
    lynx_apps?: lynx_appsUncheckedCreateNestedManyWithoutUsersInput
    lynx_logs?: lynx_logsUncheckedCreateNestedManyWithoutUsersInput
    lynx_ratings?: lynx_ratingsUncheckedCreateNestedManyWithoutUsersInput
    lynx_survey_responses?: lynx_survey_responsesUncheckedCreateNestedManyWithoutUsersInput
    push_notifications?: push_notificationsUncheckedCreateNestedManyWithoutUsersInput
    review_votes?: review_votesUncheckedCreateNestedManyWithoutUsersInput
    reviews?: reviewsUncheckedCreateNestedManyWithoutUsersInput
    server_audit_logs?: server_audit_logsUncheckedCreateNestedManyWithoutUsersInput
    server_voters?: server_votersUncheckedCreateNestedManyWithoutUsersInput
    servers?: serversUncheckedCreateNestedManyWithoutUsersInput
    user_bot_logs?: user_bot_logsUncheckedCreateNestedManyWithoutUsersInput
    user_server_vote_table?: user_server_vote_tableUncheckedCreateNestedOneWithoutUsersInput
    user_vote_table?: user_vote_tableUncheckedCreateNestedOneWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutUser_connectionsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutUser_connectionsInput, usersUncheckedCreateWithoutUser_connectionsInput>
  }

  export type usersUpsertWithoutUser_connectionsInput = {
    update: XOR<usersUpdateWithoutUser_connectionsInput, usersUncheckedUpdateWithoutUser_connectionsInput>
    create: XOR<usersCreateWithoutUser_connectionsInput, usersUncheckedCreateWithoutUser_connectionsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutUser_connectionsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutUser_connectionsInput, usersUncheckedUpdateWithoutUser_connectionsInput>
  }

  export type usersUpdateWithoutUser_connectionsInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    api_token?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    badges?: usersUpdatebadgesInput | string[]
    username?: NullableStringFieldUpdateOperationsInput | string | null
    user_css?: NullableStringFieldUpdateOperationsInput | string | null
    state?: IntFieldUpdateOperationsInput | number
    coins?: NullableIntFieldUpdateOperationsInput | number | null
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    site_lang?: NullableStringFieldUpdateOperationsInput | string | null
    profile_css?: StringFieldUpdateOperationsInput | string
    vote_reminders?: usersUpdatevote_remindersInput | bigint[] | number[]
    vote_reminder_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    staff_verify_code?: NullableStringFieldUpdateOperationsInput | string | null
    vote_reminders_last_acked?: DateTimeFieldUpdateOperationsInput | Date | string
    vote_reminders_servers?: usersUpdatevote_reminders_serversInput | bigint[] | number[]
    vote_reminders_servers_last_acked?: DateTimeFieldUpdateOperationsInput | Date | string
    vote_reminder_servers_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    experiments?: usersUpdateexperimentsInput | number[]
    flags?: usersUpdateflagsInput | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    totp_shared_key?: NullableStringFieldUpdateOperationsInput | string | null
    staff_password?: NullableStringFieldUpdateOperationsInput | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
    bot_voters?: bot_votersUpdateManyWithoutUsersNestedInput
    extra_data?: extra_dataUpdateManyWithoutUsersNestedInput
    frostpaw_clients?: frostpaw_clientsUpdateManyWithoutUsersNestedInput
    leave_of_absence?: leave_of_absenceUpdateManyWithoutUsersNestedInput
    lynx_apps?: lynx_appsUpdateManyWithoutUsersNestedInput
    lynx_logs?: lynx_logsUpdateManyWithoutUsersNestedInput
    lynx_ratings?: lynx_ratingsUpdateManyWithoutUsersNestedInput
    lynx_survey_responses?: lynx_survey_responsesUpdateManyWithoutUsersNestedInput
    push_notifications?: push_notificationsUpdateManyWithoutUsersNestedInput
    review_votes?: review_votesUpdateManyWithoutUsersNestedInput
    reviews?: reviewsUpdateManyWithoutUsersNestedInput
    server_audit_logs?: server_audit_logsUpdateManyWithoutUsersNestedInput
    server_voters?: server_votersUpdateManyWithoutUsersNestedInput
    servers?: serversUpdateManyWithoutUsersNestedInput
    user_bot_logs?: user_bot_logsUpdateManyWithoutUsersNestedInput
    user_server_vote_table?: user_server_vote_tableUpdateOneWithoutUsersNestedInput
    user_vote_table?: user_vote_tableUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutUser_connectionsInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    api_token?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    badges?: usersUpdatebadgesInput | string[]
    username?: NullableStringFieldUpdateOperationsInput | string | null
    user_css?: NullableStringFieldUpdateOperationsInput | string | null
    state?: IntFieldUpdateOperationsInput | number
    coins?: NullableIntFieldUpdateOperationsInput | number | null
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    site_lang?: NullableStringFieldUpdateOperationsInput | string | null
    profile_css?: StringFieldUpdateOperationsInput | string
    vote_reminders?: usersUpdatevote_remindersInput | bigint[] | number[]
    vote_reminder_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    staff_verify_code?: NullableStringFieldUpdateOperationsInput | string | null
    vote_reminders_last_acked?: DateTimeFieldUpdateOperationsInput | Date | string
    vote_reminders_servers?: usersUpdatevote_reminders_serversInput | bigint[] | number[]
    vote_reminders_servers_last_acked?: DateTimeFieldUpdateOperationsInput | Date | string
    vote_reminder_servers_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    experiments?: usersUpdateexperimentsInput | number[]
    flags?: usersUpdateflagsInput | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    totp_shared_key?: NullableStringFieldUpdateOperationsInput | string | null
    staff_password?: NullableStringFieldUpdateOperationsInput | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
    bot_voters?: bot_votersUncheckedUpdateManyWithoutUsersNestedInput
    extra_data?: extra_dataUncheckedUpdateManyWithoutUsersNestedInput
    frostpaw_clients?: frostpaw_clientsUncheckedUpdateManyWithoutUsersNestedInput
    leave_of_absence?: leave_of_absenceUncheckedUpdateManyWithoutUsersNestedInput
    lynx_apps?: lynx_appsUncheckedUpdateManyWithoutUsersNestedInput
    lynx_logs?: lynx_logsUncheckedUpdateManyWithoutUsersNestedInput
    lynx_ratings?: lynx_ratingsUncheckedUpdateManyWithoutUsersNestedInput
    lynx_survey_responses?: lynx_survey_responsesUncheckedUpdateManyWithoutUsersNestedInput
    push_notifications?: push_notificationsUncheckedUpdateManyWithoutUsersNestedInput
    review_votes?: review_votesUncheckedUpdateManyWithoutUsersNestedInput
    reviews?: reviewsUncheckedUpdateManyWithoutUsersNestedInput
    server_audit_logs?: server_audit_logsUncheckedUpdateManyWithoutUsersNestedInput
    server_voters?: server_votersUncheckedUpdateManyWithoutUsersNestedInput
    servers?: serversUncheckedUpdateManyWithoutUsersNestedInput
    user_bot_logs?: user_bot_logsUncheckedUpdateManyWithoutUsersNestedInput
    user_server_vote_table?: user_server_vote_tableUncheckedUpdateOneWithoutUsersNestedInput
    user_vote_table?: user_vote_tableUncheckedUpdateOneWithoutUsersNestedInput
  }

  export type usersCreateWithoutUser_server_vote_tableInput = {
    user_id: bigint | number
    api_token: string
    description?: string | null
    badges?: usersCreatebadgesInput | string[]
    username?: string | null
    user_css?: string | null
    state?: number
    coins?: number | null
    id: bigint | number
    site_lang?: string | null
    profile_css?: string
    vote_reminders?: usersCreatevote_remindersInput | bigint[] | number[]
    vote_reminder_channel?: bigint | number | null
    staff_verify_code?: string | null
    vote_reminders_last_acked?: Date | string
    vote_reminders_servers?: usersCreatevote_reminders_serversInput | bigint[] | number[]
    vote_reminders_servers_last_acked?: Date | string
    vote_reminder_servers_channel?: bigint | number | null
    experiments?: usersCreateexperimentsInput | number[]
    flags?: usersCreateflagsInput | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    supabase_id?: string | null
    totp_shared_key?: string | null
    staff_password?: string | null
    lynxtag?: string
    bot_voters?: bot_votersCreateNestedManyWithoutUsersInput
    extra_data?: extra_dataCreateNestedManyWithoutUsersInput
    frostpaw_clients?: frostpaw_clientsCreateNestedManyWithoutUsersInput
    leave_of_absence?: leave_of_absenceCreateNestedManyWithoutUsersInput
    lynx_apps?: lynx_appsCreateNestedManyWithoutUsersInput
    lynx_logs?: lynx_logsCreateNestedManyWithoutUsersInput
    lynx_ratings?: lynx_ratingsCreateNestedManyWithoutUsersInput
    lynx_survey_responses?: lynx_survey_responsesCreateNestedManyWithoutUsersInput
    push_notifications?: push_notificationsCreateNestedManyWithoutUsersInput
    review_votes?: review_votesCreateNestedManyWithoutUsersInput
    reviews?: reviewsCreateNestedManyWithoutUsersInput
    server_audit_logs?: server_audit_logsCreateNestedManyWithoutUsersInput
    server_voters?: server_votersCreateNestedManyWithoutUsersInput
    servers?: serversCreateNestedManyWithoutUsersInput
    user_bot_logs?: user_bot_logsCreateNestedManyWithoutUsersInput
    user_connections?: user_connectionsCreateNestedManyWithoutUsersInput
    user_vote_table?: user_vote_tableCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutUser_server_vote_tableInput = {
    user_id: bigint | number
    api_token: string
    description?: string | null
    badges?: usersCreatebadgesInput | string[]
    username?: string | null
    user_css?: string | null
    state?: number
    coins?: number | null
    id: bigint | number
    site_lang?: string | null
    profile_css?: string
    vote_reminders?: usersCreatevote_remindersInput | bigint[] | number[]
    vote_reminder_channel?: bigint | number | null
    staff_verify_code?: string | null
    vote_reminders_last_acked?: Date | string
    vote_reminders_servers?: usersCreatevote_reminders_serversInput | bigint[] | number[]
    vote_reminders_servers_last_acked?: Date | string
    vote_reminder_servers_channel?: bigint | number | null
    experiments?: usersCreateexperimentsInput | number[]
    flags?: usersCreateflagsInput | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    supabase_id?: string | null
    totp_shared_key?: string | null
    staff_password?: string | null
    lynxtag?: string
    bot_voters?: bot_votersUncheckedCreateNestedManyWithoutUsersInput
    extra_data?: extra_dataUncheckedCreateNestedManyWithoutUsersInput
    frostpaw_clients?: frostpaw_clientsUncheckedCreateNestedManyWithoutUsersInput
    leave_of_absence?: leave_of_absenceUncheckedCreateNestedManyWithoutUsersInput
    lynx_apps?: lynx_appsUncheckedCreateNestedManyWithoutUsersInput
    lynx_logs?: lynx_logsUncheckedCreateNestedManyWithoutUsersInput
    lynx_ratings?: lynx_ratingsUncheckedCreateNestedManyWithoutUsersInput
    lynx_survey_responses?: lynx_survey_responsesUncheckedCreateNestedManyWithoutUsersInput
    push_notifications?: push_notificationsUncheckedCreateNestedManyWithoutUsersInput
    review_votes?: review_votesUncheckedCreateNestedManyWithoutUsersInput
    reviews?: reviewsUncheckedCreateNestedManyWithoutUsersInput
    server_audit_logs?: server_audit_logsUncheckedCreateNestedManyWithoutUsersInput
    server_voters?: server_votersUncheckedCreateNestedManyWithoutUsersInput
    servers?: serversUncheckedCreateNestedManyWithoutUsersInput
    user_bot_logs?: user_bot_logsUncheckedCreateNestedManyWithoutUsersInput
    user_connections?: user_connectionsUncheckedCreateNestedManyWithoutUsersInput
    user_vote_table?: user_vote_tableUncheckedCreateNestedOneWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutUser_server_vote_tableInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutUser_server_vote_tableInput, usersUncheckedCreateWithoutUser_server_vote_tableInput>
  }

  export type usersUpsertWithoutUser_server_vote_tableInput = {
    update: XOR<usersUpdateWithoutUser_server_vote_tableInput, usersUncheckedUpdateWithoutUser_server_vote_tableInput>
    create: XOR<usersCreateWithoutUser_server_vote_tableInput, usersUncheckedCreateWithoutUser_server_vote_tableInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutUser_server_vote_tableInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutUser_server_vote_tableInput, usersUncheckedUpdateWithoutUser_server_vote_tableInput>
  }

  export type usersUpdateWithoutUser_server_vote_tableInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    api_token?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    badges?: usersUpdatebadgesInput | string[]
    username?: NullableStringFieldUpdateOperationsInput | string | null
    user_css?: NullableStringFieldUpdateOperationsInput | string | null
    state?: IntFieldUpdateOperationsInput | number
    coins?: NullableIntFieldUpdateOperationsInput | number | null
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    site_lang?: NullableStringFieldUpdateOperationsInput | string | null
    profile_css?: StringFieldUpdateOperationsInput | string
    vote_reminders?: usersUpdatevote_remindersInput | bigint[] | number[]
    vote_reminder_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    staff_verify_code?: NullableStringFieldUpdateOperationsInput | string | null
    vote_reminders_last_acked?: DateTimeFieldUpdateOperationsInput | Date | string
    vote_reminders_servers?: usersUpdatevote_reminders_serversInput | bigint[] | number[]
    vote_reminders_servers_last_acked?: DateTimeFieldUpdateOperationsInput | Date | string
    vote_reminder_servers_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    experiments?: usersUpdateexperimentsInput | number[]
    flags?: usersUpdateflagsInput | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    totp_shared_key?: NullableStringFieldUpdateOperationsInput | string | null
    staff_password?: NullableStringFieldUpdateOperationsInput | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
    bot_voters?: bot_votersUpdateManyWithoutUsersNestedInput
    extra_data?: extra_dataUpdateManyWithoutUsersNestedInput
    frostpaw_clients?: frostpaw_clientsUpdateManyWithoutUsersNestedInput
    leave_of_absence?: leave_of_absenceUpdateManyWithoutUsersNestedInput
    lynx_apps?: lynx_appsUpdateManyWithoutUsersNestedInput
    lynx_logs?: lynx_logsUpdateManyWithoutUsersNestedInput
    lynx_ratings?: lynx_ratingsUpdateManyWithoutUsersNestedInput
    lynx_survey_responses?: lynx_survey_responsesUpdateManyWithoutUsersNestedInput
    push_notifications?: push_notificationsUpdateManyWithoutUsersNestedInput
    review_votes?: review_votesUpdateManyWithoutUsersNestedInput
    reviews?: reviewsUpdateManyWithoutUsersNestedInput
    server_audit_logs?: server_audit_logsUpdateManyWithoutUsersNestedInput
    server_voters?: server_votersUpdateManyWithoutUsersNestedInput
    servers?: serversUpdateManyWithoutUsersNestedInput
    user_bot_logs?: user_bot_logsUpdateManyWithoutUsersNestedInput
    user_connections?: user_connectionsUpdateManyWithoutUsersNestedInput
    user_vote_table?: user_vote_tableUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutUser_server_vote_tableInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    api_token?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    badges?: usersUpdatebadgesInput | string[]
    username?: NullableStringFieldUpdateOperationsInput | string | null
    user_css?: NullableStringFieldUpdateOperationsInput | string | null
    state?: IntFieldUpdateOperationsInput | number
    coins?: NullableIntFieldUpdateOperationsInput | number | null
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    site_lang?: NullableStringFieldUpdateOperationsInput | string | null
    profile_css?: StringFieldUpdateOperationsInput | string
    vote_reminders?: usersUpdatevote_remindersInput | bigint[] | number[]
    vote_reminder_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    staff_verify_code?: NullableStringFieldUpdateOperationsInput | string | null
    vote_reminders_last_acked?: DateTimeFieldUpdateOperationsInput | Date | string
    vote_reminders_servers?: usersUpdatevote_reminders_serversInput | bigint[] | number[]
    vote_reminders_servers_last_acked?: DateTimeFieldUpdateOperationsInput | Date | string
    vote_reminder_servers_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    experiments?: usersUpdateexperimentsInput | number[]
    flags?: usersUpdateflagsInput | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    totp_shared_key?: NullableStringFieldUpdateOperationsInput | string | null
    staff_password?: NullableStringFieldUpdateOperationsInput | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
    bot_voters?: bot_votersUncheckedUpdateManyWithoutUsersNestedInput
    extra_data?: extra_dataUncheckedUpdateManyWithoutUsersNestedInput
    frostpaw_clients?: frostpaw_clientsUncheckedUpdateManyWithoutUsersNestedInput
    leave_of_absence?: leave_of_absenceUncheckedUpdateManyWithoutUsersNestedInput
    lynx_apps?: lynx_appsUncheckedUpdateManyWithoutUsersNestedInput
    lynx_logs?: lynx_logsUncheckedUpdateManyWithoutUsersNestedInput
    lynx_ratings?: lynx_ratingsUncheckedUpdateManyWithoutUsersNestedInput
    lynx_survey_responses?: lynx_survey_responsesUncheckedUpdateManyWithoutUsersNestedInput
    push_notifications?: push_notificationsUncheckedUpdateManyWithoutUsersNestedInput
    review_votes?: review_votesUncheckedUpdateManyWithoutUsersNestedInput
    reviews?: reviewsUncheckedUpdateManyWithoutUsersNestedInput
    server_audit_logs?: server_audit_logsUncheckedUpdateManyWithoutUsersNestedInput
    server_voters?: server_votersUncheckedUpdateManyWithoutUsersNestedInput
    servers?: serversUncheckedUpdateManyWithoutUsersNestedInput
    user_bot_logs?: user_bot_logsUncheckedUpdateManyWithoutUsersNestedInput
    user_connections?: user_connectionsUncheckedUpdateManyWithoutUsersNestedInput
    user_vote_table?: user_vote_tableUncheckedUpdateOneWithoutUsersNestedInput
  }

  export type usersCreateWithoutUser_vote_tableInput = {
    user_id: bigint | number
    api_token: string
    description?: string | null
    badges?: usersCreatebadgesInput | string[]
    username?: string | null
    user_css?: string | null
    state?: number
    coins?: number | null
    id: bigint | number
    site_lang?: string | null
    profile_css?: string
    vote_reminders?: usersCreatevote_remindersInput | bigint[] | number[]
    vote_reminder_channel?: bigint | number | null
    staff_verify_code?: string | null
    vote_reminders_last_acked?: Date | string
    vote_reminders_servers?: usersCreatevote_reminders_serversInput | bigint[] | number[]
    vote_reminders_servers_last_acked?: Date | string
    vote_reminder_servers_channel?: bigint | number | null
    experiments?: usersCreateexperimentsInput | number[]
    flags?: usersCreateflagsInput | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    supabase_id?: string | null
    totp_shared_key?: string | null
    staff_password?: string | null
    lynxtag?: string
    bot_voters?: bot_votersCreateNestedManyWithoutUsersInput
    extra_data?: extra_dataCreateNestedManyWithoutUsersInput
    frostpaw_clients?: frostpaw_clientsCreateNestedManyWithoutUsersInput
    leave_of_absence?: leave_of_absenceCreateNestedManyWithoutUsersInput
    lynx_apps?: lynx_appsCreateNestedManyWithoutUsersInput
    lynx_logs?: lynx_logsCreateNestedManyWithoutUsersInput
    lynx_ratings?: lynx_ratingsCreateNestedManyWithoutUsersInput
    lynx_survey_responses?: lynx_survey_responsesCreateNestedManyWithoutUsersInput
    push_notifications?: push_notificationsCreateNestedManyWithoutUsersInput
    review_votes?: review_votesCreateNestedManyWithoutUsersInput
    reviews?: reviewsCreateNestedManyWithoutUsersInput
    server_audit_logs?: server_audit_logsCreateNestedManyWithoutUsersInput
    server_voters?: server_votersCreateNestedManyWithoutUsersInput
    servers?: serversCreateNestedManyWithoutUsersInput
    user_bot_logs?: user_bot_logsCreateNestedManyWithoutUsersInput
    user_connections?: user_connectionsCreateNestedManyWithoutUsersInput
    user_server_vote_table?: user_server_vote_tableCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutUser_vote_tableInput = {
    user_id: bigint | number
    api_token: string
    description?: string | null
    badges?: usersCreatebadgesInput | string[]
    username?: string | null
    user_css?: string | null
    state?: number
    coins?: number | null
    id: bigint | number
    site_lang?: string | null
    profile_css?: string
    vote_reminders?: usersCreatevote_remindersInput | bigint[] | number[]
    vote_reminder_channel?: bigint | number | null
    staff_verify_code?: string | null
    vote_reminders_last_acked?: Date | string
    vote_reminders_servers?: usersCreatevote_reminders_serversInput | bigint[] | number[]
    vote_reminders_servers_last_acked?: Date | string
    vote_reminder_servers_channel?: bigint | number | null
    experiments?: usersCreateexperimentsInput | number[]
    flags?: usersCreateflagsInput | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    supabase_id?: string | null
    totp_shared_key?: string | null
    staff_password?: string | null
    lynxtag?: string
    bot_voters?: bot_votersUncheckedCreateNestedManyWithoutUsersInput
    extra_data?: extra_dataUncheckedCreateNestedManyWithoutUsersInput
    frostpaw_clients?: frostpaw_clientsUncheckedCreateNestedManyWithoutUsersInput
    leave_of_absence?: leave_of_absenceUncheckedCreateNestedManyWithoutUsersInput
    lynx_apps?: lynx_appsUncheckedCreateNestedManyWithoutUsersInput
    lynx_logs?: lynx_logsUncheckedCreateNestedManyWithoutUsersInput
    lynx_ratings?: lynx_ratingsUncheckedCreateNestedManyWithoutUsersInput
    lynx_survey_responses?: lynx_survey_responsesUncheckedCreateNestedManyWithoutUsersInput
    push_notifications?: push_notificationsUncheckedCreateNestedManyWithoutUsersInput
    review_votes?: review_votesUncheckedCreateNestedManyWithoutUsersInput
    reviews?: reviewsUncheckedCreateNestedManyWithoutUsersInput
    server_audit_logs?: server_audit_logsUncheckedCreateNestedManyWithoutUsersInput
    server_voters?: server_votersUncheckedCreateNestedManyWithoutUsersInput
    servers?: serversUncheckedCreateNestedManyWithoutUsersInput
    user_bot_logs?: user_bot_logsUncheckedCreateNestedManyWithoutUsersInput
    user_connections?: user_connectionsUncheckedCreateNestedManyWithoutUsersInput
    user_server_vote_table?: user_server_vote_tableUncheckedCreateNestedOneWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutUser_vote_tableInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutUser_vote_tableInput, usersUncheckedCreateWithoutUser_vote_tableInput>
  }

  export type usersUpsertWithoutUser_vote_tableInput = {
    update: XOR<usersUpdateWithoutUser_vote_tableInput, usersUncheckedUpdateWithoutUser_vote_tableInput>
    create: XOR<usersCreateWithoutUser_vote_tableInput, usersUncheckedCreateWithoutUser_vote_tableInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutUser_vote_tableInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutUser_vote_tableInput, usersUncheckedUpdateWithoutUser_vote_tableInput>
  }

  export type usersUpdateWithoutUser_vote_tableInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    api_token?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    badges?: usersUpdatebadgesInput | string[]
    username?: NullableStringFieldUpdateOperationsInput | string | null
    user_css?: NullableStringFieldUpdateOperationsInput | string | null
    state?: IntFieldUpdateOperationsInput | number
    coins?: NullableIntFieldUpdateOperationsInput | number | null
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    site_lang?: NullableStringFieldUpdateOperationsInput | string | null
    profile_css?: StringFieldUpdateOperationsInput | string
    vote_reminders?: usersUpdatevote_remindersInput | bigint[] | number[]
    vote_reminder_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    staff_verify_code?: NullableStringFieldUpdateOperationsInput | string | null
    vote_reminders_last_acked?: DateTimeFieldUpdateOperationsInput | Date | string
    vote_reminders_servers?: usersUpdatevote_reminders_serversInput | bigint[] | number[]
    vote_reminders_servers_last_acked?: DateTimeFieldUpdateOperationsInput | Date | string
    vote_reminder_servers_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    experiments?: usersUpdateexperimentsInput | number[]
    flags?: usersUpdateflagsInput | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    totp_shared_key?: NullableStringFieldUpdateOperationsInput | string | null
    staff_password?: NullableStringFieldUpdateOperationsInput | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
    bot_voters?: bot_votersUpdateManyWithoutUsersNestedInput
    extra_data?: extra_dataUpdateManyWithoutUsersNestedInput
    frostpaw_clients?: frostpaw_clientsUpdateManyWithoutUsersNestedInput
    leave_of_absence?: leave_of_absenceUpdateManyWithoutUsersNestedInput
    lynx_apps?: lynx_appsUpdateManyWithoutUsersNestedInput
    lynx_logs?: lynx_logsUpdateManyWithoutUsersNestedInput
    lynx_ratings?: lynx_ratingsUpdateManyWithoutUsersNestedInput
    lynx_survey_responses?: lynx_survey_responsesUpdateManyWithoutUsersNestedInput
    push_notifications?: push_notificationsUpdateManyWithoutUsersNestedInput
    review_votes?: review_votesUpdateManyWithoutUsersNestedInput
    reviews?: reviewsUpdateManyWithoutUsersNestedInput
    server_audit_logs?: server_audit_logsUpdateManyWithoutUsersNestedInput
    server_voters?: server_votersUpdateManyWithoutUsersNestedInput
    servers?: serversUpdateManyWithoutUsersNestedInput
    user_bot_logs?: user_bot_logsUpdateManyWithoutUsersNestedInput
    user_connections?: user_connectionsUpdateManyWithoutUsersNestedInput
    user_server_vote_table?: user_server_vote_tableUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutUser_vote_tableInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    api_token?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    badges?: usersUpdatebadgesInput | string[]
    username?: NullableStringFieldUpdateOperationsInput | string | null
    user_css?: NullableStringFieldUpdateOperationsInput | string | null
    state?: IntFieldUpdateOperationsInput | number
    coins?: NullableIntFieldUpdateOperationsInput | number | null
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    site_lang?: NullableStringFieldUpdateOperationsInput | string | null
    profile_css?: StringFieldUpdateOperationsInput | string
    vote_reminders?: usersUpdatevote_remindersInput | bigint[] | number[]
    vote_reminder_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    staff_verify_code?: NullableStringFieldUpdateOperationsInput | string | null
    vote_reminders_last_acked?: DateTimeFieldUpdateOperationsInput | Date | string
    vote_reminders_servers?: usersUpdatevote_reminders_serversInput | bigint[] | number[]
    vote_reminders_servers_last_acked?: DateTimeFieldUpdateOperationsInput | Date | string
    vote_reminder_servers_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    experiments?: usersUpdateexperimentsInput | number[]
    flags?: usersUpdateflagsInput | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    supabase_id?: NullableStringFieldUpdateOperationsInput | string | null
    totp_shared_key?: NullableStringFieldUpdateOperationsInput | string | null
    staff_password?: NullableStringFieldUpdateOperationsInput | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
    bot_voters?: bot_votersUncheckedUpdateManyWithoutUsersNestedInput
    extra_data?: extra_dataUncheckedUpdateManyWithoutUsersNestedInput
    frostpaw_clients?: frostpaw_clientsUncheckedUpdateManyWithoutUsersNestedInput
    leave_of_absence?: leave_of_absenceUncheckedUpdateManyWithoutUsersNestedInput
    lynx_apps?: lynx_appsUncheckedUpdateManyWithoutUsersNestedInput
    lynx_logs?: lynx_logsUncheckedUpdateManyWithoutUsersNestedInput
    lynx_ratings?: lynx_ratingsUncheckedUpdateManyWithoutUsersNestedInput
    lynx_survey_responses?: lynx_survey_responsesUncheckedUpdateManyWithoutUsersNestedInput
    push_notifications?: push_notificationsUncheckedUpdateManyWithoutUsersNestedInput
    review_votes?: review_votesUncheckedUpdateManyWithoutUsersNestedInput
    reviews?: reviewsUncheckedUpdateManyWithoutUsersNestedInput
    server_audit_logs?: server_audit_logsUncheckedUpdateManyWithoutUsersNestedInput
    server_voters?: server_votersUncheckedUpdateManyWithoutUsersNestedInput
    servers?: serversUncheckedUpdateManyWithoutUsersNestedInput
    user_bot_logs?: user_bot_logsUncheckedUpdateManyWithoutUsersNestedInput
    user_connections?: user_connectionsUncheckedUpdateManyWithoutUsersNestedInput
    user_server_vote_table?: user_server_vote_tableUncheckedUpdateOneWithoutUsersNestedInput
  }

  export type bot_votersCreateWithoutUsersInput = {
    bot_id: bigint | number
    timestamps?: bot_votersCreatetimestampsInput | Date[] | string[]
    lynxtag?: string
  }

  export type bot_votersUncheckedCreateWithoutUsersInput = {
    bot_id: bigint | number
    timestamps?: bot_votersCreatetimestampsInput | Date[] | string[]
    lynxtag?: string
  }

  export type bot_votersCreateOrConnectWithoutUsersInput = {
    where: bot_votersWhereUniqueInput
    create: XOR<bot_votersCreateWithoutUsersInput, bot_votersUncheckedCreateWithoutUsersInput>
  }

  export type bot_votersCreateManyUsersInputEnvelope = {
    data: bot_votersCreateManyUsersInput | bot_votersCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type extra_dataCreateWithoutUsersInput = {
    name?: string | null
    value?: NullableJsonNullValueInput | InputJsonValue
    lynxtag?: string
  }

  export type extra_dataUncheckedCreateWithoutUsersInput = {
    name?: string | null
    value?: NullableJsonNullValueInput | InputJsonValue
    lynxtag?: string
  }

  export type extra_dataCreateOrConnectWithoutUsersInput = {
    where: extra_dataWhereUniqueInput
    create: XOR<extra_dataCreateWithoutUsersInput, extra_dataUncheckedCreateWithoutUsersInput>
  }

  export type extra_dataCreateManyUsersInputEnvelope = {
    data: extra_dataCreateManyUsersInput | extra_dataCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type frostpaw_clientsCreateWithoutUsersInput = {
    id: string
    name: string
    domain: string
    privacy_policy: string
    secret: string
    lynxtag?: string
    verified?: boolean
  }

  export type frostpaw_clientsUncheckedCreateWithoutUsersInput = {
    id: string
    name: string
    domain: string
    privacy_policy: string
    secret: string
    lynxtag?: string
    verified?: boolean
  }

  export type frostpaw_clientsCreateOrConnectWithoutUsersInput = {
    where: frostpaw_clientsWhereUniqueInput
    create: XOR<frostpaw_clientsCreateWithoutUsersInput, frostpaw_clientsUncheckedCreateWithoutUsersInput>
  }

  export type frostpaw_clientsCreateManyUsersInputEnvelope = {
    data: frostpaw_clientsCreateManyUsersInput | frostpaw_clientsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type leave_of_absenceCreateWithoutUsersInput = {
    reason?: string | null
    start_date?: Date | string | null
    id?: number
    lynxtag?: string
  }

  export type leave_of_absenceUncheckedCreateWithoutUsersInput = {
    reason?: string | null
    start_date?: Date | string | null
    id?: number
    lynxtag?: string
  }

  export type leave_of_absenceCreateOrConnectWithoutUsersInput = {
    where: leave_of_absenceWhereUniqueInput
    create: XOR<leave_of_absenceCreateWithoutUsersInput, leave_of_absenceUncheckedCreateWithoutUsersInput>
  }

  export type leave_of_absenceCreateManyUsersInputEnvelope = {
    data: leave_of_absenceCreateManyUsersInput | leave_of_absenceCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type lynx_appsCreateWithoutUsersInput = {
    app_id?: string
    questions?: NullableJsonNullValueInput | InputJsonValue
    answers?: NullableJsonNullValueInput | InputJsonValue
    app_version?: number | null
    created_at?: Date | string | null
    lynxtag?: string
  }

  export type lynx_appsUncheckedCreateWithoutUsersInput = {
    app_id?: string
    questions?: NullableJsonNullValueInput | InputJsonValue
    answers?: NullableJsonNullValueInput | InputJsonValue
    app_version?: number | null
    created_at?: Date | string | null
    lynxtag?: string
  }

  export type lynx_appsCreateOrConnectWithoutUsersInput = {
    where: lynx_appsWhereUniqueInput
    create: XOR<lynx_appsCreateWithoutUsersInput, lynx_appsUncheckedCreateWithoutUsersInput>
  }

  export type lynx_appsCreateManyUsersInputEnvelope = {
    data: lynx_appsCreateManyUsersInput | lynx_appsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type lynx_logsCreateWithoutUsersInput = {
    method: string
    url: string
    status_code: number
    request_time?: Date | string | null
    lynxtag?: string
  }

  export type lynx_logsUncheckedCreateWithoutUsersInput = {
    method: string
    url: string
    status_code: number
    request_time?: Date | string | null
    lynxtag?: string
  }

  export type lynx_logsCreateOrConnectWithoutUsersInput = {
    where: lynx_logsWhereUniqueInput
    create: XOR<lynx_logsCreateWithoutUsersInput, lynx_logsUncheckedCreateWithoutUsersInput>
  }

  export type lynx_logsCreateManyUsersInputEnvelope = {
    data: lynx_logsCreateManyUsersInput | lynx_logsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type lynx_ratingsCreateWithoutUsersInput = {
    id?: string
    feedback: string
    username_cached: string
    page: string
    lynxtag?: string
  }

  export type lynx_ratingsUncheckedCreateWithoutUsersInput = {
    id?: string
    feedback: string
    username_cached: string
    page: string
    lynxtag?: string
  }

  export type lynx_ratingsCreateOrConnectWithoutUsersInput = {
    where: lynx_ratingsWhereUniqueInput
    create: XOR<lynx_ratingsCreateWithoutUsersInput, lynx_ratingsUncheckedCreateWithoutUsersInput>
  }

  export type lynx_ratingsCreateManyUsersInputEnvelope = {
    data: lynx_ratingsCreateManyUsersInput | lynx_ratingsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type lynx_survey_responsesCreateWithoutUsersInput = {
    id?: string
    questions: JsonNullValueInput | InputJsonValue
    answers: JsonNullValueInput | InputJsonValue
    username_cached: string
    lynxtag?: string
    lynx_surveys: lynx_surveysCreateNestedOneWithoutLynx_survey_responsesInput
  }

  export type lynx_survey_responsesUncheckedCreateWithoutUsersInput = {
    id?: string
    questions: JsonNullValueInput | InputJsonValue
    answers: JsonNullValueInput | InputJsonValue
    username_cached: string
    survey_id: string
    lynxtag?: string
  }

  export type lynx_survey_responsesCreateOrConnectWithoutUsersInput = {
    where: lynx_survey_responsesWhereUniqueInput
    create: XOR<lynx_survey_responsesCreateWithoutUsersInput, lynx_survey_responsesUncheckedCreateWithoutUsersInput>
  }

  export type lynx_survey_responsesCreateManyUsersInputEnvelope = {
    data: lynx_survey_responsesCreateManyUsersInput | lynx_survey_responsesCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type push_notificationsCreateWithoutUsersInput = {
    id?: string
    token: string
  }

  export type push_notificationsUncheckedCreateWithoutUsersInput = {
    id?: string
    token: string
  }

  export type push_notificationsCreateOrConnectWithoutUsersInput = {
    where: push_notificationsWhereUniqueInput
    create: XOR<push_notificationsCreateWithoutUsersInput, push_notificationsUncheckedCreateWithoutUsersInput>
  }

  export type push_notificationsCreateManyUsersInputEnvelope = {
    data: push_notificationsCreateManyUsersInput | push_notificationsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type review_votesCreateWithoutUsersInput = {
    upvote: boolean
    lynxtag?: string
    reviews: reviewsCreateNestedOneWithoutReview_votesInput
  }

  export type review_votesUncheckedCreateWithoutUsersInput = {
    id: string
    upvote: boolean
    lynxtag?: string
  }

  export type review_votesCreateOrConnectWithoutUsersInput = {
    where: review_votesWhereUniqueInput
    create: XOR<review_votesCreateWithoutUsersInput, review_votesUncheckedCreateWithoutUsersInput>
  }

  export type review_votesCreateManyUsersInputEnvelope = {
    data: review_votesCreateManyUsersInput | review_votesCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type reviewsCreateWithoutUsersInput = {
    id?: string
    target_id: bigint | number
    star_rating?: Decimal | DecimalJsLike | number | string
    review_text: string
    flagged?: boolean
    epoch?: reviewsCreateepochInput | bigint[] | number[]
    target_type?: number | null
    lynxtag?: string
    review_votes?: review_votesCreateNestedManyWithoutReviewsInput
    reviews?: reviewsCreateNestedOneWithoutOther_reviewsInput
    other_reviews?: reviewsCreateNestedManyWithoutReviewsInput
  }

  export type reviewsUncheckedCreateWithoutUsersInput = {
    id?: string
    target_id: bigint | number
    star_rating?: Decimal | DecimalJsLike | number | string
    review_text: string
    flagged?: boolean
    epoch?: reviewsCreateepochInput | bigint[] | number[]
    target_type?: number | null
    parent_id?: string | null
    lynxtag?: string
    review_votes?: review_votesUncheckedCreateNestedManyWithoutReviewsInput
    other_reviews?: reviewsUncheckedCreateNestedManyWithoutReviewsInput
  }

  export type reviewsCreateOrConnectWithoutUsersInput = {
    where: reviewsWhereUniqueInput
    create: XOR<reviewsCreateWithoutUsersInput, reviewsUncheckedCreateWithoutUsersInput>
  }

  export type reviewsCreateManyUsersInputEnvelope = {
    data: reviewsCreateManyUsersInput | reviewsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type server_audit_logsCreateWithoutUsersInput = {
    username: string
    user_guild_perms: string
    field: string
    value: string
    action_time?: Date | string
    action_id?: string
    lynxtag?: string
    servers: serversCreateNestedOneWithoutServer_audit_logsInput
  }

  export type server_audit_logsUncheckedCreateWithoutUsersInput = {
    guild_id: bigint | number
    username: string
    user_guild_perms: string
    field: string
    value: string
    action_time?: Date | string
    action_id?: string
    lynxtag?: string
  }

  export type server_audit_logsCreateOrConnectWithoutUsersInput = {
    where: server_audit_logsWhereUniqueInput
    create: XOR<server_audit_logsCreateWithoutUsersInput, server_audit_logsUncheckedCreateWithoutUsersInput>
  }

  export type server_audit_logsCreateManyUsersInputEnvelope = {
    data: server_audit_logsCreateManyUsersInput | server_audit_logsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type server_votersCreateWithoutUsersInput = {
    guild_id: bigint | number
    timestamps?: server_votersCreatetimestampsInput | Date[] | string[]
    lynxtag?: string
  }

  export type server_votersUncheckedCreateWithoutUsersInput = {
    guild_id: bigint | number
    timestamps?: server_votersCreatetimestampsInput | Date[] | string[]
    lynxtag?: string
  }

  export type server_votersCreateOrConnectWithoutUsersInput = {
    where: server_votersWhereUniqueInput
    create: XOR<server_votersCreateWithoutUsersInput, server_votersUncheckedCreateWithoutUsersInput>
  }

  export type server_votersCreateManyUsersInputEnvelope = {
    data: server_votersCreateManyUsersInput | server_votersCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type serversCreateWithoutUsersInput = {
    guild_id: bigint | number
    votes?: bigint | number | null
    webhook?: string | null
    description?: string
    long_description?: string
    css?: string | null
    api_token: string
    invite_amount?: number | null
    invite_url?: string | null
    name_cached: string
    long_description_type?: number | null
    state?: number
    created_at?: Date | string
    avatar_cached?: string | null
    invite_channel?: bigint | number | null
    guild_count?: bigint | number | null
    banner_card?: string | null
    banner_page?: string | null
    webhook_secret?: string | null
    webhook_type?: number | null
    total_votes?: bigint | number | null
    tags?: serversCreatetagsInput | string[]
    flags?: serversCreateflagsInput | number[]
    autorole_votes?: serversCreateautorole_votesInput | bigint[] | number[]
    whitelist_form?: string | null
    webhook_hmac_only?: boolean | null
    old_state?: number
    user_whitelist?: serversCreateuser_whitelistInput | bigint[] | number[]
    user_blacklist?: serversCreateuser_blacklistInput | bigint[] | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    lynxtag?: string
    server_audit_logs?: server_audit_logsCreateNestedManyWithoutServersInput
  }

  export type serversUncheckedCreateWithoutUsersInput = {
    guild_id: bigint | number
    votes?: bigint | number | null
    webhook?: string | null
    description?: string
    long_description?: string
    css?: string | null
    api_token: string
    invite_amount?: number | null
    invite_url?: string | null
    name_cached: string
    long_description_type?: number | null
    state?: number
    created_at?: Date | string
    avatar_cached?: string | null
    invite_channel?: bigint | number | null
    guild_count?: bigint | number | null
    banner_card?: string | null
    banner_page?: string | null
    webhook_secret?: string | null
    webhook_type?: number | null
    total_votes?: bigint | number | null
    tags?: serversCreatetagsInput | string[]
    flags?: serversCreateflagsInput | number[]
    autorole_votes?: serversCreateautorole_votesInput | bigint[] | number[]
    whitelist_form?: string | null
    webhook_hmac_only?: boolean | null
    old_state?: number
    user_whitelist?: serversCreateuser_whitelistInput | bigint[] | number[]
    user_blacklist?: serversCreateuser_blacklistInput | bigint[] | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    lynxtag?: string
    server_audit_logs?: server_audit_logsUncheckedCreateNestedManyWithoutServersInput
  }

  export type serversCreateOrConnectWithoutUsersInput = {
    where: serversWhereUniqueInput
    create: XOR<serversCreateWithoutUsersInput, serversUncheckedCreateWithoutUsersInput>
  }

  export type serversCreateManyUsersInputEnvelope = {
    data: serversCreateManyUsersInput | serversCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type user_bot_logsCreateWithoutUsersInput = {
    bot_id: bigint | number
    action_time?: Date | string
    action: number
    context?: string | null
    lynxtag?: string
  }

  export type user_bot_logsUncheckedCreateWithoutUsersInput = {
    bot_id: bigint | number
    action_time?: Date | string
    action: number
    context?: string | null
    lynxtag?: string
  }

  export type user_bot_logsCreateOrConnectWithoutUsersInput = {
    where: user_bot_logsWhereUniqueInput
    create: XOR<user_bot_logsCreateWithoutUsersInput, user_bot_logsUncheckedCreateWithoutUsersInput>
  }

  export type user_bot_logsCreateManyUsersInputEnvelope = {
    data: user_bot_logsCreateManyUsersInput | user_bot_logsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type user_connectionsCreateWithoutUsersInput = {
    client_id: string
    refresh_token: string
    expires_on?: Date | string
    lynxtag?: string
  }

  export type user_connectionsUncheckedCreateWithoutUsersInput = {
    client_id: string
    refresh_token: string
    expires_on?: Date | string
    lynxtag?: string
  }

  export type user_connectionsCreateOrConnectWithoutUsersInput = {
    where: user_connectionsWhereUniqueInput
    create: XOR<user_connectionsCreateWithoutUsersInput, user_connectionsUncheckedCreateWithoutUsersInput>
  }

  export type user_connectionsCreateManyUsersInputEnvelope = {
    data: user_connectionsCreateManyUsersInput | user_connectionsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type user_server_vote_tableCreateWithoutUsersInput = {
    guild_id: bigint | number
    expires_on?: Date | string | null
    lynxtag?: string
  }

  export type user_server_vote_tableUncheckedCreateWithoutUsersInput = {
    guild_id: bigint | number
    expires_on?: Date | string | null
    lynxtag?: string
  }

  export type user_server_vote_tableCreateOrConnectWithoutUsersInput = {
    where: user_server_vote_tableWhereUniqueInput
    create: XOR<user_server_vote_tableCreateWithoutUsersInput, user_server_vote_tableUncheckedCreateWithoutUsersInput>
  }

  export type user_vote_tableCreateWithoutUsersInput = {
    bot_id: bigint | number
    expires_on?: Date | string | null
    lynxtag?: string
  }

  export type user_vote_tableUncheckedCreateWithoutUsersInput = {
    bot_id: bigint | number
    expires_on?: Date | string | null
    lynxtag?: string
  }

  export type user_vote_tableCreateOrConnectWithoutUsersInput = {
    where: user_vote_tableWhereUniqueInput
    create: XOR<user_vote_tableCreateWithoutUsersInput, user_vote_tableUncheckedCreateWithoutUsersInput>
  }

  export type bot_votersUpsertWithWhereUniqueWithoutUsersInput = {
    where: bot_votersWhereUniqueInput
    update: XOR<bot_votersUpdateWithoutUsersInput, bot_votersUncheckedUpdateWithoutUsersInput>
    create: XOR<bot_votersCreateWithoutUsersInput, bot_votersUncheckedCreateWithoutUsersInput>
  }

  export type bot_votersUpdateWithWhereUniqueWithoutUsersInput = {
    where: bot_votersWhereUniqueInput
    data: XOR<bot_votersUpdateWithoutUsersInput, bot_votersUncheckedUpdateWithoutUsersInput>
  }

  export type bot_votersUpdateManyWithWhereWithoutUsersInput = {
    where: bot_votersScalarWhereInput
    data: XOR<bot_votersUpdateManyMutationInput, bot_votersUncheckedUpdateManyWithoutUsersInput>
  }

  export type bot_votersScalarWhereInput = {
    AND?: bot_votersScalarWhereInput | bot_votersScalarWhereInput[]
    OR?: bot_votersScalarWhereInput[]
    NOT?: bot_votersScalarWhereInput | bot_votersScalarWhereInput[]
    bot_id?: BigIntFilter<"bot_voters"> | bigint | number
    user_id?: BigIntFilter<"bot_voters"> | bigint | number
    timestamps?: DateTimeNullableListFilter<"bot_voters">
    lynxtag?: UuidFilter<"bot_voters"> | string
  }

  export type extra_dataUpsertWithWhereUniqueWithoutUsersInput = {
    where: extra_dataWhereUniqueInput
    update: XOR<extra_dataUpdateWithoutUsersInput, extra_dataUncheckedUpdateWithoutUsersInput>
    create: XOR<extra_dataCreateWithoutUsersInput, extra_dataUncheckedCreateWithoutUsersInput>
  }

  export type extra_dataUpdateWithWhereUniqueWithoutUsersInput = {
    where: extra_dataWhereUniqueInput
    data: XOR<extra_dataUpdateWithoutUsersInput, extra_dataUncheckedUpdateWithoutUsersInput>
  }

  export type extra_dataUpdateManyWithWhereWithoutUsersInput = {
    where: extra_dataScalarWhereInput
    data: XOR<extra_dataUpdateManyMutationInput, extra_dataUncheckedUpdateManyWithoutUsersInput>
  }

  export type extra_dataScalarWhereInput = {
    AND?: extra_dataScalarWhereInput | extra_dataScalarWhereInput[]
    OR?: extra_dataScalarWhereInput[]
    NOT?: extra_dataScalarWhereInput | extra_dataScalarWhereInput[]
    name?: StringNullableFilter<"extra_data"> | string | null
    value?: JsonNullableFilter<"extra_data">
    user_id?: BigIntNullableFilter<"extra_data"> | bigint | number | null
    lynxtag?: UuidFilter<"extra_data"> | string
  }

  export type frostpaw_clientsUpsertWithWhereUniqueWithoutUsersInput = {
    where: frostpaw_clientsWhereUniqueInput
    update: XOR<frostpaw_clientsUpdateWithoutUsersInput, frostpaw_clientsUncheckedUpdateWithoutUsersInput>
    create: XOR<frostpaw_clientsCreateWithoutUsersInput, frostpaw_clientsUncheckedCreateWithoutUsersInput>
  }

  export type frostpaw_clientsUpdateWithWhereUniqueWithoutUsersInput = {
    where: frostpaw_clientsWhereUniqueInput
    data: XOR<frostpaw_clientsUpdateWithoutUsersInput, frostpaw_clientsUncheckedUpdateWithoutUsersInput>
  }

  export type frostpaw_clientsUpdateManyWithWhereWithoutUsersInput = {
    where: frostpaw_clientsScalarWhereInput
    data: XOR<frostpaw_clientsUpdateManyMutationInput, frostpaw_clientsUncheckedUpdateManyWithoutUsersInput>
  }

  export type frostpaw_clientsScalarWhereInput = {
    AND?: frostpaw_clientsScalarWhereInput | frostpaw_clientsScalarWhereInput[]
    OR?: frostpaw_clientsScalarWhereInput[]
    NOT?: frostpaw_clientsScalarWhereInput | frostpaw_clientsScalarWhereInput[]
    id?: StringFilter<"frostpaw_clients"> | string
    name?: StringFilter<"frostpaw_clients"> | string
    domain?: StringFilter<"frostpaw_clients"> | string
    privacy_policy?: StringFilter<"frostpaw_clients"> | string
    secret?: StringFilter<"frostpaw_clients"> | string
    owner_id?: BigIntFilter<"frostpaw_clients"> | bigint | number
    lynxtag?: UuidFilter<"frostpaw_clients"> | string
    verified?: BoolFilter<"frostpaw_clients"> | boolean
  }

  export type leave_of_absenceUpsertWithWhereUniqueWithoutUsersInput = {
    where: leave_of_absenceWhereUniqueInput
    update: XOR<leave_of_absenceUpdateWithoutUsersInput, leave_of_absenceUncheckedUpdateWithoutUsersInput>
    create: XOR<leave_of_absenceCreateWithoutUsersInput, leave_of_absenceUncheckedCreateWithoutUsersInput>
  }

  export type leave_of_absenceUpdateWithWhereUniqueWithoutUsersInput = {
    where: leave_of_absenceWhereUniqueInput
    data: XOR<leave_of_absenceUpdateWithoutUsersInput, leave_of_absenceUncheckedUpdateWithoutUsersInput>
  }

  export type leave_of_absenceUpdateManyWithWhereWithoutUsersInput = {
    where: leave_of_absenceScalarWhereInput
    data: XOR<leave_of_absenceUpdateManyMutationInput, leave_of_absenceUncheckedUpdateManyWithoutUsersInput>
  }

  export type leave_of_absenceScalarWhereInput = {
    AND?: leave_of_absenceScalarWhereInput | leave_of_absenceScalarWhereInput[]
    OR?: leave_of_absenceScalarWhereInput[]
    NOT?: leave_of_absenceScalarWhereInput | leave_of_absenceScalarWhereInput[]
    reason?: StringNullableFilter<"leave_of_absence"> | string | null
    start_date?: DateTimeNullableFilter<"leave_of_absence"> | Date | string | null
    user_id?: BigIntNullableFilter<"leave_of_absence"> | bigint | number | null
    id?: IntFilter<"leave_of_absence"> | number
    lynxtag?: UuidFilter<"leave_of_absence"> | string
  }

  export type lynx_appsUpsertWithWhereUniqueWithoutUsersInput = {
    where: lynx_appsWhereUniqueInput
    update: XOR<lynx_appsUpdateWithoutUsersInput, lynx_appsUncheckedUpdateWithoutUsersInput>
    create: XOR<lynx_appsCreateWithoutUsersInput, lynx_appsUncheckedCreateWithoutUsersInput>
  }

  export type lynx_appsUpdateWithWhereUniqueWithoutUsersInput = {
    where: lynx_appsWhereUniqueInput
    data: XOR<lynx_appsUpdateWithoutUsersInput, lynx_appsUncheckedUpdateWithoutUsersInput>
  }

  export type lynx_appsUpdateManyWithWhereWithoutUsersInput = {
    where: lynx_appsScalarWhereInput
    data: XOR<lynx_appsUpdateManyMutationInput, lynx_appsUncheckedUpdateManyWithoutUsersInput>
  }

  export type lynx_appsScalarWhereInput = {
    AND?: lynx_appsScalarWhereInput | lynx_appsScalarWhereInput[]
    OR?: lynx_appsScalarWhereInput[]
    NOT?: lynx_appsScalarWhereInput | lynx_appsScalarWhereInput[]
    user_id?: BigIntNullableFilter<"lynx_apps"> | bigint | number | null
    app_id?: UuidFilter<"lynx_apps"> | string
    questions?: JsonNullableFilter<"lynx_apps">
    answers?: JsonNullableFilter<"lynx_apps">
    app_version?: IntNullableFilter<"lynx_apps"> | number | null
    created_at?: DateTimeNullableFilter<"lynx_apps"> | Date | string | null
    lynxtag?: UuidFilter<"lynx_apps"> | string
  }

  export type lynx_logsUpsertWithWhereUniqueWithoutUsersInput = {
    where: lynx_logsWhereUniqueInput
    update: XOR<lynx_logsUpdateWithoutUsersInput, lynx_logsUncheckedUpdateWithoutUsersInput>
    create: XOR<lynx_logsCreateWithoutUsersInput, lynx_logsUncheckedCreateWithoutUsersInput>
  }

  export type lynx_logsUpdateWithWhereUniqueWithoutUsersInput = {
    where: lynx_logsWhereUniqueInput
    data: XOR<lynx_logsUpdateWithoutUsersInput, lynx_logsUncheckedUpdateWithoutUsersInput>
  }

  export type lynx_logsUpdateManyWithWhereWithoutUsersInput = {
    where: lynx_logsScalarWhereInput
    data: XOR<lynx_logsUpdateManyMutationInput, lynx_logsUncheckedUpdateManyWithoutUsersInput>
  }

  export type lynx_logsScalarWhereInput = {
    AND?: lynx_logsScalarWhereInput | lynx_logsScalarWhereInput[]
    OR?: lynx_logsScalarWhereInput[]
    NOT?: lynx_logsScalarWhereInput | lynx_logsScalarWhereInput[]
    user_id?: BigIntFilter<"lynx_logs"> | bigint | number
    method?: StringFilter<"lynx_logs"> | string
    url?: StringFilter<"lynx_logs"> | string
    status_code?: IntFilter<"lynx_logs"> | number
    request_time?: DateTimeNullableFilter<"lynx_logs"> | Date | string | null
    lynxtag?: UuidFilter<"lynx_logs"> | string
  }

  export type lynx_ratingsUpsertWithWhereUniqueWithoutUsersInput = {
    where: lynx_ratingsWhereUniqueInput
    update: XOR<lynx_ratingsUpdateWithoutUsersInput, lynx_ratingsUncheckedUpdateWithoutUsersInput>
    create: XOR<lynx_ratingsCreateWithoutUsersInput, lynx_ratingsUncheckedCreateWithoutUsersInput>
  }

  export type lynx_ratingsUpdateWithWhereUniqueWithoutUsersInput = {
    where: lynx_ratingsWhereUniqueInput
    data: XOR<lynx_ratingsUpdateWithoutUsersInput, lynx_ratingsUncheckedUpdateWithoutUsersInput>
  }

  export type lynx_ratingsUpdateManyWithWhereWithoutUsersInput = {
    where: lynx_ratingsScalarWhereInput
    data: XOR<lynx_ratingsUpdateManyMutationInput, lynx_ratingsUncheckedUpdateManyWithoutUsersInput>
  }

  export type lynx_ratingsScalarWhereInput = {
    AND?: lynx_ratingsScalarWhereInput | lynx_ratingsScalarWhereInput[]
    OR?: lynx_ratingsScalarWhereInput[]
    NOT?: lynx_ratingsScalarWhereInput | lynx_ratingsScalarWhereInput[]
    id?: UuidFilter<"lynx_ratings"> | string
    feedback?: StringFilter<"lynx_ratings"> | string
    username_cached?: StringFilter<"lynx_ratings"> | string
    user_id?: BigIntNullableFilter<"lynx_ratings"> | bigint | number | null
    page?: StringFilter<"lynx_ratings"> | string
    lynxtag?: UuidFilter<"lynx_ratings"> | string
  }

  export type lynx_survey_responsesUpsertWithWhereUniqueWithoutUsersInput = {
    where: lynx_survey_responsesWhereUniqueInput
    update: XOR<lynx_survey_responsesUpdateWithoutUsersInput, lynx_survey_responsesUncheckedUpdateWithoutUsersInput>
    create: XOR<lynx_survey_responsesCreateWithoutUsersInput, lynx_survey_responsesUncheckedCreateWithoutUsersInput>
  }

  export type lynx_survey_responsesUpdateWithWhereUniqueWithoutUsersInput = {
    where: lynx_survey_responsesWhereUniqueInput
    data: XOR<lynx_survey_responsesUpdateWithoutUsersInput, lynx_survey_responsesUncheckedUpdateWithoutUsersInput>
  }

  export type lynx_survey_responsesUpdateManyWithWhereWithoutUsersInput = {
    where: lynx_survey_responsesScalarWhereInput
    data: XOR<lynx_survey_responsesUpdateManyMutationInput, lynx_survey_responsesUncheckedUpdateManyWithoutUsersInput>
  }

  export type push_notificationsUpsertWithWhereUniqueWithoutUsersInput = {
    where: push_notificationsWhereUniqueInput
    update: XOR<push_notificationsUpdateWithoutUsersInput, push_notificationsUncheckedUpdateWithoutUsersInput>
    create: XOR<push_notificationsCreateWithoutUsersInput, push_notificationsUncheckedCreateWithoutUsersInput>
  }

  export type push_notificationsUpdateWithWhereUniqueWithoutUsersInput = {
    where: push_notificationsWhereUniqueInput
    data: XOR<push_notificationsUpdateWithoutUsersInput, push_notificationsUncheckedUpdateWithoutUsersInput>
  }

  export type push_notificationsUpdateManyWithWhereWithoutUsersInput = {
    where: push_notificationsScalarWhereInput
    data: XOR<push_notificationsUpdateManyMutationInput, push_notificationsUncheckedUpdateManyWithoutUsersInput>
  }

  export type push_notificationsScalarWhereInput = {
    AND?: push_notificationsScalarWhereInput | push_notificationsScalarWhereInput[]
    OR?: push_notificationsScalarWhereInput[]
    NOT?: push_notificationsScalarWhereInput | push_notificationsScalarWhereInput[]
    id?: UuidFilter<"push_notifications"> | string
    user_id?: BigIntFilter<"push_notifications"> | bigint | number
    token?: StringFilter<"push_notifications"> | string
  }

  export type review_votesUpsertWithWhereUniqueWithoutUsersInput = {
    where: review_votesWhereUniqueInput
    update: XOR<review_votesUpdateWithoutUsersInput, review_votesUncheckedUpdateWithoutUsersInput>
    create: XOR<review_votesCreateWithoutUsersInput, review_votesUncheckedCreateWithoutUsersInput>
  }

  export type review_votesUpdateWithWhereUniqueWithoutUsersInput = {
    where: review_votesWhereUniqueInput
    data: XOR<review_votesUpdateWithoutUsersInput, review_votesUncheckedUpdateWithoutUsersInput>
  }

  export type review_votesUpdateManyWithWhereWithoutUsersInput = {
    where: review_votesScalarWhereInput
    data: XOR<review_votesUpdateManyMutationInput, review_votesUncheckedUpdateManyWithoutUsersInput>
  }

  export type reviewsUpsertWithWhereUniqueWithoutUsersInput = {
    where: reviewsWhereUniqueInput
    update: XOR<reviewsUpdateWithoutUsersInput, reviewsUncheckedUpdateWithoutUsersInput>
    create: XOR<reviewsCreateWithoutUsersInput, reviewsUncheckedCreateWithoutUsersInput>
  }

  export type reviewsUpdateWithWhereUniqueWithoutUsersInput = {
    where: reviewsWhereUniqueInput
    data: XOR<reviewsUpdateWithoutUsersInput, reviewsUncheckedUpdateWithoutUsersInput>
  }

  export type reviewsUpdateManyWithWhereWithoutUsersInput = {
    where: reviewsScalarWhereInput
    data: XOR<reviewsUpdateManyMutationInput, reviewsUncheckedUpdateManyWithoutUsersInput>
  }

  export type server_audit_logsUpsertWithWhereUniqueWithoutUsersInput = {
    where: server_audit_logsWhereUniqueInput
    update: XOR<server_audit_logsUpdateWithoutUsersInput, server_audit_logsUncheckedUpdateWithoutUsersInput>
    create: XOR<server_audit_logsCreateWithoutUsersInput, server_audit_logsUncheckedCreateWithoutUsersInput>
  }

  export type server_audit_logsUpdateWithWhereUniqueWithoutUsersInput = {
    where: server_audit_logsWhereUniqueInput
    data: XOR<server_audit_logsUpdateWithoutUsersInput, server_audit_logsUncheckedUpdateWithoutUsersInput>
  }

  export type server_audit_logsUpdateManyWithWhereWithoutUsersInput = {
    where: server_audit_logsScalarWhereInput
    data: XOR<server_audit_logsUpdateManyMutationInput, server_audit_logsUncheckedUpdateManyWithoutUsersInput>
  }

  export type server_votersUpsertWithWhereUniqueWithoutUsersInput = {
    where: server_votersWhereUniqueInput
    update: XOR<server_votersUpdateWithoutUsersInput, server_votersUncheckedUpdateWithoutUsersInput>
    create: XOR<server_votersCreateWithoutUsersInput, server_votersUncheckedCreateWithoutUsersInput>
  }

  export type server_votersUpdateWithWhereUniqueWithoutUsersInput = {
    where: server_votersWhereUniqueInput
    data: XOR<server_votersUpdateWithoutUsersInput, server_votersUncheckedUpdateWithoutUsersInput>
  }

  export type server_votersUpdateManyWithWhereWithoutUsersInput = {
    where: server_votersScalarWhereInput
    data: XOR<server_votersUpdateManyMutationInput, server_votersUncheckedUpdateManyWithoutUsersInput>
  }

  export type server_votersScalarWhereInput = {
    AND?: server_votersScalarWhereInput | server_votersScalarWhereInput[]
    OR?: server_votersScalarWhereInput[]
    NOT?: server_votersScalarWhereInput | server_votersScalarWhereInput[]
    guild_id?: BigIntFilter<"server_voters"> | bigint | number
    user_id?: BigIntFilter<"server_voters"> | bigint | number
    timestamps?: DateTimeNullableListFilter<"server_voters">
    lynxtag?: UuidFilter<"server_voters"> | string
  }

  export type serversUpsertWithWhereUniqueWithoutUsersInput = {
    where: serversWhereUniqueInput
    update: XOR<serversUpdateWithoutUsersInput, serversUncheckedUpdateWithoutUsersInput>
    create: XOR<serversCreateWithoutUsersInput, serversUncheckedCreateWithoutUsersInput>
  }

  export type serversUpdateWithWhereUniqueWithoutUsersInput = {
    where: serversWhereUniqueInput
    data: XOR<serversUpdateWithoutUsersInput, serversUncheckedUpdateWithoutUsersInput>
  }

  export type serversUpdateManyWithWhereWithoutUsersInput = {
    where: serversScalarWhereInput
    data: XOR<serversUpdateManyMutationInput, serversUncheckedUpdateManyWithoutUsersInput>
  }

  export type serversScalarWhereInput = {
    AND?: serversScalarWhereInput | serversScalarWhereInput[]
    OR?: serversScalarWhereInput[]
    NOT?: serversScalarWhereInput | serversScalarWhereInput[]
    guild_id?: BigIntFilter<"servers"> | bigint | number
    votes?: BigIntNullableFilter<"servers"> | bigint | number | null
    webhook?: StringNullableFilter<"servers"> | string | null
    description?: StringFilter<"servers"> | string
    long_description?: StringFilter<"servers"> | string
    css?: StringNullableFilter<"servers"> | string | null
    api_token?: StringFilter<"servers"> | string
    invite_amount?: IntNullableFilter<"servers"> | number | null
    invite_url?: StringNullableFilter<"servers"> | string | null
    name_cached?: StringFilter<"servers"> | string
    long_description_type?: IntNullableFilter<"servers"> | number | null
    state?: IntFilter<"servers"> | number
    created_at?: DateTimeFilter<"servers"> | Date | string
    avatar_cached?: StringNullableFilter<"servers"> | string | null
    invite_channel?: BigIntNullableFilter<"servers"> | bigint | number | null
    guild_count?: BigIntNullableFilter<"servers"> | bigint | number | null
    banner_card?: StringNullableFilter<"servers"> | string | null
    banner_page?: StringNullableFilter<"servers"> | string | null
    webhook_secret?: StringNullableFilter<"servers"> | string | null
    webhook_type?: IntNullableFilter<"servers"> | number | null
    total_votes?: BigIntNullableFilter<"servers"> | bigint | number | null
    tags?: StringNullableListFilter<"servers">
    owner_id?: BigIntFilter<"servers"> | bigint | number
    flags?: IntNullableListFilter<"servers">
    autorole_votes?: BigIntNullableListFilter<"servers">
    whitelist_form?: StringNullableFilter<"servers"> | string | null
    webhook_hmac_only?: BoolNullableFilter<"servers"> | boolean | null
    old_state?: IntFilter<"servers"> | number
    user_whitelist?: BigIntNullableListFilter<"servers">
    user_blacklist?: BigIntNullableListFilter<"servers">
    extra_links?: JsonFilter<"servers">
    lynxtag?: UuidFilter<"servers"> | string
  }

  export type user_bot_logsUpsertWithWhereUniqueWithoutUsersInput = {
    where: user_bot_logsWhereUniqueInput
    update: XOR<user_bot_logsUpdateWithoutUsersInput, user_bot_logsUncheckedUpdateWithoutUsersInput>
    create: XOR<user_bot_logsCreateWithoutUsersInput, user_bot_logsUncheckedCreateWithoutUsersInput>
  }

  export type user_bot_logsUpdateWithWhereUniqueWithoutUsersInput = {
    where: user_bot_logsWhereUniqueInput
    data: XOR<user_bot_logsUpdateWithoutUsersInput, user_bot_logsUncheckedUpdateWithoutUsersInput>
  }

  export type user_bot_logsUpdateManyWithWhereWithoutUsersInput = {
    where: user_bot_logsScalarWhereInput
    data: XOR<user_bot_logsUpdateManyMutationInput, user_bot_logsUncheckedUpdateManyWithoutUsersInput>
  }

  export type user_bot_logsScalarWhereInput = {
    AND?: user_bot_logsScalarWhereInput | user_bot_logsScalarWhereInput[]
    OR?: user_bot_logsScalarWhereInput[]
    NOT?: user_bot_logsScalarWhereInput | user_bot_logsScalarWhereInput[]
    user_id?: BigIntFilter<"user_bot_logs"> | bigint | number
    bot_id?: BigIntFilter<"user_bot_logs"> | bigint | number
    action_time?: DateTimeFilter<"user_bot_logs"> | Date | string
    action?: IntFilter<"user_bot_logs"> | number
    context?: StringNullableFilter<"user_bot_logs"> | string | null
    lynxtag?: UuidFilter<"user_bot_logs"> | string
  }

  export type user_connectionsUpsertWithWhereUniqueWithoutUsersInput = {
    where: user_connectionsWhereUniqueInput
    update: XOR<user_connectionsUpdateWithoutUsersInput, user_connectionsUncheckedUpdateWithoutUsersInput>
    create: XOR<user_connectionsCreateWithoutUsersInput, user_connectionsUncheckedCreateWithoutUsersInput>
  }

  export type user_connectionsUpdateWithWhereUniqueWithoutUsersInput = {
    where: user_connectionsWhereUniqueInput
    data: XOR<user_connectionsUpdateWithoutUsersInput, user_connectionsUncheckedUpdateWithoutUsersInput>
  }

  export type user_connectionsUpdateManyWithWhereWithoutUsersInput = {
    where: user_connectionsScalarWhereInput
    data: XOR<user_connectionsUpdateManyMutationInput, user_connectionsUncheckedUpdateManyWithoutUsersInput>
  }

  export type user_connectionsScalarWhereInput = {
    AND?: user_connectionsScalarWhereInput | user_connectionsScalarWhereInput[]
    OR?: user_connectionsScalarWhereInput[]
    NOT?: user_connectionsScalarWhereInput | user_connectionsScalarWhereInput[]
    user_id?: BigIntFilter<"user_connections"> | bigint | number
    client_id?: StringFilter<"user_connections"> | string
    refresh_token?: StringFilter<"user_connections"> | string
    expires_on?: DateTimeFilter<"user_connections"> | Date | string
    lynxtag?: UuidFilter<"user_connections"> | string
  }

  export type user_server_vote_tableUpsertWithoutUsersInput = {
    update: XOR<user_server_vote_tableUpdateWithoutUsersInput, user_server_vote_tableUncheckedUpdateWithoutUsersInput>
    create: XOR<user_server_vote_tableCreateWithoutUsersInput, user_server_vote_tableUncheckedCreateWithoutUsersInput>
    where?: user_server_vote_tableWhereInput
  }

  export type user_server_vote_tableUpdateToOneWithWhereWithoutUsersInput = {
    where?: user_server_vote_tableWhereInput
    data: XOR<user_server_vote_tableUpdateWithoutUsersInput, user_server_vote_tableUncheckedUpdateWithoutUsersInput>
  }

  export type user_server_vote_tableUpdateWithoutUsersInput = {
    guild_id?: BigIntFieldUpdateOperationsInput | bigint | number
    expires_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type user_server_vote_tableUncheckedUpdateWithoutUsersInput = {
    guild_id?: BigIntFieldUpdateOperationsInput | bigint | number
    expires_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type user_vote_tableUpsertWithoutUsersInput = {
    update: XOR<user_vote_tableUpdateWithoutUsersInput, user_vote_tableUncheckedUpdateWithoutUsersInput>
    create: XOR<user_vote_tableCreateWithoutUsersInput, user_vote_tableUncheckedCreateWithoutUsersInput>
    where?: user_vote_tableWhereInput
  }

  export type user_vote_tableUpdateToOneWithWhereWithoutUsersInput = {
    where?: user_vote_tableWhereInput
    data: XOR<user_vote_tableUpdateWithoutUsersInput, user_vote_tableUncheckedUpdateWithoutUsersInput>
  }

  export type user_vote_tableUpdateWithoutUsersInput = {
    bot_id?: BigIntFieldUpdateOperationsInput | bigint | number
    expires_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type user_vote_tableUncheckedUpdateWithoutUsersInput = {
    bot_id?: BigIntFieldUpdateOperationsInput | bigint | number
    expires_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type bot_tagsCreateManyBot_list_tagsInput = {
    bot_id: bigint | number
    id?: number
    lynxtag?: string
  }

  export type bot_tagsUpdateWithoutBot_list_tagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    lynxtag?: StringFieldUpdateOperationsInput | string
    bots?: botsUpdateOneRequiredWithoutBot_tagsNestedInput
  }

  export type bot_tagsUncheckedUpdateWithoutBot_list_tagsInput = {
    bot_id?: BigIntFieldUpdateOperationsInput | bigint | number
    id?: IntFieldUpdateOperationsInput | number
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type bot_tagsUncheckedUpdateManyWithoutBot_list_tagsInput = {
    bot_id?: BigIntFieldUpdateOperationsInput | bigint | number
    id?: IntFieldUpdateOperationsInput | number
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type bot_commandsCreateManyBotsInput = {
    id?: string
    cmd_type: number
    groups?: bot_commandsCreategroupsInput | string[]
    name: string
    vote_locked?: boolean
    description: string
    args?: bot_commandsCreateargsInput | string[]
    examples?: bot_commandsCreateexamplesInput | string[]
    premium_only?: boolean
    notes?: bot_commandsCreatenotesInput | string[]
    doc_link?: string | null
    nsfw?: boolean | null
    lynxtag?: string
  }

  export type bot_eventsCreateManyBotsInput = {
    event_type: number
    ts?: Date | string
    reason: string
    css?: string
    id?: string
    lynxtag?: string
  }

  export type bot_ownerCreateManyBotsInput = {
    owner: bigint | number
    main?: boolean | null
    id?: number
    lynxtag?: string
  }

  export type bot_promotionsCreateManyBotsInput = {
    id?: string
    title?: string | null
    info?: string | null
    css?: string | null
    type?: number | null
    lynxtag?: string
  }

  export type bot_tagsCreateManyBotsInput = {
    tag: string
    id?: number
    lynxtag?: string
  }

  export type bot_commandsUpdateWithoutBotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    cmd_type?: IntFieldUpdateOperationsInput | number
    groups?: bot_commandsUpdategroupsInput | string[]
    name?: StringFieldUpdateOperationsInput | string
    vote_locked?: BoolFieldUpdateOperationsInput | boolean
    description?: StringFieldUpdateOperationsInput | string
    args?: bot_commandsUpdateargsInput | string[]
    examples?: bot_commandsUpdateexamplesInput | string[]
    premium_only?: BoolFieldUpdateOperationsInput | boolean
    notes?: bot_commandsUpdatenotesInput | string[]
    doc_link?: NullableStringFieldUpdateOperationsInput | string | null
    nsfw?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type bot_commandsUncheckedUpdateWithoutBotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    cmd_type?: IntFieldUpdateOperationsInput | number
    groups?: bot_commandsUpdategroupsInput | string[]
    name?: StringFieldUpdateOperationsInput | string
    vote_locked?: BoolFieldUpdateOperationsInput | boolean
    description?: StringFieldUpdateOperationsInput | string
    args?: bot_commandsUpdateargsInput | string[]
    examples?: bot_commandsUpdateexamplesInput | string[]
    premium_only?: BoolFieldUpdateOperationsInput | boolean
    notes?: bot_commandsUpdatenotesInput | string[]
    doc_link?: NullableStringFieldUpdateOperationsInput | string | null
    nsfw?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type bot_commandsUncheckedUpdateManyWithoutBotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    cmd_type?: IntFieldUpdateOperationsInput | number
    groups?: bot_commandsUpdategroupsInput | string[]
    name?: StringFieldUpdateOperationsInput | string
    vote_locked?: BoolFieldUpdateOperationsInput | boolean
    description?: StringFieldUpdateOperationsInput | string
    args?: bot_commandsUpdateargsInput | string[]
    examples?: bot_commandsUpdateexamplesInput | string[]
    premium_only?: BoolFieldUpdateOperationsInput | boolean
    notes?: bot_commandsUpdatenotesInput | string[]
    doc_link?: NullableStringFieldUpdateOperationsInput | string | null
    nsfw?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type bot_eventsUpdateWithoutBotsInput = {
    event_type?: IntFieldUpdateOperationsInput | number
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: StringFieldUpdateOperationsInput | string
    css?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type bot_eventsUncheckedUpdateWithoutBotsInput = {
    event_type?: IntFieldUpdateOperationsInput | number
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: StringFieldUpdateOperationsInput | string
    css?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type bot_eventsUncheckedUpdateManyWithoutBotsInput = {
    event_type?: IntFieldUpdateOperationsInput | number
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: StringFieldUpdateOperationsInput | string
    css?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type bot_ownerUpdateWithoutBotsInput = {
    owner?: BigIntFieldUpdateOperationsInput | bigint | number
    main?: NullableBoolFieldUpdateOperationsInput | boolean | null
    id?: IntFieldUpdateOperationsInput | number
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type bot_ownerUncheckedUpdateWithoutBotsInput = {
    owner?: BigIntFieldUpdateOperationsInput | bigint | number
    main?: NullableBoolFieldUpdateOperationsInput | boolean | null
    id?: IntFieldUpdateOperationsInput | number
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type bot_ownerUncheckedUpdateManyWithoutBotsInput = {
    owner?: BigIntFieldUpdateOperationsInput | bigint | number
    main?: NullableBoolFieldUpdateOperationsInput | boolean | null
    id?: IntFieldUpdateOperationsInput | number
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type bot_promotionsUpdateWithoutBotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    info?: NullableStringFieldUpdateOperationsInput | string | null
    css?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type bot_promotionsUncheckedUpdateWithoutBotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    info?: NullableStringFieldUpdateOperationsInput | string | null
    css?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type bot_promotionsUncheckedUpdateManyWithoutBotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    info?: NullableStringFieldUpdateOperationsInput | string | null
    css?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type bot_tagsUpdateWithoutBotsInput = {
    id?: IntFieldUpdateOperationsInput | number
    lynxtag?: StringFieldUpdateOperationsInput | string
    bot_list_tags?: bot_list_tagsUpdateOneRequiredWithoutBot_tagsNestedInput
  }

  export type bot_tagsUncheckedUpdateWithoutBotsInput = {
    tag?: StringFieldUpdateOperationsInput | string
    id?: IntFieldUpdateOperationsInput | number
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type bot_tagsUncheckedUpdateManyWithoutBotsInput = {
    tag?: StringFieldUpdateOperationsInput | string
    id?: IntFieldUpdateOperationsInput | number
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type lynx_survey_responsesCreateManyLynx_surveysInput = {
    id?: string
    questions: JsonNullValueInput | InputJsonValue
    answers: JsonNullValueInput | InputJsonValue
    username_cached: string
    user_id?: bigint | number | null
    lynxtag?: string
  }

  export type lynx_survey_responsesUpdateWithoutLynx_surveysInput = {
    id?: StringFieldUpdateOperationsInput | string
    questions?: JsonNullValueInput | InputJsonValue
    answers?: JsonNullValueInput | InputJsonValue
    username_cached?: StringFieldUpdateOperationsInput | string
    lynxtag?: StringFieldUpdateOperationsInput | string
    users?: usersUpdateOneWithoutLynx_survey_responsesNestedInput
  }

  export type lynx_survey_responsesUncheckedUpdateWithoutLynx_surveysInput = {
    id?: StringFieldUpdateOperationsInput | string
    questions?: JsonNullValueInput | InputJsonValue
    answers?: JsonNullValueInput | InputJsonValue
    username_cached?: StringFieldUpdateOperationsInput | string
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type lynx_survey_responsesUncheckedUpdateManyWithoutLynx_surveysInput = {
    id?: StringFieldUpdateOperationsInput | string
    questions?: JsonNullValueInput | InputJsonValue
    answers?: JsonNullValueInput | InputJsonValue
    username_cached?: StringFieldUpdateOperationsInput | string
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type review_votesCreateManyReviewsInput = {
    user_id: bigint | number
    upvote: boolean
    lynxtag?: string
  }

  export type reviewsCreateManyReviewsInput = {
    id?: string
    target_id: bigint | number
    user_id: bigint | number
    star_rating?: Decimal | DecimalJsLike | number | string
    review_text: string
    flagged?: boolean
    epoch?: reviewsCreateepochInput | bigint[] | number[]
    target_type?: number | null
    lynxtag?: string
  }

  export type review_votesUpdateWithoutReviewsInput = {
    upvote?: BoolFieldUpdateOperationsInput | boolean
    lynxtag?: StringFieldUpdateOperationsInput | string
    users?: usersUpdateOneRequiredWithoutReview_votesNestedInput
  }

  export type review_votesUncheckedUpdateWithoutReviewsInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    upvote?: BoolFieldUpdateOperationsInput | boolean
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type review_votesUncheckedUpdateManyWithoutReviewsInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    upvote?: BoolFieldUpdateOperationsInput | boolean
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type reviewsUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    target_id?: BigIntFieldUpdateOperationsInput | bigint | number
    star_rating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    review_text?: StringFieldUpdateOperationsInput | string
    flagged?: BoolFieldUpdateOperationsInput | boolean
    epoch?: reviewsUpdateepochInput | bigint[] | number[]
    target_type?: NullableIntFieldUpdateOperationsInput | number | null
    lynxtag?: StringFieldUpdateOperationsInput | string
    review_votes?: review_votesUpdateManyWithoutReviewsNestedInput
    other_reviews?: reviewsUpdateManyWithoutReviewsNestedInput
    users?: usersUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type reviewsUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    target_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    star_rating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    review_text?: StringFieldUpdateOperationsInput | string
    flagged?: BoolFieldUpdateOperationsInput | boolean
    epoch?: reviewsUpdateepochInput | bigint[] | number[]
    target_type?: NullableIntFieldUpdateOperationsInput | number | null
    lynxtag?: StringFieldUpdateOperationsInput | string
    review_votes?: review_votesUncheckedUpdateManyWithoutReviewsNestedInput
    other_reviews?: reviewsUncheckedUpdateManyWithoutReviewsNestedInput
  }

  export type reviewsUncheckedUpdateManyWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    target_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    star_rating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    review_text?: StringFieldUpdateOperationsInput | string
    flagged?: BoolFieldUpdateOperationsInput | boolean
    epoch?: reviewsUpdateepochInput | bigint[] | number[]
    target_type?: NullableIntFieldUpdateOperationsInput | number | null
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type server_audit_logsCreateManyServersInput = {
    user_id: bigint | number
    username: string
    user_guild_perms: string
    field: string
    value: string
    action_time?: Date | string
    action_id?: string
    lynxtag?: string
  }

  export type server_audit_logsUpdateWithoutServersInput = {
    username?: StringFieldUpdateOperationsInput | string
    user_guild_perms?: StringFieldUpdateOperationsInput | string
    field?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    action_time?: DateTimeFieldUpdateOperationsInput | Date | string
    action_id?: StringFieldUpdateOperationsInput | string
    lynxtag?: StringFieldUpdateOperationsInput | string
    users?: usersUpdateOneRequiredWithoutServer_audit_logsNestedInput
  }

  export type server_audit_logsUncheckedUpdateWithoutServersInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    username?: StringFieldUpdateOperationsInput | string
    user_guild_perms?: StringFieldUpdateOperationsInput | string
    field?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    action_time?: DateTimeFieldUpdateOperationsInput | Date | string
    action_id?: StringFieldUpdateOperationsInput | string
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type server_audit_logsUncheckedUpdateManyWithoutServersInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    username?: StringFieldUpdateOperationsInput | string
    user_guild_perms?: StringFieldUpdateOperationsInput | string
    field?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    action_time?: DateTimeFieldUpdateOperationsInput | Date | string
    action_id?: StringFieldUpdateOperationsInput | string
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type bot_votersCreateManyUsersInput = {
    bot_id: bigint | number
    timestamps?: bot_votersCreatetimestampsInput | Date[] | string[]
    lynxtag?: string
  }

  export type extra_dataCreateManyUsersInput = {
    name?: string | null
    value?: NullableJsonNullValueInput | InputJsonValue
    lynxtag?: string
  }

  export type frostpaw_clientsCreateManyUsersInput = {
    id: string
    name: string
    domain: string
    privacy_policy: string
    secret: string
    lynxtag?: string
    verified?: boolean
  }

  export type leave_of_absenceCreateManyUsersInput = {
    reason?: string | null
    start_date?: Date | string | null
    id?: number
    lynxtag?: string
  }

  export type lynx_appsCreateManyUsersInput = {
    app_id?: string
    questions?: NullableJsonNullValueInput | InputJsonValue
    answers?: NullableJsonNullValueInput | InputJsonValue
    app_version?: number | null
    created_at?: Date | string | null
    lynxtag?: string
  }

  export type lynx_logsCreateManyUsersInput = {
    method: string
    url: string
    status_code: number
    request_time?: Date | string | null
    lynxtag?: string
  }

  export type lynx_ratingsCreateManyUsersInput = {
    id?: string
    feedback: string
    username_cached: string
    page: string
    lynxtag?: string
  }

  export type lynx_survey_responsesCreateManyUsersInput = {
    id?: string
    questions: JsonNullValueInput | InputJsonValue
    answers: JsonNullValueInput | InputJsonValue
    username_cached: string
    survey_id: string
    lynxtag?: string
  }

  export type push_notificationsCreateManyUsersInput = {
    id?: string
    token: string
  }

  export type review_votesCreateManyUsersInput = {
    id: string
    upvote: boolean
    lynxtag?: string
  }

  export type reviewsCreateManyUsersInput = {
    id?: string
    target_id: bigint | number
    star_rating?: Decimal | DecimalJsLike | number | string
    review_text: string
    flagged?: boolean
    epoch?: reviewsCreateepochInput | bigint[] | number[]
    target_type?: number | null
    parent_id?: string | null
    lynxtag?: string
  }

  export type server_audit_logsCreateManyUsersInput = {
    guild_id: bigint | number
    username: string
    user_guild_perms: string
    field: string
    value: string
    action_time?: Date | string
    action_id?: string
    lynxtag?: string
  }

  export type server_votersCreateManyUsersInput = {
    guild_id: bigint | number
    timestamps?: server_votersCreatetimestampsInput | Date[] | string[]
    lynxtag?: string
  }

  export type serversCreateManyUsersInput = {
    guild_id: bigint | number
    votes?: bigint | number | null
    webhook?: string | null
    description?: string
    long_description?: string
    css?: string | null
    api_token: string
    invite_amount?: number | null
    invite_url?: string | null
    name_cached: string
    long_description_type?: number | null
    state?: number
    created_at?: Date | string
    avatar_cached?: string | null
    invite_channel?: bigint | number | null
    guild_count?: bigint | number | null
    banner_card?: string | null
    banner_page?: string | null
    webhook_secret?: string | null
    webhook_type?: number | null
    total_votes?: bigint | number | null
    tags?: serversCreatetagsInput | string[]
    flags?: serversCreateflagsInput | number[]
    autorole_votes?: serversCreateautorole_votesInput | bigint[] | number[]
    whitelist_form?: string | null
    webhook_hmac_only?: boolean | null
    old_state?: number
    user_whitelist?: serversCreateuser_whitelistInput | bigint[] | number[]
    user_blacklist?: serversCreateuser_blacklistInput | bigint[] | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    lynxtag?: string
  }

  export type user_bot_logsCreateManyUsersInput = {
    bot_id: bigint | number
    action_time?: Date | string
    action: number
    context?: string | null
    lynxtag?: string
  }

  export type user_connectionsCreateManyUsersInput = {
    client_id: string
    refresh_token: string
    expires_on?: Date | string
    lynxtag?: string
  }

  export type bot_votersUpdateWithoutUsersInput = {
    bot_id?: BigIntFieldUpdateOperationsInput | bigint | number
    timestamps?: bot_votersUpdatetimestampsInput | Date[] | string[]
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type bot_votersUncheckedUpdateWithoutUsersInput = {
    bot_id?: BigIntFieldUpdateOperationsInput | bigint | number
    timestamps?: bot_votersUpdatetimestampsInput | Date[] | string[]
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type bot_votersUncheckedUpdateManyWithoutUsersInput = {
    bot_id?: BigIntFieldUpdateOperationsInput | bigint | number
    timestamps?: bot_votersUpdatetimestampsInput | Date[] | string[]
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type extra_dataUpdateWithoutUsersInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableJsonNullValueInput | InputJsonValue
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type extra_dataUncheckedUpdateWithoutUsersInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableJsonNullValueInput | InputJsonValue
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type extra_dataUncheckedUpdateManyWithoutUsersInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableJsonNullValueInput | InputJsonValue
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type frostpaw_clientsUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    privacy_policy?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    lynxtag?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type frostpaw_clientsUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    privacy_policy?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    lynxtag?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type frostpaw_clientsUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    privacy_policy?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    lynxtag?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type leave_of_absenceUpdateWithoutUsersInput = {
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id?: IntFieldUpdateOperationsInput | number
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type leave_of_absenceUncheckedUpdateWithoutUsersInput = {
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id?: IntFieldUpdateOperationsInput | number
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type leave_of_absenceUncheckedUpdateManyWithoutUsersInput = {
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id?: IntFieldUpdateOperationsInput | number
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type lynx_appsUpdateWithoutUsersInput = {
    app_id?: StringFieldUpdateOperationsInput | string
    questions?: NullableJsonNullValueInput | InputJsonValue
    answers?: NullableJsonNullValueInput | InputJsonValue
    app_version?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type lynx_appsUncheckedUpdateWithoutUsersInput = {
    app_id?: StringFieldUpdateOperationsInput | string
    questions?: NullableJsonNullValueInput | InputJsonValue
    answers?: NullableJsonNullValueInput | InputJsonValue
    app_version?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type lynx_appsUncheckedUpdateManyWithoutUsersInput = {
    app_id?: StringFieldUpdateOperationsInput | string
    questions?: NullableJsonNullValueInput | InputJsonValue
    answers?: NullableJsonNullValueInput | InputJsonValue
    app_version?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type lynx_logsUpdateWithoutUsersInput = {
    method?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    status_code?: IntFieldUpdateOperationsInput | number
    request_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type lynx_logsUncheckedUpdateWithoutUsersInput = {
    method?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    status_code?: IntFieldUpdateOperationsInput | number
    request_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type lynx_logsUncheckedUpdateManyWithoutUsersInput = {
    method?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    status_code?: IntFieldUpdateOperationsInput | number
    request_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type lynx_ratingsUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    feedback?: StringFieldUpdateOperationsInput | string
    username_cached?: StringFieldUpdateOperationsInput | string
    page?: StringFieldUpdateOperationsInput | string
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type lynx_ratingsUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    feedback?: StringFieldUpdateOperationsInput | string
    username_cached?: StringFieldUpdateOperationsInput | string
    page?: StringFieldUpdateOperationsInput | string
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type lynx_ratingsUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    feedback?: StringFieldUpdateOperationsInput | string
    username_cached?: StringFieldUpdateOperationsInput | string
    page?: StringFieldUpdateOperationsInput | string
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type lynx_survey_responsesUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    questions?: JsonNullValueInput | InputJsonValue
    answers?: JsonNullValueInput | InputJsonValue
    username_cached?: StringFieldUpdateOperationsInput | string
    lynxtag?: StringFieldUpdateOperationsInput | string
    lynx_surveys?: lynx_surveysUpdateOneRequiredWithoutLynx_survey_responsesNestedInput
  }

  export type lynx_survey_responsesUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    questions?: JsonNullValueInput | InputJsonValue
    answers?: JsonNullValueInput | InputJsonValue
    username_cached?: StringFieldUpdateOperationsInput | string
    survey_id?: StringFieldUpdateOperationsInput | string
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type lynx_survey_responsesUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    questions?: JsonNullValueInput | InputJsonValue
    answers?: JsonNullValueInput | InputJsonValue
    username_cached?: StringFieldUpdateOperationsInput | string
    survey_id?: StringFieldUpdateOperationsInput | string
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type push_notificationsUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
  }

  export type push_notificationsUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
  }

  export type push_notificationsUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
  }

  export type review_votesUpdateWithoutUsersInput = {
    upvote?: BoolFieldUpdateOperationsInput | boolean
    lynxtag?: StringFieldUpdateOperationsInput | string
    reviews?: reviewsUpdateOneRequiredWithoutReview_votesNestedInput
  }

  export type review_votesUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    upvote?: BoolFieldUpdateOperationsInput | boolean
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type review_votesUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    upvote?: BoolFieldUpdateOperationsInput | boolean
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type reviewsUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    target_id?: BigIntFieldUpdateOperationsInput | bigint | number
    star_rating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    review_text?: StringFieldUpdateOperationsInput | string
    flagged?: BoolFieldUpdateOperationsInput | boolean
    epoch?: reviewsUpdateepochInput | bigint[] | number[]
    target_type?: NullableIntFieldUpdateOperationsInput | number | null
    lynxtag?: StringFieldUpdateOperationsInput | string
    review_votes?: review_votesUpdateManyWithoutReviewsNestedInput
    reviews?: reviewsUpdateOneWithoutOther_reviewsNestedInput
    other_reviews?: reviewsUpdateManyWithoutReviewsNestedInput
  }

  export type reviewsUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    target_id?: BigIntFieldUpdateOperationsInput | bigint | number
    star_rating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    review_text?: StringFieldUpdateOperationsInput | string
    flagged?: BoolFieldUpdateOperationsInput | boolean
    epoch?: reviewsUpdateepochInput | bigint[] | number[]
    target_type?: NullableIntFieldUpdateOperationsInput | number | null
    parent_id?: NullableStringFieldUpdateOperationsInput | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
    review_votes?: review_votesUncheckedUpdateManyWithoutReviewsNestedInput
    other_reviews?: reviewsUncheckedUpdateManyWithoutReviewsNestedInput
  }

  export type reviewsUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    target_id?: BigIntFieldUpdateOperationsInput | bigint | number
    star_rating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    review_text?: StringFieldUpdateOperationsInput | string
    flagged?: BoolFieldUpdateOperationsInput | boolean
    epoch?: reviewsUpdateepochInput | bigint[] | number[]
    target_type?: NullableIntFieldUpdateOperationsInput | number | null
    parent_id?: NullableStringFieldUpdateOperationsInput | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type server_audit_logsUpdateWithoutUsersInput = {
    username?: StringFieldUpdateOperationsInput | string
    user_guild_perms?: StringFieldUpdateOperationsInput | string
    field?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    action_time?: DateTimeFieldUpdateOperationsInput | Date | string
    action_id?: StringFieldUpdateOperationsInput | string
    lynxtag?: StringFieldUpdateOperationsInput | string
    servers?: serversUpdateOneRequiredWithoutServer_audit_logsNestedInput
  }

  export type server_audit_logsUncheckedUpdateWithoutUsersInput = {
    guild_id?: BigIntFieldUpdateOperationsInput | bigint | number
    username?: StringFieldUpdateOperationsInput | string
    user_guild_perms?: StringFieldUpdateOperationsInput | string
    field?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    action_time?: DateTimeFieldUpdateOperationsInput | Date | string
    action_id?: StringFieldUpdateOperationsInput | string
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type server_audit_logsUncheckedUpdateManyWithoutUsersInput = {
    guild_id?: BigIntFieldUpdateOperationsInput | bigint | number
    username?: StringFieldUpdateOperationsInput | string
    user_guild_perms?: StringFieldUpdateOperationsInput | string
    field?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    action_time?: DateTimeFieldUpdateOperationsInput | Date | string
    action_id?: StringFieldUpdateOperationsInput | string
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type server_votersUpdateWithoutUsersInput = {
    guild_id?: BigIntFieldUpdateOperationsInput | bigint | number
    timestamps?: server_votersUpdatetimestampsInput | Date[] | string[]
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type server_votersUncheckedUpdateWithoutUsersInput = {
    guild_id?: BigIntFieldUpdateOperationsInput | bigint | number
    timestamps?: server_votersUpdatetimestampsInput | Date[] | string[]
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type server_votersUncheckedUpdateManyWithoutUsersInput = {
    guild_id?: BigIntFieldUpdateOperationsInput | bigint | number
    timestamps?: server_votersUpdatetimestampsInput | Date[] | string[]
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type serversUpdateWithoutUsersInput = {
    guild_id?: BigIntFieldUpdateOperationsInput | bigint | number
    votes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    webhook?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    long_description?: StringFieldUpdateOperationsInput | string
    css?: NullableStringFieldUpdateOperationsInput | string | null
    api_token?: StringFieldUpdateOperationsInput | string
    invite_amount?: NullableIntFieldUpdateOperationsInput | number | null
    invite_url?: NullableStringFieldUpdateOperationsInput | string | null
    name_cached?: StringFieldUpdateOperationsInput | string
    long_description_type?: NullableIntFieldUpdateOperationsInput | number | null
    state?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar_cached?: NullableStringFieldUpdateOperationsInput | string | null
    invite_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    guild_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    banner_card?: NullableStringFieldUpdateOperationsInput | string | null
    banner_page?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_secret?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_type?: NullableIntFieldUpdateOperationsInput | number | null
    total_votes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    tags?: serversUpdatetagsInput | string[]
    flags?: serversUpdateflagsInput | number[]
    autorole_votes?: serversUpdateautorole_votesInput | bigint[] | number[]
    whitelist_form?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_hmac_only?: NullableBoolFieldUpdateOperationsInput | boolean | null
    old_state?: IntFieldUpdateOperationsInput | number
    user_whitelist?: serversUpdateuser_whitelistInput | bigint[] | number[]
    user_blacklist?: serversUpdateuser_blacklistInput | bigint[] | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    lynxtag?: StringFieldUpdateOperationsInput | string
    server_audit_logs?: server_audit_logsUpdateManyWithoutServersNestedInput
  }

  export type serversUncheckedUpdateWithoutUsersInput = {
    guild_id?: BigIntFieldUpdateOperationsInput | bigint | number
    votes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    webhook?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    long_description?: StringFieldUpdateOperationsInput | string
    css?: NullableStringFieldUpdateOperationsInput | string | null
    api_token?: StringFieldUpdateOperationsInput | string
    invite_amount?: NullableIntFieldUpdateOperationsInput | number | null
    invite_url?: NullableStringFieldUpdateOperationsInput | string | null
    name_cached?: StringFieldUpdateOperationsInput | string
    long_description_type?: NullableIntFieldUpdateOperationsInput | number | null
    state?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar_cached?: NullableStringFieldUpdateOperationsInput | string | null
    invite_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    guild_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    banner_card?: NullableStringFieldUpdateOperationsInput | string | null
    banner_page?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_secret?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_type?: NullableIntFieldUpdateOperationsInput | number | null
    total_votes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    tags?: serversUpdatetagsInput | string[]
    flags?: serversUpdateflagsInput | number[]
    autorole_votes?: serversUpdateautorole_votesInput | bigint[] | number[]
    whitelist_form?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_hmac_only?: NullableBoolFieldUpdateOperationsInput | boolean | null
    old_state?: IntFieldUpdateOperationsInput | number
    user_whitelist?: serversUpdateuser_whitelistInput | bigint[] | number[]
    user_blacklist?: serversUpdateuser_blacklistInput | bigint[] | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    lynxtag?: StringFieldUpdateOperationsInput | string
    server_audit_logs?: server_audit_logsUncheckedUpdateManyWithoutServersNestedInput
  }

  export type serversUncheckedUpdateManyWithoutUsersInput = {
    guild_id?: BigIntFieldUpdateOperationsInput | bigint | number
    votes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    webhook?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    long_description?: StringFieldUpdateOperationsInput | string
    css?: NullableStringFieldUpdateOperationsInput | string | null
    api_token?: StringFieldUpdateOperationsInput | string
    invite_amount?: NullableIntFieldUpdateOperationsInput | number | null
    invite_url?: NullableStringFieldUpdateOperationsInput | string | null
    name_cached?: StringFieldUpdateOperationsInput | string
    long_description_type?: NullableIntFieldUpdateOperationsInput | number | null
    state?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar_cached?: NullableStringFieldUpdateOperationsInput | string | null
    invite_channel?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    guild_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    banner_card?: NullableStringFieldUpdateOperationsInput | string | null
    banner_page?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_secret?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_type?: NullableIntFieldUpdateOperationsInput | number | null
    total_votes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    tags?: serversUpdatetagsInput | string[]
    flags?: serversUpdateflagsInput | number[]
    autorole_votes?: serversUpdateautorole_votesInput | bigint[] | number[]
    whitelist_form?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_hmac_only?: NullableBoolFieldUpdateOperationsInput | boolean | null
    old_state?: IntFieldUpdateOperationsInput | number
    user_whitelist?: serversUpdateuser_whitelistInput | bigint[] | number[]
    user_blacklist?: serversUpdateuser_blacklistInput | bigint[] | number[]
    extra_links?: JsonNullValueInput | InputJsonValue
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type user_bot_logsUpdateWithoutUsersInput = {
    bot_id?: BigIntFieldUpdateOperationsInput | bigint | number
    action_time?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: IntFieldUpdateOperationsInput | number
    context?: NullableStringFieldUpdateOperationsInput | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type user_bot_logsUncheckedUpdateWithoutUsersInput = {
    bot_id?: BigIntFieldUpdateOperationsInput | bigint | number
    action_time?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: IntFieldUpdateOperationsInput | number
    context?: NullableStringFieldUpdateOperationsInput | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type user_bot_logsUncheckedUpdateManyWithoutUsersInput = {
    bot_id?: BigIntFieldUpdateOperationsInput | bigint | number
    action_time?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: IntFieldUpdateOperationsInput | number
    context?: NullableStringFieldUpdateOperationsInput | string | null
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type user_connectionsUpdateWithoutUsersInput = {
    client_id?: StringFieldUpdateOperationsInput | string
    refresh_token?: StringFieldUpdateOperationsInput | string
    expires_on?: DateTimeFieldUpdateOperationsInput | Date | string
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type user_connectionsUncheckedUpdateWithoutUsersInput = {
    client_id?: StringFieldUpdateOperationsInput | string
    refresh_token?: StringFieldUpdateOperationsInput | string
    expires_on?: DateTimeFieldUpdateOperationsInput | Date | string
    lynxtag?: StringFieldUpdateOperationsInput | string
  }

  export type user_connectionsUncheckedUpdateManyWithoutUsersInput = {
    client_id?: StringFieldUpdateOperationsInput | string
    refresh_token?: StringFieldUpdateOperationsInput | string
    expires_on?: DateTimeFieldUpdateOperationsInput | Date | string
    lynxtag?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use Bot_list_tagsCountOutputTypeDefaultArgs instead
     */
    export type Bot_list_tagsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Bot_list_tagsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BotsCountOutputTypeDefaultArgs instead
     */
    export type BotsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BotsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Lynx_surveysCountOutputTypeDefaultArgs instead
     */
    export type Lynx_surveysCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Lynx_surveysCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReviewsCountOutputTypeDefaultArgs instead
     */
    export type ReviewsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReviewsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServersCountOutputTypeDefaultArgs instead
     */
    export type ServersCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServersCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsersCountOutputTypeDefaultArgs instead
     */
    export type UsersCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsersCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use bot_commandsDefaultArgs instead
     */
    export type bot_commandsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = bot_commandsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use bot_eventsDefaultArgs instead
     */
    export type bot_eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = bot_eventsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use bot_list_featureDefaultArgs instead
     */
    export type bot_list_featureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = bot_list_featureDefaultArgs<ExtArgs>
    /**
     * @deprecated Use bot_list_tagsDefaultArgs instead
     */
    export type bot_list_tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = bot_list_tagsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use bot_ownerDefaultArgs instead
     */
    export type bot_ownerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = bot_ownerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use bot_packsDefaultArgs instead
     */
    export type bot_packsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = bot_packsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use bot_promotionsDefaultArgs instead
     */
    export type bot_promotionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = bot_promotionsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use bot_stats_votes_pmDefaultArgs instead
     */
    export type bot_stats_votes_pmArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = bot_stats_votes_pmDefaultArgs<ExtArgs>
    /**
     * @deprecated Use bot_tagsDefaultArgs instead
     */
    export type bot_tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = bot_tagsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use bot_votersDefaultArgs instead
     */
    export type bot_votersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = bot_votersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use botsDefaultArgs instead
     */
    export type botsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = botsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use extra_dataDefaultArgs instead
     */
    export type extra_dataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = extra_dataDefaultArgs<ExtArgs>
    /**
     * @deprecated Use featuresDefaultArgs instead
     */
    export type featuresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = featuresDefaultArgs<ExtArgs>
    /**
     * @deprecated Use frostpaw_clientsDefaultArgs instead
     */
    export type frostpaw_clientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = frostpaw_clientsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use leave_of_absenceDefaultArgs instead
     */
    export type leave_of_absenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = leave_of_absenceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use lynx_appsDefaultArgs instead
     */
    export type lynx_appsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = lynx_appsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use lynx_dataDefaultArgs instead
     */
    export type lynx_dataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = lynx_dataDefaultArgs<ExtArgs>
    /**
     * @deprecated Use lynx_logsDefaultArgs instead
     */
    export type lynx_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = lynx_logsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use lynx_notificationsDefaultArgs instead
     */
    export type lynx_notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = lynx_notificationsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use lynx_ratingsDefaultArgs instead
     */
    export type lynx_ratingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = lynx_ratingsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use lynx_survey_responsesDefaultArgs instead
     */
    export type lynx_survey_responsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = lynx_survey_responsesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use lynx_surveysDefaultArgs instead
     */
    export type lynx_surveysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = lynx_surveysDefaultArgs<ExtArgs>
    /**
     * @deprecated Use migrationDefaultArgs instead
     */
    export type migrationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = migrationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use piccolo_userDefaultArgs instead
     */
    export type piccolo_userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = piccolo_userDefaultArgs<ExtArgs>
    /**
     * @deprecated Use platform_mapDefaultArgs instead
     */
    export type platform_mapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = platform_mapDefaultArgs<ExtArgs>
    /**
     * @deprecated Use push_notificationsDefaultArgs instead
     */
    export type push_notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = push_notificationsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use review_votesDefaultArgs instead
     */
    export type review_votesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = review_votesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use reviewsDefaultArgs instead
     */
    export type reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = reviewsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use server_audit_logsDefaultArgs instead
     */
    export type server_audit_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = server_audit_logsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use server_tagsDefaultArgs instead
     */
    export type server_tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = server_tagsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use server_votersDefaultArgs instead
     */
    export type server_votersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = server_votersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use serversDefaultArgs instead
     */
    export type serversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = serversDefaultArgs<ExtArgs>
    /**
     * @deprecated Use sessionsDefaultArgs instead
     */
    export type sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = sessionsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use user_bot_logsDefaultArgs instead
     */
    export type user_bot_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = user_bot_logsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use user_connectionsDefaultArgs instead
     */
    export type user_connectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = user_connectionsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use user_server_vote_tableDefaultArgs instead
     */
    export type user_server_vote_tableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = user_server_vote_tableDefaultArgs<ExtArgs>
    /**
     * @deprecated Use user_vote_tableDefaultArgs instead
     */
    export type user_vote_tableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = user_vote_tableDefaultArgs<ExtArgs>
    /**
     * @deprecated Use usersDefaultArgs instead
     */
    export type usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = usersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use vanityDefaultArgs instead
     */
    export type vanityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = vanityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ws_eventsDefaultArgs instead
     */
    export type ws_eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ws_eventsDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}